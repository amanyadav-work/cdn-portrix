import * as kn from "react";
import Vx, { useReducer as a3, useRef as gl, useEffect as Tc, useLayoutEffect as TL, useDebugValue as o3, useState as Ax, useMemo as l3 } from "react";
function u3(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var Xy = { exports: {} }, Tg = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DR;
function c3() {
  if (DR) return Tg;
  DR = 1;
  var s = Vx, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, r = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(u, c, d) {
    var p, g = {}, v = null, y = null;
    d !== void 0 && (v = "" + d), c.key !== void 0 && (v = "" + c.key), c.ref !== void 0 && (y = c.ref);
    for (p in c) n.call(c, p) && !r.hasOwnProperty(p) && (g[p] = c[p]);
    if (u && u.defaultProps) for (p in c = u.defaultProps, c) g[p] === void 0 && (g[p] = c[p]);
    return { $$typeof: e, type: u, key: v, ref: y, props: g, _owner: i.current };
  }
  return Tg.Fragment = t, Tg.jsx = o, Tg.jsxs = o, Tg;
}
var bg = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var LR;
function f3() {
  return LR || (LR = 1, process.env.NODE_ENV !== "production" && function() {
    var s = Vx, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), u = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), p = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), v = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), S = Symbol.iterator, T = "@@iterator";
    function E(te) {
      if (te === null || typeof te != "object")
        return null;
      var ze = S && te[S] || te[T];
      return typeof ze == "function" ? ze : null;
    }
    var M = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(te) {
      {
        for (var ze = arguments.length, tt = new Array(ze > 1 ? ze - 1 : 0), gt = 1; gt < ze; gt++)
          tt[gt - 1] = arguments[gt];
        C("error", te, tt);
      }
    }
    function C(te, ze, tt) {
      {
        var gt = M.ReactDebugCurrentFrame, Ht = gt.getStackAddendum();
        Ht !== "" && (ze += "%s", tt = tt.concat([Ht]));
        var tn = tt.map(function(k) {
          return String(k);
        });
        tn.unshift("Warning: " + ze), Function.prototype.apply.call(console[te], console, tn);
      }
    }
    var D = !1, N = !1, U = !1, O = !1, V = !1, L;
    L = Symbol.for("react.module.reference");
    function I(te) {
      return !!(typeof te == "string" || typeof te == "function" || te === n || te === r || V || te === i || te === d || te === p || O || te === y || D || N || U || typeof te == "object" && te !== null && (te.$$typeof === v || te.$$typeof === g || te.$$typeof === o || te.$$typeof === u || te.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      te.$$typeof === L || te.getModuleId !== void 0));
    }
    function Y(te, ze, tt) {
      var gt = te.displayName;
      if (gt)
        return gt;
      var Ht = ze.displayName || ze.name || "";
      return Ht !== "" ? tt + "(" + Ht + ")" : tt;
    }
    function Q(te) {
      return te.displayName || "Context";
    }
    function fe(te) {
      if (te == null)
        return null;
      if (typeof te.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof te == "function")
        return te.displayName || te.name || null;
      if (typeof te == "string")
        return te;
      switch (te) {
        case n:
          return "Fragment";
        case t:
          return "Portal";
        case r:
          return "Profiler";
        case i:
          return "StrictMode";
        case d:
          return "Suspense";
        case p:
          return "SuspenseList";
      }
      if (typeof te == "object")
        switch (te.$$typeof) {
          case u:
            var ze = te;
            return Q(ze) + ".Consumer";
          case o:
            var tt = te;
            return Q(tt._context) + ".Provider";
          case c:
            return Y(te, te.render, "ForwardRef");
          case g:
            var gt = te.displayName || null;
            return gt !== null ? gt : fe(te.type) || "Memo";
          case v: {
            var Ht = te, tn = Ht._payload, k = Ht._init;
            try {
              return fe(k(tn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var j = Object.assign, ie = 0, re, pe, J, Z, H, ue, Se;
    function me() {
    }
    me.__reactDisabledLog = !0;
    function ye() {
      {
        if (ie === 0) {
          re = console.log, pe = console.info, J = console.warn, Z = console.error, H = console.group, ue = console.groupCollapsed, Se = console.groupEnd;
          var te = {
            configurable: !0,
            enumerable: !0,
            value: me,
            writable: !0
          };
          Object.defineProperties(console, {
            info: te,
            log: te,
            warn: te,
            error: te,
            group: te,
            groupCollapsed: te,
            groupEnd: te
          });
        }
        ie++;
      }
    }
    function Xe() {
      {
        if (ie--, ie === 0) {
          var te = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: j({}, te, {
              value: re
            }),
            info: j({}, te, {
              value: pe
            }),
            warn: j({}, te, {
              value: J
            }),
            error: j({}, te, {
              value: Z
            }),
            group: j({}, te, {
              value: H
            }),
            groupCollapsed: j({}, te, {
              value: ue
            }),
            groupEnd: j({}, te, {
              value: Se
            })
          });
        }
        ie < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Je = M.ReactCurrentDispatcher, Ye;
    function At(te, ze, tt) {
      {
        if (Ye === void 0)
          try {
            throw Error();
          } catch (Ht) {
            var gt = Ht.stack.trim().match(/\n( *(at )?)/);
            Ye = gt && gt[1] || "";
          }
        return `
` + Ye + te;
      }
    }
    var Ct = !1, pt;
    {
      var mt = typeof WeakMap == "function" ? WeakMap : Map;
      pt = new mt();
    }
    function ne(te, ze) {
      if (!te || Ct)
        return "";
      {
        var tt = pt.get(te);
        if (tt !== void 0)
          return tt;
      }
      var gt;
      Ct = !0;
      var Ht = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var tn;
      tn = Je.current, Je.current = null, ye();
      try {
        if (ze) {
          var k = function() {
            throw Error();
          };
          if (Object.defineProperty(k.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(k, []);
            } catch (vt) {
              gt = vt;
            }
            Reflect.construct(te, [], k);
          } else {
            try {
              k.call();
            } catch (vt) {
              gt = vt;
            }
            te.call(k.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (vt) {
            gt = vt;
          }
          te();
        }
      } catch (vt) {
        if (vt && gt && typeof vt.stack == "string") {
          for (var se = vt.stack.split(`
`), _e = gt.stack.split(`
`), ge = se.length - 1, he = _e.length - 1; ge >= 1 && he >= 0 && se[ge] !== _e[he]; )
            he--;
          for (; ge >= 1 && he >= 0; ge--, he--)
            if (se[ge] !== _e[he]) {
              if (ge !== 1 || he !== 1)
                do
                  if (ge--, he--, he < 0 || se[ge] !== _e[he]) {
                    var je = `
` + se[ge].replace(" at new ", " at ");
                    return te.displayName && je.includes("<anonymous>") && (je = je.replace("<anonymous>", te.displayName)), typeof te == "function" && pt.set(te, je), je;
                  }
                while (ge >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        Ct = !1, Je.current = tn, Xe(), Error.prepareStackTrace = Ht;
      }
      var Rt = te ? te.displayName || te.name : "", Ft = Rt ? At(Rt) : "";
      return typeof te == "function" && pt.set(te, Ft), Ft;
    }
    function we(te, ze, tt) {
      return ne(te, !1);
    }
    function Ee(te) {
      var ze = te.prototype;
      return !!(ze && ze.isReactComponent);
    }
    function He(te, ze, tt) {
      if (te == null)
        return "";
      if (typeof te == "function")
        return ne(te, Ee(te));
      if (typeof te == "string")
        return At(te);
      switch (te) {
        case d:
          return At("Suspense");
        case p:
          return At("SuspenseList");
      }
      if (typeof te == "object")
        switch (te.$$typeof) {
          case c:
            return we(te.render);
          case g:
            return He(te.type, ze, tt);
          case v: {
            var gt = te, Ht = gt._payload, tn = gt._init;
            try {
              return He(tn(Ht), ze, tt);
            } catch {
            }
          }
        }
      return "";
    }
    var be = Object.prototype.hasOwnProperty, ce = {}, nt = M.ReactDebugCurrentFrame;
    function X(te) {
      if (te) {
        var ze = te._owner, tt = He(te.type, te._source, ze ? ze.type : null);
        nt.setExtraStackFrame(tt);
      } else
        nt.setExtraStackFrame(null);
    }
    function G(te, ze, tt, gt, Ht) {
      {
        var tn = Function.call.bind(be);
        for (var k in te)
          if (tn(te, k)) {
            var se = void 0;
            try {
              if (typeof te[k] != "function") {
                var _e = Error((gt || "React class") + ": " + tt + " type `" + k + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof te[k] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw _e.name = "Invariant Violation", _e;
              }
              se = te[k](ze, k, gt, tt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ge) {
              se = ge;
            }
            se && !(se instanceof Error) && (X(Ht), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", gt || "React class", tt, k, typeof se), X(null)), se instanceof Error && !(se.message in ce) && (ce[se.message] = !0, X(Ht), w("Failed %s type: %s", tt, se.message), X(null));
          }
      }
    }
    var le = Array.isArray;
    function Ue(te) {
      return le(te);
    }
    function Ve(te) {
      {
        var ze = typeof Symbol == "function" && Symbol.toStringTag, tt = ze && te[Symbol.toStringTag] || te.constructor.name || "Object";
        return tt;
      }
    }
    function Oe(te) {
      try {
        return ct(te), !1;
      } catch {
        return !0;
      }
    }
    function ct(te) {
      return "" + te;
    }
    function st(te) {
      if (Oe(te))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ve(te)), ct(te);
    }
    var it = M.ReactCurrentOwner, Lt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, zt, ee;
    function Re(te) {
      if (be.call(te, "ref")) {
        var ze = Object.getOwnPropertyDescriptor(te, "ref").get;
        if (ze && ze.isReactWarning)
          return !1;
      }
      return te.ref !== void 0;
    }
    function De(te) {
      if (be.call(te, "key")) {
        var ze = Object.getOwnPropertyDescriptor(te, "key").get;
        if (ze && ze.isReactWarning)
          return !1;
      }
      return te.key !== void 0;
    }
    function Ie(te, ze) {
      typeof te.ref == "string" && it.current;
    }
    function Qe(te, ze) {
      {
        var tt = function() {
          zt || (zt = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ze));
        };
        tt.isReactWarning = !0, Object.defineProperty(te, "key", {
          get: tt,
          configurable: !0
        });
      }
    }
    function rt(te, ze) {
      {
        var tt = function() {
          ee || (ee = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ze));
        };
        tt.isReactWarning = !0, Object.defineProperty(te, "ref", {
          get: tt,
          configurable: !0
        });
      }
    }
    var Fe = function(te, ze, tt, gt, Ht, tn, k) {
      var se = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: te,
        key: ze,
        ref: tt,
        props: k,
        // Record the component responsible for creating this element.
        _owner: tn
      };
      return se._store = {}, Object.defineProperty(se._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(se, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: gt
      }), Object.defineProperty(se, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ht
      }), Object.freeze && (Object.freeze(se.props), Object.freeze(se)), se;
    };
    function Ke(te, ze, tt, gt, Ht) {
      {
        var tn, k = {}, se = null, _e = null;
        tt !== void 0 && (st(tt), se = "" + tt), De(ze) && (st(ze.key), se = "" + ze.key), Re(ze) && (_e = ze.ref, Ie(ze, Ht));
        for (tn in ze)
          be.call(ze, tn) && !Lt.hasOwnProperty(tn) && (k[tn] = ze[tn]);
        if (te && te.defaultProps) {
          var ge = te.defaultProps;
          for (tn in ge)
            k[tn] === void 0 && (k[tn] = ge[tn]);
        }
        if (se || _e) {
          var he = typeof te == "function" ? te.displayName || te.name || "Unknown" : te;
          se && Qe(k, he), _e && rt(k, he);
        }
        return Fe(te, se, _e, Ht, gt, it.current, k);
      }
    }
    var Dt = M.ReactCurrentOwner, We = M.ReactDebugCurrentFrame;
    function Pe(te) {
      if (te) {
        var ze = te._owner, tt = He(te.type, te._source, ze ? ze.type : null);
        We.setExtraStackFrame(tt);
      } else
        We.setExtraStackFrame(null);
    }
    var ae;
    ae = !1;
    function et(te) {
      return typeof te == "object" && te !== null && te.$$typeof === e;
    }
    function at() {
      {
        if (Dt.current) {
          var te = fe(Dt.current.type);
          if (te)
            return `

Check the render method of \`` + te + "`.";
        }
        return "";
      }
    }
    function Wt(te) {
      return "";
    }
    var ot = {};
    function an(te) {
      {
        var ze = at();
        if (!ze) {
          var tt = typeof te == "string" ? te : te.displayName || te.name;
          tt && (ze = `

Check the top-level render call using <` + tt + ">.");
        }
        return ze;
      }
    }
    function un(te, ze) {
      {
        if (!te._store || te._store.validated || te.key != null)
          return;
        te._store.validated = !0;
        var tt = an(ze);
        if (ot[tt])
          return;
        ot[tt] = !0;
        var gt = "";
        te && te._owner && te._owner !== Dt.current && (gt = " It was passed a child from " + fe(te._owner.type) + "."), Pe(te), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', tt, gt), Pe(null);
      }
    }
    function wt(te, ze) {
      {
        if (typeof te != "object")
          return;
        if (Ue(te))
          for (var tt = 0; tt < te.length; tt++) {
            var gt = te[tt];
            et(gt) && un(gt, ze);
          }
        else if (et(te))
          te._store && (te._store.validated = !0);
        else if (te) {
          var Ht = E(te);
          if (typeof Ht == "function" && Ht !== te.entries)
            for (var tn = Ht.call(te), k; !(k = tn.next()).done; )
              et(k.value) && un(k.value, ze);
        }
      }
    }
    function St(te) {
      {
        var ze = te.type;
        if (ze == null || typeof ze == "string")
          return;
        var tt;
        if (typeof ze == "function")
          tt = ze.propTypes;
        else if (typeof ze == "object" && (ze.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ze.$$typeof === g))
          tt = ze.propTypes;
        else
          return;
        if (tt) {
          var gt = fe(ze);
          G(tt, te.props, "prop", gt, te);
        } else if (ze.PropTypes !== void 0 && !ae) {
          ae = !0;
          var Ht = fe(ze);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ht || "Unknown");
        }
        typeof ze.getDefaultProps == "function" && !ze.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function bt(te) {
      {
        for (var ze = Object.keys(te.props), tt = 0; tt < ze.length; tt++) {
          var gt = ze[tt];
          if (gt !== "children" && gt !== "key") {
            Pe(te), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", gt), Pe(null);
            break;
          }
        }
        te.ref !== null && (Pe(te), w("Invalid attribute `ref` supplied to `React.Fragment`."), Pe(null));
      }
    }
    var lt = {};
    function Ot(te, ze, tt, gt, Ht, tn) {
      {
        var k = I(te);
        if (!k) {
          var se = "";
          (te === void 0 || typeof te == "object" && te !== null && Object.keys(te).length === 0) && (se += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var _e = Wt();
          _e ? se += _e : se += at();
          var ge;
          te === null ? ge = "null" : Ue(te) ? ge = "array" : te !== void 0 && te.$$typeof === e ? (ge = "<" + (fe(te.type) || "Unknown") + " />", se = " Did you accidentally export a JSX literal instead of a component?") : ge = typeof te, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ge, se);
        }
        var he = Ke(te, ze, tt, Ht, tn);
        if (he == null)
          return he;
        if (k) {
          var je = ze.children;
          if (je !== void 0)
            if (gt)
              if (Ue(je)) {
                for (var Rt = 0; Rt < je.length; Rt++)
                  wt(je[Rt], te);
                Object.freeze && Object.freeze(je);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              wt(je, te);
        }
        if (be.call(ze, "key")) {
          var Ft = fe(te), vt = Object.keys(ze).filter(function($t) {
            return $t !== "key";
          }), It = vt.length > 0 ? "{key: someKey, " + vt.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!lt[Ft + It]) {
            var Xt = vt.length > 0 ? "{" + vt.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, It, Ft, Xt, Ft), lt[Ft + It] = !0;
          }
        }
        return te === n ? bt(he) : St(he), he;
      }
    }
    function kt(te, ze, tt) {
      return Ot(te, ze, tt, !0);
    }
    function en(te, ze, tt) {
      return Ot(te, ze, tt, !1);
    }
    var Vn = en, Yt = kt;
    bg.Fragment = n, bg.jsx = Vn, bg.jsxs = Yt;
  }()), bg;
}
var PR;
function d3() {
  return PR || (PR = 1, process.env.NODE_ENV === "production" ? Xy.exports = c3() : Xy.exports = f3()), Xy.exports;
}
var Qi = d3();
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Gv = "160", h3 = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, p3 = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, bL = 0, tT = 1, CL = 2, m3 = 3, wL = 0, Wx = 1, Zg = 2, No = 3, El = 0, zs = 1, Ho = 2, g3 = 2, du = 0, td = 1, nT = 2, iT = 3, rT = 4, RL = 5, yc = 100, BL = 101, DL = 102, sT = 103, aT = 104, LL = 200, PL = 201, IL = 202, UL = 203, Mx = 204, Ex = 205, FL = 206, NL = 207, OL = 208, HL = 209, zL = 210, GL = 211, kL = 212, VL = 213, WL = 214, XL = 0, JL = 1, YL = 2, gv = 3, KL = 4, qL = 5, jL = 6, QL = 7, kv = 0, ZL = 1, $L = 2, xl = 0, eP = 1, tP = 2, nP = 3, _b = 4, iP = 5, rP = 6, oT = "attached", sP = "detached", Xx = 300, mu = 301, Pc = 302, vv = 303, _v = 304, nm = 306, Ic = 1e3, qr = 1001, Gp = 1002, Oi = 1003, yv = 1004, v3 = 1004, Dp = 1005, _3 = 1005, bi = 1006, Jx = 1007, y3 = 1007, Tl = 1008, x3 = 1008, Sl = 1009, aP = 1010, oP = 1011, Yx = 1012, yb = 1013, lu = 1014, zo = 1015, kp = 1016, xb = 1017, Sb = 1018, bc = 1020, lP = 1021, Ns = 1023, uP = 1024, cP = 1025, Cc = 1026, hd = 1027, fP = 1028, Ab = 1029, dP = 1030, Mb = 1031, Eb = 1033, sx = 33776, ax = 33777, ox = 33778, lx = 33779, lT = 35840, uT = 35841, cT = 35842, fT = 35843, Tb = 36196, dT = 37492, hT = 37496, pT = 37808, mT = 37809, gT = 37810, vT = 37811, _T = 37812, yT = 37813, xT = 37814, ST = 37815, AT = 37816, MT = 37817, ET = 37818, TT = 37819, bT = 37820, CT = 37821, ux = 36492, wT = 36494, RT = 36495, hP = 36283, BT = 36284, DT = 36285, LT = 36286, pP = 2200, mP = 2201, gP = 2202, Vp = 2300, pd = 2301, cx = 2302, Yf = 2400, Kf = 2401, xv = 2402, Kx = 2500, bb = 2501, vP = 0, Cb = 1, Tx = 2, wb = 3e3, wc = 3001, _P = 3200, yP = 3201, zc = 0, xP = 1, ba = "", Sr = "srgb", bl = "srgb-linear", qx = "display-p3", Vv = "display-p3-linear", Sv = "linear", li = "srgb", Av = "rec709", Mv = "p3", S3 = 0, Gf = 7680, A3 = 7681, M3 = 7682, E3 = 7683, T3 = 34055, b3 = 34056, C3 = 5386, w3 = 512, R3 = 513, B3 = 514, D3 = 515, L3 = 516, P3 = 517, I3 = 518, PT = 519, SP = 512, AP = 513, MP = 514, Rb = 515, EP = 516, TP = 517, bP = 518, CP = 519, Ev = 35044, U3 = 35048, F3 = 35040, N3 = 35045, O3 = 35049, H3 = 35041, z3 = 35046, G3 = 35050, k3 = 35042, V3 = "100", IT = "300 es", bx = 1035, Go = 2e3, Wp = 2001;
class yu {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const r = i.indexOf(t);
      r !== -1 && i.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let r = 0, o = i.length; r < o; r++)
        i[r].call(this, e);
      e.target = null;
    }
  }
}
const ds = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let IR = 1234567;
const nd = Math.PI / 180, Xp = 180 / Math.PI;
function Da() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (ds[s & 255] + ds[s >> 8 & 255] + ds[s >> 16 & 255] + ds[s >> 24 & 255] + "-" + ds[e & 255] + ds[e >> 8 & 255] + "-" + ds[e >> 16 & 15 | 64] + ds[e >> 24 & 255] + "-" + ds[t & 63 | 128] + ds[t >> 8 & 255] + "-" + ds[t >> 16 & 255] + ds[t >> 24 & 255] + ds[n & 255] + ds[n >> 8 & 255] + ds[n >> 16 & 255] + ds[n >> 24 & 255]).toLowerCase();
}
function Hi(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function Bb(s, e) {
  return (s % e + e) % e;
}
function W3(s, e, t, n, i) {
  return n + (s - e) * (i - n) / (t - e);
}
function X3(s, e, t) {
  return s !== e ? (t - s) / (e - s) : 0;
}
function $g(s, e, t) {
  return (1 - t) * s + t * e;
}
function J3(s, e, t, n) {
  return $g(s, e, 1 - Math.exp(-t * n));
}
function Y3(s, e = 1) {
  return e - Math.abs(Bb(s, e * 2) - e);
}
function K3(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
}
function q3(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
}
function j3(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function Q3(s, e) {
  return s + Math.random() * (e - s);
}
function Z3(s) {
  return s * (0.5 - Math.random());
}
function $3(s) {
  s !== void 0 && (IR = s);
  let e = IR += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function eH(s) {
  return s * nd;
}
function tH(s) {
  return s * Xp;
}
function UT(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function nH(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function Cx(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function iH(s, e, t, n, i) {
  const r = Math.cos, o = Math.sin, u = r(t / 2), c = o(t / 2), d = r((e + n) / 2), p = o((e + n) / 2), g = r((e - n) / 2), v = o((e - n) / 2), y = r((n - e) / 2), S = o((n - e) / 2);
  switch (i) {
    case "XYX":
      s.set(u * p, c * g, c * v, u * d);
      break;
    case "YZY":
      s.set(c * v, u * p, c * g, u * d);
      break;
    case "ZXZ":
      s.set(c * g, c * v, u * p, u * d);
      break;
    case "XZX":
      s.set(u * p, c * S, c * y, u * d);
      break;
    case "YXY":
      s.set(c * y, u * p, c * S, u * d);
      break;
    case "ZYZ":
      s.set(c * S, c * y, u * p, u * d);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function ia(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function xn(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const ev = {
  DEG2RAD: nd,
  RAD2DEG: Xp,
  generateUUID: Da,
  clamp: Hi,
  euclideanModulo: Bb,
  mapLinear: W3,
  inverseLerp: X3,
  lerp: $g,
  damp: J3,
  pingpong: Y3,
  smoothstep: K3,
  smootherstep: q3,
  randInt: j3,
  randFloat: Q3,
  randFloatSpread: Z3,
  seededRandom: $3,
  degToRad: eH,
  radToDeg: tH,
  isPowerOfTwo: UT,
  ceilPowerOfTwo: nH,
  floorPowerOfTwo: Cx,
  setQuaternionFromProperEuler: iH,
  normalize: xn,
  denormalize: ia
};
class qe {
  constructor(e = 0, t = 0) {
    qe.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Hi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, o = this.y - e.y;
    return this.x = r * n - o * i + e.x, this.y = r * i + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Mn {
  constructor(e, t, n, i, r, o, u, c, d) {
    Mn.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, r, o, u, c, d);
  }
  set(e, t, n, i, r, o, u, c, d) {
    const p = this.elements;
    return p[0] = e, p[1] = i, p[2] = u, p[3] = t, p[4] = r, p[5] = c, p[6] = n, p[7] = o, p[8] = d, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, r = this.elements, o = n[0], u = n[3], c = n[6], d = n[1], p = n[4], g = n[7], v = n[2], y = n[5], S = n[8], T = i[0], E = i[3], M = i[6], w = i[1], C = i[4], D = i[7], N = i[2], U = i[5], O = i[8];
    return r[0] = o * T + u * w + c * N, r[3] = o * E + u * C + c * U, r[6] = o * M + u * D + c * O, r[1] = d * T + p * w + g * N, r[4] = d * E + p * C + g * U, r[7] = d * M + p * D + g * O, r[2] = v * T + y * w + S * N, r[5] = v * E + y * C + S * U, r[8] = v * M + y * D + S * O, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], u = e[5], c = e[6], d = e[7], p = e[8];
    return t * o * p - t * u * d - n * r * p + n * u * c + i * r * d - i * o * c;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], u = e[5], c = e[6], d = e[7], p = e[8], g = p * o - u * d, v = u * c - p * r, y = d * r - o * c, S = t * g + n * v + i * y;
    if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / S;
    return e[0] = g * T, e[1] = (i * d - p * n) * T, e[2] = (u * n - i * o) * T, e[3] = v * T, e[4] = (p * t - i * c) * T, e[5] = (i * r - u * t) * T, e[6] = y * T, e[7] = (n * c - d * t) * T, e[8] = (o * t - n * r) * T, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, i, r, o, u) {
    const c = Math.cos(r), d = Math.sin(r);
    return this.set(
      n * c,
      n * d,
      -n * (c * o + d * u) + o + e,
      -i * d,
      i * c,
      -i * (-d * o + c * u) + u + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(OM.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(OM.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(OM.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const OM = /* @__PURE__ */ new Mn();
function wP(s) {
  for (let e = s.length - 1; e >= 0; --e)
    if (s[e] >= 65535) return !0;
  return !1;
}
const rH = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Mp(s, e) {
  return new rH[s](e);
}
function Tv(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function RP() {
  const s = Tv("canvas");
  return s.style.display = "block", s;
}
const UR = {};
function tv(s) {
  s in UR || (UR[s] = !0, console.warn(s));
}
const FR = /* @__PURE__ */ new Mn().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), NR = /* @__PURE__ */ new Mn().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), Jy = {
  [bl]: {
    transfer: Sv,
    primaries: Av,
    toReference: (s) => s,
    fromReference: (s) => s
  },
  [Sr]: {
    transfer: li,
    primaries: Av,
    toReference: (s) => s.convertSRGBToLinear(),
    fromReference: (s) => s.convertLinearToSRGB()
  },
  [Vv]: {
    transfer: Sv,
    primaries: Mv,
    toReference: (s) => s.applyMatrix3(NR),
    fromReference: (s) => s.applyMatrix3(FR)
  },
  [qx]: {
    transfer: li,
    primaries: Mv,
    toReference: (s) => s.convertSRGBToLinear().applyMatrix3(NR),
    fromReference: (s) => s.applyMatrix3(FR).convertLinearToSRGB()
  }
}, sH = /* @__PURE__ */ new Set([bl, Vv]), Zn = {
  enabled: !0,
  _workingColorSpace: bl,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(s) {
    if (!sH.has(s))
      throw new Error(`Unsupported working color space, "${s}".`);
    this._workingColorSpace = s;
  },
  convert: function(s, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return s;
    const n = Jy[e].toReference, i = Jy[t].fromReference;
    return i(n(s));
  },
  fromWorkingColorSpace: function(s, e) {
    return this.convert(s, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(s, e) {
    return this.convert(s, e, this._workingColorSpace);
  },
  getPrimaries: function(s) {
    return Jy[s].primaries;
  },
  getTransfer: function(s) {
    return s === ba ? Sv : Jy[s].transfer;
  }
};
function Lp(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function HM(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
let Yh;
class Db {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      Yh === void 0 && (Yh = Tv("canvas")), Yh.width = e.width, Yh.height = e.height;
      const n = Yh.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Yh;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = Tv("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height), r = i.data;
      for (let o = 0; o < r.length; o++)
        r[o] = Lp(r[o] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Lp(t[n] / 255) * 255) : t[n] = Lp(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let aH = 0;
class qf {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: aH++ }), this.uuid = Da(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let r;
      if (Array.isArray(i)) {
        r = [];
        for (let o = 0, u = i.length; o < u; o++)
          i[o].isDataTexture ? r.push(zM(i[o].image)) : r.push(zM(i[o]));
      } else
        r = zM(i);
      n.url = r;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function zM(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Db.getDataURL(s) : s.data ? {
    data: Array.from(s.data),
    width: s.width,
    height: s.height,
    type: s.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let oH = 0;
class Ri extends yu {
  constructor(e = Ri.DEFAULT_IMAGE, t = Ri.DEFAULT_MAPPING, n = qr, i = qr, r = bi, o = Tl, u = Ns, c = Sl, d = Ri.DEFAULT_ANISOTROPY, p = ba) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: oH++ }), this.uuid = Da(), this.name = "", this.source = new qf(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = o, this.anisotropy = d, this.format = u, this.internalFormat = null, this.type = c, this.offset = new qe(0, 0), this.repeat = new qe(1, 1), this.center = new qe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Mn(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof p == "string" ? this.colorSpace = p : (tv("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = p === wc ? Sr : ba), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Xx) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Ic:
          e.x = e.x - Math.floor(e.x);
          break;
        case qr:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Gp:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Ic:
          e.y = e.y - Math.floor(e.y);
          break;
        case qr:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Gp:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  get encoding() {
    return tv("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Sr ? wc : wb;
  }
  set encoding(e) {
    tv("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === wc ? Sr : ba;
  }
}
Ri.DEFAULT_IMAGE = null;
Ri.DEFAULT_MAPPING = Xx;
Ri.DEFAULT_ANISOTROPY = 1;
class $n {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    $n.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, r = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, r;
    const c = e.elements, d = c[0], p = c[4], g = c[8], v = c[1], y = c[5], S = c[9], T = c[2], E = c[6], M = c[10];
    if (Math.abs(p - v) < 0.01 && Math.abs(g - T) < 0.01 && Math.abs(S - E) < 0.01) {
      if (Math.abs(p + v) < 0.1 && Math.abs(g + T) < 0.1 && Math.abs(S + E) < 0.1 && Math.abs(d + y + M - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const C = (d + 1) / 2, D = (y + 1) / 2, N = (M + 1) / 2, U = (p + v) / 4, O = (g + T) / 4, V = (S + E) / 4;
      return C > D && C > N ? C < 0.01 ? (n = 0, i = 0.707106781, r = 0.707106781) : (n = Math.sqrt(C), i = U / n, r = O / n) : D > N ? D < 0.01 ? (n = 0.707106781, i = 0, r = 0.707106781) : (i = Math.sqrt(D), n = U / i, r = V / i) : N < 0.01 ? (n = 0.707106781, i = 0.707106781, r = 0) : (r = Math.sqrt(N), n = O / r, i = V / r), this.set(n, i, r, t), this;
    }
    let w = Math.sqrt((E - S) * (E - S) + (g - T) * (g - T) + (v - p) * (v - p));
    return Math.abs(w) < 1e-3 && (w = 1), this.x = (E - S) / w, this.y = (g - T) / w, this.z = (v - p) / w, this.w = Math.acos((d + y + M - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class BP extends yu {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new $n(0, 0, e, t), this.scissorTest = !1, this.viewport = new $n(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    n.encoding !== void 0 && (tv("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === wc ? Sr : ba), n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: bi,
      depthBuffer: !0,
      stencilBuffer: !1,
      depthTexture: null,
      samples: 0
    }, n), this.texture = new Ri(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps, this.texture.internalFormat = n.internalFormat, this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new qf(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ko extends BP {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class jx extends Ri {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = Oi, this.minFilter = Oi, this.wrapR = qr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class lH extends ko {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new jx(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class Lb extends Ri {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = Oi, this.minFilter = Oi, this.wrapR = qr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class uH extends ko {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new Lb(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class cH extends ko {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGLMultipleRenderTargets = !0;
    const r = this.texture;
    this.texture = [];
    for (let o = 0; o < n; o++)
      this.texture[o] = r.clone(), this.texture[o].isRenderTargetTexture = !0;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let i = 0, r = this.texture.length; i < r; i++)
        this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, n = e.texture.length; t < n; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class ys {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
  }
  static slerpFlat(e, t, n, i, r, o, u) {
    let c = n[i + 0], d = n[i + 1], p = n[i + 2], g = n[i + 3];
    const v = r[o + 0], y = r[o + 1], S = r[o + 2], T = r[o + 3];
    if (u === 0) {
      e[t + 0] = c, e[t + 1] = d, e[t + 2] = p, e[t + 3] = g;
      return;
    }
    if (u === 1) {
      e[t + 0] = v, e[t + 1] = y, e[t + 2] = S, e[t + 3] = T;
      return;
    }
    if (g !== T || c !== v || d !== y || p !== S) {
      let E = 1 - u;
      const M = c * v + d * y + p * S + g * T, w = M >= 0 ? 1 : -1, C = 1 - M * M;
      if (C > Number.EPSILON) {
        const N = Math.sqrt(C), U = Math.atan2(N, M * w);
        E = Math.sin(E * U) / N, u = Math.sin(u * U) / N;
      }
      const D = u * w;
      if (c = c * E + v * D, d = d * E + y * D, p = p * E + S * D, g = g * E + T * D, E === 1 - u) {
        const N = 1 / Math.sqrt(c * c + d * d + p * p + g * g);
        c *= N, d *= N, p *= N, g *= N;
      }
    }
    e[t] = c, e[t + 1] = d, e[t + 2] = p, e[t + 3] = g;
  }
  static multiplyQuaternionsFlat(e, t, n, i, r, o) {
    const u = n[i], c = n[i + 1], d = n[i + 2], p = n[i + 3], g = r[o], v = r[o + 1], y = r[o + 2], S = r[o + 3];
    return e[t] = u * S + p * g + c * y - d * v, e[t + 1] = c * S + p * v + d * g - u * y, e[t + 2] = d * S + p * y + u * v - c * g, e[t + 3] = p * S - u * g - c * v - d * y, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, i) {
    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = !0) {
    const n = e._x, i = e._y, r = e._z, o = e._order, u = Math.cos, c = Math.sin, d = u(n / 2), p = u(i / 2), g = u(r / 2), v = c(n / 2), y = c(i / 2), S = c(r / 2);
    switch (o) {
      case "XYZ":
        this._x = v * p * g + d * y * S, this._y = d * y * g - v * p * S, this._z = d * p * S + v * y * g, this._w = d * p * g - v * y * S;
        break;
      case "YXZ":
        this._x = v * p * g + d * y * S, this._y = d * y * g - v * p * S, this._z = d * p * S - v * y * g, this._w = d * p * g + v * y * S;
        break;
      case "ZXY":
        this._x = v * p * g - d * y * S, this._y = d * y * g + v * p * S, this._z = d * p * S + v * y * g, this._w = d * p * g - v * y * S;
        break;
      case "ZYX":
        this._x = v * p * g - d * y * S, this._y = d * y * g + v * p * S, this._z = d * p * S - v * y * g, this._w = d * p * g + v * y * S;
        break;
      case "YZX":
        this._x = v * p * g + d * y * S, this._y = d * y * g + v * p * S, this._z = d * p * S - v * y * g, this._w = d * p * g - v * y * S;
        break;
      case "XZY":
        this._x = v * p * g - d * y * S, this._y = d * y * g - v * p * S, this._z = d * p * S + v * y * g, this._w = d * p * g + v * y * S;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, i = Math.sin(n);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], i = t[4], r = t[8], o = t[1], u = t[5], c = t[9], d = t[2], p = t[6], g = t[10], v = n + u + g;
    if (v > 0) {
      const y = 0.5 / Math.sqrt(v + 1);
      this._w = 0.25 / y, this._x = (p - c) * y, this._y = (r - d) * y, this._z = (o - i) * y;
    } else if (n > u && n > g) {
      const y = 2 * Math.sqrt(1 + n - u - g);
      this._w = (p - c) / y, this._x = 0.25 * y, this._y = (i + o) / y, this._z = (r + d) / y;
    } else if (u > g) {
      const y = 2 * Math.sqrt(1 + u - n - g);
      this._w = (r - d) / y, this._x = (i + o) / y, this._y = 0.25 * y, this._z = (c + p) / y;
    } else {
      const y = 2 * Math.sqrt(1 + g - n - u);
      this._w = (o - i) / y, this._x = (r + d) / y, this._y = (c + p) / y, this._z = 0.25 * y;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Hi(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, i = e._y, r = e._z, o = e._w, u = t._x, c = t._y, d = t._z, p = t._w;
    return this._x = n * p + o * u + i * d - r * c, this._y = i * p + o * c + r * u - n * d, this._z = r * p + o * d + n * c - i * u, this._w = o * p - n * u - i * c - r * d, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x, i = this._y, r = this._z, o = this._w;
    let u = o * e._w + n * e._x + i * e._y + r * e._z;
    if (u < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, u = -u) : this.copy(e), u >= 1)
      return this._w = o, this._x = n, this._y = i, this._z = r, this;
    const c = 1 - u * u;
    if (c <= Number.EPSILON) {
      const y = 1 - t;
      return this._w = y * o + t * this._w, this._x = y * n + t * this._x, this._y = y * i + t * this._y, this._z = y * r + t * this._z, this.normalize(), this;
    }
    const d = Math.sqrt(c), p = Math.atan2(d, u), g = Math.sin((1 - t) * p) / d, v = Math.sin(t * p) / d;
    return this._w = o * g + this._w * v, this._x = n * g + this._x * v, this._y = i * g + this._y * v, this._z = r * g + this._z * v, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), i = 2 * Math.PI * Math.random(), r = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      n * Math.sin(r),
      n * Math.cos(r),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class q {
  constructor(e = 0, t = 0, n = 0) {
    q.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(OR.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(OR.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements, o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, i = this.z, r = e.x, o = e.y, u = e.z, c = e.w, d = 2 * (o * i - u * n), p = 2 * (u * t - r * i), g = 2 * (r * n - o * t);
    return this.x = t + c * d + o * g - u * p, this.y = n + c * p + u * d - r * g, this.z = i + c * g + r * p - o * d, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, i = e.y, r = e.z, o = t.x, u = t.y, c = t.z;
    return this.x = i * c - r * u, this.y = r * o - n * c, this.z = n * u - i * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return GM.copy(this).projectOnVector(e), this.sub(GM);
  }
  reflect(e) {
    return this.sub(GM.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Hi(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2);
    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const GM = /* @__PURE__ */ new q(), OR = /* @__PURE__ */ new ys();
class xs {
  constructor(e = new q(1 / 0, 1 / 0, 1 / 0), t = new q(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Po.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Po.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Po.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const r = n.getAttribute("position");
      if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, u = r.count; o < u; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, Po) : Po.fromBufferAttribute(r, o), Po.applyMatrix4(e.matrixWorld), this.expandByPoint(Po);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Yy.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), Yy.copy(n.boundingBox)), Yy.applyMatrix4(e.matrixWorld), this.union(Yy);
    }
    const i = e.children;
    for (let r = 0, o = i.length; r < o; r++)
      this.expandByObject(i[r], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Po), Po.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Cg), Ky.subVectors(this.max, Cg), Kh.subVectors(e.a, Cg), qh.subVectors(e.b, Cg), jh.subVectors(e.c, Cg), oc.subVectors(qh, Kh), lc.subVectors(jh, qh), wf.subVectors(Kh, jh);
    let t = [
      0,
      -oc.z,
      oc.y,
      0,
      -lc.z,
      lc.y,
      0,
      -wf.z,
      wf.y,
      oc.z,
      0,
      -oc.x,
      lc.z,
      0,
      -lc.x,
      wf.z,
      0,
      -wf.x,
      -oc.y,
      oc.x,
      0,
      -lc.y,
      lc.x,
      0,
      -wf.y,
      wf.x,
      0
    ];
    return !kM(t, Kh, qh, jh, Ky) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !kM(t, Kh, qh, jh, Ky)) ? !1 : (qy.crossVectors(oc, lc), t = [qy.x, qy.y, qy.z], kM(t, Kh, qh, jh, Ky));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Po).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Po).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Ql[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Ql[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Ql[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Ql[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Ql[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Ql[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Ql[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Ql[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Ql), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ql = [
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q(),
  /* @__PURE__ */ new q()
], Po = /* @__PURE__ */ new q(), Yy = /* @__PURE__ */ new xs(), Kh = /* @__PURE__ */ new q(), qh = /* @__PURE__ */ new q(), jh = /* @__PURE__ */ new q(), oc = /* @__PURE__ */ new q(), lc = /* @__PURE__ */ new q(), wf = /* @__PURE__ */ new q(), Cg = /* @__PURE__ */ new q(), Ky = /* @__PURE__ */ new q(), qy = /* @__PURE__ */ new q(), Rf = /* @__PURE__ */ new q();
function kM(s, e, t, n, i) {
  for (let r = 0, o = s.length - 3; r <= o; r += 3) {
    Rf.fromArray(s, r);
    const u = i.x * Math.abs(Rf.x) + i.y * Math.abs(Rf.y) + i.z * Math.abs(Rf.z), c = e.dot(Rf), d = t.dot(Rf), p = n.dot(Rf);
    if (Math.max(-Math.max(c, d, p), Math.min(c, d, p)) > u)
      return !1;
  }
  return !0;
}
const fH = /* @__PURE__ */ new xs(), wg = /* @__PURE__ */ new q(), VM = /* @__PURE__ */ new q();
class Qr {
  constructor(e = new q(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : fH.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let r = 0, o = e.length; r < o; r++)
      i = Math.max(i, n.distanceToSquared(e[r]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    wg.subVectors(e, this.center);
    const t = wg.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
      this.center.addScaledVector(wg, i / n), this.radius += i;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (VM.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(wg.copy(e.center).add(VM)), this.expandByPoint(wg.copy(e.center).sub(VM))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Zl = /* @__PURE__ */ new q(), WM = /* @__PURE__ */ new q(), jy = /* @__PURE__ */ new q(), uc = /* @__PURE__ */ new q(), XM = /* @__PURE__ */ new q(), Qy = /* @__PURE__ */ new q(), JM = /* @__PURE__ */ new q();
class im {
  constructor(e = new q(), t = new q(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Zl)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Zl.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Zl.copy(this.origin).addScaledVector(this.direction, t), Zl.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    WM.copy(e).add(t).multiplyScalar(0.5), jy.copy(t).sub(e).normalize(), uc.copy(this.origin).sub(WM);
    const r = e.distanceTo(t) * 0.5, o = -this.direction.dot(jy), u = uc.dot(this.direction), c = -uc.dot(jy), d = uc.lengthSq(), p = Math.abs(1 - o * o);
    let g, v, y, S;
    if (p > 0)
      if (g = o * c - u, v = o * u - c, S = r * p, g >= 0)
        if (v >= -S)
          if (v <= S) {
            const T = 1 / p;
            g *= T, v *= T, y = g * (g + o * v + 2 * u) + v * (o * g + v + 2 * c) + d;
          } else
            v = r, g = Math.max(0, -(o * v + u)), y = -g * g + v * (v + 2 * c) + d;
        else
          v = -r, g = Math.max(0, -(o * v + u)), y = -g * g + v * (v + 2 * c) + d;
      else
        v <= -S ? (g = Math.max(0, -(-o * r + u)), v = g > 0 ? -r : Math.min(Math.max(-r, -c), r), y = -g * g + v * (v + 2 * c) + d) : v <= S ? (g = 0, v = Math.min(Math.max(-r, -c), r), y = v * (v + 2 * c) + d) : (g = Math.max(0, -(o * r + u)), v = g > 0 ? r : Math.min(Math.max(-r, -c), r), y = -g * g + v * (v + 2 * c) + d);
    else
      v = o > 0 ? -r : r, g = Math.max(0, -(o * v + u)), y = -g * g + v * (v + 2 * c) + d;
    return n && n.copy(this.origin).addScaledVector(this.direction, g), i && i.copy(WM).addScaledVector(jy, v), y;
  }
  intersectSphere(e, t) {
    Zl.subVectors(e.center, this.origin);
    const n = Zl.dot(this.direction), i = Zl.dot(Zl) - n * n, r = e.radius * e.radius;
    if (i > r) return null;
    const o = Math.sqrt(r - i), u = n - o, c = n + o;
    return c < 0 ? null : u < 0 ? this.at(c, t) : this.at(u, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, r, o, u, c;
    const d = 1 / this.direction.x, p = 1 / this.direction.y, g = 1 / this.direction.z, v = this.origin;
    return d >= 0 ? (n = (e.min.x - v.x) * d, i = (e.max.x - v.x) * d) : (n = (e.max.x - v.x) * d, i = (e.min.x - v.x) * d), p >= 0 ? (r = (e.min.y - v.y) * p, o = (e.max.y - v.y) * p) : (r = (e.max.y - v.y) * p, o = (e.min.y - v.y) * p), n > o || r > i || ((r > n || isNaN(n)) && (n = r), (o < i || isNaN(i)) && (i = o), g >= 0 ? (u = (e.min.z - v.z) * g, c = (e.max.z - v.z) * g) : (u = (e.max.z - v.z) * g, c = (e.min.z - v.z) * g), n > c || u > i) || ((u > n || n !== n) && (n = u), (c < i || i !== i) && (i = c), i < 0) ? null : this.at(n >= 0 ? n : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Zl) !== null;
  }
  intersectTriangle(e, t, n, i, r) {
    XM.subVectors(t, e), Qy.subVectors(n, e), JM.crossVectors(XM, Qy);
    let o = this.direction.dot(JM), u;
    if (o > 0) {
      if (i) return null;
      u = 1;
    } else if (o < 0)
      u = -1, o = -o;
    else
      return null;
    uc.subVectors(this.origin, e);
    const c = u * this.direction.dot(Qy.crossVectors(uc, Qy));
    if (c < 0)
      return null;
    const d = u * this.direction.dot(XM.cross(uc));
    if (d < 0 || c + d > o)
      return null;
    const p = -u * uc.dot(JM);
    return p < 0 ? null : this.at(p / o, r);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class sn {
  constructor(e, t, n, i, r, o, u, c, d, p, g, v, y, S, T, E) {
    sn.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, r, o, u, c, d, p, g, v, y, S, T, E);
  }
  set(e, t, n, i, r, o, u, c, d, p, g, v, y, S, T, E) {
    const M = this.elements;
    return M[0] = e, M[4] = t, M[8] = n, M[12] = i, M[1] = r, M[5] = o, M[9] = u, M[13] = c, M[2] = d, M[6] = p, M[10] = g, M[14] = v, M[3] = y, M[7] = S, M[11] = T, M[15] = E, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new sn().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, i = 1 / Qh.setFromMatrixColumn(e, 0).length(), r = 1 / Qh.setFromMatrixColumn(e, 1).length(), o = 1 / Qh.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, i = e.y, r = e.z, o = Math.cos(n), u = Math.sin(n), c = Math.cos(i), d = Math.sin(i), p = Math.cos(r), g = Math.sin(r);
    if (e.order === "XYZ") {
      const v = o * p, y = o * g, S = u * p, T = u * g;
      t[0] = c * p, t[4] = -c * g, t[8] = d, t[1] = y + S * d, t[5] = v - T * d, t[9] = -u * c, t[2] = T - v * d, t[6] = S + y * d, t[10] = o * c;
    } else if (e.order === "YXZ") {
      const v = c * p, y = c * g, S = d * p, T = d * g;
      t[0] = v + T * u, t[4] = S * u - y, t[8] = o * d, t[1] = o * g, t[5] = o * p, t[9] = -u, t[2] = y * u - S, t[6] = T + v * u, t[10] = o * c;
    } else if (e.order === "ZXY") {
      const v = c * p, y = c * g, S = d * p, T = d * g;
      t[0] = v - T * u, t[4] = -o * g, t[8] = S + y * u, t[1] = y + S * u, t[5] = o * p, t[9] = T - v * u, t[2] = -o * d, t[6] = u, t[10] = o * c;
    } else if (e.order === "ZYX") {
      const v = o * p, y = o * g, S = u * p, T = u * g;
      t[0] = c * p, t[4] = S * d - y, t[8] = v * d + T, t[1] = c * g, t[5] = T * d + v, t[9] = y * d - S, t[2] = -d, t[6] = u * c, t[10] = o * c;
    } else if (e.order === "YZX") {
      const v = o * c, y = o * d, S = u * c, T = u * d;
      t[0] = c * p, t[4] = T - v * g, t[8] = S * g + y, t[1] = g, t[5] = o * p, t[9] = -u * p, t[2] = -d * p, t[6] = y * g + S, t[10] = v - T * g;
    } else if (e.order === "XZY") {
      const v = o * c, y = o * d, S = u * c, T = u * d;
      t[0] = c * p, t[4] = -g, t[8] = d * p, t[1] = v * g + T, t[5] = o * p, t[9] = y * g - S, t[2] = S * g - y, t[6] = u * p, t[10] = T * g + v;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(dH, e, hH);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return xa.subVectors(e, t), xa.lengthSq() === 0 && (xa.z = 1), xa.normalize(), cc.crossVectors(n, xa), cc.lengthSq() === 0 && (Math.abs(n.z) === 1 ? xa.x += 1e-4 : xa.z += 1e-4, xa.normalize(), cc.crossVectors(n, xa)), cc.normalize(), Zy.crossVectors(xa, cc), i[0] = cc.x, i[4] = Zy.x, i[8] = xa.x, i[1] = cc.y, i[5] = Zy.y, i[9] = xa.y, i[2] = cc.z, i[6] = Zy.z, i[10] = xa.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, r = this.elements, o = n[0], u = n[4], c = n[8], d = n[12], p = n[1], g = n[5], v = n[9], y = n[13], S = n[2], T = n[6], E = n[10], M = n[14], w = n[3], C = n[7], D = n[11], N = n[15], U = i[0], O = i[4], V = i[8], L = i[12], I = i[1], Y = i[5], Q = i[9], fe = i[13], j = i[2], ie = i[6], re = i[10], pe = i[14], J = i[3], Z = i[7], H = i[11], ue = i[15];
    return r[0] = o * U + u * I + c * j + d * J, r[4] = o * O + u * Y + c * ie + d * Z, r[8] = o * V + u * Q + c * re + d * H, r[12] = o * L + u * fe + c * pe + d * ue, r[1] = p * U + g * I + v * j + y * J, r[5] = p * O + g * Y + v * ie + y * Z, r[9] = p * V + g * Q + v * re + y * H, r[13] = p * L + g * fe + v * pe + y * ue, r[2] = S * U + T * I + E * j + M * J, r[6] = S * O + T * Y + E * ie + M * Z, r[10] = S * V + T * Q + E * re + M * H, r[14] = S * L + T * fe + E * pe + M * ue, r[3] = w * U + C * I + D * j + N * J, r[7] = w * O + C * Y + D * ie + N * Z, r[11] = w * V + C * Q + D * re + N * H, r[15] = w * L + C * fe + D * pe + N * ue, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], o = e[1], u = e[5], c = e[9], d = e[13], p = e[2], g = e[6], v = e[10], y = e[14], S = e[3], T = e[7], E = e[11], M = e[15];
    return S * (+r * c * g - i * d * g - r * u * v + n * d * v + i * u * y - n * c * y) + T * (+t * c * y - t * d * v + r * o * v - i * o * y + i * d * p - r * c * p) + E * (+t * d * g - t * u * y - r * o * g + n * o * y + r * u * p - n * d * p) + M * (-i * u * p - t * c * g + t * u * v + i * o * g - n * o * v + n * c * p);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], u = e[5], c = e[6], d = e[7], p = e[8], g = e[9], v = e[10], y = e[11], S = e[12], T = e[13], E = e[14], M = e[15], w = g * E * d - T * v * d + T * c * y - u * E * y - g * c * M + u * v * M, C = S * v * d - p * E * d - S * c * y + o * E * y + p * c * M - o * v * M, D = p * T * d - S * g * d + S * u * y - o * T * y - p * u * M + o * g * M, N = S * g * c - p * T * c - S * u * v + o * T * v + p * u * E - o * g * E, U = t * w + n * C + i * D + r * N;
    if (U === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const O = 1 / U;
    return e[0] = w * O, e[1] = (T * v * r - g * E * r - T * i * y + n * E * y + g * i * M - n * v * M) * O, e[2] = (u * E * r - T * c * r + T * i * d - n * E * d - u * i * M + n * c * M) * O, e[3] = (g * c * r - u * v * r - g * i * d + n * v * d + u * i * y - n * c * y) * O, e[4] = C * O, e[5] = (p * E * r - S * v * r + S * i * y - t * E * y - p * i * M + t * v * M) * O, e[6] = (S * c * r - o * E * r - S * i * d + t * E * d + o * i * M - t * c * M) * O, e[7] = (o * v * r - p * c * r + p * i * d - t * v * d - o * i * y + t * c * y) * O, e[8] = D * O, e[9] = (S * g * r - p * T * r - S * n * y + t * T * y + p * n * M - t * g * M) * O, e[10] = (o * T * r - S * u * r + S * n * d - t * T * d - o * n * M + t * u * M) * O, e[11] = (p * u * r - o * g * r - p * n * d + t * g * d + o * n * y - t * u * y) * O, e[12] = N * O, e[13] = (p * T * i - S * g * i + S * n * v - t * T * v - p * n * E + t * g * E) * O, e[14] = (S * u * i - o * T * i - S * n * c + t * T * c + o * n * E - t * u * E) * O, e[15] = (o * g * i - p * u * i + p * n * c - t * g * c - o * n * v + t * u * v) * O, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, i = e.y, r = e.z;
    return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), i = Math.sin(t), r = 1 - n, o = e.x, u = e.y, c = e.z, d = r * o, p = r * u;
    return this.set(
      d * o + n,
      d * u - i * c,
      d * c + i * u,
      0,
      d * u + i * c,
      p * u + n,
      p * c - i * o,
      0,
      d * c - i * u,
      p * c + i * o,
      r * c * c + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, i, r, o) {
    return this.set(
      1,
      n,
      r,
      0,
      e,
      1,
      o,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const i = this.elements, r = t._x, o = t._y, u = t._z, c = t._w, d = r + r, p = o + o, g = u + u, v = r * d, y = r * p, S = r * g, T = o * p, E = o * g, M = u * g, w = c * d, C = c * p, D = c * g, N = n.x, U = n.y, O = n.z;
    return i[0] = (1 - (T + M)) * N, i[1] = (y + D) * N, i[2] = (S - C) * N, i[3] = 0, i[4] = (y - D) * U, i[5] = (1 - (v + M)) * U, i[6] = (E + w) * U, i[7] = 0, i[8] = (S + C) * O, i[9] = (E - w) * O, i[10] = (1 - (v + T)) * O, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, n) {
    const i = this.elements;
    let r = Qh.set(i[0], i[1], i[2]).length();
    const o = Qh.set(i[4], i[5], i[6]).length(), u = Qh.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Io.copy(this);
    const d = 1 / r, p = 1 / o, g = 1 / u;
    return Io.elements[0] *= d, Io.elements[1] *= d, Io.elements[2] *= d, Io.elements[4] *= p, Io.elements[5] *= p, Io.elements[6] *= p, Io.elements[8] *= g, Io.elements[9] *= g, Io.elements[10] *= g, t.setFromRotationMatrix(Io), n.x = r, n.y = o, n.z = u, this;
  }
  makePerspective(e, t, n, i, r, o, u = Go) {
    const c = this.elements, d = 2 * r / (t - e), p = 2 * r / (n - i), g = (t + e) / (t - e), v = (n + i) / (n - i);
    let y, S;
    if (u === Go)
      y = -(o + r) / (o - r), S = -2 * o * r / (o - r);
    else if (u === Wp)
      y = -o / (o - r), S = -o * r / (o - r);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + u);
    return c[0] = d, c[4] = 0, c[8] = g, c[12] = 0, c[1] = 0, c[5] = p, c[9] = v, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = y, c[14] = S, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(e, t, n, i, r, o, u = Go) {
    const c = this.elements, d = 1 / (t - e), p = 1 / (n - i), g = 1 / (o - r), v = (t + e) * d, y = (n + i) * p;
    let S, T;
    if (u === Go)
      S = (o + r) * g, T = -2 * g;
    else if (u === Wp)
      S = r * g, T = -1 * g;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + u);
    return c[0] = 2 * d, c[4] = 0, c[8] = 0, c[12] = -v, c[1] = 0, c[5] = 2 * p, c[9] = 0, c[13] = -y, c[2] = 0, c[6] = 0, c[10] = T, c[14] = -S, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const Qh = /* @__PURE__ */ new q(), Io = /* @__PURE__ */ new sn(), dH = /* @__PURE__ */ new q(0, 0, 0), hH = /* @__PURE__ */ new q(1, 1, 1), cc = /* @__PURE__ */ new q(), Zy = /* @__PURE__ */ new q(), xa = /* @__PURE__ */ new q(), HR = /* @__PURE__ */ new sn(), zR = /* @__PURE__ */ new ys();
class rm {
  constructor(e = 0, t = 0, n = 0, i = rm.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements, r = i[0], o = i[4], u = i[8], c = i[1], d = i[5], p = i[9], g = i[2], v = i[6], y = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Hi(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-p, y), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(v, d), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Hi(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(u, y), this._z = Math.atan2(c, d)) : (this._y = Math.atan2(-g, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Hi(v, -1, 1)), Math.abs(v) < 0.9999999 ? (this._y = Math.atan2(-g, y), this._z = Math.atan2(-o, d)) : (this._y = 0, this._z = Math.atan2(c, r));
        break;
      case "ZYX":
        this._y = Math.asin(-Hi(g, -1, 1)), Math.abs(g) < 0.9999999 ? (this._x = Math.atan2(v, y), this._z = Math.atan2(c, r)) : (this._x = 0, this._z = Math.atan2(-o, d));
        break;
      case "YZX":
        this._z = Math.asin(Hi(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-p, d), this._y = Math.atan2(-g, r)) : (this._x = 0, this._y = Math.atan2(u, y));
        break;
      case "XZY":
        this._z = Math.asin(-Hi(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(v, d), this._y = Math.atan2(u, r)) : (this._x = Math.atan2(-p, y), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return HR.makeRotationFromQuaternion(e), this.setFromRotationMatrix(HR, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return zR.setFromEuler(this), this.setFromQuaternion(zR, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
rm.DEFAULT_ORDER = "XYZ";
class id {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let pH = 0;
const GR = /* @__PURE__ */ new q(), Zh = /* @__PURE__ */ new ys(), $l = /* @__PURE__ */ new sn(), $y = /* @__PURE__ */ new q(), Rg = /* @__PURE__ */ new q(), mH = /* @__PURE__ */ new q(), gH = /* @__PURE__ */ new ys(), kR = /* @__PURE__ */ new q(1, 0, 0), VR = /* @__PURE__ */ new q(0, 1, 0), WR = /* @__PURE__ */ new q(0, 0, 1), vH = { type: "added" }, _H = { type: "removed" };
class On extends yu {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: pH++ }), this.uuid = Da(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = On.DEFAULT_UP.clone();
    const e = new q(), t = new rm(), n = new ys(), i = new q(1, 1, 1);
    function r() {
      n.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(r), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new sn()
      },
      normalMatrix: {
        value: new Mn()
      }
    }), this.matrix = new sn(), this.matrixWorld = new sn(), this.matrixAutoUpdate = On.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = On.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new id(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Zh.setFromAxisAngle(e, t), this.quaternion.multiply(Zh), this;
  }
  rotateOnWorldAxis(e, t) {
    return Zh.setFromAxisAngle(e, t), this.quaternion.premultiply(Zh), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(kR, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(VR, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(WR, e);
  }
  translateOnAxis(e, t) {
    return GR.copy(e).applyQuaternion(this.quaternion), this.position.add(GR.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(kR, e);
  }
  translateY(e) {
    return this.translateOnAxis(VR, e);
  }
  translateZ(e) {
    return this.translateOnAxis(WR, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4($l.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? $y.copy(e) : $y.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), Rg.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? $l.lookAt(Rg, $y, this.up) : $l.lookAt($y, Rg, this.up), this.quaternion.setFromRotationMatrix($l), i && ($l.extractRotation(i.matrixWorld), Zh.setFromRotationMatrix($l), this.quaternion.premultiply(Zh.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(vH)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(_H)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), $l.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), $l.multiply(e.parent.matrixWorld)), e.applyMatrix4($l), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const o = this.children[n].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let r = 0, o = i.length; r < o; r++)
      i[r].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Rg, e, mH), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Rg, gH, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const i = this.children;
      for (let r = 0, o = i.length; r < o; r++) {
        const u = i[r];
        u.matrixWorldAutoUpdate === !0 && u.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((u) => ({
      boxInitialized: u.boxInitialized,
      boxMin: u.box.min.toArray(),
      boxMax: u.box.max.toArray(),
      sphereInitialized: u.sphereInitialized,
      sphereRadius: u.sphere.radius,
      sphereCenter: u.sphere.center.toArray()
    })), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (i.boundingSphere = {
      center: i.boundingSphere.center.toArray(),
      radius: i.boundingSphere.radius
    }), this.boundingBox !== null && (i.boundingBox = {
      min: i.boundingBox.min.toArray(),
      max: i.boundingBox.max.toArray()
    }));
    function r(u, c) {
      return u[c.uuid] === void 0 && (u[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(e.geometries, this.geometry);
      const u = this.geometry.parameters;
      if (u !== void 0 && u.shapes !== void 0) {
        const c = u.shapes;
        if (Array.isArray(c))
          for (let d = 0, p = c.length; d < p; d++) {
            const g = c[d];
            r(e.shapes, g);
          }
        else
          r(e.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const u = [];
        for (let c = 0, d = this.material.length; c < d; c++)
          u.push(r(e.materials, this.material[c]));
        i.material = u;
      } else
        i.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let u = 0; u < this.children.length; u++)
        i.children.push(this.children[u].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let u = 0; u < this.animations.length; u++) {
        const c = this.animations[u];
        i.animations.push(r(e.animations, c));
      }
    }
    if (t) {
      const u = o(e.geometries), c = o(e.materials), d = o(e.textures), p = o(e.images), g = o(e.shapes), v = o(e.skeletons), y = o(e.animations), S = o(e.nodes);
      u.length > 0 && (n.geometries = u), c.length > 0 && (n.materials = c), d.length > 0 && (n.textures = d), p.length > 0 && (n.images = p), g.length > 0 && (n.shapes = g), v.length > 0 && (n.skeletons = v), y.length > 0 && (n.animations = y), S.length > 0 && (n.nodes = S);
    }
    return n.object = i, n;
    function o(u) {
      const c = [];
      for (const d in u) {
        const p = u[d];
        delete p.metadata, c.push(p);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
On.DEFAULT_UP = /* @__PURE__ */ new q(0, 1, 0);
On.DEFAULT_MATRIX_AUTO_UPDATE = !0;
On.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Uo = /* @__PURE__ */ new q(), eu = /* @__PURE__ */ new q(), YM = /* @__PURE__ */ new q(), tu = /* @__PURE__ */ new q(), $h = /* @__PURE__ */ new q(), ep = /* @__PURE__ */ new q(), XR = /* @__PURE__ */ new q(), KM = /* @__PURE__ */ new q(), qM = /* @__PURE__ */ new q(), jM = /* @__PURE__ */ new q();
let e0 = !1;
class na {
  constructor(e = new q(), t = new q(), n = new q()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), Uo.subVectors(e, t), i.cross(Uo);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, n, i, r) {
    Uo.subVectors(i, t), eu.subVectors(n, t), YM.subVectors(e, t);
    const o = Uo.dot(Uo), u = Uo.dot(eu), c = Uo.dot(YM), d = eu.dot(eu), p = eu.dot(YM), g = o * d - u * u;
    if (g === 0)
      return r.set(0, 0, 0), null;
    const v = 1 / g, y = (d * c - u * p) * v, S = (o * p - u * c) * v;
    return r.set(1 - y - S, S, y);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, tu) === null ? !1 : tu.x >= 0 && tu.y >= 0 && tu.x + tu.y <= 1;
  }
  static getUV(e, t, n, i, r, o, u, c) {
    return e0 === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), e0 = !0), this.getInterpolation(e, t, n, i, r, o, u, c);
  }
  static getInterpolation(e, t, n, i, r, o, u, c) {
    return this.getBarycoord(e, t, n, i, tu) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(r, tu.x), c.addScaledVector(o, tu.y), c.addScaledVector(u, tu.z), c);
  }
  static isFrontFacing(e, t, n, i) {
    return Uo.subVectors(n, t), eu.subVectors(e, t), Uo.cross(eu).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Uo.subVectors(this.c, this.b), eu.subVectors(this.a, this.b), Uo.cross(eu).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return na.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return na.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, i, r) {
    return e0 === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), e0 = !0), na.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
  }
  getInterpolation(e, t, n, i, r) {
    return na.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
  }
  containsPoint(e) {
    return na.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return na.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, i = this.b, r = this.c;
    let o, u;
    $h.subVectors(i, n), ep.subVectors(r, n), KM.subVectors(e, n);
    const c = $h.dot(KM), d = ep.dot(KM);
    if (c <= 0 && d <= 0)
      return t.copy(n);
    qM.subVectors(e, i);
    const p = $h.dot(qM), g = ep.dot(qM);
    if (p >= 0 && g <= p)
      return t.copy(i);
    const v = c * g - p * d;
    if (v <= 0 && c >= 0 && p <= 0)
      return o = c / (c - p), t.copy(n).addScaledVector($h, o);
    jM.subVectors(e, r);
    const y = $h.dot(jM), S = ep.dot(jM);
    if (S >= 0 && y <= S)
      return t.copy(r);
    const T = y * d - c * S;
    if (T <= 0 && d >= 0 && S <= 0)
      return u = d / (d - S), t.copy(n).addScaledVector(ep, u);
    const E = p * S - y * g;
    if (E <= 0 && g - p >= 0 && y - S >= 0)
      return XR.subVectors(r, i), u = (g - p) / (g - p + (y - S)), t.copy(i).addScaledVector(XR, u);
    const M = 1 / (E + T + v);
    return o = T * M, u = v * M, t.copy(n).addScaledVector($h, o).addScaledVector(ep, u);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const DP = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, fc = { h: 0, s: 0, l: 0 }, t0 = { h: 0, s: 0, l: 0 };
function QM(s, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
}
class Tt {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = Sr) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Zn.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, i = Zn.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, Zn.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, n, i = Zn.workingColorSpace) {
    if (e = Bb(e, 1), t = Hi(t, 0, 1), n = Hi(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const r = n <= 0.5 ? n * (1 + t) : n + t - n * t, o = 2 * n - r;
      this.r = QM(o, r, e + 1 / 3), this.g = QM(o, r, e), this.b = QM(o, r, e - 1 / 3);
    }
    return Zn.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Sr) {
    function n(r) {
      r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let r;
      const o = i[1], u = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(r[4]), this.setRGB(
              Math.min(255, parseInt(r[1], 10)) / 255,
              Math.min(255, parseInt(r[2], 10)) / 255,
              Math.min(255, parseInt(r[3], 10)) / 255,
              t
            );
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(r[4]), this.setRGB(
              Math.min(100, parseInt(r[1], 10)) / 100,
              Math.min(100, parseInt(r[2], 10)) / 100,
              Math.min(100, parseInt(r[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(u))
            return n(r[4]), this.setHSL(
              parseFloat(r[1]) / 360,
              parseFloat(r[2]) / 100,
              parseFloat(r[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const r = i[1], o = r.length;
      if (o === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          t
        );
      if (o === 6)
        return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Sr) {
    const n = DP[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Lp(e.r), this.g = Lp(e.g), this.b = Lp(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = HM(e.r), this.g = HM(e.g), this.b = HM(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Sr) {
    return Zn.fromWorkingColorSpace(hs.copy(this), e), Math.round(Hi(hs.r * 255, 0, 255)) * 65536 + Math.round(Hi(hs.g * 255, 0, 255)) * 256 + Math.round(Hi(hs.b * 255, 0, 255));
  }
  getHexString(e = Sr) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Zn.workingColorSpace) {
    Zn.fromWorkingColorSpace(hs.copy(this), t);
    const n = hs.r, i = hs.g, r = hs.b, o = Math.max(n, i, r), u = Math.min(n, i, r);
    let c, d;
    const p = (u + o) / 2;
    if (u === o)
      c = 0, d = 0;
    else {
      const g = o - u;
      switch (d = p <= 0.5 ? g / (o + u) : g / (2 - o - u), o) {
        case n:
          c = (i - r) / g + (i < r ? 6 : 0);
          break;
        case i:
          c = (r - n) / g + 2;
          break;
        case r:
          c = (n - i) / g + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = d, e.l = p, e;
  }
  getRGB(e, t = Zn.workingColorSpace) {
    return Zn.fromWorkingColorSpace(hs.copy(this), t), e.r = hs.r, e.g = hs.g, e.b = hs.b, e;
  }
  getStyle(e = Sr) {
    Zn.fromWorkingColorSpace(hs.copy(this), e);
    const t = hs.r, n = hs.g, i = hs.b;
    return e !== Sr ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(fc), this.setHSL(fc.h + e, fc.s + t, fc.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(fc), e.getHSL(t0);
    const n = $g(fc.h, t0.h, t), i = $g(fc.s, t0.s, t), r = $g(fc.l, t0.l, t);
    return this.setHSL(n, i, r), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, i = this.b, r = e.elements;
    return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const hs = /* @__PURE__ */ new Tt();
Tt.NAMES = DP;
let yH = 0;
class Mr extends yu {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: yH++ }), this.uuid = Da(), this.name = "", this.type = "Material", this.blending = td, this.side = El, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Mx, this.blendDst = Ex, this.blendEquation = yc, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Tt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = gv, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = PT, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Gf, this.stencilZFail = Gf, this.stencilZPass = Gf, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== td && (n.blending = this.blending), this.side !== El && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Mx && (n.blendSrc = this.blendSrc), this.blendDst !== Ex && (n.blendDst = this.blendDst), this.blendEquation !== yc && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== gv && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== PT && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Gf && (n.stencilFail = this.stencilFail), this.stencilZFail !== Gf && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Gf && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(r) {
      const o = [];
      for (const u in r) {
        const c = r[u];
        delete c.metadata, o.push(c);
      }
      return o;
    }
    if (t) {
      const r = i(e.textures), o = i(e.images);
      r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let r = 0; r !== i; ++r)
        n[r] = t[r].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Ra extends Mr {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Tt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = kv, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const au = /* @__PURE__ */ xH();
function xH() {
  const s = new ArrayBuffer(4), e = new Float32Array(s), t = new Uint32Array(s), n = new Uint32Array(512), i = new Uint32Array(512);
  for (let c = 0; c < 256; ++c) {
    const d = c - 127;
    d < -27 ? (n[c] = 0, n[c | 256] = 32768, i[c] = 24, i[c | 256] = 24) : d < -14 ? (n[c] = 1024 >> -d - 14, n[c | 256] = 1024 >> -d - 14 | 32768, i[c] = -d - 1, i[c | 256] = -d - 1) : d <= 15 ? (n[c] = d + 15 << 10, n[c | 256] = d + 15 << 10 | 32768, i[c] = 13, i[c | 256] = 13) : d < 128 ? (n[c] = 31744, n[c | 256] = 64512, i[c] = 24, i[c | 256] = 24) : (n[c] = 31744, n[c | 256] = 64512, i[c] = 13, i[c | 256] = 13);
  }
  const r = new Uint32Array(2048), o = new Uint32Array(64), u = new Uint32Array(64);
  for (let c = 1; c < 1024; ++c) {
    let d = c << 13, p = 0;
    for (; (d & 8388608) === 0; )
      d <<= 1, p -= 8388608;
    d &= -8388609, p += 947912704, r[c] = d | p;
  }
  for (let c = 1024; c < 2048; ++c)
    r[c] = 939524096 + (c - 1024 << 13);
  for (let c = 1; c < 31; ++c)
    o[c] = c << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let c = 33; c < 63; ++c)
    o[c] = 2147483648 + (c - 32 << 23);
  o[63] = 3347054592;
  for (let c = 1; c < 64; ++c)
    c !== 32 && (u[c] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: r,
    exponentTable: o,
    offsetTable: u
  };
}
function ea(s) {
  Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = Hi(s, -65504, 65504), au.floatView[0] = s;
  const e = au.uint32View[0], t = e >> 23 & 511;
  return au.baseTable[t] + ((e & 8388607) >> au.shiftTable[t]);
}
function Wg(s) {
  const e = s >> 10;
  return au.uint32View[0] = au.mantissaTable[au.offsetTable[e] + (s & 1023)] + au.exponentTable[e], au.floatView[0];
}
const SH = {
  toHalfFloat: ea,
  fromHalfFloat: Wg
}, sr = /* @__PURE__ */ new q(), n0 = /* @__PURE__ */ new qe();
class Hn {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = Ev, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = zo, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let i = 0, r = this.itemSize; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        n0.fromBufferAttribute(this, t), n0.applyMatrix3(e), this.setXY(t, n0.x, n0.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        sr.fromBufferAttribute(this, t), sr.applyMatrix3(e), this.setXYZ(t, sr.x, sr.y, sr.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      sr.fromBufferAttribute(this, t), sr.applyMatrix4(e), this.setXYZ(t, sr.x, sr.y, sr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      sr.fromBufferAttribute(this, t), sr.applyNormalMatrix(e), this.setXYZ(t, sr.x, sr.y, sr.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      sr.fromBufferAttribute(this, t), sr.transformDirection(e), this.setXYZ(t, sr.x, sr.y, sr.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = ia(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = xn(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = ia(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = ia(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = ia(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = ia(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, r) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array), r = xn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Ev && (e.usage = this.usage), e;
  }
}
class AH extends Hn {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class MH extends Hn {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class EH extends Hn {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class TH extends Hn {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class Pb extends Hn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class bH extends Hn {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class Ib extends Hn {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class CH extends Hn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = Wg(this.array[e * this.itemSize]);
    return this.normalized && (t = ia(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize] = ea(t), this;
  }
  getY(e) {
    let t = Wg(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = ia(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 1] = ea(t), this;
  }
  getZ(e) {
    let t = Wg(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = ia(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 2] = ea(t), this;
  }
  getW(e) {
    let t = Wg(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = ia(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 3] = ea(t), this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array)), this.array[e + 0] = ea(t), this.array[e + 1] = ea(n), this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array)), this.array[e + 0] = ea(t), this.array[e + 1] = ea(n), this.array[e + 2] = ea(i), this;
  }
  setXYZW(e, t, n, i, r) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array), r = xn(r, this.array)), this.array[e + 0] = ea(t), this.array[e + 1] = ea(n), this.array[e + 2] = ea(i), this.array[e + 3] = ea(r), this;
  }
}
class Kt extends Hn {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
class wH extends Hn {
  constructor(e, t, n) {
    super(new Float64Array(e), t, n);
  }
}
let RH = 0;
const ro = /* @__PURE__ */ new sn(), ZM = /* @__PURE__ */ new On(), tp = /* @__PURE__ */ new q(), Sa = /* @__PURE__ */ new xs(), Bg = /* @__PURE__ */ new xs(), Br = /* @__PURE__ */ new q();
class pn extends yu {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: RH++ }), this.uuid = Da(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (wP(e) ? Ib : Pb)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new Mn().getNormalMatrix(e);
      n.applyNormalMatrix(r), n.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return ro.makeRotationFromQuaternion(e), this.applyMatrix4(ro), this;
  }
  rotateX(e) {
    return ro.makeRotationX(e), this.applyMatrix4(ro), this;
  }
  rotateY(e) {
    return ro.makeRotationY(e), this.applyMatrix4(ro), this;
  }
  rotateZ(e) {
    return ro.makeRotationZ(e), this.applyMatrix4(ro), this;
  }
  translate(e, t, n) {
    return ro.makeTranslation(e, t, n), this.applyMatrix4(ro), this;
  }
  scale(e, t, n) {
    return ro.makeScale(e, t, n), this.applyMatrix4(ro), this;
  }
  lookAt(e) {
    return ZM.lookAt(e), ZM.updateMatrix(), this.applyMatrix4(ZM.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(tp).negate(), this.translate(tp.x, tp.y, tp.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const r = e[n];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new Kt(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new xs());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new q(-1 / 0, -1 / 0, -1 / 0),
        new q(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, i = t.length; n < i; n++) {
          const r = t[n];
          Sa.setFromBufferAttribute(r), this.morphTargetsRelative ? (Br.addVectors(this.boundingBox.min, Sa.min), this.boundingBox.expandByPoint(Br), Br.addVectors(this.boundingBox.max, Sa.max), this.boundingBox.expandByPoint(Br)) : (this.boundingBox.expandByPoint(Sa.min), this.boundingBox.expandByPoint(Sa.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Qr());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new q(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (Sa.setFromBufferAttribute(e), t)
        for (let r = 0, o = t.length; r < o; r++) {
          const u = t[r];
          Bg.setFromBufferAttribute(u), this.morphTargetsRelative ? (Br.addVectors(Sa.min, Bg.min), Sa.expandByPoint(Br), Br.addVectors(Sa.max, Bg.max), Sa.expandByPoint(Br)) : (Sa.expandByPoint(Bg.min), Sa.expandByPoint(Bg.max));
        }
      Sa.getCenter(n);
      let i = 0;
      for (let r = 0, o = e.count; r < o; r++)
        Br.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(Br));
      if (t)
        for (let r = 0, o = t.length; r < o; r++) {
          const u = t[r], c = this.morphTargetsRelative;
          for (let d = 0, p = u.count; d < p; d++)
            Br.fromBufferAttribute(u, d), c && (tp.fromBufferAttribute(e, d), Br.add(tp)), i = Math.max(i, n.distanceToSquared(Br));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = e.array, i = t.position.array, r = t.normal.array, o = t.uv.array, u = i.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Hn(new Float32Array(4 * u), 4));
    const c = this.getAttribute("tangent").array, d = [], p = [];
    for (let I = 0; I < u; I++)
      d[I] = new q(), p[I] = new q();
    const g = new q(), v = new q(), y = new q(), S = new qe(), T = new qe(), E = new qe(), M = new q(), w = new q();
    function C(I, Y, Q) {
      g.fromArray(i, I * 3), v.fromArray(i, Y * 3), y.fromArray(i, Q * 3), S.fromArray(o, I * 2), T.fromArray(o, Y * 2), E.fromArray(o, Q * 2), v.sub(g), y.sub(g), T.sub(S), E.sub(S);
      const fe = 1 / (T.x * E.y - E.x * T.y);
      isFinite(fe) && (M.copy(v).multiplyScalar(E.y).addScaledVector(y, -T.y).multiplyScalar(fe), w.copy(y).multiplyScalar(T.x).addScaledVector(v, -E.x).multiplyScalar(fe), d[I].add(M), d[Y].add(M), d[Q].add(M), p[I].add(w), p[Y].add(w), p[Q].add(w));
    }
    let D = this.groups;
    D.length === 0 && (D = [{
      start: 0,
      count: n.length
    }]);
    for (let I = 0, Y = D.length; I < Y; ++I) {
      const Q = D[I], fe = Q.start, j = Q.count;
      for (let ie = fe, re = fe + j; ie < re; ie += 3)
        C(
          n[ie + 0],
          n[ie + 1],
          n[ie + 2]
        );
    }
    const N = new q(), U = new q(), O = new q(), V = new q();
    function L(I) {
      O.fromArray(r, I * 3), V.copy(O);
      const Y = d[I];
      N.copy(Y), N.sub(O.multiplyScalar(O.dot(Y))).normalize(), U.crossVectors(V, Y);
      const fe = U.dot(p[I]) < 0 ? -1 : 1;
      c[I * 4] = N.x, c[I * 4 + 1] = N.y, c[I * 4 + 2] = N.z, c[I * 4 + 3] = fe;
    }
    for (let I = 0, Y = D.length; I < Y; ++I) {
      const Q = D[I], fe = Q.start, j = Q.count;
      for (let ie = fe, re = fe + j; ie < re; ie += 3)
        L(n[ie + 0]), L(n[ie + 1]), L(n[ie + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Hn(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let v = 0, y = n.count; v < y; v++)
          n.setXYZ(v, 0, 0, 0);
      const i = new q(), r = new q(), o = new q(), u = new q(), c = new q(), d = new q(), p = new q(), g = new q();
      if (e)
        for (let v = 0, y = e.count; v < y; v += 3) {
          const S = e.getX(v + 0), T = e.getX(v + 1), E = e.getX(v + 2);
          i.fromBufferAttribute(t, S), r.fromBufferAttribute(t, T), o.fromBufferAttribute(t, E), p.subVectors(o, r), g.subVectors(i, r), p.cross(g), u.fromBufferAttribute(n, S), c.fromBufferAttribute(n, T), d.fromBufferAttribute(n, E), u.add(p), c.add(p), d.add(p), n.setXYZ(S, u.x, u.y, u.z), n.setXYZ(T, c.x, c.y, c.z), n.setXYZ(E, d.x, d.y, d.z);
        }
      else
        for (let v = 0, y = t.count; v < y; v += 3)
          i.fromBufferAttribute(t, v + 0), r.fromBufferAttribute(t, v + 1), o.fromBufferAttribute(t, v + 2), p.subVectors(o, r), g.subVectors(i, r), p.cross(g), n.setXYZ(v + 0, p.x, p.y, p.z), n.setXYZ(v + 1, p.x, p.y, p.z), n.setXYZ(v + 2, p.x, p.y, p.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Br.fromBufferAttribute(e, t), Br.normalize(), e.setXYZ(t, Br.x, Br.y, Br.z);
  }
  toNonIndexed() {
    function e(u, c) {
      const d = u.array, p = u.itemSize, g = u.normalized, v = new d.constructor(c.length * p);
      let y = 0, S = 0;
      for (let T = 0, E = c.length; T < E; T++) {
        u.isInterleavedBufferAttribute ? y = c[T] * u.data.stride + u.offset : y = c[T] * p;
        for (let M = 0; M < p; M++)
          v[S++] = d[y++];
      }
      return new Hn(v, p, g);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new pn(), n = this.index.array, i = this.attributes;
    for (const u in i) {
      const c = i[u], d = e(c, n);
      t.setAttribute(u, d);
    }
    const r = this.morphAttributes;
    for (const u in r) {
      const c = [], d = r[u];
      for (let p = 0, g = d.length; p < g; p++) {
        const v = d[p], y = e(v, n);
        c.push(y);
      }
      t.morphAttributes[u] = c;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let u = 0, c = o.length; u < c; u++) {
      const d = o[u];
      t.addGroup(d.start, d.count, d.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const d in c)
        c[d] !== void 0 && (e[d] = c[d]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const c in n) {
      const d = n[c];
      e.data.attributes[c] = d.toJSON(e.data);
    }
    const i = {};
    let r = !1;
    for (const c in this.morphAttributes) {
      const d = this.morphAttributes[c], p = [];
      for (let g = 0, v = d.length; g < v; g++) {
        const y = d[g];
        p.push(y.toJSON(e.data));
      }
      p.length > 0 && (i[c] = p, r = !0);
    }
    r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const u = this.boundingSphere;
    return u !== null && (e.data.boundingSphere = {
      center: u.center.toArray(),
      radius: u.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const d in i) {
      const p = i[d];
      this.setAttribute(d, p.clone(t));
    }
    const r = e.morphAttributes;
    for (const d in r) {
      const p = [], g = r[d];
      for (let v = 0, y = g.length; v < y; v++)
        p.push(g[v].clone(t));
      this.morphAttributes[d] = p;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let d = 0, p = o.length; d < p; d++) {
      const g = o[d];
      this.addGroup(g.start, g.count, g.materialIndex);
    }
    const u = e.boundingBox;
    u !== null && (this.boundingBox = u.clone());
    const c = e.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const JR = /* @__PURE__ */ new sn(), Bf = /* @__PURE__ */ new im(), i0 = /* @__PURE__ */ new Qr(), YR = /* @__PURE__ */ new q(), np = /* @__PURE__ */ new q(), ip = /* @__PURE__ */ new q(), rp = /* @__PURE__ */ new q(), $M = /* @__PURE__ */ new q(), r0 = /* @__PURE__ */ new q(), s0 = /* @__PURE__ */ new qe(), a0 = /* @__PURE__ */ new qe(), o0 = /* @__PURE__ */ new qe(), KR = /* @__PURE__ */ new q(), qR = /* @__PURE__ */ new q(), jR = /* @__PURE__ */ new q(), l0 = /* @__PURE__ */ new q(), u0 = /* @__PURE__ */ new q();
class ur extends On {
  constructor(e = new pn(), t = new Ra()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = i.length; r < o; r++) {
          const u = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = r;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, i = n.attributes.position, r = n.morphAttributes.position, o = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const u = this.morphTargetInfluences;
    if (r && u) {
      r0.set(0, 0, 0);
      for (let c = 0, d = r.length; c < d; c++) {
        const p = u[c], g = r[c];
        p !== 0 && ($M.fromBufferAttribute(g, e), o ? r0.addScaledVector($M, p) : r0.addScaledVector($M.sub(t), p));
      }
      t.add(r0);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.material, r = this.matrixWorld;
    i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), i0.copy(n.boundingSphere), i0.applyMatrix4(r), Bf.copy(e.ray).recast(e.near), !(i0.containsPoint(Bf.origin) === !1 && (Bf.intersectSphere(i0, YR) === null || Bf.origin.distanceToSquared(YR) > (e.far - e.near) ** 2)) && (JR.copy(r).invert(), Bf.copy(e.ray).applyMatrix4(JR), !(n.boundingBox !== null && Bf.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Bf)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const r = this.geometry, o = this.material, u = r.index, c = r.attributes.position, d = r.attributes.uv, p = r.attributes.uv1, g = r.attributes.normal, v = r.groups, y = r.drawRange;
    if (u !== null)
      if (Array.isArray(o))
        for (let S = 0, T = v.length; S < T; S++) {
          const E = v[S], M = o[E.materialIndex], w = Math.max(E.start, y.start), C = Math.min(u.count, Math.min(E.start + E.count, y.start + y.count));
          for (let D = w, N = C; D < N; D += 3) {
            const U = u.getX(D), O = u.getX(D + 1), V = u.getX(D + 2);
            i = c0(this, M, e, n, d, p, g, U, O, V), i && (i.faceIndex = Math.floor(D / 3), i.face.materialIndex = E.materialIndex, t.push(i));
          }
        }
      else {
        const S = Math.max(0, y.start), T = Math.min(u.count, y.start + y.count);
        for (let E = S, M = T; E < M; E += 3) {
          const w = u.getX(E), C = u.getX(E + 1), D = u.getX(E + 2);
          i = c0(this, o, e, n, d, p, g, w, C, D), i && (i.faceIndex = Math.floor(E / 3), t.push(i));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(o))
        for (let S = 0, T = v.length; S < T; S++) {
          const E = v[S], M = o[E.materialIndex], w = Math.max(E.start, y.start), C = Math.min(c.count, Math.min(E.start + E.count, y.start + y.count));
          for (let D = w, N = C; D < N; D += 3) {
            const U = D, O = D + 1, V = D + 2;
            i = c0(this, M, e, n, d, p, g, U, O, V), i && (i.faceIndex = Math.floor(D / 3), i.face.materialIndex = E.materialIndex, t.push(i));
          }
        }
      else {
        const S = Math.max(0, y.start), T = Math.min(c.count, y.start + y.count);
        for (let E = S, M = T; E < M; E += 3) {
          const w = E, C = E + 1, D = E + 2;
          i = c0(this, o, e, n, d, p, g, w, C, D), i && (i.faceIndex = Math.floor(E / 3), t.push(i));
        }
      }
  }
}
function BH(s, e, t, n, i, r, o, u) {
  let c;
  if (e.side === zs ? c = n.intersectTriangle(o, r, i, !0, u) : c = n.intersectTriangle(i, r, o, e.side === El, u), c === null) return null;
  u0.copy(u), u0.applyMatrix4(s.matrixWorld);
  const d = t.ray.origin.distanceTo(u0);
  return d < t.near || d > t.far ? null : {
    distance: d,
    point: u0.clone(),
    object: s
  };
}
function c0(s, e, t, n, i, r, o, u, c, d) {
  s.getVertexPosition(u, np), s.getVertexPosition(c, ip), s.getVertexPosition(d, rp);
  const p = BH(s, e, t, n, np, ip, rp, l0);
  if (p) {
    i && (s0.fromBufferAttribute(i, u), a0.fromBufferAttribute(i, c), o0.fromBufferAttribute(i, d), p.uv = na.getInterpolation(l0, np, ip, rp, s0, a0, o0, new qe())), r && (s0.fromBufferAttribute(r, u), a0.fromBufferAttribute(r, c), o0.fromBufferAttribute(r, d), p.uv1 = na.getInterpolation(l0, np, ip, rp, s0, a0, o0, new qe()), p.uv2 = p.uv1), o && (KR.fromBufferAttribute(o, u), qR.fromBufferAttribute(o, c), jR.fromBufferAttribute(o, d), p.normal = na.getInterpolation(l0, np, ip, rp, KR, qR, jR, new q()), p.normal.dot(n.direction) > 0 && p.normal.multiplyScalar(-1));
    const g = {
      a: u,
      b: c,
      c: d,
      normal: new q(),
      materialIndex: 0
    };
    na.getNormal(np, ip, rp, g.normal), p.face = g;
  }
  return p;
}
class Md extends pn {
  constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: i,
      heightSegments: r,
      depthSegments: o
    };
    const u = this;
    i = Math.floor(i), r = Math.floor(r), o = Math.floor(o);
    const c = [], d = [], p = [], g = [];
    let v = 0, y = 0;
    S("z", "y", "x", -1, -1, n, t, e, o, r, 0), S("z", "y", "x", 1, -1, n, t, -e, o, r, 1), S("x", "z", "y", 1, 1, e, n, t, i, o, 2), S("x", "z", "y", 1, -1, e, n, -t, i, o, 3), S("x", "y", "z", 1, -1, e, t, n, i, r, 4), S("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(c), this.setAttribute("position", new Kt(d, 3)), this.setAttribute("normal", new Kt(p, 3)), this.setAttribute("uv", new Kt(g, 2));
    function S(T, E, M, w, C, D, N, U, O, V, L) {
      const I = D / O, Y = N / V, Q = D / 2, fe = N / 2, j = U / 2, ie = O + 1, re = V + 1;
      let pe = 0, J = 0;
      const Z = new q();
      for (let H = 0; H < re; H++) {
        const ue = H * Y - fe;
        for (let Se = 0; Se < ie; Se++) {
          const me = Se * I - Q;
          Z[T] = me * w, Z[E] = ue * C, Z[M] = j, d.push(Z.x, Z.y, Z.z), Z[T] = 0, Z[E] = 0, Z[M] = U > 0 ? 1 : -1, p.push(Z.x, Z.y, Z.z), g.push(Se / O), g.push(1 - H / V), pe += 1;
        }
      }
      for (let H = 0; H < V; H++)
        for (let ue = 0; ue < O; ue++) {
          const Se = v + ue + ie * H, me = v + ue + ie * (H + 1), ye = v + (ue + 1) + ie * (H + 1), Xe = v + (ue + 1) + ie * H;
          c.push(Se, me, Xe), c.push(me, ye, Xe), J += 6;
        }
      u.addGroup(y, J, L), y += J, v += pe;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Md(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Jp(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const n in s[t]) {
      const i = s[t][n];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
    }
  }
  return e;
}
function Ps(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const n = Jp(s[t]);
    for (const i in n)
      e[i] = n[i];
  }
  return e;
}
function DH(s) {
  const e = [];
  for (let t = 0; t < s.length; t++)
    e.push(s[t].clone());
  return e;
}
function LP(s) {
  return s.getRenderTarget() === null ? s.outputColorSpace : Zn.workingColorSpace;
}
const PP = { clone: Jp, merge: Ps };
var LH = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, PH = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Cl extends Mr {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = LH, this.fragmentShader = PH, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1,
      // set to use shader texture LOD
      clipCullDistance: !1
      // set to use vertex shader clipping
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Jp(e.uniforms), this.uniformsGroups = DH(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture ? t.uniforms[i] = {
        type: "t",
        value: o.toJSON(e).uuid
      } : o && o.isColor ? t.uniforms[i] = {
        type: "c",
        value: o.getHex()
      } : o && o.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: o.toArray()
      } : o && o.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: o.toArray()
      } : o && o.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: o.toArray()
      } : o && o.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: o.toArray()
      } : o && o.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: o.toArray()
      } : t.uniforms[i] = {
        value: o
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class Wv extends On {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new sn(), this.projectionMatrix = new sn(), this.projectionMatrixInverse = new sn(), this.coordinateSystem = Go;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ar extends Wv {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = Xp * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(nd * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return Xp * 2 * Math.atan(
      Math.tan(nd * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, n, i, r, o) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(nd * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = o.fullWidth, d = o.fullHeight;
      r += o.offsetX * i / c, t -= o.offsetY * n / d, i *= o.width / c, n *= o.height / d;
    }
    const u = this.filmOffset;
    u !== 0 && (r += e * u / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const sp = -90, ap = 1;
class IP extends On {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new Ar(sp, ap, e, t);
    i.layers = this.layers, this.add(i);
    const r = new Ar(sp, ap, e, t);
    r.layers = this.layers, this.add(r);
    const o = new Ar(sp, ap, e, t);
    o.layers = this.layers, this.add(o);
    const u = new Ar(sp, ap, e, t);
    u.layers = this.layers, this.add(u);
    const c = new Ar(sp, ap, e, t);
    c.layers = this.layers, this.add(c);
    const d = new Ar(sp, ap, e, t);
    d.layers = this.layers, this.add(d);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, i, r, o, u, c] = t;
    for (const d of t) this.remove(d);
    if (e === Go)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), u.up.set(0, 1, 0), u.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (e === Wp)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), u.up.set(0, -1, 0), u.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const d of t)
      this.add(d), d.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [r, o, u, c, d, p] = this.children, g = e.getRenderTarget(), v = e.getActiveCubeFace(), y = e.getActiveMipmapLevel(), S = e.xr.enabled;
    e.xr.enabled = !1;
    const T = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, o), e.setRenderTarget(n, 2, i), e.render(t, u), e.setRenderTarget(n, 3, i), e.render(t, c), e.setRenderTarget(n, 4, i), e.render(t, d), n.texture.generateMipmaps = T, e.setRenderTarget(n, 5, i), e.render(t, p), e.setRenderTarget(g, v, y), e.xr.enabled = S, n.texture.needsPMREMUpdate = !0;
  }
}
class Xv extends Ri {
  constructor(e, t, n, i, r, o, u, c, d, p) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : mu, super(e, t, n, i, r, o, u, c, d, p), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class UP extends ko {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n];
    t.encoding !== void 0 && (tv("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === wc ? Sr : ba), this.texture = new Xv(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : bi;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new Md(5, 5, 5), r = new Cl({
      name: "CubemapFromEquirect",
      uniforms: Jp(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: zs,
      blending: du
    });
    r.uniforms.tEquirect.value = t;
    const o = new ur(i, r), u = t.minFilter;
    return t.minFilter === Tl && (t.minFilter = bi), new IP(1, 10, this).update(e, o), t.minFilter = u, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, t, n, i) {
    const r = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(t, n, i);
    e.setRenderTarget(r);
  }
}
const eE = /* @__PURE__ */ new q(), IH = /* @__PURE__ */ new q(), UH = /* @__PURE__ */ new Mn();
class _c {
  constructor(e = new q(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = eE.subVectors(n, t).cross(IH.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(eE), i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || UH.getNormalMatrix(e), i = this.coplanarPoint(eE).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(r), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Df = /* @__PURE__ */ new Qr(), f0 = /* @__PURE__ */ new q();
class Jv {
  constructor(e = new _c(), t = new _c(), n = new _c(), i = new _c(), r = new _c(), o = new _c()) {
    this.planes = [e, t, n, i, r, o];
  }
  set(e, t, n, i, r, o) {
    const u = this.planes;
    return u[0].copy(e), u[1].copy(t), u[2].copy(n), u[3].copy(i), u[4].copy(r), u[5].copy(o), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = Go) {
    const n = this.planes, i = e.elements, r = i[0], o = i[1], u = i[2], c = i[3], d = i[4], p = i[5], g = i[6], v = i[7], y = i[8], S = i[9], T = i[10], E = i[11], M = i[12], w = i[13], C = i[14], D = i[15];
    if (n[0].setComponents(c - r, v - d, E - y, D - M).normalize(), n[1].setComponents(c + r, v + d, E + y, D + M).normalize(), n[2].setComponents(c + o, v + p, E + S, D + w).normalize(), n[3].setComponents(c - o, v - p, E - S, D - w).normalize(), n[4].setComponents(c - u, v - g, E - T, D - C).normalize(), t === Go)
      n[5].setComponents(c + u, v + g, E + T, D + C).normalize();
    else if (t === Wp)
      n[5].setComponents(u, g, T, C).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), Df.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), Df.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Df);
  }
  intersectsSprite(e) {
    return Df.center.set(0, 0, 0), Df.radius = 0.7071067811865476, Df.applyMatrix4(e.matrixWorld), this.intersectsSphere(Df);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, i = -e.radius;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(n) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (f0.x = i.normal.x > 0 ? e.max.x : e.min.x, f0.y = i.normal.y > 0 ? e.max.y : e.min.y, f0.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(f0) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function FP() {
  let s = null, e = !1, t = null, n = null;
  function i(r, o) {
    t(r, o), n = s.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = s.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      s.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(r) {
      t = r;
    },
    setContext: function(r) {
      s = r;
    }
  };
}
function FH(s, e) {
  const t = e.isWebGL2, n = /* @__PURE__ */ new WeakMap();
  function i(d, p) {
    const g = d.array, v = d.usage, y = g.byteLength, S = s.createBuffer();
    s.bindBuffer(p, S), s.bufferData(p, g, v), d.onUploadCallback();
    let T;
    if (g instanceof Float32Array)
      T = s.FLOAT;
    else if (g instanceof Uint16Array)
      if (d.isFloat16BufferAttribute)
        if (t)
          T = s.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        T = s.UNSIGNED_SHORT;
    else if (g instanceof Int16Array)
      T = s.SHORT;
    else if (g instanceof Uint32Array)
      T = s.UNSIGNED_INT;
    else if (g instanceof Int32Array)
      T = s.INT;
    else if (g instanceof Int8Array)
      T = s.BYTE;
    else if (g instanceof Uint8Array)
      T = s.UNSIGNED_BYTE;
    else if (g instanceof Uint8ClampedArray)
      T = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + g);
    return {
      buffer: S,
      type: T,
      bytesPerElement: g.BYTES_PER_ELEMENT,
      version: d.version,
      size: y
    };
  }
  function r(d, p, g) {
    const v = p.array, y = p._updateRange, S = p.updateRanges;
    if (s.bindBuffer(g, d), y.count === -1 && S.length === 0 && s.bufferSubData(g, 0, v), S.length !== 0) {
      for (let T = 0, E = S.length; T < E; T++) {
        const M = S[T];
        t ? s.bufferSubData(
          g,
          M.start * v.BYTES_PER_ELEMENT,
          v,
          M.start,
          M.count
        ) : s.bufferSubData(
          g,
          M.start * v.BYTES_PER_ELEMENT,
          v.subarray(M.start, M.start + M.count)
        );
      }
      p.clearUpdateRanges();
    }
    y.count !== -1 && (t ? s.bufferSubData(
      g,
      y.offset * v.BYTES_PER_ELEMENT,
      v,
      y.offset,
      y.count
    ) : s.bufferSubData(
      g,
      y.offset * v.BYTES_PER_ELEMENT,
      v.subarray(y.offset, y.offset + y.count)
    ), y.count = -1), p.onUploadCallback();
  }
  function o(d) {
    return d.isInterleavedBufferAttribute && (d = d.data), n.get(d);
  }
  function u(d) {
    d.isInterleavedBufferAttribute && (d = d.data);
    const p = n.get(d);
    p && (s.deleteBuffer(p.buffer), n.delete(d));
  }
  function c(d, p) {
    if (d.isGLBufferAttribute) {
      const v = n.get(d);
      (!v || v.version < d.version) && n.set(d, {
        buffer: d.buffer,
        type: d.type,
        bytesPerElement: d.elementSize,
        version: d.version
      });
      return;
    }
    d.isInterleavedBufferAttribute && (d = d.data);
    const g = n.get(d);
    if (g === void 0)
      n.set(d, i(d, p));
    else if (g.version < d.version) {
      if (g.size !== d.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      r(g.buffer, d, p), g.version = d.version;
    }
  }
  return {
    get: o,
    remove: u,
    update: c
  };
}
class Yv extends pn {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: i
    };
    const r = e / 2, o = t / 2, u = Math.floor(n), c = Math.floor(i), d = u + 1, p = c + 1, g = e / u, v = t / c, y = [], S = [], T = [], E = [];
    for (let M = 0; M < p; M++) {
      const w = M * v - o;
      for (let C = 0; C < d; C++) {
        const D = C * g - r;
        S.push(D, -w, 0), T.push(0, 0, 1), E.push(C / u), E.push(1 - M / c);
      }
    }
    for (let M = 0; M < c; M++)
      for (let w = 0; w < u; w++) {
        const C = w + d * M, D = w + d * (M + 1), N = w + 1 + d * (M + 1), U = w + 1 + d * M;
        y.push(C, D, U), y.push(D, N, U);
      }
    this.setIndex(y), this.setAttribute("position", new Kt(S, 3)), this.setAttribute("normal", new Kt(T, 3)), this.setAttribute("uv", new Kt(E, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Yv(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var NH = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, OH = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, HH = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, zH = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, GH = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, kH = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, VH = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, WH = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, XH = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, JH = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, YH = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, KH = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, qH = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, jH = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, QH = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, ZH = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, $H = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, ez = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, tz = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, nz = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, iz = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, rz = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, sz = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, az = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, oz = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, lz = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, uz = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, cz = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, fz = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, dz = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, hz = "gl_FragColor = linearToOutputTexel( gl_FragColor );", pz = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, mz = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, gz = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, vz = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, _z = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, yz = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, xz = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Sz = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Az = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Mz = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Ez = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Tz = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, bz = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Cz = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, wz = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Rz = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Bz = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Dz = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Lz = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Pz = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Iz = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Uz = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Fz = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Nz = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Oz = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Hz = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, zz = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Gz = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, kz = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, Vz = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, Wz = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Xz = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Jz = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Yz = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Kz = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, qz = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, jz = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Qz = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, Zz = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, $z = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, eG = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, tG = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, nG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, iG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, rG = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, sG = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, aG = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, oG = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, lG = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, uG = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, cG = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, fG = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, dG = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, hG = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, pG = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, mG = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, gG = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, vG = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, _G = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, yG = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, xG = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, SG = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, AG = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, MG = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, EG = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, TG = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, bG = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, CG = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, wG = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, RG = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, BG = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, DG = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, LG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, PG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, IG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, UG = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const FG = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, NG = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, OG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, HG = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, zG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, GG = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, kG = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, VG = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, WG = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, XG = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, JG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, YG = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, KG = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, qG = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, jG = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, QG = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ZG = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, $G = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ek = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, tk = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, nk = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, ik = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, rk = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, sk = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ak = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, ok = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, lk = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, uk = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ck = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, fk = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, dk = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, hk = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, pk = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, mk = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, yn = {
  alphahash_fragment: NH,
  alphahash_pars_fragment: OH,
  alphamap_fragment: HH,
  alphamap_pars_fragment: zH,
  alphatest_fragment: GH,
  alphatest_pars_fragment: kH,
  aomap_fragment: VH,
  aomap_pars_fragment: WH,
  batching_pars_vertex: XH,
  batching_vertex: JH,
  begin_vertex: YH,
  beginnormal_vertex: KH,
  bsdfs: qH,
  iridescence_fragment: jH,
  bumpmap_pars_fragment: QH,
  clipping_planes_fragment: ZH,
  clipping_planes_pars_fragment: $H,
  clipping_planes_pars_vertex: ez,
  clipping_planes_vertex: tz,
  color_fragment: nz,
  color_pars_fragment: iz,
  color_pars_vertex: rz,
  color_vertex: sz,
  common: az,
  cube_uv_reflection_fragment: oz,
  defaultnormal_vertex: lz,
  displacementmap_pars_vertex: uz,
  displacementmap_vertex: cz,
  emissivemap_fragment: fz,
  emissivemap_pars_fragment: dz,
  colorspace_fragment: hz,
  colorspace_pars_fragment: pz,
  envmap_fragment: mz,
  envmap_common_pars_fragment: gz,
  envmap_pars_fragment: vz,
  envmap_pars_vertex: _z,
  envmap_physical_pars_fragment: Bz,
  envmap_vertex: yz,
  fog_vertex: xz,
  fog_pars_vertex: Sz,
  fog_fragment: Az,
  fog_pars_fragment: Mz,
  gradientmap_pars_fragment: Ez,
  lightmap_fragment: Tz,
  lightmap_pars_fragment: bz,
  lights_lambert_fragment: Cz,
  lights_lambert_pars_fragment: wz,
  lights_pars_begin: Rz,
  lights_toon_fragment: Dz,
  lights_toon_pars_fragment: Lz,
  lights_phong_fragment: Pz,
  lights_phong_pars_fragment: Iz,
  lights_physical_fragment: Uz,
  lights_physical_pars_fragment: Fz,
  lights_fragment_begin: Nz,
  lights_fragment_maps: Oz,
  lights_fragment_end: Hz,
  logdepthbuf_fragment: zz,
  logdepthbuf_pars_fragment: Gz,
  logdepthbuf_pars_vertex: kz,
  logdepthbuf_vertex: Vz,
  map_fragment: Wz,
  map_pars_fragment: Xz,
  map_particle_fragment: Jz,
  map_particle_pars_fragment: Yz,
  metalnessmap_fragment: Kz,
  metalnessmap_pars_fragment: qz,
  morphcolor_vertex: jz,
  morphnormal_vertex: Qz,
  morphtarget_pars_vertex: Zz,
  morphtarget_vertex: $z,
  normal_fragment_begin: eG,
  normal_fragment_maps: tG,
  normal_pars_fragment: nG,
  normal_pars_vertex: iG,
  normal_vertex: rG,
  normalmap_pars_fragment: sG,
  clearcoat_normal_fragment_begin: aG,
  clearcoat_normal_fragment_maps: oG,
  clearcoat_pars_fragment: lG,
  iridescence_pars_fragment: uG,
  opaque_fragment: cG,
  packing: fG,
  premultiplied_alpha_fragment: dG,
  project_vertex: hG,
  dithering_fragment: pG,
  dithering_pars_fragment: mG,
  roughnessmap_fragment: gG,
  roughnessmap_pars_fragment: vG,
  shadowmap_pars_fragment: _G,
  shadowmap_pars_vertex: yG,
  shadowmap_vertex: xG,
  shadowmask_pars_fragment: SG,
  skinbase_vertex: AG,
  skinning_pars_vertex: MG,
  skinning_vertex: EG,
  skinnormal_vertex: TG,
  specularmap_fragment: bG,
  specularmap_pars_fragment: CG,
  tonemapping_fragment: wG,
  tonemapping_pars_fragment: RG,
  transmission_fragment: BG,
  transmission_pars_fragment: DG,
  uv_pars_fragment: LG,
  uv_pars_vertex: PG,
  uv_vertex: IG,
  worldpos_vertex: UG,
  background_vert: FG,
  background_frag: NG,
  backgroundCube_vert: OG,
  backgroundCube_frag: HG,
  cube_vert: zG,
  cube_frag: GG,
  depth_vert: kG,
  depth_frag: VG,
  distanceRGBA_vert: WG,
  distanceRGBA_frag: XG,
  equirect_vert: JG,
  equirect_frag: YG,
  linedashed_vert: KG,
  linedashed_frag: qG,
  meshbasic_vert: jG,
  meshbasic_frag: QG,
  meshlambert_vert: ZG,
  meshlambert_frag: $G,
  meshmatcap_vert: ek,
  meshmatcap_frag: tk,
  meshnormal_vert: nk,
  meshnormal_frag: ik,
  meshphong_vert: rk,
  meshphong_frag: sk,
  meshphysical_vert: ak,
  meshphysical_frag: ok,
  meshtoon_vert: lk,
  meshtoon_frag: uk,
  points_vert: ck,
  points_frag: fk,
  shadow_vert: dk,
  shadow_frag: hk,
  sprite_vert: pk,
  sprite_frag: mk
}, xt = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Tt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Mn() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Mn() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Mn() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Mn() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Mn() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Mn() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Mn() },
    normalScale: { value: /* @__PURE__ */ new qe(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Mn() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Mn() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Mn() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Mn() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Tt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Tt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Mn() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Mn() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Tt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new qe(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Mn() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Mn() },
    alphaTest: { value: 0 }
  }
}, Oo = {
  basic: {
    uniforms: /* @__PURE__ */ Ps([
      xt.common,
      xt.specularmap,
      xt.envmap,
      xt.aomap,
      xt.lightmap,
      xt.fog
    ]),
    vertexShader: yn.meshbasic_vert,
    fragmentShader: yn.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Ps([
      xt.common,
      xt.specularmap,
      xt.envmap,
      xt.aomap,
      xt.lightmap,
      xt.emissivemap,
      xt.bumpmap,
      xt.normalmap,
      xt.displacementmap,
      xt.fog,
      xt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) }
      }
    ]),
    vertexShader: yn.meshlambert_vert,
    fragmentShader: yn.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Ps([
      xt.common,
      xt.specularmap,
      xt.envmap,
      xt.aomap,
      xt.lightmap,
      xt.emissivemap,
      xt.bumpmap,
      xt.normalmap,
      xt.displacementmap,
      xt.fog,
      xt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) },
        specular: { value: /* @__PURE__ */ new Tt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: yn.meshphong_vert,
    fragmentShader: yn.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Ps([
      xt.common,
      xt.envmap,
      xt.aomap,
      xt.lightmap,
      xt.emissivemap,
      xt.bumpmap,
      xt.normalmap,
      xt.displacementmap,
      xt.roughnessmap,
      xt.metalnessmap,
      xt.fog,
      xt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: yn.meshphysical_vert,
    fragmentShader: yn.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Ps([
      xt.common,
      xt.aomap,
      xt.lightmap,
      xt.emissivemap,
      xt.bumpmap,
      xt.normalmap,
      xt.displacementmap,
      xt.gradientmap,
      xt.fog,
      xt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Tt(0) }
      }
    ]),
    vertexShader: yn.meshtoon_vert,
    fragmentShader: yn.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Ps([
      xt.common,
      xt.bumpmap,
      xt.normalmap,
      xt.displacementmap,
      xt.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: yn.meshmatcap_vert,
    fragmentShader: yn.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Ps([
      xt.points,
      xt.fog
    ]),
    vertexShader: yn.points_vert,
    fragmentShader: yn.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Ps([
      xt.common,
      xt.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: yn.linedashed_vert,
    fragmentShader: yn.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Ps([
      xt.common,
      xt.displacementmap
    ]),
    vertexShader: yn.depth_vert,
    fragmentShader: yn.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Ps([
      xt.common,
      xt.bumpmap,
      xt.normalmap,
      xt.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: yn.meshnormal_vert,
    fragmentShader: yn.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Ps([
      xt.sprite,
      xt.fog
    ]),
    vertexShader: yn.sprite_vert,
    fragmentShader: yn.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Mn() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: yn.background_vert,
    fragmentShader: yn.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: yn.backgroundCube_vert,
    fragmentShader: yn.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: yn.cube_vert,
    fragmentShader: yn.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: yn.equirect_vert,
    fragmentShader: yn.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Ps([
      xt.common,
      xt.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new q() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: yn.distanceRGBA_vert,
    fragmentShader: yn.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Ps([
      xt.lights,
      xt.fog,
      {
        color: { value: /* @__PURE__ */ new Tt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: yn.shadow_vert,
    fragmentShader: yn.shadow_frag
  }
};
Oo.physical = {
  uniforms: /* @__PURE__ */ Ps([
    Oo.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Mn() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Mn() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new qe(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Mn() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Mn() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Mn() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Tt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Mn() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Mn() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Mn() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new qe() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Mn() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Tt(0) },
      specularColor: { value: /* @__PURE__ */ new Tt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Mn() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Mn() },
      anisotropyVector: { value: /* @__PURE__ */ new qe() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Mn() }
    }
  ]),
  vertexShader: yn.meshphysical_vert,
  fragmentShader: yn.meshphysical_frag
};
const d0 = { r: 0, b: 0, g: 0 };
function gk(s, e, t, n, i, r, o) {
  const u = new Tt(0);
  let c = r === !0 ? 0 : 1, d, p, g = null, v = 0, y = null;
  function S(E, M) {
    let w = !1, C = M.isScene === !0 ? M.background : null;
    C && C.isTexture && (C = (M.backgroundBlurriness > 0 ? t : e).get(C)), C === null ? T(u, c) : C && C.isColor && (T(C, 1), w = !0);
    const D = s.xr.getEnvironmentBlendMode();
    D === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : D === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (s.autoClear || w) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil), C && (C.isCubeTexture || C.mapping === nm) ? (p === void 0 && (p = new ur(
      new Md(1, 1, 1),
      new Cl({
        name: "BackgroundCubeMaterial",
        uniforms: Jp(Oo.backgroundCube.uniforms),
        vertexShader: Oo.backgroundCube.vertexShader,
        fragmentShader: Oo.backgroundCube.fragmentShader,
        side: zs,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), p.geometry.deleteAttribute("normal"), p.geometry.deleteAttribute("uv"), p.onBeforeRender = function(N, U, O) {
      this.matrixWorld.copyPosition(O.matrixWorld);
    }, Object.defineProperty(p.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(p)), p.material.uniforms.envMap.value = C, p.material.uniforms.flipEnvMap.value = C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1, p.material.uniforms.backgroundBlurriness.value = M.backgroundBlurriness, p.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, p.material.toneMapped = Zn.getTransfer(C.colorSpace) !== li, (g !== C || v !== C.version || y !== s.toneMapping) && (p.material.needsUpdate = !0, g = C, v = C.version, y = s.toneMapping), p.layers.enableAll(), E.unshift(p, p.geometry, p.material, 0, 0, null)) : C && C.isTexture && (d === void 0 && (d = new ur(
      new Yv(2, 2),
      new Cl({
        name: "BackgroundMaterial",
        uniforms: Jp(Oo.background.uniforms),
        vertexShader: Oo.background.vertexShader,
        fragmentShader: Oo.background.fragmentShader,
        side: El,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), d.geometry.deleteAttribute("normal"), Object.defineProperty(d.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(d)), d.material.uniforms.t2D.value = C, d.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, d.material.toneMapped = Zn.getTransfer(C.colorSpace) !== li, C.matrixAutoUpdate === !0 && C.updateMatrix(), d.material.uniforms.uvTransform.value.copy(C.matrix), (g !== C || v !== C.version || y !== s.toneMapping) && (d.material.needsUpdate = !0, g = C, v = C.version, y = s.toneMapping), d.layers.enableAll(), E.unshift(d, d.geometry, d.material, 0, 0, null));
  }
  function T(E, M) {
    E.getRGB(d0, LP(s)), n.buffers.color.setClear(d0.r, d0.g, d0.b, M, o);
  }
  return {
    getClearColor: function() {
      return u;
    },
    setClearColor: function(E, M = 1) {
      u.set(E), c = M, T(u, c);
    },
    getClearAlpha: function() {
      return c;
    },
    setClearAlpha: function(E) {
      c = E, T(u, c);
    },
    render: S
  };
}
function vk(s, e, t, n) {
  const i = s.getParameter(s.MAX_VERTEX_ATTRIBS), r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = n.isWebGL2 || r !== null, u = {}, c = E(null);
  let d = c, p = !1;
  function g(j, ie, re, pe, J) {
    let Z = !1;
    if (o) {
      const H = T(pe, re, ie);
      d !== H && (d = H, y(d.object)), Z = M(j, pe, re, J), Z && w(j, pe, re, J);
    } else {
      const H = ie.wireframe === !0;
      (d.geometry !== pe.id || d.program !== re.id || d.wireframe !== H) && (d.geometry = pe.id, d.program = re.id, d.wireframe = H, Z = !0);
    }
    J !== null && t.update(J, s.ELEMENT_ARRAY_BUFFER), (Z || p) && (p = !1, V(j, ie, re, pe), J !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t.get(J).buffer));
  }
  function v() {
    return n.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
  }
  function y(j) {
    return n.isWebGL2 ? s.bindVertexArray(j) : r.bindVertexArrayOES(j);
  }
  function S(j) {
    return n.isWebGL2 ? s.deleteVertexArray(j) : r.deleteVertexArrayOES(j);
  }
  function T(j, ie, re) {
    const pe = re.wireframe === !0;
    let J = u[j.id];
    J === void 0 && (J = {}, u[j.id] = J);
    let Z = J[ie.id];
    Z === void 0 && (Z = {}, J[ie.id] = Z);
    let H = Z[pe];
    return H === void 0 && (H = E(v()), Z[pe] = H), H;
  }
  function E(j) {
    const ie = [], re = [], pe = [];
    for (let J = 0; J < i; J++)
      ie[J] = 0, re[J] = 0, pe[J] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: ie,
      enabledAttributes: re,
      attributeDivisors: pe,
      object: j,
      attributes: {},
      index: null
    };
  }
  function M(j, ie, re, pe) {
    const J = d.attributes, Z = ie.attributes;
    let H = 0;
    const ue = re.getAttributes();
    for (const Se in ue)
      if (ue[Se].location >= 0) {
        const ye = J[Se];
        let Xe = Z[Se];
        if (Xe === void 0 && (Se === "instanceMatrix" && j.instanceMatrix && (Xe = j.instanceMatrix), Se === "instanceColor" && j.instanceColor && (Xe = j.instanceColor)), ye === void 0 || ye.attribute !== Xe || Xe && ye.data !== Xe.data) return !0;
        H++;
      }
    return d.attributesNum !== H || d.index !== pe;
  }
  function w(j, ie, re, pe) {
    const J = {}, Z = ie.attributes;
    let H = 0;
    const ue = re.getAttributes();
    for (const Se in ue)
      if (ue[Se].location >= 0) {
        let ye = Z[Se];
        ye === void 0 && (Se === "instanceMatrix" && j.instanceMatrix && (ye = j.instanceMatrix), Se === "instanceColor" && j.instanceColor && (ye = j.instanceColor));
        const Xe = {};
        Xe.attribute = ye, ye && ye.data && (Xe.data = ye.data), J[Se] = Xe, H++;
      }
    d.attributes = J, d.attributesNum = H, d.index = pe;
  }
  function C() {
    const j = d.newAttributes;
    for (let ie = 0, re = j.length; ie < re; ie++)
      j[ie] = 0;
  }
  function D(j) {
    N(j, 0);
  }
  function N(j, ie) {
    const re = d.newAttributes, pe = d.enabledAttributes, J = d.attributeDivisors;
    re[j] = 1, pe[j] === 0 && (s.enableVertexAttribArray(j), pe[j] = 1), J[j] !== ie && ((n.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](j, ie), J[j] = ie);
  }
  function U() {
    const j = d.newAttributes, ie = d.enabledAttributes;
    for (let re = 0, pe = ie.length; re < pe; re++)
      ie[re] !== j[re] && (s.disableVertexAttribArray(re), ie[re] = 0);
  }
  function O(j, ie, re, pe, J, Z, H) {
    H === !0 ? s.vertexAttribIPointer(j, ie, re, J, Z) : s.vertexAttribPointer(j, ie, re, pe, J, Z);
  }
  function V(j, ie, re, pe) {
    if (n.isWebGL2 === !1 && (j.isInstancedMesh || pe.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    C();
    const J = pe.attributes, Z = re.getAttributes(), H = ie.defaultAttributeValues;
    for (const ue in Z) {
      const Se = Z[ue];
      if (Se.location >= 0) {
        let me = J[ue];
        if (me === void 0 && (ue === "instanceMatrix" && j.instanceMatrix && (me = j.instanceMatrix), ue === "instanceColor" && j.instanceColor && (me = j.instanceColor)), me !== void 0) {
          const ye = me.normalized, Xe = me.itemSize, Je = t.get(me);
          if (Je === void 0) continue;
          const Ye = Je.buffer, At = Je.type, Ct = Je.bytesPerElement, pt = n.isWebGL2 === !0 && (At === s.INT || At === s.UNSIGNED_INT || me.gpuType === yb);
          if (me.isInterleavedBufferAttribute) {
            const mt = me.data, ne = mt.stride, we = me.offset;
            if (mt.isInstancedInterleavedBuffer) {
              for (let Ee = 0; Ee < Se.locationSize; Ee++)
                N(Se.location + Ee, mt.meshPerAttribute);
              j.isInstancedMesh !== !0 && pe._maxInstanceCount === void 0 && (pe._maxInstanceCount = mt.meshPerAttribute * mt.count);
            } else
              for (let Ee = 0; Ee < Se.locationSize; Ee++)
                D(Se.location + Ee);
            s.bindBuffer(s.ARRAY_BUFFER, Ye);
            for (let Ee = 0; Ee < Se.locationSize; Ee++)
              O(
                Se.location + Ee,
                Xe / Se.locationSize,
                At,
                ye,
                ne * Ct,
                (we + Xe / Se.locationSize * Ee) * Ct,
                pt
              );
          } else {
            if (me.isInstancedBufferAttribute) {
              for (let mt = 0; mt < Se.locationSize; mt++)
                N(Se.location + mt, me.meshPerAttribute);
              j.isInstancedMesh !== !0 && pe._maxInstanceCount === void 0 && (pe._maxInstanceCount = me.meshPerAttribute * me.count);
            } else
              for (let mt = 0; mt < Se.locationSize; mt++)
                D(Se.location + mt);
            s.bindBuffer(s.ARRAY_BUFFER, Ye);
            for (let mt = 0; mt < Se.locationSize; mt++)
              O(
                Se.location + mt,
                Xe / Se.locationSize,
                At,
                ye,
                Xe * Ct,
                Xe / Se.locationSize * mt * Ct,
                pt
              );
          }
        } else if (H !== void 0) {
          const ye = H[ue];
          if (ye !== void 0)
            switch (ye.length) {
              case 2:
                s.vertexAttrib2fv(Se.location, ye);
                break;
              case 3:
                s.vertexAttrib3fv(Se.location, ye);
                break;
              case 4:
                s.vertexAttrib4fv(Se.location, ye);
                break;
              default:
                s.vertexAttrib1fv(Se.location, ye);
            }
        }
      }
    }
    U();
  }
  function L() {
    Q();
    for (const j in u) {
      const ie = u[j];
      for (const re in ie) {
        const pe = ie[re];
        for (const J in pe)
          S(pe[J].object), delete pe[J];
        delete ie[re];
      }
      delete u[j];
    }
  }
  function I(j) {
    if (u[j.id] === void 0) return;
    const ie = u[j.id];
    for (const re in ie) {
      const pe = ie[re];
      for (const J in pe)
        S(pe[J].object), delete pe[J];
      delete ie[re];
    }
    delete u[j.id];
  }
  function Y(j) {
    for (const ie in u) {
      const re = u[ie];
      if (re[j.id] === void 0) continue;
      const pe = re[j.id];
      for (const J in pe)
        S(pe[J].object), delete pe[J];
      delete re[j.id];
    }
  }
  function Q() {
    fe(), p = !0, d !== c && (d = c, y(d.object));
  }
  function fe() {
    c.geometry = null, c.program = null, c.wireframe = !1;
  }
  return {
    setup: g,
    reset: Q,
    resetDefaultState: fe,
    dispose: L,
    releaseStatesOfGeometry: I,
    releaseStatesOfProgram: Y,
    initAttributes: C,
    enableAttribute: D,
    disableUnusedAttributes: U
  };
}
function _k(s, e, t, n) {
  const i = n.isWebGL2;
  let r;
  function o(p) {
    r = p;
  }
  function u(p, g) {
    s.drawArrays(r, p, g), t.update(g, r, 1);
  }
  function c(p, g, v) {
    if (v === 0) return;
    let y, S;
    if (i)
      y = s, S = "drawArraysInstanced";
    else if (y = e.get("ANGLE_instanced_arrays"), S = "drawArraysInstancedANGLE", y === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    y[S](r, p, g, v), t.update(g, r, v);
  }
  function d(p, g, v) {
    if (v === 0) return;
    const y = e.get("WEBGL_multi_draw");
    if (y === null)
      for (let S = 0; S < v; S++)
        this.render(p[S], g[S]);
    else {
      y.multiDrawArraysWEBGL(r, p, 0, g, 0, v);
      let S = 0;
      for (let T = 0; T < v; T++)
        S += g[T];
      t.update(S, r, 1);
    }
  }
  this.setMode = o, this.render = u, this.renderInstances = c, this.renderMultiDraw = d;
}
function yk(s, e, t) {
  let n;
  function i() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const O = e.get("EXT_texture_filter_anisotropic");
      n = s.getParameter(O.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      n = 0;
    return n;
  }
  function r(O) {
    if (O === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
        return "highp";
      O = "mediump";
    }
    return O === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const o = typeof WebGL2RenderingContext < "u" && s.constructor.name === "WebGL2RenderingContext";
  let u = t.precision !== void 0 ? t.precision : "highp";
  const c = r(u);
  c !== u && (console.warn("THREE.WebGLRenderer:", u, "not supported, using", c, "instead."), u = c);
  const d = o || e.has("WEBGL_draw_buffers"), p = t.logarithmicDepthBuffer === !0, g = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), v = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), y = s.getParameter(s.MAX_TEXTURE_SIZE), S = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), T = s.getParameter(s.MAX_VERTEX_ATTRIBS), E = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), M = s.getParameter(s.MAX_VARYING_VECTORS), w = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), C = v > 0, D = o || e.has("OES_texture_float"), N = C && D, U = o ? s.getParameter(s.MAX_SAMPLES) : 0;
  return {
    isWebGL2: o,
    drawBuffers: d,
    getMaxAnisotropy: i,
    getMaxPrecision: r,
    precision: u,
    logarithmicDepthBuffer: p,
    maxTextures: g,
    maxVertexTextures: v,
    maxTextureSize: y,
    maxCubemapSize: S,
    maxAttributes: T,
    maxVertexUniforms: E,
    maxVaryings: M,
    maxFragmentUniforms: w,
    vertexTextures: C,
    floatFragmentTextures: D,
    floatVertexTextures: N,
    maxSamples: U
  };
}
function xk(s) {
  const e = this;
  let t = null, n = 0, i = !1, r = !1;
  const o = new _c(), u = new Mn(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(g, v) {
    const y = g.length !== 0 || v || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || i;
    return i = v, n = g.length, y;
  }, this.beginShadows = function() {
    r = !0, p(null);
  }, this.endShadows = function() {
    r = !1;
  }, this.setGlobalState = function(g, v) {
    t = p(g, v, 0);
  }, this.setState = function(g, v, y) {
    const S = g.clippingPlanes, T = g.clipIntersection, E = g.clipShadows, M = s.get(g);
    if (!i || S === null || S.length === 0 || r && !E)
      r ? p(null) : d();
    else {
      const w = r ? 0 : n, C = w * 4;
      let D = M.clippingState || null;
      c.value = D, D = p(S, v, C, y);
      for (let N = 0; N !== C; ++N)
        D[N] = t[N];
      M.clippingState = D, this.numIntersection = T ? this.numPlanes : 0, this.numPlanes += w;
    }
  };
  function d() {
    c.value !== t && (c.value = t, c.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function p(g, v, y, S) {
    const T = g !== null ? g.length : 0;
    let E = null;
    if (T !== 0) {
      if (E = c.value, S !== !0 || E === null) {
        const M = y + T * 4, w = v.matrixWorldInverse;
        u.getNormalMatrix(w), (E === null || E.length < M) && (E = new Float32Array(M));
        for (let C = 0, D = y; C !== T; ++C, D += 4)
          o.copy(g[C]).applyMatrix4(w, u), o.normal.toArray(E, D), E[D + 3] = o.constant;
      }
      c.value = E, c.needsUpdate = !0;
    }
    return e.numPlanes = T, e.numIntersection = 0, E;
  }
}
function Sk(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, u) {
    return u === vv ? o.mapping = mu : u === _v && (o.mapping = Pc), o;
  }
  function n(o) {
    if (o && o.isTexture) {
      const u = o.mapping;
      if (u === vv || u === _v)
        if (e.has(o)) {
          const c = e.get(o).texture;
          return t(c, o.mapping);
        } else {
          const c = o.image;
          if (c && c.height > 0) {
            const d = new UP(c.height / 2);
            return d.fromEquirectangularTexture(s, o), e.set(o, d), o.addEventListener("dispose", i), t(d.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function i(o) {
    const u = o.target;
    u.removeEventListener("dispose", i);
    const c = e.get(u);
    c !== void 0 && (e.delete(u), c.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: r
  };
}
class sm extends Wv {
  constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, i, r, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let r = n - e, o = n + e, u = i + t, c = i - t;
    if (this.view !== null && this.view.enabled) {
      const d = (this.right - this.left) / this.view.fullWidth / this.zoom, p = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += d * this.view.offsetX, o = r + d * this.view.width, u -= p * this.view.offsetY, c = u - p * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, o, u, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const Ep = 4, QR = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Jf = 20, tE = /* @__PURE__ */ new sm(), ZR = /* @__PURE__ */ new Tt();
let nE = null, iE = 0, rE = 0;
const kf = (1 + Math.sqrt(5)) / 2, op = 1 / kf, $R = [
  /* @__PURE__ */ new q(1, 1, 1),
  /* @__PURE__ */ new q(-1, 1, 1),
  /* @__PURE__ */ new q(1, 1, -1),
  /* @__PURE__ */ new q(-1, 1, -1),
  /* @__PURE__ */ new q(0, kf, op),
  /* @__PURE__ */ new q(0, kf, -op),
  /* @__PURE__ */ new q(op, 0, kf),
  /* @__PURE__ */ new q(-op, 0, kf),
  /* @__PURE__ */ new q(kf, op, 0),
  /* @__PURE__ */ new q(-kf, op, 0)
];
class FT {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, n = 0.1, i = 100) {
    nE = this._renderer.getRenderTarget(), iE = this._renderer.getActiveCubeFace(), rE = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const r = this._allocateTargets();
    return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = nB(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = tB(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(nE, iE, rE), e.scissorTest = !1, h0(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === mu || e.mapping === Pc ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), nE = this._renderer.getRenderTarget(), iE = this._renderer.getActiveCubeFace(), rE = this._renderer.getActiveMipmapLevel();
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: bi,
      minFilter: bi,
      generateMipmaps: !1,
      type: kp,
      format: Ns,
      colorSpace: bl,
      depthBuffer: !1
    }, i = eB(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = eB(e, t, n);
      const { _lodMax: r } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Ak(r)), this._blurMaterial = Mk(r, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new ur(this._lodPlanes[0], e);
    this._renderer.compile(t, tE);
  }
  _sceneToCubeUV(e, t, n, i) {
    const u = new Ar(90, 1, t, n), c = [1, -1, 1, 1, 1, 1], d = [1, 1, 1, -1, -1, -1], p = this._renderer, g = p.autoClear, v = p.toneMapping;
    p.getClearColor(ZR), p.toneMapping = xl, p.autoClear = !1;
    const y = new Ra({
      name: "PMREM.Background",
      side: zs,
      depthWrite: !1,
      depthTest: !1
    }), S = new ur(new Md(), y);
    let T = !1;
    const E = e.background;
    E ? E.isColor && (y.color.copy(E), e.background = null, T = !0) : (y.color.copy(ZR), T = !0);
    for (let M = 0; M < 6; M++) {
      const w = M % 3;
      w === 0 ? (u.up.set(0, c[M], 0), u.lookAt(d[M], 0, 0)) : w === 1 ? (u.up.set(0, 0, c[M]), u.lookAt(0, d[M], 0)) : (u.up.set(0, c[M], 0), u.lookAt(0, 0, d[M]));
      const C = this._cubeSize;
      h0(i, w * C, M > 2 ? C : 0, C, C), p.setRenderTarget(i), T && p.render(S, u), p.render(e, u);
    }
    S.geometry.dispose(), S.material.dispose(), p.toneMapping = v, p.autoClear = g, e.background = E;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, i = e.mapping === mu || e.mapping === Pc;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = nB()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = tB());
    const r = i ? this._cubemapMaterial : this._equirectMaterial, o = new ur(this._lodPlanes[0], r), u = r.uniforms;
    u.envMap.value = e;
    const c = this._cubeSize;
    h0(t, 0, 0, 3 * c, 2 * c), n.setRenderTarget(t), n.render(o, tE);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const r = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), o = $R[(i - 1) % $R.length];
      this._blur(e, i - 1, i, r, o);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, n, i, r) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      t,
      n,
      i,
      "latitudinal",
      r
    ), this._halfBlur(
      o,
      e,
      n,
      n,
      i,
      "longitudinal",
      r
    );
  }
  _halfBlur(e, t, n, i, r, o, u) {
    const c = this._renderer, d = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const p = 3, g = new ur(this._lodPlanes[i], d), v = d.uniforms, y = this._sizeLods[n] - 1, S = isFinite(r) ? Math.PI / (2 * y) : 2 * Math.PI / (2 * Jf - 1), T = r / S, E = isFinite(r) ? 1 + Math.floor(p * T) : Jf;
    E > Jf && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${E} samples when the maximum is set to ${Jf}`);
    const M = [];
    let w = 0;
    for (let O = 0; O < Jf; ++O) {
      const V = O / T, L = Math.exp(-V * V / 2);
      M.push(L), O === 0 ? w += L : O < E && (w += 2 * L);
    }
    for (let O = 0; O < M.length; O++)
      M[O] = M[O] / w;
    v.envMap.value = e.texture, v.samples.value = E, v.weights.value = M, v.latitudinal.value = o === "latitudinal", u && (v.poleAxis.value = u);
    const { _lodMax: C } = this;
    v.dTheta.value = S, v.mipInt.value = C - n;
    const D = this._sizeLods[i], N = 3 * D * (i > C - Ep ? i - C + Ep : 0), U = 4 * (this._cubeSize - D);
    h0(t, N, U, 3 * D, 2 * D), c.setRenderTarget(t), c.render(g, tE);
  }
}
function Ak(s) {
  const e = [], t = [], n = [];
  let i = s;
  const r = s - Ep + 1 + QR.length;
  for (let o = 0; o < r; o++) {
    const u = Math.pow(2, i);
    t.push(u);
    let c = 1 / u;
    o > s - Ep ? c = QR[o - s + Ep - 1] : o === 0 && (c = 0), n.push(c);
    const d = 1 / (u - 2), p = -d, g = 1 + d, v = [p, p, g, p, g, g, p, p, g, g, p, g], y = 6, S = 6, T = 3, E = 2, M = 1, w = new Float32Array(T * S * y), C = new Float32Array(E * S * y), D = new Float32Array(M * S * y);
    for (let U = 0; U < y; U++) {
      const O = U % 3 * 2 / 3 - 1, V = U > 2 ? 0 : -1, L = [
        O,
        V,
        0,
        O + 2 / 3,
        V,
        0,
        O + 2 / 3,
        V + 1,
        0,
        O,
        V,
        0,
        O + 2 / 3,
        V + 1,
        0,
        O,
        V + 1,
        0
      ];
      w.set(L, T * S * U), C.set(v, E * S * U);
      const I = [U, U, U, U, U, U];
      D.set(I, M * S * U);
    }
    const N = new pn();
    N.setAttribute("position", new Hn(w, T)), N.setAttribute("uv", new Hn(C, E)), N.setAttribute("faceIndex", new Hn(D, M)), e.push(N), i > Ep && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function eB(s, e, t) {
  const n = new ko(s, e, t);
  return n.texture.mapping = nm, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function h0(s, e, t, n, i) {
  s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
}
function Mk(s, e, t) {
  const n = new Float32Array(Jf), i = new q(0, 1, 0);
  return new Cl({
    name: "SphericalGaussianBlur",
    defines: {
      n: Jf,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${s}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: Ub(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: du,
    depthTest: !1,
    depthWrite: !1
  });
}
function tB() {
  return new Cl({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Ub(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: du,
    depthTest: !1,
    depthWrite: !1
  });
}
function nB() {
  return new Cl({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Ub(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: du,
    depthTest: !1,
    depthWrite: !1
  });
}
function Ub() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function Ek(s) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(u) {
    if (u && u.isTexture) {
      const c = u.mapping, d = c === vv || c === _v, p = c === mu || c === Pc;
      if (d || p)
        if (u.isRenderTargetTexture && u.needsPMREMUpdate === !0) {
          u.needsPMREMUpdate = !1;
          let g = e.get(u);
          return t === null && (t = new FT(s)), g = d ? t.fromEquirectangular(u, g) : t.fromCubemap(u, g), e.set(u, g), g.texture;
        } else {
          if (e.has(u))
            return e.get(u).texture;
          {
            const g = u.image;
            if (d && g && g.height > 0 || p && g && i(g)) {
              t === null && (t = new FT(s));
              const v = d ? t.fromEquirectangular(u) : t.fromCubemap(u);
              return e.set(u, v), u.addEventListener("dispose", r), v.texture;
            } else
              return null;
          }
        }
    }
    return u;
  }
  function i(u) {
    let c = 0;
    const d = 6;
    for (let p = 0; p < d; p++)
      u[p] !== void 0 && c++;
    return c === d;
  }
  function r(u) {
    const c = u.target;
    c.removeEventListener("dispose", r);
    const d = e.get(c);
    d !== void 0 && (e.delete(c), d.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: o
  };
}
function Tk(s) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = s.getExtension(n);
    }
    return e[n] = i, i;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function(n) {
      n.isWebGL2 ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(n) {
      const i = t(n);
      return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
    }
  };
}
function bk(s, e, t, n) {
  const i = {}, r = /* @__PURE__ */ new WeakMap();
  function o(g) {
    const v = g.target;
    v.index !== null && e.remove(v.index);
    for (const S in v.attributes)
      e.remove(v.attributes[S]);
    for (const S in v.morphAttributes) {
      const T = v.morphAttributes[S];
      for (let E = 0, M = T.length; E < M; E++)
        e.remove(T[E]);
    }
    v.removeEventListener("dispose", o), delete i[v.id];
    const y = r.get(v);
    y && (e.remove(y), r.delete(v)), n.releaseStatesOfGeometry(v), v.isInstancedBufferGeometry === !0 && delete v._maxInstanceCount, t.memory.geometries--;
  }
  function u(g, v) {
    return i[v.id] === !0 || (v.addEventListener("dispose", o), i[v.id] = !0, t.memory.geometries++), v;
  }
  function c(g) {
    const v = g.attributes;
    for (const S in v)
      e.update(v[S], s.ARRAY_BUFFER);
    const y = g.morphAttributes;
    for (const S in y) {
      const T = y[S];
      for (let E = 0, M = T.length; E < M; E++)
        e.update(T[E], s.ARRAY_BUFFER);
    }
  }
  function d(g) {
    const v = [], y = g.index, S = g.attributes.position;
    let T = 0;
    if (y !== null) {
      const w = y.array;
      T = y.version;
      for (let C = 0, D = w.length; C < D; C += 3) {
        const N = w[C + 0], U = w[C + 1], O = w[C + 2];
        v.push(N, U, U, O, O, N);
      }
    } else if (S !== void 0) {
      const w = S.array;
      T = S.version;
      for (let C = 0, D = w.length / 3 - 1; C < D; C += 3) {
        const N = C + 0, U = C + 1, O = C + 2;
        v.push(N, U, U, O, O, N);
      }
    } else
      return;
    const E = new (wP(v) ? Ib : Pb)(v, 1);
    E.version = T;
    const M = r.get(g);
    M && e.remove(M), r.set(g, E);
  }
  function p(g) {
    const v = r.get(g);
    if (v) {
      const y = g.index;
      y !== null && v.version < y.version && d(g);
    } else
      d(g);
    return r.get(g);
  }
  return {
    get: u,
    update: c,
    getWireframeAttribute: p
  };
}
function Ck(s, e, t, n) {
  const i = n.isWebGL2;
  let r;
  function o(y) {
    r = y;
  }
  let u, c;
  function d(y) {
    u = y.type, c = y.bytesPerElement;
  }
  function p(y, S) {
    s.drawElements(r, S, u, y * c), t.update(S, r, 1);
  }
  function g(y, S, T) {
    if (T === 0) return;
    let E, M;
    if (i)
      E = s, M = "drawElementsInstanced";
    else if (E = e.get("ANGLE_instanced_arrays"), M = "drawElementsInstancedANGLE", E === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    E[M](r, S, u, y * c, T), t.update(S, r, T);
  }
  function v(y, S, T) {
    if (T === 0) return;
    const E = e.get("WEBGL_multi_draw");
    if (E === null)
      for (let M = 0; M < T; M++)
        this.render(y[M] / c, S[M]);
    else {
      E.multiDrawElementsWEBGL(r, S, 0, u, y, 0, T);
      let M = 0;
      for (let w = 0; w < T; w++)
        M += S[w];
      t.update(M, r, 1);
    }
  }
  this.setMode = o, this.setIndex = d, this.render = p, this.renderInstances = g, this.renderMultiDraw = v;
}
function wk(s) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(r, o, u) {
    switch (t.calls++, o) {
      case s.TRIANGLES:
        t.triangles += u * (r / 3);
        break;
      case s.LINES:
        t.lines += u * (r / 2);
        break;
      case s.LINE_STRIP:
        t.lines += u * (r - 1);
        break;
      case s.LINE_LOOP:
        t.lines += u * r;
        break;
      case s.POINTS:
        t.points += u * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function Rk(s, e) {
  return s[0] - e[0];
}
function Bk(s, e) {
  return Math.abs(e[1]) - Math.abs(s[1]);
}
function Dk(s, e, t) {
  const n = {}, i = new Float32Array(8), r = /* @__PURE__ */ new WeakMap(), o = new $n(), u = [];
  for (let d = 0; d < 8; d++)
    u[d] = [d, 0];
  function c(d, p, g) {
    const v = d.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const y = p.morphAttributes.position || p.morphAttributes.normal || p.morphAttributes.color, S = y !== void 0 ? y.length : 0;
      let T = r.get(p);
      if (T === void 0 || T.count !== S) {
        let j = function() {
          Q.dispose(), r.delete(p), p.removeEventListener("dispose", j);
        };
        T !== void 0 && T.texture.dispose();
        const w = p.morphAttributes.position !== void 0, C = p.morphAttributes.normal !== void 0, D = p.morphAttributes.color !== void 0, N = p.morphAttributes.position || [], U = p.morphAttributes.normal || [], O = p.morphAttributes.color || [];
        let V = 0;
        w === !0 && (V = 1), C === !0 && (V = 2), D === !0 && (V = 3);
        let L = p.attributes.position.count * V, I = 1;
        L > e.maxTextureSize && (I = Math.ceil(L / e.maxTextureSize), L = e.maxTextureSize);
        const Y = new Float32Array(L * I * 4 * S), Q = new jx(Y, L, I, S);
        Q.type = zo, Q.needsUpdate = !0;
        const fe = V * 4;
        for (let ie = 0; ie < S; ie++) {
          const re = N[ie], pe = U[ie], J = O[ie], Z = L * I * 4 * ie;
          for (let H = 0; H < re.count; H++) {
            const ue = H * fe;
            w === !0 && (o.fromBufferAttribute(re, H), Y[Z + ue + 0] = o.x, Y[Z + ue + 1] = o.y, Y[Z + ue + 2] = o.z, Y[Z + ue + 3] = 0), C === !0 && (o.fromBufferAttribute(pe, H), Y[Z + ue + 4] = o.x, Y[Z + ue + 5] = o.y, Y[Z + ue + 6] = o.z, Y[Z + ue + 7] = 0), D === !0 && (o.fromBufferAttribute(J, H), Y[Z + ue + 8] = o.x, Y[Z + ue + 9] = o.y, Y[Z + ue + 10] = o.z, Y[Z + ue + 11] = J.itemSize === 4 ? o.w : 1);
          }
        }
        T = {
          count: S,
          texture: Q,
          size: new qe(L, I)
        }, r.set(p, T), p.addEventListener("dispose", j);
      }
      let E = 0;
      for (let w = 0; w < v.length; w++)
        E += v[w];
      const M = p.morphTargetsRelative ? 1 : 1 - E;
      g.getUniforms().setValue(s, "morphTargetBaseInfluence", M), g.getUniforms().setValue(s, "morphTargetInfluences", v), g.getUniforms().setValue(s, "morphTargetsTexture", T.texture, t), g.getUniforms().setValue(s, "morphTargetsTextureSize", T.size);
    } else {
      const y = v === void 0 ? 0 : v.length;
      let S = n[p.id];
      if (S === void 0 || S.length !== y) {
        S = [];
        for (let C = 0; C < y; C++)
          S[C] = [C, 0];
        n[p.id] = S;
      }
      for (let C = 0; C < y; C++) {
        const D = S[C];
        D[0] = C, D[1] = v[C];
      }
      S.sort(Bk);
      for (let C = 0; C < 8; C++)
        C < y && S[C][1] ? (u[C][0] = S[C][0], u[C][1] = S[C][1]) : (u[C][0] = Number.MAX_SAFE_INTEGER, u[C][1] = 0);
      u.sort(Rk);
      const T = p.morphAttributes.position, E = p.morphAttributes.normal;
      let M = 0;
      for (let C = 0; C < 8; C++) {
        const D = u[C], N = D[0], U = D[1];
        N !== Number.MAX_SAFE_INTEGER && U ? (T && p.getAttribute("morphTarget" + C) !== T[N] && p.setAttribute("morphTarget" + C, T[N]), E && p.getAttribute("morphNormal" + C) !== E[N] && p.setAttribute("morphNormal" + C, E[N]), i[C] = U, M += U) : (T && p.hasAttribute("morphTarget" + C) === !0 && p.deleteAttribute("morphTarget" + C), E && p.hasAttribute("morphNormal" + C) === !0 && p.deleteAttribute("morphNormal" + C), i[C] = 0);
      }
      const w = p.morphTargetsRelative ? 1 : 1 - M;
      g.getUniforms().setValue(s, "morphTargetBaseInfluence", w), g.getUniforms().setValue(s, "morphTargetInfluences", i);
    }
  }
  return {
    update: c
  };
}
function Lk(s, e, t, n) {
  let i = /* @__PURE__ */ new WeakMap();
  function r(c) {
    const d = n.render.frame, p = c.geometry, g = e.get(c, p);
    if (i.get(g) !== d && (e.update(g), i.set(g, d)), c.isInstancedMesh && (c.hasEventListener("dispose", u) === !1 && c.addEventListener("dispose", u), i.get(c) !== d && (t.update(c.instanceMatrix, s.ARRAY_BUFFER), c.instanceColor !== null && t.update(c.instanceColor, s.ARRAY_BUFFER), i.set(c, d))), c.isSkinnedMesh) {
      const v = c.skeleton;
      i.get(v) !== d && (v.update(), i.set(v, d));
    }
    return g;
  }
  function o() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function u(c) {
    const d = c.target;
    d.removeEventListener("dispose", u), t.remove(d.instanceMatrix), d.instanceColor !== null && t.remove(d.instanceColor);
  }
  return {
    update: r,
    dispose: o
  };
}
class Fb extends Ri {
  constructor(e, t, n, i, r, o, u, c, d, p) {
    if (p = p !== void 0 ? p : Cc, p !== Cc && p !== hd)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && p === Cc && (n = lu), n === void 0 && p === hd && (n = bc), super(null, i, r, o, u, c, p, n, d), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = u !== void 0 ? u : Oi, this.minFilter = c !== void 0 ? c : Oi, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const NP = /* @__PURE__ */ new Ri(), OP = /* @__PURE__ */ new Fb(1, 1);
OP.compareFunction = Rb;
const HP = /* @__PURE__ */ new jx(), zP = /* @__PURE__ */ new Lb(), GP = /* @__PURE__ */ new Xv(), iB = [], rB = [], sB = new Float32Array(16), aB = new Float32Array(9), oB = new Float32Array(4);
function am(s, e, t) {
  const n = s[0];
  if (n <= 0 || n > 0) return s;
  const i = e * t;
  let r = iB[i];
  if (r === void 0 && (r = new Float32Array(i), iB[i] = r), e !== 0) {
    n.toArray(r, 0);
    for (let o = 1, u = 0; o !== e; ++o)
      u += t, s[o].toArray(r, u);
  }
  return r;
}
function Er(s, e) {
  if (s.length !== e.length) return !1;
  for (let t = 0, n = s.length; t < n; t++)
    if (s[t] !== e[t]) return !1;
  return !0;
}
function Tr(s, e) {
  for (let t = 0, n = e.length; t < n; t++)
    s[t] = e[t];
}
function Qx(s, e) {
  let t = rB[e];
  t === void 0 && (t = new Int32Array(e), rB[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = s.allocateTextureUnit();
  return t;
}
function Pk(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
}
function Ik(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Er(t, e)) return;
    s.uniform2fv(this.addr, e), Tr(t, e);
  }
}
function Uk(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (Er(t, e)) return;
    s.uniform3fv(this.addr, e), Tr(t, e);
  }
}
function Fk(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Er(t, e)) return;
    s.uniform4fv(this.addr, e), Tr(t, e);
  }
}
function Nk(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (Er(t, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), Tr(t, e);
  } else {
    if (Er(t, n)) return;
    oB.set(n), s.uniformMatrix2fv(this.addr, !1, oB), Tr(t, n);
  }
}
function Ok(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (Er(t, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), Tr(t, e);
  } else {
    if (Er(t, n)) return;
    aB.set(n), s.uniformMatrix3fv(this.addr, !1, aB), Tr(t, n);
  }
}
function Hk(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (Er(t, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), Tr(t, e);
  } else {
    if (Er(t, n)) return;
    sB.set(n), s.uniformMatrix4fv(this.addr, !1, sB), Tr(t, n);
  }
}
function zk(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
}
function Gk(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Er(t, e)) return;
    s.uniform2iv(this.addr, e), Tr(t, e);
  }
}
function kk(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Er(t, e)) return;
    s.uniform3iv(this.addr, e), Tr(t, e);
  }
}
function Vk(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Er(t, e)) return;
    s.uniform4iv(this.addr, e), Tr(t, e);
  }
}
function Wk(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
}
function Xk(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Er(t, e)) return;
    s.uniform2uiv(this.addr, e), Tr(t, e);
  }
}
function Jk(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Er(t, e)) return;
    s.uniform3uiv(this.addr, e), Tr(t, e);
  }
}
function Yk(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Er(t, e)) return;
    s.uniform4uiv(this.addr, e), Tr(t, e);
  }
}
function Kk(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i);
  const r = this.type === s.SAMPLER_2D_SHADOW ? OP : NP;
  t.setTexture2D(e || r, i);
}
function qk(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || zP, i);
}
function jk(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || GP, i);
}
function Qk(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || HP, i);
}
function Zk(s) {
  switch (s) {
    case 5126:
      return Pk;
    // FLOAT
    case 35664:
      return Ik;
    // _VEC2
    case 35665:
      return Uk;
    // _VEC3
    case 35666:
      return Fk;
    // _VEC4
    case 35674:
      return Nk;
    // _MAT2
    case 35675:
      return Ok;
    // _MAT3
    case 35676:
      return Hk;
    // _MAT4
    case 5124:
    case 35670:
      return zk;
    // INT, BOOL
    case 35667:
    case 35671:
      return Gk;
    // _VEC2
    case 35668:
    case 35672:
      return kk;
    // _VEC3
    case 35669:
    case 35673:
      return Vk;
    // _VEC4
    case 5125:
      return Wk;
    // UINT
    case 36294:
      return Xk;
    // _VEC2
    case 36295:
      return Jk;
    // _VEC3
    case 36296:
      return Yk;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return Kk;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return qk;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return jk;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return Qk;
  }
}
function $k(s, e) {
  s.uniform1fv(this.addr, e);
}
function eV(s, e) {
  const t = am(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function tV(s, e) {
  const t = am(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function nV(s, e) {
  const t = am(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function iV(s, e) {
  const t = am(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, t);
}
function rV(s, e) {
  const t = am(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, t);
}
function sV(s, e) {
  const t = am(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, t);
}
function aV(s, e) {
  s.uniform1iv(this.addr, e);
}
function oV(s, e) {
  s.uniform2iv(this.addr, e);
}
function lV(s, e) {
  s.uniform3iv(this.addr, e);
}
function uV(s, e) {
  s.uniform4iv(this.addr, e);
}
function cV(s, e) {
  s.uniform1uiv(this.addr, e);
}
function fV(s, e) {
  s.uniform2uiv(this.addr, e);
}
function dV(s, e) {
  s.uniform3uiv(this.addr, e);
}
function hV(s, e) {
  s.uniform4uiv(this.addr, e);
}
function pV(s, e, t) {
  const n = this.cache, i = e.length, r = Qx(t, i);
  Er(n, r) || (s.uniform1iv(this.addr, r), Tr(n, r));
  for (let o = 0; o !== i; ++o)
    t.setTexture2D(e[o] || NP, r[o]);
}
function mV(s, e, t) {
  const n = this.cache, i = e.length, r = Qx(t, i);
  Er(n, r) || (s.uniform1iv(this.addr, r), Tr(n, r));
  for (let o = 0; o !== i; ++o)
    t.setTexture3D(e[o] || zP, r[o]);
}
function gV(s, e, t) {
  const n = this.cache, i = e.length, r = Qx(t, i);
  Er(n, r) || (s.uniform1iv(this.addr, r), Tr(n, r));
  for (let o = 0; o !== i; ++o)
    t.setTextureCube(e[o] || GP, r[o]);
}
function vV(s, e, t) {
  const n = this.cache, i = e.length, r = Qx(t, i);
  Er(n, r) || (s.uniform1iv(this.addr, r), Tr(n, r));
  for (let o = 0; o !== i; ++o)
    t.setTexture2DArray(e[o] || HP, r[o]);
}
function _V(s) {
  switch (s) {
    case 5126:
      return $k;
    // FLOAT
    case 35664:
      return eV;
    // _VEC2
    case 35665:
      return tV;
    // _VEC3
    case 35666:
      return nV;
    // _VEC4
    case 35674:
      return iV;
    // _MAT2
    case 35675:
      return rV;
    // _MAT3
    case 35676:
      return sV;
    // _MAT4
    case 5124:
    case 35670:
      return aV;
    // INT, BOOL
    case 35667:
    case 35671:
      return oV;
    // _VEC2
    case 35668:
    case 35672:
      return lV;
    // _VEC3
    case 35669:
    case 35673:
      return uV;
    // _VEC4
    case 5125:
      return cV;
    // UINT
    case 36294:
      return fV;
    // _VEC2
    case 36295:
      return dV;
    // _VEC3
    case 36296:
      return hV;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return pV;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return mV;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return gV;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return vV;
  }
}
class yV {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = Zk(t.type);
  }
}
class xV {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = _V(t.type);
  }
}
class SV {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let r = 0, o = i.length; r !== o; ++r) {
      const u = i[r];
      u.setValue(e, t[u.id], n);
    }
  }
}
const sE = /(\w+)(\])?(\[|\.)?/g;
function lB(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function AV(s, e, t) {
  const n = s.name, i = n.length;
  for (sE.lastIndex = 0; ; ) {
    const r = sE.exec(n), o = sE.lastIndex;
    let u = r[1];
    const c = r[2] === "]", d = r[3];
    if (c && (u = u | 0), d === void 0 || d === "[" && o + 2 === i) {
      lB(t, d === void 0 ? new yV(u, s, e) : new xV(u, s, e));
      break;
    } else {
      let g = t.map[u];
      g === void 0 && (g = new SV(u), lB(t, g)), t = g;
    }
  }
}
class fx {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const r = e.getActiveUniform(t, i), o = e.getUniformLocation(t, r.name);
      AV(r, o, this);
    }
  }
  setValue(e, t, n, i) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let r = 0, o = t.length; r !== o; ++r) {
      const u = t[r], c = n[u.id];
      c.needsUpdate !== !1 && u.setValue(e, c.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, r = e.length; i !== r; ++i) {
      const o = e[i];
      o.id in t && n.push(o);
    }
    return n;
  }
}
function uB(s, e, t) {
  const n = s.createShader(e);
  return s.shaderSource(n, t), s.compileShader(n), n;
}
const MV = 37297;
let EV = 0;
function TV(s, e) {
  const t = s.split(`
`), n = [], i = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
  for (let o = i; o < r; o++) {
    const u = o + 1;
    n.push(`${u === e ? ">" : " "} ${u}: ${t[o]}`);
  }
  return n.join(`
`);
}
function bV(s) {
  const e = Zn.getPrimaries(Zn.workingColorSpace), t = Zn.getPrimaries(s);
  let n;
  switch (e === t ? n = "" : e === Mv && t === Av ? n = "LinearDisplayP3ToLinearSRGB" : e === Av && t === Mv && (n = "LinearSRGBToLinearDisplayP3"), s) {
    case bl:
    case Vv:
      return [n, "LinearTransferOETF"];
    case Sr:
    case qx:
      return [n, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", s), [n, "LinearTransferOETF"];
  }
}
function cB(s, e, t) {
  const n = s.getShaderParameter(e, s.COMPILE_STATUS), i = s.getShaderInfoLog(e).trim();
  if (n && i === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(i);
  if (r) {
    const o = parseInt(r[1]);
    return t.toUpperCase() + `

` + i + `

` + TV(s.getShaderSource(e), o);
  } else
    return i;
}
function CV(s, e) {
  const t = bV(e);
  return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function wV(s, e) {
  let t;
  switch (e) {
    case eP:
      t = "Linear";
      break;
    case tP:
      t = "Reinhard";
      break;
    case nP:
      t = "OptimizedCineon";
      break;
    case _b:
      t = "ACESFilmic";
      break;
    case rP:
      t = "AgX";
      break;
    case iP:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function RV(s) {
  return [
    s.extensionDerivatives || s.envMapCubeUVHeight || s.bumpMap || s.normalMapTangentSpace || s.clearcoatNormalMap || s.flatShading || s.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (s.extensionFragDepth || s.logarithmicDepthBuffer) && s.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    s.extensionDrawBuffers && s.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (s.extensionShaderTextureLOD || s.envMap || s.transmission) && s.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(Tp).join(`
`);
}
function BV(s) {
  return [
    s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : ""
  ].filter(Tp).join(`
`);
}
function DV(s) {
  const e = [];
  for (const t in s) {
    const n = s[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function LV(s, e) {
  const t = {}, n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const r = s.getActiveAttrib(e, i), o = r.name;
    let u = 1;
    r.type === s.FLOAT_MAT2 && (u = 2), r.type === s.FLOAT_MAT3 && (u = 3), r.type === s.FLOAT_MAT4 && (u = 4), t[o] = {
      type: r.type,
      location: s.getAttribLocation(e, o),
      locationSize: u
    };
  }
  return t;
}
function Tp(s) {
  return s !== "";
}
function fB(s, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function dB(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const PV = /^[ \t]*#include +<([\w\d./]+)>/gm;
function NT(s) {
  return s.replace(PV, UV);
}
const IV = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function UV(s, e) {
  let t = yn[e];
  if (t === void 0) {
    const n = IV.get(e);
    if (n !== void 0)
      t = yn[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return NT(t);
}
const FV = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function hB(s) {
  return s.replace(FV, NV);
}
function NV(s, e, t, n) {
  let i = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return i;
}
function pB(s) {
  let e = "precision " + s.precision + ` float;
precision ` + s.precision + " int;";
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function OV(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === Wx ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === Zg ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === No && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function HV(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case mu:
      case Pc:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case nm:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function zV(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case Pc:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function GV(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case kv:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case ZL:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case $L:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function kV(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)), texelHeight: n, maxMip: t };
}
function VV(s, e, t, n) {
  const i = s.getContext(), r = t.defines;
  let o = t.vertexShader, u = t.fragmentShader;
  const c = OV(t), d = HV(t), p = zV(t), g = GV(t), v = kV(t), y = t.isWebGL2 ? "" : RV(t), S = BV(t), T = DV(r), E = i.createProgram();
  let M, w, C = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (M = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    T
  ].filter(Tp).join(`
`), M.length > 0 && (M += `
`), w = [
    y,
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    T
  ].filter(Tp).join(`
`), w.length > 0 && (w += `
`)) : (M = [
    pB(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    T,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + p : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + c : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Tp).join(`
`), w = [
    y,
    pB(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    T,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + d : "",
    t.envMap ? "#define " + p : "",
    t.envMap ? "#define " + g : "",
    v ? "#define CUBEUV_TEXEL_WIDTH " + v.texelWidth : "",
    v ? "#define CUBEUV_TEXEL_HEIGHT " + v.texelHeight : "",
    v ? "#define CUBEUV_MAX_MIP " + v.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + c : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== xl ? "#define TONE_MAPPING" : "",
    t.toneMapping !== xl ? yn.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== xl ? wV("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    yn.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    CV("linearToOutputTexel", t.outputColorSpace),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(Tp).join(`
`)), o = NT(o), o = fB(o, t), o = dB(o, t), u = NT(u), u = fB(u, t), u = dB(u, t), o = hB(o), u = hB(u), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (C = `#version 300 es
`, M = [
    S,
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + M, w = [
    "precision mediump sampler2DArray;",
    "#define varying in",
    t.glslVersion === IT ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === IT ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + w);
  const D = C + M + o, N = C + w + u, U = uB(i, i.VERTEX_SHADER, D), O = uB(i, i.FRAGMENT_SHADER, N);
  i.attachShader(E, U), i.attachShader(E, O), t.index0AttributeName !== void 0 ? i.bindAttribLocation(E, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(E, 0, "position"), i.linkProgram(E);
  function V(Q) {
    if (s.debug.checkShaderErrors) {
      const fe = i.getProgramInfoLog(E).trim(), j = i.getShaderInfoLog(U).trim(), ie = i.getShaderInfoLog(O).trim();
      let re = !0, pe = !0;
      if (i.getProgramParameter(E, i.LINK_STATUS) === !1)
        if (re = !1, typeof s.debug.onShaderError == "function")
          s.debug.onShaderError(i, E, U, O);
        else {
          const J = cB(i, U, "vertex"), Z = cB(i, O, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(E, i.VALIDATE_STATUS) + `

Program Info Log: ` + fe + `
` + J + `
` + Z
          );
        }
      else fe !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", fe) : (j === "" || ie === "") && (pe = !1);
      pe && (Q.diagnostics = {
        runnable: re,
        programLog: fe,
        vertexShader: {
          log: j,
          prefix: M
        },
        fragmentShader: {
          log: ie,
          prefix: w
        }
      });
    }
    i.deleteShader(U), i.deleteShader(O), L = new fx(i, E), I = LV(i, E);
  }
  let L;
  this.getUniforms = function() {
    return L === void 0 && V(this), L;
  };
  let I;
  this.getAttributes = function() {
    return I === void 0 && V(this), I;
  };
  let Y = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return Y === !1 && (Y = i.getProgramParameter(E, MV)), Y;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), i.deleteProgram(E), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = EV++, this.cacheKey = e, this.usedTimes = 1, this.program = E, this.vertexShader = U, this.fragmentShader = O, this;
}
let WV = 0;
class XV {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), r = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
    return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(r) === !1 && (o.add(r), r.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new JV(e), t.set(e, n)), n;
  }
}
class JV {
  constructor(e) {
    this.id = WV++, this.code = e, this.usedTimes = 0;
  }
}
function YV(s, e, t, n, i, r, o) {
  const u = new id(), c = new XV(), d = [], p = i.isWebGL2, g = i.logarithmicDepthBuffer, v = i.vertexTextures;
  let y = i.precision;
  const S = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function T(L) {
    return L === 0 ? "uv" : `uv${L}`;
  }
  function E(L, I, Y, Q, fe) {
    const j = Q.fog, ie = fe.geometry, re = L.isMeshStandardMaterial ? Q.environment : null, pe = (L.isMeshStandardMaterial ? t : e).get(L.envMap || re), J = pe && pe.mapping === nm ? pe.image.height : null, Z = S[L.type];
    L.precision !== null && (y = i.getMaxPrecision(L.precision), y !== L.precision && console.warn("THREE.WebGLProgram.getParameters:", L.precision, "not supported, using", y, "instead."));
    const H = ie.morphAttributes.position || ie.morphAttributes.normal || ie.morphAttributes.color, ue = H !== void 0 ? H.length : 0;
    let Se = 0;
    ie.morphAttributes.position !== void 0 && (Se = 1), ie.morphAttributes.normal !== void 0 && (Se = 2), ie.morphAttributes.color !== void 0 && (Se = 3);
    let me, ye, Xe, Je;
    if (Z) {
      const St = Oo[Z];
      me = St.vertexShader, ye = St.fragmentShader;
    } else
      me = L.vertexShader, ye = L.fragmentShader, c.update(L), Xe = c.getVertexShaderID(L), Je = c.getFragmentShaderID(L);
    const Ye = s.getRenderTarget(), At = fe.isInstancedMesh === !0, Ct = fe.isBatchedMesh === !0, pt = !!L.map, mt = !!L.matcap, ne = !!pe, we = !!L.aoMap, Ee = !!L.lightMap, He = !!L.bumpMap, be = !!L.normalMap, ce = !!L.displacementMap, nt = !!L.emissiveMap, X = !!L.metalnessMap, G = !!L.roughnessMap, le = L.anisotropy > 0, Ue = L.clearcoat > 0, Ve = L.iridescence > 0, Oe = L.sheen > 0, ct = L.transmission > 0, st = le && !!L.anisotropyMap, it = Ue && !!L.clearcoatMap, Lt = Ue && !!L.clearcoatNormalMap, zt = Ue && !!L.clearcoatRoughnessMap, ee = Ve && !!L.iridescenceMap, Re = Ve && !!L.iridescenceThicknessMap, De = Oe && !!L.sheenColorMap, Ie = Oe && !!L.sheenRoughnessMap, Qe = !!L.specularMap, rt = !!L.specularColorMap, Fe = !!L.specularIntensityMap, Ke = ct && !!L.transmissionMap, Dt = ct && !!L.thicknessMap, We = !!L.gradientMap, Pe = !!L.alphaMap, ae = L.alphaTest > 0, et = !!L.alphaHash, at = !!L.extensions, Wt = !!ie.attributes.uv1, ot = !!ie.attributes.uv2, an = !!ie.attributes.uv3;
    let un = xl;
    return L.toneMapped && (Ye === null || Ye.isXRRenderTarget === !0) && (un = s.toneMapping), {
      isWebGL2: p,
      shaderID: Z,
      shaderType: L.type,
      shaderName: L.name,
      vertexShader: me,
      fragmentShader: ye,
      defines: L.defines,
      customVertexShaderID: Xe,
      customFragmentShaderID: Je,
      isRawShaderMaterial: L.isRawShaderMaterial === !0,
      glslVersion: L.glslVersion,
      precision: y,
      batching: Ct,
      instancing: At,
      instancingColor: At && fe.instanceColor !== null,
      supportsVertexTextures: v,
      outputColorSpace: Ye === null ? s.outputColorSpace : Ye.isXRRenderTarget === !0 ? Ye.texture.colorSpace : bl,
      map: pt,
      matcap: mt,
      envMap: ne,
      envMapMode: ne && pe.mapping,
      envMapCubeUVHeight: J,
      aoMap: we,
      lightMap: Ee,
      bumpMap: He,
      normalMap: be,
      displacementMap: v && ce,
      emissiveMap: nt,
      normalMapObjectSpace: be && L.normalMapType === xP,
      normalMapTangentSpace: be && L.normalMapType === zc,
      metalnessMap: X,
      roughnessMap: G,
      anisotropy: le,
      anisotropyMap: st,
      clearcoat: Ue,
      clearcoatMap: it,
      clearcoatNormalMap: Lt,
      clearcoatRoughnessMap: zt,
      iridescence: Ve,
      iridescenceMap: ee,
      iridescenceThicknessMap: Re,
      sheen: Oe,
      sheenColorMap: De,
      sheenRoughnessMap: Ie,
      specularMap: Qe,
      specularColorMap: rt,
      specularIntensityMap: Fe,
      transmission: ct,
      transmissionMap: Ke,
      thicknessMap: Dt,
      gradientMap: We,
      opaque: L.transparent === !1 && L.blending === td,
      alphaMap: Pe,
      alphaTest: ae,
      alphaHash: et,
      combine: L.combine,
      //
      mapUv: pt && T(L.map.channel),
      aoMapUv: we && T(L.aoMap.channel),
      lightMapUv: Ee && T(L.lightMap.channel),
      bumpMapUv: He && T(L.bumpMap.channel),
      normalMapUv: be && T(L.normalMap.channel),
      displacementMapUv: ce && T(L.displacementMap.channel),
      emissiveMapUv: nt && T(L.emissiveMap.channel),
      metalnessMapUv: X && T(L.metalnessMap.channel),
      roughnessMapUv: G && T(L.roughnessMap.channel),
      anisotropyMapUv: st && T(L.anisotropyMap.channel),
      clearcoatMapUv: it && T(L.clearcoatMap.channel),
      clearcoatNormalMapUv: Lt && T(L.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: zt && T(L.clearcoatRoughnessMap.channel),
      iridescenceMapUv: ee && T(L.iridescenceMap.channel),
      iridescenceThicknessMapUv: Re && T(L.iridescenceThicknessMap.channel),
      sheenColorMapUv: De && T(L.sheenColorMap.channel),
      sheenRoughnessMapUv: Ie && T(L.sheenRoughnessMap.channel),
      specularMapUv: Qe && T(L.specularMap.channel),
      specularColorMapUv: rt && T(L.specularColorMap.channel),
      specularIntensityMapUv: Fe && T(L.specularIntensityMap.channel),
      transmissionMapUv: Ke && T(L.transmissionMap.channel),
      thicknessMapUv: Dt && T(L.thicknessMap.channel),
      alphaMapUv: Pe && T(L.alphaMap.channel),
      //
      vertexTangents: !!ie.attributes.tangent && (be || le),
      vertexColors: L.vertexColors,
      vertexAlphas: L.vertexColors === !0 && !!ie.attributes.color && ie.attributes.color.itemSize === 4,
      vertexUv1s: Wt,
      vertexUv2s: ot,
      vertexUv3s: an,
      pointsUvs: fe.isPoints === !0 && !!ie.attributes.uv && (pt || Pe),
      fog: !!j,
      useFog: L.fog === !0,
      fogExp2: j && j.isFogExp2,
      flatShading: L.flatShading === !0,
      sizeAttenuation: L.sizeAttenuation === !0,
      logarithmicDepthBuffer: g,
      skinning: fe.isSkinnedMesh === !0,
      morphTargets: ie.morphAttributes.position !== void 0,
      morphNormals: ie.morphAttributes.normal !== void 0,
      morphColors: ie.morphAttributes.color !== void 0,
      morphTargetsCount: ue,
      morphTextureStride: Se,
      numDirLights: I.directional.length,
      numPointLights: I.point.length,
      numSpotLights: I.spot.length,
      numSpotLightMaps: I.spotLightMap.length,
      numRectAreaLights: I.rectArea.length,
      numHemiLights: I.hemi.length,
      numDirLightShadows: I.directionalShadowMap.length,
      numPointLightShadows: I.pointShadowMap.length,
      numSpotLightShadows: I.spotShadowMap.length,
      numSpotLightShadowsWithMaps: I.numSpotLightShadowsWithMaps,
      numLightProbes: I.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: L.dithering,
      shadowMapEnabled: s.shadowMap.enabled && Y.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: un,
      useLegacyLights: s._useLegacyLights,
      decodeVideoTexture: pt && L.map.isVideoTexture === !0 && Zn.getTransfer(L.map.colorSpace) === li,
      premultipliedAlpha: L.premultipliedAlpha,
      doubleSided: L.side === Ho,
      flipSided: L.side === zs,
      useDepthPacking: L.depthPacking >= 0,
      depthPacking: L.depthPacking || 0,
      index0AttributeName: L.index0AttributeName,
      extensionDerivatives: at && L.extensions.derivatives === !0,
      extensionFragDepth: at && L.extensions.fragDepth === !0,
      extensionDrawBuffers: at && L.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: at && L.extensions.shaderTextureLOD === !0,
      extensionClipCullDistance: at && L.extensions.clipCullDistance && n.has("WEBGL_clip_cull_distance"),
      rendererExtensionFragDepth: p || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: p || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: p || n.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: L.customProgramCacheKey()
    };
  }
  function M(L) {
    const I = [];
    if (L.shaderID ? I.push(L.shaderID) : (I.push(L.customVertexShaderID), I.push(L.customFragmentShaderID)), L.defines !== void 0)
      for (const Y in L.defines)
        I.push(Y), I.push(L.defines[Y]);
    return L.isRawShaderMaterial === !1 && (w(I, L), C(I, L), I.push(s.outputColorSpace)), I.push(L.customProgramCacheKey), I.join();
  }
  function w(L, I) {
    L.push(I.precision), L.push(I.outputColorSpace), L.push(I.envMapMode), L.push(I.envMapCubeUVHeight), L.push(I.mapUv), L.push(I.alphaMapUv), L.push(I.lightMapUv), L.push(I.aoMapUv), L.push(I.bumpMapUv), L.push(I.normalMapUv), L.push(I.displacementMapUv), L.push(I.emissiveMapUv), L.push(I.metalnessMapUv), L.push(I.roughnessMapUv), L.push(I.anisotropyMapUv), L.push(I.clearcoatMapUv), L.push(I.clearcoatNormalMapUv), L.push(I.clearcoatRoughnessMapUv), L.push(I.iridescenceMapUv), L.push(I.iridescenceThicknessMapUv), L.push(I.sheenColorMapUv), L.push(I.sheenRoughnessMapUv), L.push(I.specularMapUv), L.push(I.specularColorMapUv), L.push(I.specularIntensityMapUv), L.push(I.transmissionMapUv), L.push(I.thicknessMapUv), L.push(I.combine), L.push(I.fogExp2), L.push(I.sizeAttenuation), L.push(I.morphTargetsCount), L.push(I.morphAttributeCount), L.push(I.numDirLights), L.push(I.numPointLights), L.push(I.numSpotLights), L.push(I.numSpotLightMaps), L.push(I.numHemiLights), L.push(I.numRectAreaLights), L.push(I.numDirLightShadows), L.push(I.numPointLightShadows), L.push(I.numSpotLightShadows), L.push(I.numSpotLightShadowsWithMaps), L.push(I.numLightProbes), L.push(I.shadowMapType), L.push(I.toneMapping), L.push(I.numClippingPlanes), L.push(I.numClipIntersection), L.push(I.depthPacking);
  }
  function C(L, I) {
    u.disableAll(), I.isWebGL2 && u.enable(0), I.supportsVertexTextures && u.enable(1), I.instancing && u.enable(2), I.instancingColor && u.enable(3), I.matcap && u.enable(4), I.envMap && u.enable(5), I.normalMapObjectSpace && u.enable(6), I.normalMapTangentSpace && u.enable(7), I.clearcoat && u.enable(8), I.iridescence && u.enable(9), I.alphaTest && u.enable(10), I.vertexColors && u.enable(11), I.vertexAlphas && u.enable(12), I.vertexUv1s && u.enable(13), I.vertexUv2s && u.enable(14), I.vertexUv3s && u.enable(15), I.vertexTangents && u.enable(16), I.anisotropy && u.enable(17), I.alphaHash && u.enable(18), I.batching && u.enable(19), L.push(u.mask), u.disableAll(), I.fog && u.enable(0), I.useFog && u.enable(1), I.flatShading && u.enable(2), I.logarithmicDepthBuffer && u.enable(3), I.skinning && u.enable(4), I.morphTargets && u.enable(5), I.morphNormals && u.enable(6), I.morphColors && u.enable(7), I.premultipliedAlpha && u.enable(8), I.shadowMapEnabled && u.enable(9), I.useLegacyLights && u.enable(10), I.doubleSided && u.enable(11), I.flipSided && u.enable(12), I.useDepthPacking && u.enable(13), I.dithering && u.enable(14), I.transmission && u.enable(15), I.sheen && u.enable(16), I.opaque && u.enable(17), I.pointsUvs && u.enable(18), I.decodeVideoTexture && u.enable(19), L.push(u.mask);
  }
  function D(L) {
    const I = S[L.type];
    let Y;
    if (I) {
      const Q = Oo[I];
      Y = PP.clone(Q.uniforms);
    } else
      Y = L.uniforms;
    return Y;
  }
  function N(L, I) {
    let Y;
    for (let Q = 0, fe = d.length; Q < fe; Q++) {
      const j = d[Q];
      if (j.cacheKey === I) {
        Y = j, ++Y.usedTimes;
        break;
      }
    }
    return Y === void 0 && (Y = new VV(s, I, L, r), d.push(Y)), Y;
  }
  function U(L) {
    if (--L.usedTimes === 0) {
      const I = d.indexOf(L);
      d[I] = d[d.length - 1], d.pop(), L.destroy();
    }
  }
  function O(L) {
    c.remove(L);
  }
  function V() {
    c.dispose();
  }
  return {
    getParameters: E,
    getProgramCacheKey: M,
    getUniforms: D,
    acquireProgram: N,
    releaseProgram: U,
    releaseShaderCache: O,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: d,
    dispose: V
  };
}
function KV() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(r) {
    let o = s.get(r);
    return o === void 0 && (o = {}, s.set(r, o)), o;
  }
  function t(r) {
    s.delete(r);
  }
  function n(r, o, u) {
    s.get(r)[o] = u;
  }
  function i() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: n,
    dispose: i
  };
}
function qV(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function mB(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function gB() {
  const s = [];
  let e = 0;
  const t = [], n = [], i = [];
  function r() {
    e = 0, t.length = 0, n.length = 0, i.length = 0;
  }
  function o(g, v, y, S, T, E) {
    let M = s[e];
    return M === void 0 ? (M = {
      id: g.id,
      object: g,
      geometry: v,
      material: y,
      groupOrder: S,
      renderOrder: g.renderOrder,
      z: T,
      group: E
    }, s[e] = M) : (M.id = g.id, M.object = g, M.geometry = v, M.material = y, M.groupOrder = S, M.renderOrder = g.renderOrder, M.z = T, M.group = E), e++, M;
  }
  function u(g, v, y, S, T, E) {
    const M = o(g, v, y, S, T, E);
    y.transmission > 0 ? n.push(M) : y.transparent === !0 ? i.push(M) : t.push(M);
  }
  function c(g, v, y, S, T, E) {
    const M = o(g, v, y, S, T, E);
    y.transmission > 0 ? n.unshift(M) : y.transparent === !0 ? i.unshift(M) : t.unshift(M);
  }
  function d(g, v) {
    t.length > 1 && t.sort(g || qV), n.length > 1 && n.sort(v || mB), i.length > 1 && i.sort(v || mB);
  }
  function p() {
    for (let g = e, v = s.length; g < v; g++) {
      const y = s[g];
      if (y.id === null) break;
      y.id = null, y.object = null, y.geometry = null, y.material = null, y.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: r,
    push: u,
    unshift: c,
    finish: p,
    sort: d
  };
}
function jV() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(n, i) {
    const r = s.get(n);
    let o;
    return r === void 0 ? (o = new gB(), s.set(n, [o])) : i >= r.length ? (o = new gB(), r.push(o)) : o = r[i], o;
  }
  function t() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function QV() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new q(),
            color: new Tt()
          };
          break;
        case "SpotLight":
          t = {
            position: new q(),
            direction: new q(),
            color: new Tt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new q(),
            color: new Tt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new q(),
            skyColor: new Tt(),
            groundColor: new Tt()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Tt(),
            position: new q(),
            halfWidth: new q(),
            halfHeight: new q()
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
function ZV() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
let $V = 0;
function e4(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function t4(s, e) {
  const t = new QV(), n = ZV(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let p = 0; p < 9; p++) i.probe.push(new q());
  const r = new q(), o = new sn(), u = new sn();
  function c(p, g) {
    let v = 0, y = 0, S = 0;
    for (let Q = 0; Q < 9; Q++) i.probe[Q].set(0, 0, 0);
    let T = 0, E = 0, M = 0, w = 0, C = 0, D = 0, N = 0, U = 0, O = 0, V = 0, L = 0;
    p.sort(e4);
    const I = g === !0 ? Math.PI : 1;
    for (let Q = 0, fe = p.length; Q < fe; Q++) {
      const j = p[Q], ie = j.color, re = j.intensity, pe = j.distance, J = j.shadow && j.shadow.map ? j.shadow.map.texture : null;
      if (j.isAmbientLight)
        v += ie.r * re * I, y += ie.g * re * I, S += ie.b * re * I;
      else if (j.isLightProbe) {
        for (let Z = 0; Z < 9; Z++)
          i.probe[Z].addScaledVector(j.sh.coefficients[Z], re);
        L++;
      } else if (j.isDirectionalLight) {
        const Z = t.get(j);
        if (Z.color.copy(j.color).multiplyScalar(j.intensity * I), j.castShadow) {
          const H = j.shadow, ue = n.get(j);
          ue.shadowBias = H.bias, ue.shadowNormalBias = H.normalBias, ue.shadowRadius = H.radius, ue.shadowMapSize = H.mapSize, i.directionalShadow[T] = ue, i.directionalShadowMap[T] = J, i.directionalShadowMatrix[T] = j.shadow.matrix, D++;
        }
        i.directional[T] = Z, T++;
      } else if (j.isSpotLight) {
        const Z = t.get(j);
        Z.position.setFromMatrixPosition(j.matrixWorld), Z.color.copy(ie).multiplyScalar(re * I), Z.distance = pe, Z.coneCos = Math.cos(j.angle), Z.penumbraCos = Math.cos(j.angle * (1 - j.penumbra)), Z.decay = j.decay, i.spot[M] = Z;
        const H = j.shadow;
        if (j.map && (i.spotLightMap[O] = j.map, O++, H.updateMatrices(j), j.castShadow && V++), i.spotLightMatrix[M] = H.matrix, j.castShadow) {
          const ue = n.get(j);
          ue.shadowBias = H.bias, ue.shadowNormalBias = H.normalBias, ue.shadowRadius = H.radius, ue.shadowMapSize = H.mapSize, i.spotShadow[M] = ue, i.spotShadowMap[M] = J, U++;
        }
        M++;
      } else if (j.isRectAreaLight) {
        const Z = t.get(j);
        Z.color.copy(ie).multiplyScalar(re), Z.halfWidth.set(j.width * 0.5, 0, 0), Z.halfHeight.set(0, j.height * 0.5, 0), i.rectArea[w] = Z, w++;
      } else if (j.isPointLight) {
        const Z = t.get(j);
        if (Z.color.copy(j.color).multiplyScalar(j.intensity * I), Z.distance = j.distance, Z.decay = j.decay, j.castShadow) {
          const H = j.shadow, ue = n.get(j);
          ue.shadowBias = H.bias, ue.shadowNormalBias = H.normalBias, ue.shadowRadius = H.radius, ue.shadowMapSize = H.mapSize, ue.shadowCameraNear = H.camera.near, ue.shadowCameraFar = H.camera.far, i.pointShadow[E] = ue, i.pointShadowMap[E] = J, i.pointShadowMatrix[E] = j.shadow.matrix, N++;
        }
        i.point[E] = Z, E++;
      } else if (j.isHemisphereLight) {
        const Z = t.get(j);
        Z.skyColor.copy(j.color).multiplyScalar(re * I), Z.groundColor.copy(j.groundColor).multiplyScalar(re * I), i.hemi[C] = Z, C++;
      }
    }
    w > 0 && (e.isWebGL2 ? s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = xt.LTC_FLOAT_1, i.rectAreaLTC2 = xt.LTC_FLOAT_2) : (i.rectAreaLTC1 = xt.LTC_HALF_1, i.rectAreaLTC2 = xt.LTC_HALF_2) : s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = xt.LTC_FLOAT_1, i.rectAreaLTC2 = xt.LTC_FLOAT_2) : s.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = xt.LTC_HALF_1, i.rectAreaLTC2 = xt.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = v, i.ambient[1] = y, i.ambient[2] = S;
    const Y = i.hash;
    (Y.directionalLength !== T || Y.pointLength !== E || Y.spotLength !== M || Y.rectAreaLength !== w || Y.hemiLength !== C || Y.numDirectionalShadows !== D || Y.numPointShadows !== N || Y.numSpotShadows !== U || Y.numSpotMaps !== O || Y.numLightProbes !== L) && (i.directional.length = T, i.spot.length = M, i.rectArea.length = w, i.point.length = E, i.hemi.length = C, i.directionalShadow.length = D, i.directionalShadowMap.length = D, i.pointShadow.length = N, i.pointShadowMap.length = N, i.spotShadow.length = U, i.spotShadowMap.length = U, i.directionalShadowMatrix.length = D, i.pointShadowMatrix.length = N, i.spotLightMatrix.length = U + O - V, i.spotLightMap.length = O, i.numSpotLightShadowsWithMaps = V, i.numLightProbes = L, Y.directionalLength = T, Y.pointLength = E, Y.spotLength = M, Y.rectAreaLength = w, Y.hemiLength = C, Y.numDirectionalShadows = D, Y.numPointShadows = N, Y.numSpotShadows = U, Y.numSpotMaps = O, Y.numLightProbes = L, i.version = $V++);
  }
  function d(p, g) {
    let v = 0, y = 0, S = 0, T = 0, E = 0;
    const M = g.matrixWorldInverse;
    for (let w = 0, C = p.length; w < C; w++) {
      const D = p[w];
      if (D.isDirectionalLight) {
        const N = i.directional[v];
        N.direction.setFromMatrixPosition(D.matrixWorld), r.setFromMatrixPosition(D.target.matrixWorld), N.direction.sub(r), N.direction.transformDirection(M), v++;
      } else if (D.isSpotLight) {
        const N = i.spot[S];
        N.position.setFromMatrixPosition(D.matrixWorld), N.position.applyMatrix4(M), N.direction.setFromMatrixPosition(D.matrixWorld), r.setFromMatrixPosition(D.target.matrixWorld), N.direction.sub(r), N.direction.transformDirection(M), S++;
      } else if (D.isRectAreaLight) {
        const N = i.rectArea[T];
        N.position.setFromMatrixPosition(D.matrixWorld), N.position.applyMatrix4(M), u.identity(), o.copy(D.matrixWorld), o.premultiply(M), u.extractRotation(o), N.halfWidth.set(D.width * 0.5, 0, 0), N.halfHeight.set(0, D.height * 0.5, 0), N.halfWidth.applyMatrix4(u), N.halfHeight.applyMatrix4(u), T++;
      } else if (D.isPointLight) {
        const N = i.point[y];
        N.position.setFromMatrixPosition(D.matrixWorld), N.position.applyMatrix4(M), y++;
      } else if (D.isHemisphereLight) {
        const N = i.hemi[E];
        N.direction.setFromMatrixPosition(D.matrixWorld), N.direction.transformDirection(M), E++;
      }
    }
  }
  return {
    setup: c,
    setupView: d,
    state: i
  };
}
function vB(s, e) {
  const t = new t4(s, e), n = [], i = [];
  function r() {
    n.length = 0, i.length = 0;
  }
  function o(g) {
    n.push(g);
  }
  function u(g) {
    i.push(g);
  }
  function c(g) {
    t.setup(n, g);
  }
  function d(g) {
    t.setupView(n, g);
  }
  return {
    init: r,
    state: {
      lightsArray: n,
      shadowsArray: i,
      lights: t
    },
    setupLights: c,
    setupLightsView: d,
    pushLight: o,
    pushShadow: u
  };
}
function n4(s, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function n(r, o = 0) {
    const u = t.get(r);
    let c;
    return u === void 0 ? (c = new vB(s, e), t.set(r, [c])) : o >= u.length ? (c = new vB(s, e), u.push(c)) : c = u[o], c;
  }
  function i() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: i
  };
}
class Nb extends Mr {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = _P, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Ob extends Mr {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const i4 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, r4 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function s4(s, e, t) {
  let n = new Jv();
  const i = new qe(), r = new qe(), o = new $n(), u = new Nb({ depthPacking: yP }), c = new Ob(), d = {}, p = t.maxTextureSize, g = { [El]: zs, [zs]: El, [Ho]: Ho }, v = new Cl({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new qe() },
      radius: { value: 4 }
    },
    vertexShader: i4,
    fragmentShader: r4
  }), y = v.clone();
  y.defines.HORIZONTAL_PASS = 1;
  const S = new pn();
  S.setAttribute(
    "position",
    new Hn(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const T = new ur(S, v), E = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Wx;
  let M = this.type;
  this.render = function(U, O, V) {
    if (E.enabled === !1 || E.autoUpdate === !1 && E.needsUpdate === !1 || U.length === 0) return;
    const L = s.getRenderTarget(), I = s.getActiveCubeFace(), Y = s.getActiveMipmapLevel(), Q = s.state;
    Q.setBlending(du), Q.buffers.color.setClear(1, 1, 1, 1), Q.buffers.depth.setTest(!0), Q.setScissorTest(!1);
    const fe = M !== No && this.type === No, j = M === No && this.type !== No;
    for (let ie = 0, re = U.length; ie < re; ie++) {
      const pe = U[ie], J = pe.shadow;
      if (J === void 0) {
        console.warn("THREE.WebGLShadowMap:", pe, "has no shadow.");
        continue;
      }
      if (J.autoUpdate === !1 && J.needsUpdate === !1) continue;
      i.copy(J.mapSize);
      const Z = J.getFrameExtents();
      if (i.multiply(Z), r.copy(J.mapSize), (i.x > p || i.y > p) && (i.x > p && (r.x = Math.floor(p / Z.x), i.x = r.x * Z.x, J.mapSize.x = r.x), i.y > p && (r.y = Math.floor(p / Z.y), i.y = r.y * Z.y, J.mapSize.y = r.y)), J.map === null || fe === !0 || j === !0) {
        const ue = this.type !== No ? { minFilter: Oi, magFilter: Oi } : {};
        J.map !== null && J.map.dispose(), J.map = new ko(i.x, i.y, ue), J.map.texture.name = pe.name + ".shadowMap", J.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(J.map), s.clear();
      const H = J.getViewportCount();
      for (let ue = 0; ue < H; ue++) {
        const Se = J.getViewport(ue);
        o.set(
          r.x * Se.x,
          r.y * Se.y,
          r.x * Se.z,
          r.y * Se.w
        ), Q.viewport(o), J.updateMatrices(pe, ue), n = J.getFrustum(), D(O, V, J.camera, pe, this.type);
      }
      J.isPointLightShadow !== !0 && this.type === No && w(J, V), J.needsUpdate = !1;
    }
    M = this.type, E.needsUpdate = !1, s.setRenderTarget(L, I, Y);
  };
  function w(U, O) {
    const V = e.update(T);
    v.defines.VSM_SAMPLES !== U.blurSamples && (v.defines.VSM_SAMPLES = U.blurSamples, y.defines.VSM_SAMPLES = U.blurSamples, v.needsUpdate = !0, y.needsUpdate = !0), U.mapPass === null && (U.mapPass = new ko(i.x, i.y)), v.uniforms.shadow_pass.value = U.map.texture, v.uniforms.resolution.value = U.mapSize, v.uniforms.radius.value = U.radius, s.setRenderTarget(U.mapPass), s.clear(), s.renderBufferDirect(O, null, V, v, T, null), y.uniforms.shadow_pass.value = U.mapPass.texture, y.uniforms.resolution.value = U.mapSize, y.uniforms.radius.value = U.radius, s.setRenderTarget(U.map), s.clear(), s.renderBufferDirect(O, null, V, y, T, null);
  }
  function C(U, O, V, L) {
    let I = null;
    const Y = V.isPointLight === !0 ? U.customDistanceMaterial : U.customDepthMaterial;
    if (Y !== void 0)
      I = Y;
    else if (I = V.isPointLight === !0 ? c : u, s.localClippingEnabled && O.clipShadows === !0 && Array.isArray(O.clippingPlanes) && O.clippingPlanes.length !== 0 || O.displacementMap && O.displacementScale !== 0 || O.alphaMap && O.alphaTest > 0 || O.map && O.alphaTest > 0) {
      const Q = I.uuid, fe = O.uuid;
      let j = d[Q];
      j === void 0 && (j = {}, d[Q] = j);
      let ie = j[fe];
      ie === void 0 && (ie = I.clone(), j[fe] = ie, O.addEventListener("dispose", N)), I = ie;
    }
    if (I.visible = O.visible, I.wireframe = O.wireframe, L === No ? I.side = O.shadowSide !== null ? O.shadowSide : O.side : I.side = O.shadowSide !== null ? O.shadowSide : g[O.side], I.alphaMap = O.alphaMap, I.alphaTest = O.alphaTest, I.map = O.map, I.clipShadows = O.clipShadows, I.clippingPlanes = O.clippingPlanes, I.clipIntersection = O.clipIntersection, I.displacementMap = O.displacementMap, I.displacementScale = O.displacementScale, I.displacementBias = O.displacementBias, I.wireframeLinewidth = O.wireframeLinewidth, I.linewidth = O.linewidth, V.isPointLight === !0 && I.isMeshDistanceMaterial === !0) {
      const Q = s.properties.get(I);
      Q.light = V;
    }
    return I;
  }
  function D(U, O, V, L, I) {
    if (U.visible === !1) return;
    if (U.layers.test(O.layers) && (U.isMesh || U.isLine || U.isPoints) && (U.castShadow || U.receiveShadow && I === No) && (!U.frustumCulled || n.intersectsObject(U))) {
      U.modelViewMatrix.multiplyMatrices(V.matrixWorldInverse, U.matrixWorld);
      const fe = e.update(U), j = U.material;
      if (Array.isArray(j)) {
        const ie = fe.groups;
        for (let re = 0, pe = ie.length; re < pe; re++) {
          const J = ie[re], Z = j[J.materialIndex];
          if (Z && Z.visible) {
            const H = C(U, Z, L, I);
            U.onBeforeShadow(s, U, O, V, fe, H, J), s.renderBufferDirect(V, null, fe, H, U, J), U.onAfterShadow(s, U, O, V, fe, H, J);
          }
        }
      } else if (j.visible) {
        const ie = C(U, j, L, I);
        U.onBeforeShadow(s, U, O, V, fe, ie, null), s.renderBufferDirect(V, null, fe, ie, U, null), U.onAfterShadow(s, U, O, V, fe, ie, null);
      }
    }
    const Q = U.children;
    for (let fe = 0, j = Q.length; fe < j; fe++)
      D(Q[fe], O, V, L, I);
  }
  function N(U) {
    U.target.removeEventListener("dispose", N);
    for (const V in d) {
      const L = d[V], I = U.target.uuid;
      I in L && (L[I].dispose(), delete L[I]);
    }
  }
}
function a4(s, e, t) {
  const n = t.isWebGL2;
  function i() {
    let ae = !1;
    const et = new $n();
    let at = null;
    const Wt = new $n(0, 0, 0, 0);
    return {
      setMask: function(ot) {
        at !== ot && !ae && (s.colorMask(ot, ot, ot, ot), at = ot);
      },
      setLocked: function(ot) {
        ae = ot;
      },
      setClear: function(ot, an, un, wt, St) {
        St === !0 && (ot *= wt, an *= wt, un *= wt), et.set(ot, an, un, wt), Wt.equals(et) === !1 && (s.clearColor(ot, an, un, wt), Wt.copy(et));
      },
      reset: function() {
        ae = !1, at = null, Wt.set(-1, 0, 0, 0);
      }
    };
  }
  function r() {
    let ae = !1, et = null, at = null, Wt = null;
    return {
      setTest: function(ot) {
        ot ? Ct(s.DEPTH_TEST) : pt(s.DEPTH_TEST);
      },
      setMask: function(ot) {
        et !== ot && !ae && (s.depthMask(ot), et = ot);
      },
      setFunc: function(ot) {
        if (at !== ot) {
          switch (ot) {
            case XL:
              s.depthFunc(s.NEVER);
              break;
            case JL:
              s.depthFunc(s.ALWAYS);
              break;
            case YL:
              s.depthFunc(s.LESS);
              break;
            case gv:
              s.depthFunc(s.LEQUAL);
              break;
            case KL:
              s.depthFunc(s.EQUAL);
              break;
            case qL:
              s.depthFunc(s.GEQUAL);
              break;
            case jL:
              s.depthFunc(s.GREATER);
              break;
            case QL:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          at = ot;
        }
      },
      setLocked: function(ot) {
        ae = ot;
      },
      setClear: function(ot) {
        Wt !== ot && (s.clearDepth(ot), Wt = ot);
      },
      reset: function() {
        ae = !1, et = null, at = null, Wt = null;
      }
    };
  }
  function o() {
    let ae = !1, et = null, at = null, Wt = null, ot = null, an = null, un = null, wt = null, St = null;
    return {
      setTest: function(bt) {
        ae || (bt ? Ct(s.STENCIL_TEST) : pt(s.STENCIL_TEST));
      },
      setMask: function(bt) {
        et !== bt && !ae && (s.stencilMask(bt), et = bt);
      },
      setFunc: function(bt, lt, Ot) {
        (at !== bt || Wt !== lt || ot !== Ot) && (s.stencilFunc(bt, lt, Ot), at = bt, Wt = lt, ot = Ot);
      },
      setOp: function(bt, lt, Ot) {
        (an !== bt || un !== lt || wt !== Ot) && (s.stencilOp(bt, lt, Ot), an = bt, un = lt, wt = Ot);
      },
      setLocked: function(bt) {
        ae = bt;
      },
      setClear: function(bt) {
        St !== bt && (s.clearStencil(bt), St = bt);
      },
      reset: function() {
        ae = !1, et = null, at = null, Wt = null, ot = null, an = null, un = null, wt = null, St = null;
      }
    };
  }
  const u = new i(), c = new r(), d = new o(), p = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap();
  let v = {}, y = {}, S = /* @__PURE__ */ new WeakMap(), T = [], E = null, M = !1, w = null, C = null, D = null, N = null, U = null, O = null, V = null, L = new Tt(0, 0, 0), I = 0, Y = !1, Q = null, fe = null, j = null, ie = null, re = null;
  const pe = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let J = !1, Z = 0;
  const H = s.getParameter(s.VERSION);
  H.indexOf("WebGL") !== -1 ? (Z = parseFloat(/^WebGL (\d)/.exec(H)[1]), J = Z >= 1) : H.indexOf("OpenGL ES") !== -1 && (Z = parseFloat(/^OpenGL ES (\d)/.exec(H)[1]), J = Z >= 2);
  let ue = null, Se = {};
  const me = s.getParameter(s.SCISSOR_BOX), ye = s.getParameter(s.VIEWPORT), Xe = new $n().fromArray(me), Je = new $n().fromArray(ye);
  function Ye(ae, et, at, Wt) {
    const ot = new Uint8Array(4), an = s.createTexture();
    s.bindTexture(ae, an), s.texParameteri(ae, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(ae, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let un = 0; un < at; un++)
      n && (ae === s.TEXTURE_3D || ae === s.TEXTURE_2D_ARRAY) ? s.texImage3D(et, 0, s.RGBA, 1, 1, Wt, 0, s.RGBA, s.UNSIGNED_BYTE, ot) : s.texImage2D(et + un, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, ot);
    return an;
  }
  const At = {};
  At[s.TEXTURE_2D] = Ye(s.TEXTURE_2D, s.TEXTURE_2D, 1), At[s.TEXTURE_CUBE_MAP] = Ye(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n && (At[s.TEXTURE_2D_ARRAY] = Ye(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), At[s.TEXTURE_3D] = Ye(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1)), u.setClear(0, 0, 0, 1), c.setClear(1), d.setClear(0), Ct(s.DEPTH_TEST), c.setFunc(gv), nt(!1), X(tT), Ct(s.CULL_FACE), be(du);
  function Ct(ae) {
    v[ae] !== !0 && (s.enable(ae), v[ae] = !0);
  }
  function pt(ae) {
    v[ae] !== !1 && (s.disable(ae), v[ae] = !1);
  }
  function mt(ae, et) {
    return y[ae] !== et ? (s.bindFramebuffer(ae, et), y[ae] = et, n && (ae === s.DRAW_FRAMEBUFFER && (y[s.FRAMEBUFFER] = et), ae === s.FRAMEBUFFER && (y[s.DRAW_FRAMEBUFFER] = et)), !0) : !1;
  }
  function ne(ae, et) {
    let at = T, Wt = !1;
    if (ae)
      if (at = S.get(et), at === void 0 && (at = [], S.set(et, at)), ae.isWebGLMultipleRenderTargets) {
        const ot = ae.texture;
        if (at.length !== ot.length || at[0] !== s.COLOR_ATTACHMENT0) {
          for (let an = 0, un = ot.length; an < un; an++)
            at[an] = s.COLOR_ATTACHMENT0 + an;
          at.length = ot.length, Wt = !0;
        }
      } else
        at[0] !== s.COLOR_ATTACHMENT0 && (at[0] = s.COLOR_ATTACHMENT0, Wt = !0);
    else
      at[0] !== s.BACK && (at[0] = s.BACK, Wt = !0);
    Wt && (t.isWebGL2 ? s.drawBuffers(at) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(at));
  }
  function we(ae) {
    return E !== ae ? (s.useProgram(ae), E = ae, !0) : !1;
  }
  const Ee = {
    [yc]: s.FUNC_ADD,
    [BL]: s.FUNC_SUBTRACT,
    [DL]: s.FUNC_REVERSE_SUBTRACT
  };
  if (n)
    Ee[sT] = s.MIN, Ee[aT] = s.MAX;
  else {
    const ae = e.get("EXT_blend_minmax");
    ae !== null && (Ee[sT] = ae.MIN_EXT, Ee[aT] = ae.MAX_EXT);
  }
  const He = {
    [LL]: s.ZERO,
    [PL]: s.ONE,
    [IL]: s.SRC_COLOR,
    [Mx]: s.SRC_ALPHA,
    [zL]: s.SRC_ALPHA_SATURATE,
    [OL]: s.DST_COLOR,
    [FL]: s.DST_ALPHA,
    [UL]: s.ONE_MINUS_SRC_COLOR,
    [Ex]: s.ONE_MINUS_SRC_ALPHA,
    [HL]: s.ONE_MINUS_DST_COLOR,
    [NL]: s.ONE_MINUS_DST_ALPHA,
    [GL]: s.CONSTANT_COLOR,
    [kL]: s.ONE_MINUS_CONSTANT_COLOR,
    [VL]: s.CONSTANT_ALPHA,
    [WL]: s.ONE_MINUS_CONSTANT_ALPHA
  };
  function be(ae, et, at, Wt, ot, an, un, wt, St, bt) {
    if (ae === du) {
      M === !0 && (pt(s.BLEND), M = !1);
      return;
    }
    if (M === !1 && (Ct(s.BLEND), M = !0), ae !== RL) {
      if (ae !== w || bt !== Y) {
        if ((C !== yc || U !== yc) && (s.blendEquation(s.FUNC_ADD), C = yc, U = yc), bt)
          switch (ae) {
            case td:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case nT:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case iT:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case rT:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ae);
              break;
          }
        else
          switch (ae) {
            case td:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case nT:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case iT:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case rT:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", ae);
              break;
          }
        D = null, N = null, O = null, V = null, L.set(0, 0, 0), I = 0, w = ae, Y = bt;
      }
      return;
    }
    ot = ot || et, an = an || at, un = un || Wt, (et !== C || ot !== U) && (s.blendEquationSeparate(Ee[et], Ee[ot]), C = et, U = ot), (at !== D || Wt !== N || an !== O || un !== V) && (s.blendFuncSeparate(He[at], He[Wt], He[an], He[un]), D = at, N = Wt, O = an, V = un), (wt.equals(L) === !1 || St !== I) && (s.blendColor(wt.r, wt.g, wt.b, St), L.copy(wt), I = St), w = ae, Y = !1;
  }
  function ce(ae, et) {
    ae.side === Ho ? pt(s.CULL_FACE) : Ct(s.CULL_FACE);
    let at = ae.side === zs;
    et && (at = !at), nt(at), ae.blending === td && ae.transparent === !1 ? be(du) : be(ae.blending, ae.blendEquation, ae.blendSrc, ae.blendDst, ae.blendEquationAlpha, ae.blendSrcAlpha, ae.blendDstAlpha, ae.blendColor, ae.blendAlpha, ae.premultipliedAlpha), c.setFunc(ae.depthFunc), c.setTest(ae.depthTest), c.setMask(ae.depthWrite), u.setMask(ae.colorWrite);
    const Wt = ae.stencilWrite;
    d.setTest(Wt), Wt && (d.setMask(ae.stencilWriteMask), d.setFunc(ae.stencilFunc, ae.stencilRef, ae.stencilFuncMask), d.setOp(ae.stencilFail, ae.stencilZFail, ae.stencilZPass)), le(ae.polygonOffset, ae.polygonOffsetFactor, ae.polygonOffsetUnits), ae.alphaToCoverage === !0 ? Ct(s.SAMPLE_ALPHA_TO_COVERAGE) : pt(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function nt(ae) {
    Q !== ae && (ae ? s.frontFace(s.CW) : s.frontFace(s.CCW), Q = ae);
  }
  function X(ae) {
    ae !== bL ? (Ct(s.CULL_FACE), ae !== fe && (ae === tT ? s.cullFace(s.BACK) : ae === CL ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : pt(s.CULL_FACE), fe = ae;
  }
  function G(ae) {
    ae !== j && (J && s.lineWidth(ae), j = ae);
  }
  function le(ae, et, at) {
    ae ? (Ct(s.POLYGON_OFFSET_FILL), (ie !== et || re !== at) && (s.polygonOffset(et, at), ie = et, re = at)) : pt(s.POLYGON_OFFSET_FILL);
  }
  function Ue(ae) {
    ae ? Ct(s.SCISSOR_TEST) : pt(s.SCISSOR_TEST);
  }
  function Ve(ae) {
    ae === void 0 && (ae = s.TEXTURE0 + pe - 1), ue !== ae && (s.activeTexture(ae), ue = ae);
  }
  function Oe(ae, et, at) {
    at === void 0 && (ue === null ? at = s.TEXTURE0 + pe - 1 : at = ue);
    let Wt = Se[at];
    Wt === void 0 && (Wt = { type: void 0, texture: void 0 }, Se[at] = Wt), (Wt.type !== ae || Wt.texture !== et) && (ue !== at && (s.activeTexture(at), ue = at), s.bindTexture(ae, et || At[ae]), Wt.type = ae, Wt.texture = et);
  }
  function ct() {
    const ae = Se[ue];
    ae !== void 0 && ae.type !== void 0 && (s.bindTexture(ae.type, null), ae.type = void 0, ae.texture = void 0);
  }
  function st() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function it() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function Lt() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function zt() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function ee() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function Re() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function De() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function Ie() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function Qe() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function rt() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (ae) {
      console.error("THREE.WebGLState:", ae);
    }
  }
  function Fe(ae) {
    Xe.equals(ae) === !1 && (s.scissor(ae.x, ae.y, ae.z, ae.w), Xe.copy(ae));
  }
  function Ke(ae) {
    Je.equals(ae) === !1 && (s.viewport(ae.x, ae.y, ae.z, ae.w), Je.copy(ae));
  }
  function Dt(ae, et) {
    let at = g.get(et);
    at === void 0 && (at = /* @__PURE__ */ new WeakMap(), g.set(et, at));
    let Wt = at.get(ae);
    Wt === void 0 && (Wt = s.getUniformBlockIndex(et, ae.name), at.set(ae, Wt));
  }
  function We(ae, et) {
    const Wt = g.get(et).get(ae);
    p.get(et) !== Wt && (s.uniformBlockBinding(et, Wt, ae.__bindingPointIndex), p.set(et, Wt));
  }
  function Pe() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), n === !0 && (s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null)), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), v = {}, ue = null, Se = {}, y = {}, S = /* @__PURE__ */ new WeakMap(), T = [], E = null, M = !1, w = null, C = null, D = null, N = null, U = null, O = null, V = null, L = new Tt(0, 0, 0), I = 0, Y = !1, Q = null, fe = null, j = null, ie = null, re = null, Xe.set(0, 0, s.canvas.width, s.canvas.height), Je.set(0, 0, s.canvas.width, s.canvas.height), u.reset(), c.reset(), d.reset();
  }
  return {
    buffers: {
      color: u,
      depth: c,
      stencil: d
    },
    enable: Ct,
    disable: pt,
    bindFramebuffer: mt,
    drawBuffers: ne,
    useProgram: we,
    setBlending: be,
    setMaterial: ce,
    setFlipSided: nt,
    setCullFace: X,
    setLineWidth: G,
    setPolygonOffset: le,
    setScissorTest: Ue,
    activeTexture: Ve,
    bindTexture: Oe,
    unbindTexture: ct,
    compressedTexImage2D: st,
    compressedTexImage3D: it,
    texImage2D: Qe,
    texImage3D: rt,
    updateUBOMapping: Dt,
    uniformBlockBinding: We,
    texStorage2D: De,
    texStorage3D: Ie,
    texSubImage2D: Lt,
    texSubImage3D: zt,
    compressedTexSubImage2D: ee,
    compressedTexSubImage3D: Re,
    scissor: Fe,
    viewport: Ke,
    reset: Pe
  };
}
function o4(s, e, t, n, i, r, o) {
  const u = i.isWebGL2, c = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, d = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), p = /* @__PURE__ */ new WeakMap();
  let g;
  const v = /* @__PURE__ */ new WeakMap();
  let y = !1;
  try {
    y = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function S(X, G) {
    return y ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(X, G)
    ) : Tv("canvas");
  }
  function T(X, G, le, Ue) {
    let Ve = 1;
    if ((X.width > Ue || X.height > Ue) && (Ve = Ue / Math.max(X.width, X.height)), Ve < 1 || G === !0)
      if (typeof HTMLImageElement < "u" && X instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && X instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && X instanceof ImageBitmap) {
        const Oe = G ? Cx : Math.floor, ct = Oe(Ve * X.width), st = Oe(Ve * X.height);
        g === void 0 && (g = S(ct, st));
        const it = le ? S(ct, st) : g;
        return it.width = ct, it.height = st, it.getContext("2d").drawImage(X, 0, 0, ct, st), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + X.width + "x" + X.height + ") to (" + ct + "x" + st + ")."), it;
      } else
        return "data" in X && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + X.width + "x" + X.height + ")."), X;
    return X;
  }
  function E(X) {
    return UT(X.width) && UT(X.height);
  }
  function M(X) {
    return u ? !1 : X.wrapS !== qr || X.wrapT !== qr || X.minFilter !== Oi && X.minFilter !== bi;
  }
  function w(X, G) {
    return X.generateMipmaps && G && X.minFilter !== Oi && X.minFilter !== bi;
  }
  function C(X) {
    s.generateMipmap(X);
  }
  function D(X, G, le, Ue, Ve = !1) {
    if (u === !1) return G;
    if (X !== null) {
      if (s[X] !== void 0) return s[X];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + X + "'");
    }
    let Oe = G;
    if (G === s.RED && (le === s.FLOAT && (Oe = s.R32F), le === s.HALF_FLOAT && (Oe = s.R16F), le === s.UNSIGNED_BYTE && (Oe = s.R8)), G === s.RED_INTEGER && (le === s.UNSIGNED_BYTE && (Oe = s.R8UI), le === s.UNSIGNED_SHORT && (Oe = s.R16UI), le === s.UNSIGNED_INT && (Oe = s.R32UI), le === s.BYTE && (Oe = s.R8I), le === s.SHORT && (Oe = s.R16I), le === s.INT && (Oe = s.R32I)), G === s.RG && (le === s.FLOAT && (Oe = s.RG32F), le === s.HALF_FLOAT && (Oe = s.RG16F), le === s.UNSIGNED_BYTE && (Oe = s.RG8)), G === s.RGBA) {
      const ct = Ve ? Sv : Zn.getTransfer(Ue);
      le === s.FLOAT && (Oe = s.RGBA32F), le === s.HALF_FLOAT && (Oe = s.RGBA16F), le === s.UNSIGNED_BYTE && (Oe = ct === li ? s.SRGB8_ALPHA8 : s.RGBA8), le === s.UNSIGNED_SHORT_4_4_4_4 && (Oe = s.RGBA4), le === s.UNSIGNED_SHORT_5_5_5_1 && (Oe = s.RGB5_A1);
    }
    return (Oe === s.R16F || Oe === s.R32F || Oe === s.RG16F || Oe === s.RG32F || Oe === s.RGBA16F || Oe === s.RGBA32F) && e.get("EXT_color_buffer_float"), Oe;
  }
  function N(X, G, le) {
    return w(X, le) === !0 || X.isFramebufferTexture && X.minFilter !== Oi && X.minFilter !== bi ? Math.log2(Math.max(G.width, G.height)) + 1 : X.mipmaps !== void 0 && X.mipmaps.length > 0 ? X.mipmaps.length : X.isCompressedTexture && Array.isArray(X.image) ? G.mipmaps.length : 1;
  }
  function U(X) {
    return X === Oi || X === yv || X === Dp ? s.NEAREST : s.LINEAR;
  }
  function O(X) {
    const G = X.target;
    G.removeEventListener("dispose", O), L(G), G.isVideoTexture && p.delete(G);
  }
  function V(X) {
    const G = X.target;
    G.removeEventListener("dispose", V), Y(G);
  }
  function L(X) {
    const G = n.get(X);
    if (G.__webglInit === void 0) return;
    const le = X.source, Ue = v.get(le);
    if (Ue) {
      const Ve = Ue[G.__cacheKey];
      Ve.usedTimes--, Ve.usedTimes === 0 && I(X), Object.keys(Ue).length === 0 && v.delete(le);
    }
    n.remove(X);
  }
  function I(X) {
    const G = n.get(X);
    s.deleteTexture(G.__webglTexture);
    const le = X.source, Ue = v.get(le);
    delete Ue[G.__cacheKey], o.memory.textures--;
  }
  function Y(X) {
    const G = X.texture, le = n.get(X), Ue = n.get(G);
    if (Ue.__webglTexture !== void 0 && (s.deleteTexture(Ue.__webglTexture), o.memory.textures--), X.depthTexture && X.depthTexture.dispose(), X.isWebGLCubeRenderTarget)
      for (let Ve = 0; Ve < 6; Ve++) {
        if (Array.isArray(le.__webglFramebuffer[Ve]))
          for (let Oe = 0; Oe < le.__webglFramebuffer[Ve].length; Oe++) s.deleteFramebuffer(le.__webglFramebuffer[Ve][Oe]);
        else
          s.deleteFramebuffer(le.__webglFramebuffer[Ve]);
        le.__webglDepthbuffer && s.deleteRenderbuffer(le.__webglDepthbuffer[Ve]);
      }
    else {
      if (Array.isArray(le.__webglFramebuffer))
        for (let Ve = 0; Ve < le.__webglFramebuffer.length; Ve++) s.deleteFramebuffer(le.__webglFramebuffer[Ve]);
      else
        s.deleteFramebuffer(le.__webglFramebuffer);
      if (le.__webglDepthbuffer && s.deleteRenderbuffer(le.__webglDepthbuffer), le.__webglMultisampledFramebuffer && s.deleteFramebuffer(le.__webglMultisampledFramebuffer), le.__webglColorRenderbuffer)
        for (let Ve = 0; Ve < le.__webglColorRenderbuffer.length; Ve++)
          le.__webglColorRenderbuffer[Ve] && s.deleteRenderbuffer(le.__webglColorRenderbuffer[Ve]);
      le.__webglDepthRenderbuffer && s.deleteRenderbuffer(le.__webglDepthRenderbuffer);
    }
    if (X.isWebGLMultipleRenderTargets)
      for (let Ve = 0, Oe = G.length; Ve < Oe; Ve++) {
        const ct = n.get(G[Ve]);
        ct.__webglTexture && (s.deleteTexture(ct.__webglTexture), o.memory.textures--), n.remove(G[Ve]);
      }
    n.remove(G), n.remove(X);
  }
  let Q = 0;
  function fe() {
    Q = 0;
  }
  function j() {
    const X = Q;
    return X >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + X + " texture units while this GPU supports only " + i.maxTextures), Q += 1, X;
  }
  function ie(X) {
    const G = [];
    return G.push(X.wrapS), G.push(X.wrapT), G.push(X.wrapR || 0), G.push(X.magFilter), G.push(X.minFilter), G.push(X.anisotropy), G.push(X.internalFormat), G.push(X.format), G.push(X.type), G.push(X.generateMipmaps), G.push(X.premultiplyAlpha), G.push(X.flipY), G.push(X.unpackAlignment), G.push(X.colorSpace), G.join();
  }
  function re(X, G) {
    const le = n.get(X);
    if (X.isVideoTexture && ce(X), X.isRenderTargetTexture === !1 && X.version > 0 && le.__version !== X.version) {
      const Ue = X.image;
      if (Ue === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (Ue.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        Xe(le, X, G);
        return;
      }
    }
    t.bindTexture(s.TEXTURE_2D, le.__webglTexture, s.TEXTURE0 + G);
  }
  function pe(X, G) {
    const le = n.get(X);
    if (X.version > 0 && le.__version !== X.version) {
      Xe(le, X, G);
      return;
    }
    t.bindTexture(s.TEXTURE_2D_ARRAY, le.__webglTexture, s.TEXTURE0 + G);
  }
  function J(X, G) {
    const le = n.get(X);
    if (X.version > 0 && le.__version !== X.version) {
      Xe(le, X, G);
      return;
    }
    t.bindTexture(s.TEXTURE_3D, le.__webglTexture, s.TEXTURE0 + G);
  }
  function Z(X, G) {
    const le = n.get(X);
    if (X.version > 0 && le.__version !== X.version) {
      Je(le, X, G);
      return;
    }
    t.bindTexture(s.TEXTURE_CUBE_MAP, le.__webglTexture, s.TEXTURE0 + G);
  }
  const H = {
    [Ic]: s.REPEAT,
    [qr]: s.CLAMP_TO_EDGE,
    [Gp]: s.MIRRORED_REPEAT
  }, ue = {
    [Oi]: s.NEAREST,
    [yv]: s.NEAREST_MIPMAP_NEAREST,
    [Dp]: s.NEAREST_MIPMAP_LINEAR,
    [bi]: s.LINEAR,
    [Jx]: s.LINEAR_MIPMAP_NEAREST,
    [Tl]: s.LINEAR_MIPMAP_LINEAR
  }, Se = {
    [SP]: s.NEVER,
    [CP]: s.ALWAYS,
    [AP]: s.LESS,
    [Rb]: s.LEQUAL,
    [MP]: s.EQUAL,
    [bP]: s.GEQUAL,
    [EP]: s.GREATER,
    [TP]: s.NOTEQUAL
  };
  function me(X, G, le) {
    if (le ? (s.texParameteri(X, s.TEXTURE_WRAP_S, H[G.wrapS]), s.texParameteri(X, s.TEXTURE_WRAP_T, H[G.wrapT]), (X === s.TEXTURE_3D || X === s.TEXTURE_2D_ARRAY) && s.texParameteri(X, s.TEXTURE_WRAP_R, H[G.wrapR]), s.texParameteri(X, s.TEXTURE_MAG_FILTER, ue[G.magFilter]), s.texParameteri(X, s.TEXTURE_MIN_FILTER, ue[G.minFilter])) : (s.texParameteri(X, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(X, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), (X === s.TEXTURE_3D || X === s.TEXTURE_2D_ARRAY) && s.texParameteri(X, s.TEXTURE_WRAP_R, s.CLAMP_TO_EDGE), (G.wrapS !== qr || G.wrapT !== qr) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), s.texParameteri(X, s.TEXTURE_MAG_FILTER, U(G.magFilter)), s.texParameteri(X, s.TEXTURE_MIN_FILTER, U(G.minFilter)), G.minFilter !== Oi && G.minFilter !== bi && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), G.compareFunction && (s.texParameteri(X, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(X, s.TEXTURE_COMPARE_FUNC, Se[G.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      const Ue = e.get("EXT_texture_filter_anisotropic");
      if (G.magFilter === Oi || G.minFilter !== Dp && G.minFilter !== Tl || G.type === zo && e.has("OES_texture_float_linear") === !1 || u === !1 && G.type === kp && e.has("OES_texture_half_float_linear") === !1) return;
      (G.anisotropy > 1 || n.get(G).__currentAnisotropy) && (s.texParameterf(X, Ue.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(G.anisotropy, i.getMaxAnisotropy())), n.get(G).__currentAnisotropy = G.anisotropy);
    }
  }
  function ye(X, G) {
    let le = !1;
    X.__webglInit === void 0 && (X.__webglInit = !0, G.addEventListener("dispose", O));
    const Ue = G.source;
    let Ve = v.get(Ue);
    Ve === void 0 && (Ve = {}, v.set(Ue, Ve));
    const Oe = ie(G);
    if (Oe !== X.__cacheKey) {
      Ve[Oe] === void 0 && (Ve[Oe] = {
        texture: s.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, le = !0), Ve[Oe].usedTimes++;
      const ct = Ve[X.__cacheKey];
      ct !== void 0 && (Ve[X.__cacheKey].usedTimes--, ct.usedTimes === 0 && I(G)), X.__cacheKey = Oe, X.__webglTexture = Ve[Oe].texture;
    }
    return le;
  }
  function Xe(X, G, le) {
    let Ue = s.TEXTURE_2D;
    (G.isDataArrayTexture || G.isCompressedArrayTexture) && (Ue = s.TEXTURE_2D_ARRAY), G.isData3DTexture && (Ue = s.TEXTURE_3D);
    const Ve = ye(X, G), Oe = G.source;
    t.bindTexture(Ue, X.__webglTexture, s.TEXTURE0 + le);
    const ct = n.get(Oe);
    if (Oe.version !== ct.__version || Ve === !0) {
      t.activeTexture(s.TEXTURE0 + le);
      const st = Zn.getPrimaries(Zn.workingColorSpace), it = G.colorSpace === ba ? null : Zn.getPrimaries(G.colorSpace), Lt = G.colorSpace === ba || st === it ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, G.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, G.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Lt);
      const zt = M(G) && E(G.image) === !1;
      let ee = T(G.image, zt, !1, i.maxTextureSize);
      ee = nt(G, ee);
      const Re = E(ee) || u, De = r.convert(G.format, G.colorSpace);
      let Ie = r.convert(G.type), Qe = D(G.internalFormat, De, Ie, G.colorSpace, G.isVideoTexture);
      me(Ue, G, Re);
      let rt;
      const Fe = G.mipmaps, Ke = u && G.isVideoTexture !== !0 && Qe !== Tb, Dt = ct.__version === void 0 || Ve === !0, We = N(G, ee, Re);
      if (G.isDepthTexture)
        Qe = s.DEPTH_COMPONENT, u ? G.type === zo ? Qe = s.DEPTH_COMPONENT32F : G.type === lu ? Qe = s.DEPTH_COMPONENT24 : G.type === bc ? Qe = s.DEPTH24_STENCIL8 : Qe = s.DEPTH_COMPONENT16 : G.type === zo && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), G.format === Cc && Qe === s.DEPTH_COMPONENT && G.type !== Yx && G.type !== lu && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), G.type = lu, Ie = r.convert(G.type)), G.format === hd && Qe === s.DEPTH_COMPONENT && (Qe = s.DEPTH_STENCIL, G.type !== bc && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), G.type = bc, Ie = r.convert(G.type))), Dt && (Ke ? t.texStorage2D(s.TEXTURE_2D, 1, Qe, ee.width, ee.height) : t.texImage2D(s.TEXTURE_2D, 0, Qe, ee.width, ee.height, 0, De, Ie, null));
      else if (G.isDataTexture)
        if (Fe.length > 0 && Re) {
          Ke && Dt && t.texStorage2D(s.TEXTURE_2D, We, Qe, Fe[0].width, Fe[0].height);
          for (let Pe = 0, ae = Fe.length; Pe < ae; Pe++)
            rt = Fe[Pe], Ke ? t.texSubImage2D(s.TEXTURE_2D, Pe, 0, 0, rt.width, rt.height, De, Ie, rt.data) : t.texImage2D(s.TEXTURE_2D, Pe, Qe, rt.width, rt.height, 0, De, Ie, rt.data);
          G.generateMipmaps = !1;
        } else
          Ke ? (Dt && t.texStorage2D(s.TEXTURE_2D, We, Qe, ee.width, ee.height), t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, ee.width, ee.height, De, Ie, ee.data)) : t.texImage2D(s.TEXTURE_2D, 0, Qe, ee.width, ee.height, 0, De, Ie, ee.data);
      else if (G.isCompressedTexture)
        if (G.isCompressedArrayTexture) {
          Ke && Dt && t.texStorage3D(s.TEXTURE_2D_ARRAY, We, Qe, Fe[0].width, Fe[0].height, ee.depth);
          for (let Pe = 0, ae = Fe.length; Pe < ae; Pe++)
            rt = Fe[Pe], G.format !== Ns ? De !== null ? Ke ? t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, Pe, 0, 0, 0, rt.width, rt.height, ee.depth, De, rt.data, 0, 0) : t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, Pe, Qe, rt.width, rt.height, ee.depth, 0, rt.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ke ? t.texSubImage3D(s.TEXTURE_2D_ARRAY, Pe, 0, 0, 0, rt.width, rt.height, ee.depth, De, Ie, rt.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, Pe, Qe, rt.width, rt.height, ee.depth, 0, De, Ie, rt.data);
        } else {
          Ke && Dt && t.texStorage2D(s.TEXTURE_2D, We, Qe, Fe[0].width, Fe[0].height);
          for (let Pe = 0, ae = Fe.length; Pe < ae; Pe++)
            rt = Fe[Pe], G.format !== Ns ? De !== null ? Ke ? t.compressedTexSubImage2D(s.TEXTURE_2D, Pe, 0, 0, rt.width, rt.height, De, rt.data) : t.compressedTexImage2D(s.TEXTURE_2D, Pe, Qe, rt.width, rt.height, 0, rt.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ke ? t.texSubImage2D(s.TEXTURE_2D, Pe, 0, 0, rt.width, rt.height, De, Ie, rt.data) : t.texImage2D(s.TEXTURE_2D, Pe, Qe, rt.width, rt.height, 0, De, Ie, rt.data);
        }
      else if (G.isDataArrayTexture)
        Ke ? (Dt && t.texStorage3D(s.TEXTURE_2D_ARRAY, We, Qe, ee.width, ee.height, ee.depth), t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ee.width, ee.height, ee.depth, De, Ie, ee.data)) : t.texImage3D(s.TEXTURE_2D_ARRAY, 0, Qe, ee.width, ee.height, ee.depth, 0, De, Ie, ee.data);
      else if (G.isData3DTexture)
        Ke ? (Dt && t.texStorage3D(s.TEXTURE_3D, We, Qe, ee.width, ee.height, ee.depth), t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, ee.width, ee.height, ee.depth, De, Ie, ee.data)) : t.texImage3D(s.TEXTURE_3D, 0, Qe, ee.width, ee.height, ee.depth, 0, De, Ie, ee.data);
      else if (G.isFramebufferTexture) {
        if (Dt)
          if (Ke)
            t.texStorage2D(s.TEXTURE_2D, We, Qe, ee.width, ee.height);
          else {
            let Pe = ee.width, ae = ee.height;
            for (let et = 0; et < We; et++)
              t.texImage2D(s.TEXTURE_2D, et, Qe, Pe, ae, 0, De, Ie, null), Pe >>= 1, ae >>= 1;
          }
      } else if (Fe.length > 0 && Re) {
        Ke && Dt && t.texStorage2D(s.TEXTURE_2D, We, Qe, Fe[0].width, Fe[0].height);
        for (let Pe = 0, ae = Fe.length; Pe < ae; Pe++)
          rt = Fe[Pe], Ke ? t.texSubImage2D(s.TEXTURE_2D, Pe, 0, 0, De, Ie, rt) : t.texImage2D(s.TEXTURE_2D, Pe, Qe, De, Ie, rt);
        G.generateMipmaps = !1;
      } else
        Ke ? (Dt && t.texStorage2D(s.TEXTURE_2D, We, Qe, ee.width, ee.height), t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, De, Ie, ee)) : t.texImage2D(s.TEXTURE_2D, 0, Qe, De, Ie, ee);
      w(G, Re) && C(Ue), ct.__version = Oe.version, G.onUpdate && G.onUpdate(G);
    }
    X.__version = G.version;
  }
  function Je(X, G, le) {
    if (G.image.length !== 6) return;
    const Ue = ye(X, G), Ve = G.source;
    t.bindTexture(s.TEXTURE_CUBE_MAP, X.__webglTexture, s.TEXTURE0 + le);
    const Oe = n.get(Ve);
    if (Ve.version !== Oe.__version || Ue === !0) {
      t.activeTexture(s.TEXTURE0 + le);
      const ct = Zn.getPrimaries(Zn.workingColorSpace), st = G.colorSpace === ba ? null : Zn.getPrimaries(G.colorSpace), it = G.colorSpace === ba || ct === st ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, G.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, G.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, it);
      const Lt = G.isCompressedTexture || G.image[0].isCompressedTexture, zt = G.image[0] && G.image[0].isDataTexture, ee = [];
      for (let Pe = 0; Pe < 6; Pe++)
        !Lt && !zt ? ee[Pe] = T(G.image[Pe], !1, !0, i.maxCubemapSize) : ee[Pe] = zt ? G.image[Pe].image : G.image[Pe], ee[Pe] = nt(G, ee[Pe]);
      const Re = ee[0], De = E(Re) || u, Ie = r.convert(G.format, G.colorSpace), Qe = r.convert(G.type), rt = D(G.internalFormat, Ie, Qe, G.colorSpace), Fe = u && G.isVideoTexture !== !0, Ke = Oe.__version === void 0 || Ue === !0;
      let Dt = N(G, Re, De);
      me(s.TEXTURE_CUBE_MAP, G, De);
      let We;
      if (Lt) {
        Fe && Ke && t.texStorage2D(s.TEXTURE_CUBE_MAP, Dt, rt, Re.width, Re.height);
        for (let Pe = 0; Pe < 6; Pe++) {
          We = ee[Pe].mipmaps;
          for (let ae = 0; ae < We.length; ae++) {
            const et = We[ae];
            G.format !== Ns ? Ie !== null ? Fe ? t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, ae, 0, 0, et.width, et.height, Ie, et.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, ae, rt, et.width, et.height, 0, et.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Fe ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, ae, 0, 0, et.width, et.height, Ie, Qe, et.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, ae, rt, et.width, et.height, 0, Ie, Qe, et.data);
          }
        }
      } else {
        We = G.mipmaps, Fe && Ke && (We.length > 0 && Dt++, t.texStorage2D(s.TEXTURE_CUBE_MAP, Dt, rt, ee[0].width, ee[0].height));
        for (let Pe = 0; Pe < 6; Pe++)
          if (zt) {
            Fe ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, 0, 0, 0, ee[Pe].width, ee[Pe].height, Ie, Qe, ee[Pe].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, 0, rt, ee[Pe].width, ee[Pe].height, 0, Ie, Qe, ee[Pe].data);
            for (let ae = 0; ae < We.length; ae++) {
              const at = We[ae].image[Pe].image;
              Fe ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, ae + 1, 0, 0, at.width, at.height, Ie, Qe, at.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, ae + 1, rt, at.width, at.height, 0, Ie, Qe, at.data);
            }
          } else {
            Fe ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, 0, 0, 0, Ie, Qe, ee[Pe]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, 0, rt, Ie, Qe, ee[Pe]);
            for (let ae = 0; ae < We.length; ae++) {
              const et = We[ae];
              Fe ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, ae + 1, 0, 0, Ie, Qe, et.image[Pe]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, ae + 1, rt, Ie, Qe, et.image[Pe]);
            }
          }
      }
      w(G, De) && C(s.TEXTURE_CUBE_MAP), Oe.__version = Ve.version, G.onUpdate && G.onUpdate(G);
    }
    X.__version = G.version;
  }
  function Ye(X, G, le, Ue, Ve, Oe) {
    const ct = r.convert(le.format, le.colorSpace), st = r.convert(le.type), it = D(le.internalFormat, ct, st, le.colorSpace);
    if (!n.get(G).__hasExternalTextures) {
      const zt = Math.max(1, G.width >> Oe), ee = Math.max(1, G.height >> Oe);
      Ve === s.TEXTURE_3D || Ve === s.TEXTURE_2D_ARRAY ? t.texImage3D(Ve, Oe, it, zt, ee, G.depth, 0, ct, st, null) : t.texImage2D(Ve, Oe, it, zt, ee, 0, ct, st, null);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, X), be(G) ? c.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, Ue, Ve, n.get(le).__webglTexture, 0, He(G)) : (Ve === s.TEXTURE_2D || Ve >= s.TEXTURE_CUBE_MAP_POSITIVE_X && Ve <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, Ue, Ve, n.get(le).__webglTexture, Oe), t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function At(X, G, le) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, X), G.depthBuffer && !G.stencilBuffer) {
      let Ue = u === !0 ? s.DEPTH_COMPONENT24 : s.DEPTH_COMPONENT16;
      if (le || be(G)) {
        const Ve = G.depthTexture;
        Ve && Ve.isDepthTexture && (Ve.type === zo ? Ue = s.DEPTH_COMPONENT32F : Ve.type === lu && (Ue = s.DEPTH_COMPONENT24));
        const Oe = He(G);
        be(G) ? c.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Oe, Ue, G.width, G.height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, Oe, Ue, G.width, G.height);
      } else
        s.renderbufferStorage(s.RENDERBUFFER, Ue, G.width, G.height);
      s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, X);
    } else if (G.depthBuffer && G.stencilBuffer) {
      const Ue = He(G);
      le && be(G) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Ue, s.DEPTH24_STENCIL8, G.width, G.height) : be(G) ? c.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Ue, s.DEPTH24_STENCIL8, G.width, G.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, G.width, G.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, X);
    } else {
      const Ue = G.isWebGLMultipleRenderTargets === !0 ? G.texture : [G.texture];
      for (let Ve = 0; Ve < Ue.length; Ve++) {
        const Oe = Ue[Ve], ct = r.convert(Oe.format, Oe.colorSpace), st = r.convert(Oe.type), it = D(Oe.internalFormat, ct, st, Oe.colorSpace), Lt = He(G);
        le && be(G) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Lt, it, G.width, G.height) : be(G) ? c.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Lt, it, G.width, G.height) : s.renderbufferStorage(s.RENDERBUFFER, it, G.width, G.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function Ct(X, G) {
    if (G && G.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(s.FRAMEBUFFER, X), !(G.depthTexture && G.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(G.depthTexture).__webglTexture || G.depthTexture.image.width !== G.width || G.depthTexture.image.height !== G.height) && (G.depthTexture.image.width = G.width, G.depthTexture.image.height = G.height, G.depthTexture.needsUpdate = !0), re(G.depthTexture, 0);
    const Ue = n.get(G.depthTexture).__webglTexture, Ve = He(G);
    if (G.depthTexture.format === Cc)
      be(G) ? c.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, Ue, 0, Ve) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, Ue, 0);
    else if (G.depthTexture.format === hd)
      be(G) ? c.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, Ue, 0, Ve) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, Ue, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function pt(X) {
    const G = n.get(X), le = X.isWebGLCubeRenderTarget === !0;
    if (X.depthTexture && !G.__autoAllocateDepthBuffer) {
      if (le) throw new Error("target.depthTexture not supported in Cube render targets");
      Ct(G.__webglFramebuffer, X);
    } else if (le) {
      G.__webglDepthbuffer = [];
      for (let Ue = 0; Ue < 6; Ue++)
        t.bindFramebuffer(s.FRAMEBUFFER, G.__webglFramebuffer[Ue]), G.__webglDepthbuffer[Ue] = s.createRenderbuffer(), At(G.__webglDepthbuffer[Ue], X, !1);
    } else
      t.bindFramebuffer(s.FRAMEBUFFER, G.__webglFramebuffer), G.__webglDepthbuffer = s.createRenderbuffer(), At(G.__webglDepthbuffer, X, !1);
    t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function mt(X, G, le) {
    const Ue = n.get(X);
    G !== void 0 && Ye(Ue.__webglFramebuffer, X, X.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), le !== void 0 && pt(X);
  }
  function ne(X) {
    const G = X.texture, le = n.get(X), Ue = n.get(G);
    X.addEventListener("dispose", V), X.isWebGLMultipleRenderTargets !== !0 && (Ue.__webglTexture === void 0 && (Ue.__webglTexture = s.createTexture()), Ue.__version = G.version, o.memory.textures++);
    const Ve = X.isWebGLCubeRenderTarget === !0, Oe = X.isWebGLMultipleRenderTargets === !0, ct = E(X) || u;
    if (Ve) {
      le.__webglFramebuffer = [];
      for (let st = 0; st < 6; st++)
        if (u && G.mipmaps && G.mipmaps.length > 0) {
          le.__webglFramebuffer[st] = [];
          for (let it = 0; it < G.mipmaps.length; it++)
            le.__webglFramebuffer[st][it] = s.createFramebuffer();
        } else
          le.__webglFramebuffer[st] = s.createFramebuffer();
    } else {
      if (u && G.mipmaps && G.mipmaps.length > 0) {
        le.__webglFramebuffer = [];
        for (let st = 0; st < G.mipmaps.length; st++)
          le.__webglFramebuffer[st] = s.createFramebuffer();
      } else
        le.__webglFramebuffer = s.createFramebuffer();
      if (Oe)
        if (i.drawBuffers) {
          const st = X.texture;
          for (let it = 0, Lt = st.length; it < Lt; it++) {
            const zt = n.get(st[it]);
            zt.__webglTexture === void 0 && (zt.__webglTexture = s.createTexture(), o.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (u && X.samples > 0 && be(X) === !1) {
        const st = Oe ? G : [G];
        le.__webglMultisampledFramebuffer = s.createFramebuffer(), le.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, le.__webglMultisampledFramebuffer);
        for (let it = 0; it < st.length; it++) {
          const Lt = st[it];
          le.__webglColorRenderbuffer[it] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, le.__webglColorRenderbuffer[it]);
          const zt = r.convert(Lt.format, Lt.colorSpace), ee = r.convert(Lt.type), Re = D(Lt.internalFormat, zt, ee, Lt.colorSpace, X.isXRRenderTarget === !0), De = He(X);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, De, Re, X.width, X.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + it, s.RENDERBUFFER, le.__webglColorRenderbuffer[it]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), X.depthBuffer && (le.__webglDepthRenderbuffer = s.createRenderbuffer(), At(le.__webglDepthRenderbuffer, X, !0)), t.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (Ve) {
      t.bindTexture(s.TEXTURE_CUBE_MAP, Ue.__webglTexture), me(s.TEXTURE_CUBE_MAP, G, ct);
      for (let st = 0; st < 6; st++)
        if (u && G.mipmaps && G.mipmaps.length > 0)
          for (let it = 0; it < G.mipmaps.length; it++)
            Ye(le.__webglFramebuffer[st][it], X, G, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + st, it);
        else
          Ye(le.__webglFramebuffer[st], X, G, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + st, 0);
      w(G, ct) && C(s.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (Oe) {
      const st = X.texture;
      for (let it = 0, Lt = st.length; it < Lt; it++) {
        const zt = st[it], ee = n.get(zt);
        t.bindTexture(s.TEXTURE_2D, ee.__webglTexture), me(s.TEXTURE_2D, zt, ct), Ye(le.__webglFramebuffer, X, zt, s.COLOR_ATTACHMENT0 + it, s.TEXTURE_2D, 0), w(zt, ct) && C(s.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let st = s.TEXTURE_2D;
      if ((X.isWebGL3DRenderTarget || X.isWebGLArrayRenderTarget) && (u ? st = X.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(st, Ue.__webglTexture), me(st, G, ct), u && G.mipmaps && G.mipmaps.length > 0)
        for (let it = 0; it < G.mipmaps.length; it++)
          Ye(le.__webglFramebuffer[it], X, G, s.COLOR_ATTACHMENT0, st, it);
      else
        Ye(le.__webglFramebuffer, X, G, s.COLOR_ATTACHMENT0, st, 0);
      w(G, ct) && C(st), t.unbindTexture();
    }
    X.depthBuffer && pt(X);
  }
  function we(X) {
    const G = E(X) || u, le = X.isWebGLMultipleRenderTargets === !0 ? X.texture : [X.texture];
    for (let Ue = 0, Ve = le.length; Ue < Ve; Ue++) {
      const Oe = le[Ue];
      if (w(Oe, G)) {
        const ct = X.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D, st = n.get(Oe).__webglTexture;
        t.bindTexture(ct, st), C(ct), t.unbindTexture();
      }
    }
  }
  function Ee(X) {
    if (u && X.samples > 0 && be(X) === !1) {
      const G = X.isWebGLMultipleRenderTargets ? X.texture : [X.texture], le = X.width, Ue = X.height;
      let Ve = s.COLOR_BUFFER_BIT;
      const Oe = [], ct = X.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, st = n.get(X), it = X.isWebGLMultipleRenderTargets === !0;
      if (it)
        for (let Lt = 0; Lt < G.length; Lt++)
          t.bindFramebuffer(s.FRAMEBUFFER, st.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Lt, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, st.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Lt, s.TEXTURE_2D, null, 0);
      t.bindFramebuffer(s.READ_FRAMEBUFFER, st.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, st.__webglFramebuffer);
      for (let Lt = 0; Lt < G.length; Lt++) {
        Oe.push(s.COLOR_ATTACHMENT0 + Lt), X.depthBuffer && Oe.push(ct);
        const zt = st.__ignoreDepthValues !== void 0 ? st.__ignoreDepthValues : !1;
        if (zt === !1 && (X.depthBuffer && (Ve |= s.DEPTH_BUFFER_BIT), X.stencilBuffer && (Ve |= s.STENCIL_BUFFER_BIT)), it && s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, st.__webglColorRenderbuffer[Lt]), zt === !0 && (s.invalidateFramebuffer(s.READ_FRAMEBUFFER, [ct]), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [ct])), it) {
          const ee = n.get(G[Lt]).__webglTexture;
          s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, ee, 0);
        }
        s.blitFramebuffer(0, 0, le, Ue, 0, 0, le, Ue, Ve, s.NEAREST), d && s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Oe);
      }
      if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), it)
        for (let Lt = 0; Lt < G.length; Lt++) {
          t.bindFramebuffer(s.FRAMEBUFFER, st.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Lt, s.RENDERBUFFER, st.__webglColorRenderbuffer[Lt]);
          const zt = n.get(G[Lt]).__webglTexture;
          t.bindFramebuffer(s.FRAMEBUFFER, st.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Lt, s.TEXTURE_2D, zt, 0);
        }
      t.bindFramebuffer(s.DRAW_FRAMEBUFFER, st.__webglMultisampledFramebuffer);
    }
  }
  function He(X) {
    return Math.min(i.maxSamples, X.samples);
  }
  function be(X) {
    const G = n.get(X);
    return u && X.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && G.__useRenderToTexture !== !1;
  }
  function ce(X) {
    const G = o.render.frame;
    p.get(X) !== G && (p.set(X, G), X.update());
  }
  function nt(X, G) {
    const le = X.colorSpace, Ue = X.format, Ve = X.type;
    return X.isCompressedTexture === !0 || X.isVideoTexture === !0 || X.format === bx || le !== bl && le !== ba && (Zn.getTransfer(le) === li ? u === !1 ? e.has("EXT_sRGB") === !0 && Ue === Ns ? (X.format = bx, X.minFilter = bi, X.generateMipmaps = !1) : G = Db.sRGBToLinear(G) : (Ue !== Ns || Ve !== Sl) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", le)), G;
  }
  this.allocateTextureUnit = j, this.resetTextureUnits = fe, this.setTexture2D = re, this.setTexture2DArray = pe, this.setTexture3D = J, this.setTextureCube = Z, this.rebindTextures = mt, this.setupRenderTarget = ne, this.updateRenderTargetMipmap = we, this.updateMultisampleRenderTarget = Ee, this.setupDepthRenderbuffer = pt, this.setupFrameBufferTexture = Ye, this.useMultisampledRTT = be;
}
function kP(s, e, t) {
  const n = t.isWebGL2;
  function i(r, o = ba) {
    let u;
    const c = Zn.getTransfer(o);
    if (r === Sl) return s.UNSIGNED_BYTE;
    if (r === xb) return s.UNSIGNED_SHORT_4_4_4_4;
    if (r === Sb) return s.UNSIGNED_SHORT_5_5_5_1;
    if (r === aP) return s.BYTE;
    if (r === oP) return s.SHORT;
    if (r === Yx) return s.UNSIGNED_SHORT;
    if (r === yb) return s.INT;
    if (r === lu) return s.UNSIGNED_INT;
    if (r === zo) return s.FLOAT;
    if (r === kp)
      return n ? s.HALF_FLOAT : (u = e.get("OES_texture_half_float"), u !== null ? u.HALF_FLOAT_OES : null);
    if (r === lP) return s.ALPHA;
    if (r === Ns) return s.RGBA;
    if (r === uP) return s.LUMINANCE;
    if (r === cP) return s.LUMINANCE_ALPHA;
    if (r === Cc) return s.DEPTH_COMPONENT;
    if (r === hd) return s.DEPTH_STENCIL;
    if (r === bx)
      return u = e.get("EXT_sRGB"), u !== null ? u.SRGB_ALPHA_EXT : null;
    if (r === fP) return s.RED;
    if (r === Ab) return s.RED_INTEGER;
    if (r === dP) return s.RG;
    if (r === Mb) return s.RG_INTEGER;
    if (r === Eb) return s.RGBA_INTEGER;
    if (r === sx || r === ax || r === ox || r === lx)
      if (c === li)
        if (u = e.get("WEBGL_compressed_texture_s3tc_srgb"), u !== null) {
          if (r === sx) return u.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === ax) return u.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === ox) return u.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === lx) return u.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (u = e.get("WEBGL_compressed_texture_s3tc"), u !== null) {
        if (r === sx) return u.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === ax) return u.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === ox) return u.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === lx) return u.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (r === lT || r === uT || r === cT || r === fT)
      if (u = e.get("WEBGL_compressed_texture_pvrtc"), u !== null) {
        if (r === lT) return u.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === uT) return u.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === cT) return u.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === fT) return u.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (r === Tb)
      return u = e.get("WEBGL_compressed_texture_etc1"), u !== null ? u.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (r === dT || r === hT)
      if (u = e.get("WEBGL_compressed_texture_etc"), u !== null) {
        if (r === dT) return c === li ? u.COMPRESSED_SRGB8_ETC2 : u.COMPRESSED_RGB8_ETC2;
        if (r === hT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : u.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (r === pT || r === mT || r === gT || r === vT || r === _T || r === yT || r === xT || r === ST || r === AT || r === MT || r === ET || r === TT || r === bT || r === CT)
      if (u = e.get("WEBGL_compressed_texture_astc"), u !== null) {
        if (r === pT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : u.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === mT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : u.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === gT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : u.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === vT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : u.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === _T) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : u.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === yT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : u.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === xT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : u.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === ST) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : u.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === AT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : u.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === MT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : u.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === ET) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : u.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === TT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : u.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === bT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : u.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === CT) return c === li ? u.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : u.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (r === ux || r === wT || r === RT)
      if (u = e.get("EXT_texture_compression_bptc"), u !== null) {
        if (r === ux) return c === li ? u.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : u.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === wT) return u.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === RT) return u.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (r === hP || r === BT || r === DT || r === LT)
      if (u = e.get("EXT_texture_compression_rgtc"), u !== null) {
        if (r === ux) return u.COMPRESSED_RED_RGTC1_EXT;
        if (r === BT) return u.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === DT) return u.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === LT) return u.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return r === bc ? n ? s.UNSIGNED_INT_24_8 : (u = e.get("WEBGL_depth_texture"), u !== null ? u.UNSIGNED_INT_24_8_WEBGL : null) : s[r] !== void 0 ? s[r] : null;
  }
  return { convert: i };
}
class VP extends Ar {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class uu extends On {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const l4 = { type: "move" };
class aE {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new uu(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new uu(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new q(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new q()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new uu(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new q(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new q()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let i = null, r = null, o = null;
    const u = this._targetRay, c = this._grip, d = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (d && e.hand) {
        o = !0;
        for (const T of e.hand.values()) {
          const E = t.getJointPose(T, n), M = this._getHandJoint(d, T);
          E !== null && (M.matrix.fromArray(E.transform.matrix), M.matrix.decompose(M.position, M.rotation, M.scale), M.matrixWorldNeedsUpdate = !0, M.jointRadius = E.radius), M.visible = E !== null;
        }
        const p = d.joints["index-finger-tip"], g = d.joints["thumb-tip"], v = p.position.distanceTo(g.position), y = 0.02, S = 5e-3;
        d.inputState.pinching && v > y + S ? (d.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !d.inputState.pinching && v <= y - S && (d.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        c !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (c.matrix.fromArray(r.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(r.linearVelocity)) : c.hasLinearVelocity = !1, r.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(r.angularVelocity)) : c.hasAngularVelocity = !1));
      u !== null && (i = t.getPose(e.targetRaySpace, n), i === null && r !== null && (i = r), i !== null && (u.matrix.fromArray(i.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (u.hasLinearVelocity = !0, u.linearVelocity.copy(i.linearVelocity)) : u.hasLinearVelocity = !1, i.angularVelocity ? (u.hasAngularVelocity = !0, u.angularVelocity.copy(i.angularVelocity)) : u.hasAngularVelocity = !1, this.dispatchEvent(l4)));
    }
    return u !== null && (u.visible = i !== null), c !== null && (c.visible = r !== null), d !== null && (d.visible = o !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new uu();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class u4 extends yu {
  constructor(e, t) {
    super();
    const n = this;
    let i = null, r = 1, o = null, u = "local-floor", c = 1, d = null, p = null, g = null, v = null, y = null, S = null;
    const T = t.getContextAttributes();
    let E = null, M = null;
    const w = [], C = [], D = new qe();
    let N = null;
    const U = new Ar();
    U.layers.enable(1), U.viewport = new $n();
    const O = new Ar();
    O.layers.enable(2), O.viewport = new $n();
    const V = [U, O], L = new VP();
    L.layers.enable(1), L.layers.enable(2);
    let I = null, Y = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(me) {
      let ye = w[me];
      return ye === void 0 && (ye = new aE(), w[me] = ye), ye.getTargetRaySpace();
    }, this.getControllerGrip = function(me) {
      let ye = w[me];
      return ye === void 0 && (ye = new aE(), w[me] = ye), ye.getGripSpace();
    }, this.getHand = function(me) {
      let ye = w[me];
      return ye === void 0 && (ye = new aE(), w[me] = ye), ye.getHandSpace();
    };
    function Q(me) {
      const ye = C.indexOf(me.inputSource);
      if (ye === -1)
        return;
      const Xe = w[ye];
      Xe !== void 0 && (Xe.update(me.inputSource, me.frame, d || o), Xe.dispatchEvent({ type: me.type, data: me.inputSource }));
    }
    function fe() {
      i.removeEventListener("select", Q), i.removeEventListener("selectstart", Q), i.removeEventListener("selectend", Q), i.removeEventListener("squeeze", Q), i.removeEventListener("squeezestart", Q), i.removeEventListener("squeezeend", Q), i.removeEventListener("end", fe), i.removeEventListener("inputsourceschange", j);
      for (let me = 0; me < w.length; me++) {
        const ye = C[me];
        ye !== null && (C[me] = null, w[me].disconnect(ye));
      }
      I = null, Y = null, e.setRenderTarget(E), y = null, v = null, g = null, i = null, M = null, Se.stop(), n.isPresenting = !1, e.setPixelRatio(N), e.setSize(D.width, D.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(me) {
      r = me, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(me) {
      u = me, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return d || o;
    }, this.setReferenceSpace = function(me) {
      d = me;
    }, this.getBaseLayer = function() {
      return v !== null ? v : y;
    }, this.getBinding = function() {
      return g;
    }, this.getFrame = function() {
      return S;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(me) {
      if (i = me, i !== null) {
        if (E = e.getRenderTarget(), i.addEventListener("select", Q), i.addEventListener("selectstart", Q), i.addEventListener("selectend", Q), i.addEventListener("squeeze", Q), i.addEventListener("squeezestart", Q), i.addEventListener("squeezeend", Q), i.addEventListener("end", fe), i.addEventListener("inputsourceschange", j), T.xrCompatible !== !0 && await t.makeXRCompatible(), N = e.getPixelRatio(), e.getSize(D), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const ye = {
            antialias: i.renderState.layers === void 0 ? T.antialias : !0,
            alpha: !0,
            depth: T.depth,
            stencil: T.stencil,
            framebufferScaleFactor: r
          };
          y = new XRWebGLLayer(i, t, ye), i.updateRenderState({ baseLayer: y }), e.setPixelRatio(1), e.setSize(y.framebufferWidth, y.framebufferHeight, !1), M = new ko(
            y.framebufferWidth,
            y.framebufferHeight,
            {
              format: Ns,
              type: Sl,
              colorSpace: e.outputColorSpace,
              stencilBuffer: T.stencil
            }
          );
        } else {
          let ye = null, Xe = null, Je = null;
          T.depth && (Je = T.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, ye = T.stencil ? hd : Cc, Xe = T.stencil ? bc : lu);
          const Ye = {
            colorFormat: t.RGBA8,
            depthFormat: Je,
            scaleFactor: r
          };
          g = new XRWebGLBinding(i, t), v = g.createProjectionLayer(Ye), i.updateRenderState({ layers: [v] }), e.setPixelRatio(1), e.setSize(v.textureWidth, v.textureHeight, !1), M = new ko(
            v.textureWidth,
            v.textureHeight,
            {
              format: Ns,
              type: Sl,
              depthTexture: new Fb(v.textureWidth, v.textureHeight, Xe, void 0, void 0, void 0, void 0, void 0, void 0, ye),
              stencilBuffer: T.stencil,
              colorSpace: e.outputColorSpace,
              samples: T.antialias ? 4 : 0
            }
          );
          const At = e.properties.get(M);
          At.__ignoreDepthValues = v.ignoreDepthValues;
        }
        M.isXRRenderTarget = !0, this.setFoveation(c), d = null, o = await i.requestReferenceSpace(u), Se.setContext(i), Se.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    };
    function j(me) {
      for (let ye = 0; ye < me.removed.length; ye++) {
        const Xe = me.removed[ye], Je = C.indexOf(Xe);
        Je >= 0 && (C[Je] = null, w[Je].disconnect(Xe));
      }
      for (let ye = 0; ye < me.added.length; ye++) {
        const Xe = me.added[ye];
        let Je = C.indexOf(Xe);
        if (Je === -1) {
          for (let At = 0; At < w.length; At++)
            if (At >= C.length) {
              C.push(Xe), Je = At;
              break;
            } else if (C[At] === null) {
              C[At] = Xe, Je = At;
              break;
            }
          if (Je === -1) break;
        }
        const Ye = w[Je];
        Ye && Ye.connect(Xe);
      }
    }
    const ie = new q(), re = new q();
    function pe(me, ye, Xe) {
      ie.setFromMatrixPosition(ye.matrixWorld), re.setFromMatrixPosition(Xe.matrixWorld);
      const Je = ie.distanceTo(re), Ye = ye.projectionMatrix.elements, At = Xe.projectionMatrix.elements, Ct = Ye[14] / (Ye[10] - 1), pt = Ye[14] / (Ye[10] + 1), mt = (Ye[9] + 1) / Ye[5], ne = (Ye[9] - 1) / Ye[5], we = (Ye[8] - 1) / Ye[0], Ee = (At[8] + 1) / At[0], He = Ct * we, be = Ct * Ee, ce = Je / (-we + Ee), nt = ce * -we;
      ye.matrixWorld.decompose(me.position, me.quaternion, me.scale), me.translateX(nt), me.translateZ(ce), me.matrixWorld.compose(me.position, me.quaternion, me.scale), me.matrixWorldInverse.copy(me.matrixWorld).invert();
      const X = Ct + ce, G = pt + ce, le = He - nt, Ue = be + (Je - nt), Ve = mt * pt / G * X, Oe = ne * pt / G * X;
      me.projectionMatrix.makePerspective(le, Ue, Ve, Oe, X, G), me.projectionMatrixInverse.copy(me.projectionMatrix).invert();
    }
    function J(me, ye) {
      ye === null ? me.matrixWorld.copy(me.matrix) : me.matrixWorld.multiplyMatrices(ye.matrixWorld, me.matrix), me.matrixWorldInverse.copy(me.matrixWorld).invert();
    }
    this.updateCamera = function(me) {
      if (i === null) return;
      L.near = O.near = U.near = me.near, L.far = O.far = U.far = me.far, (I !== L.near || Y !== L.far) && (i.updateRenderState({
        depthNear: L.near,
        depthFar: L.far
      }), I = L.near, Y = L.far);
      const ye = me.parent, Xe = L.cameras;
      J(L, ye);
      for (let Je = 0; Je < Xe.length; Je++)
        J(Xe[Je], ye);
      Xe.length === 2 ? pe(L, U, O) : L.projectionMatrix.copy(U.projectionMatrix), Z(me, L, ye);
    };
    function Z(me, ye, Xe) {
      Xe === null ? me.matrix.copy(ye.matrixWorld) : (me.matrix.copy(Xe.matrixWorld), me.matrix.invert(), me.matrix.multiply(ye.matrixWorld)), me.matrix.decompose(me.position, me.quaternion, me.scale), me.updateMatrixWorld(!0), me.projectionMatrix.copy(ye.projectionMatrix), me.projectionMatrixInverse.copy(ye.projectionMatrixInverse), me.isPerspectiveCamera && (me.fov = Xp * 2 * Math.atan(1 / me.projectionMatrix.elements[5]), me.zoom = 1);
    }
    this.getCamera = function() {
      return L;
    }, this.getFoveation = function() {
      if (!(v === null && y === null))
        return c;
    }, this.setFoveation = function(me) {
      c = me, v !== null && (v.fixedFoveation = me), y !== null && y.fixedFoveation !== void 0 && (y.fixedFoveation = me);
    };
    let H = null;
    function ue(me, ye) {
      if (p = ye.getViewerPose(d || o), S = ye, p !== null) {
        const Xe = p.views;
        y !== null && (e.setRenderTargetFramebuffer(M, y.framebuffer), e.setRenderTarget(M));
        let Je = !1;
        Xe.length !== L.cameras.length && (L.cameras.length = 0, Je = !0);
        for (let Ye = 0; Ye < Xe.length; Ye++) {
          const At = Xe[Ye];
          let Ct = null;
          if (y !== null)
            Ct = y.getViewport(At);
          else {
            const mt = g.getViewSubImage(v, At);
            Ct = mt.viewport, Ye === 0 && (e.setRenderTargetTextures(
              M,
              mt.colorTexture,
              v.ignoreDepthValues ? void 0 : mt.depthStencilTexture
            ), e.setRenderTarget(M));
          }
          let pt = V[Ye];
          pt === void 0 && (pt = new Ar(), pt.layers.enable(Ye), pt.viewport = new $n(), V[Ye] = pt), pt.matrix.fromArray(At.transform.matrix), pt.matrix.decompose(pt.position, pt.quaternion, pt.scale), pt.projectionMatrix.fromArray(At.projectionMatrix), pt.projectionMatrixInverse.copy(pt.projectionMatrix).invert(), pt.viewport.set(Ct.x, Ct.y, Ct.width, Ct.height), Ye === 0 && (L.matrix.copy(pt.matrix), L.matrix.decompose(L.position, L.quaternion, L.scale)), Je === !0 && L.cameras.push(pt);
        }
      }
      for (let Xe = 0; Xe < w.length; Xe++) {
        const Je = C[Xe], Ye = w[Xe];
        Je !== null && Ye !== void 0 && Ye.update(Je, ye, d || o);
      }
      H && H(me, ye), ye.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: ye }), S = null;
    }
    const Se = new FP();
    Se.setAnimationLoop(ue), this.setAnimationLoop = function(me) {
      H = me;
    }, this.dispose = function() {
    };
  }
}
function c4(s, e) {
  function t(E, M) {
    E.matrixAutoUpdate === !0 && E.updateMatrix(), M.value.copy(E.matrix);
  }
  function n(E, M) {
    M.color.getRGB(E.fogColor.value, LP(s)), M.isFog ? (E.fogNear.value = M.near, E.fogFar.value = M.far) : M.isFogExp2 && (E.fogDensity.value = M.density);
  }
  function i(E, M, w, C, D) {
    M.isMeshBasicMaterial || M.isMeshLambertMaterial ? r(E, M) : M.isMeshToonMaterial ? (r(E, M), g(E, M)) : M.isMeshPhongMaterial ? (r(E, M), p(E, M)) : M.isMeshStandardMaterial ? (r(E, M), v(E, M), M.isMeshPhysicalMaterial && y(E, M, D)) : M.isMeshMatcapMaterial ? (r(E, M), S(E, M)) : M.isMeshDepthMaterial ? r(E, M) : M.isMeshDistanceMaterial ? (r(E, M), T(E, M)) : M.isMeshNormalMaterial ? r(E, M) : M.isLineBasicMaterial ? (o(E, M), M.isLineDashedMaterial && u(E, M)) : M.isPointsMaterial ? c(E, M, w, C) : M.isSpriteMaterial ? d(E, M) : M.isShadowMaterial ? (E.color.value.copy(M.color), E.opacity.value = M.opacity) : M.isShaderMaterial && (M.uniformsNeedUpdate = !1);
  }
  function r(E, M) {
    E.opacity.value = M.opacity, M.color && E.diffuse.value.copy(M.color), M.emissive && E.emissive.value.copy(M.emissive).multiplyScalar(M.emissiveIntensity), M.map && (E.map.value = M.map, t(M.map, E.mapTransform)), M.alphaMap && (E.alphaMap.value = M.alphaMap, t(M.alphaMap, E.alphaMapTransform)), M.bumpMap && (E.bumpMap.value = M.bumpMap, t(M.bumpMap, E.bumpMapTransform), E.bumpScale.value = M.bumpScale, M.side === zs && (E.bumpScale.value *= -1)), M.normalMap && (E.normalMap.value = M.normalMap, t(M.normalMap, E.normalMapTransform), E.normalScale.value.copy(M.normalScale), M.side === zs && E.normalScale.value.negate()), M.displacementMap && (E.displacementMap.value = M.displacementMap, t(M.displacementMap, E.displacementMapTransform), E.displacementScale.value = M.displacementScale, E.displacementBias.value = M.displacementBias), M.emissiveMap && (E.emissiveMap.value = M.emissiveMap, t(M.emissiveMap, E.emissiveMapTransform)), M.specularMap && (E.specularMap.value = M.specularMap, t(M.specularMap, E.specularMapTransform)), M.alphaTest > 0 && (E.alphaTest.value = M.alphaTest);
    const w = e.get(M).envMap;
    if (w && (E.envMap.value = w, E.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1, E.reflectivity.value = M.reflectivity, E.ior.value = M.ior, E.refractionRatio.value = M.refractionRatio), M.lightMap) {
      E.lightMap.value = M.lightMap;
      const C = s._useLegacyLights === !0 ? Math.PI : 1;
      E.lightMapIntensity.value = M.lightMapIntensity * C, t(M.lightMap, E.lightMapTransform);
    }
    M.aoMap && (E.aoMap.value = M.aoMap, E.aoMapIntensity.value = M.aoMapIntensity, t(M.aoMap, E.aoMapTransform));
  }
  function o(E, M) {
    E.diffuse.value.copy(M.color), E.opacity.value = M.opacity, M.map && (E.map.value = M.map, t(M.map, E.mapTransform));
  }
  function u(E, M) {
    E.dashSize.value = M.dashSize, E.totalSize.value = M.dashSize + M.gapSize, E.scale.value = M.scale;
  }
  function c(E, M, w, C) {
    E.diffuse.value.copy(M.color), E.opacity.value = M.opacity, E.size.value = M.size * w, E.scale.value = C * 0.5, M.map && (E.map.value = M.map, t(M.map, E.uvTransform)), M.alphaMap && (E.alphaMap.value = M.alphaMap, t(M.alphaMap, E.alphaMapTransform)), M.alphaTest > 0 && (E.alphaTest.value = M.alphaTest);
  }
  function d(E, M) {
    E.diffuse.value.copy(M.color), E.opacity.value = M.opacity, E.rotation.value = M.rotation, M.map && (E.map.value = M.map, t(M.map, E.mapTransform)), M.alphaMap && (E.alphaMap.value = M.alphaMap, t(M.alphaMap, E.alphaMapTransform)), M.alphaTest > 0 && (E.alphaTest.value = M.alphaTest);
  }
  function p(E, M) {
    E.specular.value.copy(M.specular), E.shininess.value = Math.max(M.shininess, 1e-4);
  }
  function g(E, M) {
    M.gradientMap && (E.gradientMap.value = M.gradientMap);
  }
  function v(E, M) {
    E.metalness.value = M.metalness, M.metalnessMap && (E.metalnessMap.value = M.metalnessMap, t(M.metalnessMap, E.metalnessMapTransform)), E.roughness.value = M.roughness, M.roughnessMap && (E.roughnessMap.value = M.roughnessMap, t(M.roughnessMap, E.roughnessMapTransform)), e.get(M).envMap && (E.envMapIntensity.value = M.envMapIntensity);
  }
  function y(E, M, w) {
    E.ior.value = M.ior, M.sheen > 0 && (E.sheenColor.value.copy(M.sheenColor).multiplyScalar(M.sheen), E.sheenRoughness.value = M.sheenRoughness, M.sheenColorMap && (E.sheenColorMap.value = M.sheenColorMap, t(M.sheenColorMap, E.sheenColorMapTransform)), M.sheenRoughnessMap && (E.sheenRoughnessMap.value = M.sheenRoughnessMap, t(M.sheenRoughnessMap, E.sheenRoughnessMapTransform))), M.clearcoat > 0 && (E.clearcoat.value = M.clearcoat, E.clearcoatRoughness.value = M.clearcoatRoughness, M.clearcoatMap && (E.clearcoatMap.value = M.clearcoatMap, t(M.clearcoatMap, E.clearcoatMapTransform)), M.clearcoatRoughnessMap && (E.clearcoatRoughnessMap.value = M.clearcoatRoughnessMap, t(M.clearcoatRoughnessMap, E.clearcoatRoughnessMapTransform)), M.clearcoatNormalMap && (E.clearcoatNormalMap.value = M.clearcoatNormalMap, t(M.clearcoatNormalMap, E.clearcoatNormalMapTransform), E.clearcoatNormalScale.value.copy(M.clearcoatNormalScale), M.side === zs && E.clearcoatNormalScale.value.negate())), M.iridescence > 0 && (E.iridescence.value = M.iridescence, E.iridescenceIOR.value = M.iridescenceIOR, E.iridescenceThicknessMinimum.value = M.iridescenceThicknessRange[0], E.iridescenceThicknessMaximum.value = M.iridescenceThicknessRange[1], M.iridescenceMap && (E.iridescenceMap.value = M.iridescenceMap, t(M.iridescenceMap, E.iridescenceMapTransform)), M.iridescenceThicknessMap && (E.iridescenceThicknessMap.value = M.iridescenceThicknessMap, t(M.iridescenceThicknessMap, E.iridescenceThicknessMapTransform))), M.transmission > 0 && (E.transmission.value = M.transmission, E.transmissionSamplerMap.value = w.texture, E.transmissionSamplerSize.value.set(w.width, w.height), M.transmissionMap && (E.transmissionMap.value = M.transmissionMap, t(M.transmissionMap, E.transmissionMapTransform)), E.thickness.value = M.thickness, M.thicknessMap && (E.thicknessMap.value = M.thicknessMap, t(M.thicknessMap, E.thicknessMapTransform)), E.attenuationDistance.value = M.attenuationDistance, E.attenuationColor.value.copy(M.attenuationColor)), M.anisotropy > 0 && (E.anisotropyVector.value.set(M.anisotropy * Math.cos(M.anisotropyRotation), M.anisotropy * Math.sin(M.anisotropyRotation)), M.anisotropyMap && (E.anisotropyMap.value = M.anisotropyMap, t(M.anisotropyMap, E.anisotropyMapTransform))), E.specularIntensity.value = M.specularIntensity, E.specularColor.value.copy(M.specularColor), M.specularColorMap && (E.specularColorMap.value = M.specularColorMap, t(M.specularColorMap, E.specularColorMapTransform)), M.specularIntensityMap && (E.specularIntensityMap.value = M.specularIntensityMap, t(M.specularIntensityMap, E.specularIntensityMapTransform));
  }
  function S(E, M) {
    M.matcap && (E.matcap.value = M.matcap);
  }
  function T(E, M) {
    const w = e.get(M).light;
    E.referencePosition.value.setFromMatrixPosition(w.matrixWorld), E.nearDistance.value = w.shadow.camera.near, E.farDistance.value = w.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: i
  };
}
function f4(s, e, t, n) {
  let i = {}, r = {}, o = [];
  const u = t.isWebGL2 ? s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function c(w, C) {
    const D = C.program;
    n.uniformBlockBinding(w, D);
  }
  function d(w, C) {
    let D = i[w.id];
    D === void 0 && (S(w), D = p(w), i[w.id] = D, w.addEventListener("dispose", E));
    const N = C.program;
    n.updateUBOMapping(w, N);
    const U = e.render.frame;
    r[w.id] !== U && (v(w), r[w.id] = U);
  }
  function p(w) {
    const C = g();
    w.__bindingPointIndex = C;
    const D = s.createBuffer(), N = w.__size, U = w.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, D), s.bufferData(s.UNIFORM_BUFFER, N, U), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, C, D), D;
  }
  function g() {
    for (let w = 0; w < u; w++)
      if (o.indexOf(w) === -1)
        return o.push(w), w;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function v(w) {
    const C = i[w.id], D = w.uniforms, N = w.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, C);
    for (let U = 0, O = D.length; U < O; U++) {
      const V = Array.isArray(D[U]) ? D[U] : [D[U]];
      for (let L = 0, I = V.length; L < I; L++) {
        const Y = V[L];
        if (y(Y, U, L, N) === !0) {
          const Q = Y.__offset, fe = Array.isArray(Y.value) ? Y.value : [Y.value];
          let j = 0;
          for (let ie = 0; ie < fe.length; ie++) {
            const re = fe[ie], pe = T(re);
            typeof re == "number" || typeof re == "boolean" ? (Y.__data[0] = re, s.bufferSubData(s.UNIFORM_BUFFER, Q + j, Y.__data)) : re.isMatrix3 ? (Y.__data[0] = re.elements[0], Y.__data[1] = re.elements[1], Y.__data[2] = re.elements[2], Y.__data[3] = 0, Y.__data[4] = re.elements[3], Y.__data[5] = re.elements[4], Y.__data[6] = re.elements[5], Y.__data[7] = 0, Y.__data[8] = re.elements[6], Y.__data[9] = re.elements[7], Y.__data[10] = re.elements[8], Y.__data[11] = 0) : (re.toArray(Y.__data, j), j += pe.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          s.bufferSubData(s.UNIFORM_BUFFER, Q, Y.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function y(w, C, D, N) {
    const U = w.value, O = C + "_" + D;
    if (N[O] === void 0)
      return typeof U == "number" || typeof U == "boolean" ? N[O] = U : N[O] = U.clone(), !0;
    {
      const V = N[O];
      if (typeof U == "number" || typeof U == "boolean") {
        if (V !== U)
          return N[O] = U, !0;
      } else if (V.equals(U) === !1)
        return V.copy(U), !0;
    }
    return !1;
  }
  function S(w) {
    const C = w.uniforms;
    let D = 0;
    const N = 16;
    for (let O = 0, V = C.length; O < V; O++) {
      const L = Array.isArray(C[O]) ? C[O] : [C[O]];
      for (let I = 0, Y = L.length; I < Y; I++) {
        const Q = L[I], fe = Array.isArray(Q.value) ? Q.value : [Q.value];
        for (let j = 0, ie = fe.length; j < ie; j++) {
          const re = fe[j], pe = T(re), J = D % N;
          J !== 0 && N - J < pe.boundary && (D += N - J), Q.__data = new Float32Array(pe.storage / Float32Array.BYTES_PER_ELEMENT), Q.__offset = D, D += pe.storage;
        }
      }
    }
    const U = D % N;
    return U > 0 && (D += N - U), w.__size = D, w.__cache = {}, this;
  }
  function T(w) {
    const C = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof w == "number" || typeof w == "boolean" ? (C.boundary = 4, C.storage = 4) : w.isVector2 ? (C.boundary = 8, C.storage = 8) : w.isVector3 || w.isColor ? (C.boundary = 16, C.storage = 12) : w.isVector4 ? (C.boundary = 16, C.storage = 16) : w.isMatrix3 ? (C.boundary = 48, C.storage = 48) : w.isMatrix4 ? (C.boundary = 64, C.storage = 64) : w.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", w), C;
  }
  function E(w) {
    const C = w.target;
    C.removeEventListener("dispose", E);
    const D = o.indexOf(C.__bindingPointIndex);
    o.splice(D, 1), s.deleteBuffer(i[C.id]), delete i[C.id], delete r[C.id];
  }
  function M() {
    for (const w in i)
      s.deleteBuffer(i[w]);
    o = [], i = {}, r = {};
  }
  return {
    bind: c,
    update: d,
    dispose: M
  };
}
class Hb {
  constructor(e = {}) {
    const {
      canvas: t = RP(),
      context: n = null,
      depth: i = !0,
      stencil: r = !0,
      alpha: o = !1,
      antialias: u = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: d = !1,
      powerPreference: p = "default",
      failIfMajorPerformanceCaveat: g = !1
    } = e;
    this.isWebGLRenderer = !0;
    let v;
    n !== null ? v = n.getContextAttributes().alpha : v = o;
    const y = new Uint32Array(4), S = new Int32Array(4);
    let T = null, E = null;
    const M = [], w = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Sr, this._useLegacyLights = !1, this.toneMapping = xl, this.toneMappingExposure = 1;
    const C = this;
    let D = !1, N = 0, U = 0, O = null, V = -1, L = null;
    const I = new $n(), Y = new $n();
    let Q = null;
    const fe = new Tt(0);
    let j = 0, ie = t.width, re = t.height, pe = 1, J = null, Z = null;
    const H = new $n(0, 0, ie, re), ue = new $n(0, 0, ie, re);
    let Se = !1;
    const me = new Jv();
    let ye = !1, Xe = !1, Je = null;
    const Ye = new sn(), At = new qe(), Ct = new q(), pt = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function mt() {
      return O === null ? pe : 1;
    }
    let ne = n;
    function we(k, se) {
      for (let _e = 0; _e < k.length; _e++) {
        const ge = k[_e], he = t.getContext(ge, se);
        if (he !== null) return he;
      }
      return null;
    }
    try {
      const k = {
        alpha: !0,
        depth: i,
        stencil: r,
        antialias: u,
        premultipliedAlpha: c,
        preserveDrawingBuffer: d,
        powerPreference: p,
        failIfMajorPerformanceCaveat: g
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Gv}`), t.addEventListener("webglcontextlost", Pe, !1), t.addEventListener("webglcontextrestored", ae, !1), t.addEventListener("webglcontextcreationerror", et, !1), ne === null) {
        const se = ["webgl2", "webgl", "experimental-webgl"];
        if (C.isWebGL1Renderer === !0 && se.shift(), ne = we(se, k), ne === null)
          throw we(se) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && ne instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), ne.getShaderPrecisionFormat === void 0 && (ne.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (k) {
      throw console.error("THREE.WebGLRenderer: " + k.message), k;
    }
    let Ee, He, be, ce, nt, X, G, le, Ue, Ve, Oe, ct, st, it, Lt, zt, ee, Re, De, Ie, Qe, rt, Fe, Ke;
    function Dt() {
      Ee = new Tk(ne), He = new yk(ne, Ee, e), Ee.init(He), rt = new kP(ne, Ee, He), be = new a4(ne, Ee, He), ce = new wk(ne), nt = new KV(), X = new o4(ne, Ee, be, nt, He, rt, ce), G = new Sk(C), le = new Ek(C), Ue = new FH(ne, He), Fe = new vk(ne, Ee, Ue, He), Ve = new bk(ne, Ue, ce, Fe), Oe = new Lk(ne, Ve, Ue, ce), De = new Dk(ne, He, X), zt = new xk(nt), ct = new YV(C, G, le, Ee, He, Fe, zt), st = new c4(C, nt), it = new jV(), Lt = new n4(Ee, He), Re = new gk(C, G, le, be, Oe, v, c), ee = new s4(C, Oe, He), Ke = new f4(ne, ce, He, be), Ie = new _k(ne, Ee, ce, He), Qe = new Ck(ne, Ee, ce, He), ce.programs = ct.programs, C.capabilities = He, C.extensions = Ee, C.properties = nt, C.renderLists = it, C.shadowMap = ee, C.state = be, C.info = ce;
    }
    Dt();
    const We = new u4(C, ne);
    this.xr = We, this.getContext = function() {
      return ne;
    }, this.getContextAttributes = function() {
      return ne.getContextAttributes();
    }, this.forceContextLoss = function() {
      const k = Ee.get("WEBGL_lose_context");
      k && k.loseContext();
    }, this.forceContextRestore = function() {
      const k = Ee.get("WEBGL_lose_context");
      k && k.restoreContext();
    }, this.getPixelRatio = function() {
      return pe;
    }, this.setPixelRatio = function(k) {
      k !== void 0 && (pe = k, this.setSize(ie, re, !1));
    }, this.getSize = function(k) {
      return k.set(ie, re);
    }, this.setSize = function(k, se, _e = !0) {
      if (We.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      ie = k, re = se, t.width = Math.floor(k * pe), t.height = Math.floor(se * pe), _e === !0 && (t.style.width = k + "px", t.style.height = se + "px"), this.setViewport(0, 0, k, se);
    }, this.getDrawingBufferSize = function(k) {
      return k.set(ie * pe, re * pe).floor();
    }, this.setDrawingBufferSize = function(k, se, _e) {
      ie = k, re = se, pe = _e, t.width = Math.floor(k * _e), t.height = Math.floor(se * _e), this.setViewport(0, 0, k, se);
    }, this.getCurrentViewport = function(k) {
      return k.copy(I);
    }, this.getViewport = function(k) {
      return k.copy(H);
    }, this.setViewport = function(k, se, _e, ge) {
      k.isVector4 ? H.set(k.x, k.y, k.z, k.w) : H.set(k, se, _e, ge), be.viewport(I.copy(H).multiplyScalar(pe).floor());
    }, this.getScissor = function(k) {
      return k.copy(ue);
    }, this.setScissor = function(k, se, _e, ge) {
      k.isVector4 ? ue.set(k.x, k.y, k.z, k.w) : ue.set(k, se, _e, ge), be.scissor(Y.copy(ue).multiplyScalar(pe).floor());
    }, this.getScissorTest = function() {
      return Se;
    }, this.setScissorTest = function(k) {
      be.setScissorTest(Se = k);
    }, this.setOpaqueSort = function(k) {
      J = k;
    }, this.setTransparentSort = function(k) {
      Z = k;
    }, this.getClearColor = function(k) {
      return k.copy(Re.getClearColor());
    }, this.setClearColor = function() {
      Re.setClearColor.apply(Re, arguments);
    }, this.getClearAlpha = function() {
      return Re.getClearAlpha();
    }, this.setClearAlpha = function() {
      Re.setClearAlpha.apply(Re, arguments);
    }, this.clear = function(k = !0, se = !0, _e = !0) {
      let ge = 0;
      if (k) {
        let he = !1;
        if (O !== null) {
          const je = O.texture.format;
          he = je === Eb || je === Mb || je === Ab;
        }
        if (he) {
          const je = O.texture.type, Rt = je === Sl || je === lu || je === Yx || je === bc || je === xb || je === Sb, Ft = Re.getClearColor(), vt = Re.getClearAlpha(), It = Ft.r, Xt = Ft.g, $t = Ft.b;
          Rt ? (y[0] = It, y[1] = Xt, y[2] = $t, y[3] = vt, ne.clearBufferuiv(ne.COLOR, 0, y)) : (S[0] = It, S[1] = Xt, S[2] = $t, S[3] = vt, ne.clearBufferiv(ne.COLOR, 0, S));
        } else
          ge |= ne.COLOR_BUFFER_BIT;
      }
      se && (ge |= ne.DEPTH_BUFFER_BIT), _e && (ge |= ne.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), ne.clear(ge);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Pe, !1), t.removeEventListener("webglcontextrestored", ae, !1), t.removeEventListener("webglcontextcreationerror", et, !1), it.dispose(), Lt.dispose(), nt.dispose(), G.dispose(), le.dispose(), Oe.dispose(), Fe.dispose(), Ke.dispose(), ct.dispose(), We.dispose(), We.removeEventListener("sessionstart", St), We.removeEventListener("sessionend", bt), Je && (Je.dispose(), Je = null), lt.stop();
    };
    function Pe(k) {
      k.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), D = !0;
    }
    function ae() {
      console.log("THREE.WebGLRenderer: Context Restored."), D = !1;
      const k = ce.autoReset, se = ee.enabled, _e = ee.autoUpdate, ge = ee.needsUpdate, he = ee.type;
      Dt(), ce.autoReset = k, ee.enabled = se, ee.autoUpdate = _e, ee.needsUpdate = ge, ee.type = he;
    }
    function et(k) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", k.statusMessage);
    }
    function at(k) {
      const se = k.target;
      se.removeEventListener("dispose", at), Wt(se);
    }
    function Wt(k) {
      ot(k), nt.remove(k);
    }
    function ot(k) {
      const se = nt.get(k).programs;
      se !== void 0 && (se.forEach(function(_e) {
        ct.releaseProgram(_e);
      }), k.isShaderMaterial && ct.releaseShaderCache(k));
    }
    this.renderBufferDirect = function(k, se, _e, ge, he, je) {
      se === null && (se = pt);
      const Rt = he.isMesh && he.matrixWorld.determinant() < 0, Ft = gt(k, se, _e, ge, he);
      be.setMaterial(ge, Rt);
      let vt = _e.index, It = 1;
      if (ge.wireframe === !0) {
        if (vt = Ve.getWireframeAttribute(_e), vt === void 0) return;
        It = 2;
      }
      const Xt = _e.drawRange, $t = _e.attributes.position;
      let Kn = Xt.start * It, ai = (Xt.start + Xt.count) * It;
      je !== null && (Kn = Math.max(Kn, je.start * It), ai = Math.min(ai, (je.start + je.count) * It)), vt !== null ? (Kn = Math.max(Kn, 0), ai = Math.min(ai, vt.count)) : $t != null && (Kn = Math.max(Kn, 0), ai = Math.min(ai, $t.count));
      const bn = ai - Kn;
      if (bn < 0 || bn === 1 / 0) return;
      Fe.setup(he, ge, Ft, _e, vt);
      let ti, Qt = Ie;
      if (vt !== null && (ti = Ue.get(vt), Qt = Qe, Qt.setIndex(ti)), he.isMesh)
        ge.wireframe === !0 ? (be.setLineWidth(ge.wireframeLinewidth * mt()), Qt.setMode(ne.LINES)) : Qt.setMode(ne.TRIANGLES);
      else if (he.isLine) {
        let ht = ge.linewidth;
        ht === void 0 && (ht = 1), be.setLineWidth(ht * mt()), he.isLineSegments ? Qt.setMode(ne.LINES) : he.isLineLoop ? Qt.setMode(ne.LINE_LOOP) : Qt.setMode(ne.LINE_STRIP);
      } else he.isPoints ? Qt.setMode(ne.POINTS) : he.isSprite && Qt.setMode(ne.TRIANGLES);
      if (he.isBatchedMesh)
        Qt.renderMultiDraw(he._multiDrawStarts, he._multiDrawCounts, he._multiDrawCount);
      else if (he.isInstancedMesh)
        Qt.renderInstances(Kn, bn, he.count);
      else if (_e.isInstancedBufferGeometry) {
        const ht = _e._maxInstanceCount !== void 0 ? _e._maxInstanceCount : 1 / 0, $r = Math.min(_e.instanceCount, ht);
        Qt.renderInstances(Kn, bn, $r);
      } else
        Qt.render(Kn, bn);
    };
    function an(k, se, _e) {
      k.transparent === !0 && k.side === Ho && k.forceSinglePass === !1 ? (k.side = zs, k.needsUpdate = !0, te(k, se, _e), k.side = El, k.needsUpdate = !0, te(k, se, _e), k.side = Ho) : te(k, se, _e);
    }
    this.compile = function(k, se, _e = null) {
      _e === null && (_e = k), E = Lt.get(_e), E.init(), w.push(E), _e.traverseVisible(function(he) {
        he.isLight && he.layers.test(se.layers) && (E.pushLight(he), he.castShadow && E.pushShadow(he));
      }), k !== _e && k.traverseVisible(function(he) {
        he.isLight && he.layers.test(se.layers) && (E.pushLight(he), he.castShadow && E.pushShadow(he));
      }), E.setupLights(C._useLegacyLights);
      const ge = /* @__PURE__ */ new Set();
      return k.traverse(function(he) {
        const je = he.material;
        if (je)
          if (Array.isArray(je))
            for (let Rt = 0; Rt < je.length; Rt++) {
              const Ft = je[Rt];
              an(Ft, _e, he), ge.add(Ft);
            }
          else
            an(je, _e, he), ge.add(je);
      }), w.pop(), E = null, ge;
    }, this.compileAsync = function(k, se, _e = null) {
      const ge = this.compile(k, se, _e);
      return new Promise((he) => {
        function je() {
          if (ge.forEach(function(Rt) {
            nt.get(Rt).currentProgram.isReady() && ge.delete(Rt);
          }), ge.size === 0) {
            he(k);
            return;
          }
          setTimeout(je, 10);
        }
        Ee.get("KHR_parallel_shader_compile") !== null ? je() : setTimeout(je, 10);
      });
    };
    let un = null;
    function wt(k) {
      un && un(k);
    }
    function St() {
      lt.stop();
    }
    function bt() {
      lt.start();
    }
    const lt = new FP();
    lt.setAnimationLoop(wt), typeof self < "u" && lt.setContext(self), this.setAnimationLoop = function(k) {
      un = k, We.setAnimationLoop(k), k === null ? lt.stop() : lt.start();
    }, We.addEventListener("sessionstart", St), We.addEventListener("sessionend", bt), this.render = function(k, se) {
      if (se !== void 0 && se.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (D === !0) return;
      k.matrixWorldAutoUpdate === !0 && k.updateMatrixWorld(), se.parent === null && se.matrixWorldAutoUpdate === !0 && se.updateMatrixWorld(), We.enabled === !0 && We.isPresenting === !0 && (We.cameraAutoUpdate === !0 && We.updateCamera(se), se = We.getCamera()), k.isScene === !0 && k.onBeforeRender(C, k, se, O), E = Lt.get(k, w.length), E.init(), w.push(E), Ye.multiplyMatrices(se.projectionMatrix, se.matrixWorldInverse), me.setFromProjectionMatrix(Ye), Xe = this.localClippingEnabled, ye = zt.init(this.clippingPlanes, Xe), T = it.get(k, M.length), T.init(), M.push(T), Ot(k, se, 0, C.sortObjects), T.finish(), C.sortObjects === !0 && T.sort(J, Z), this.info.render.frame++, ye === !0 && zt.beginShadows();
      const _e = E.state.shadowsArray;
      if (ee.render(_e, k, se), ye === !0 && zt.endShadows(), this.info.autoReset === !0 && this.info.reset(), Re.render(T, k), E.setupLights(C._useLegacyLights), se.isArrayCamera) {
        const ge = se.cameras;
        for (let he = 0, je = ge.length; he < je; he++) {
          const Rt = ge[he];
          kt(T, k, Rt, Rt.viewport);
        }
      } else
        kt(T, k, se);
      O !== null && (X.updateMultisampleRenderTarget(O), X.updateRenderTargetMipmap(O)), k.isScene === !0 && k.onAfterRender(C, k, se), Fe.resetDefaultState(), V = -1, L = null, w.pop(), w.length > 0 ? E = w[w.length - 1] : E = null, M.pop(), M.length > 0 ? T = M[M.length - 1] : T = null;
    };
    function Ot(k, se, _e, ge) {
      if (k.visible === !1) return;
      if (k.layers.test(se.layers)) {
        if (k.isGroup)
          _e = k.renderOrder;
        else if (k.isLOD)
          k.autoUpdate === !0 && k.update(se);
        else if (k.isLight)
          E.pushLight(k), k.castShadow && E.pushShadow(k);
        else if (k.isSprite) {
          if (!k.frustumCulled || me.intersectsSprite(k)) {
            ge && Ct.setFromMatrixPosition(k.matrixWorld).applyMatrix4(Ye);
            const Rt = Oe.update(k), Ft = k.material;
            Ft.visible && T.push(k, Rt, Ft, _e, Ct.z, null);
          }
        } else if ((k.isMesh || k.isLine || k.isPoints) && (!k.frustumCulled || me.intersectsObject(k))) {
          const Rt = Oe.update(k), Ft = k.material;
          if (ge && (k.boundingSphere !== void 0 ? (k.boundingSphere === null && k.computeBoundingSphere(), Ct.copy(k.boundingSphere.center)) : (Rt.boundingSphere === null && Rt.computeBoundingSphere(), Ct.copy(Rt.boundingSphere.center)), Ct.applyMatrix4(k.matrixWorld).applyMatrix4(Ye)), Array.isArray(Ft)) {
            const vt = Rt.groups;
            for (let It = 0, Xt = vt.length; It < Xt; It++) {
              const $t = vt[It], Kn = Ft[$t.materialIndex];
              Kn && Kn.visible && T.push(k, Rt, Kn, _e, Ct.z, $t);
            }
          } else Ft.visible && T.push(k, Rt, Ft, _e, Ct.z, null);
        }
      }
      const je = k.children;
      for (let Rt = 0, Ft = je.length; Rt < Ft; Rt++)
        Ot(je[Rt], se, _e, ge);
    }
    function kt(k, se, _e, ge) {
      const he = k.opaque, je = k.transmissive, Rt = k.transparent;
      E.setupLightsView(_e), ye === !0 && zt.setGlobalState(C.clippingPlanes, _e), je.length > 0 && en(he, je, se, _e), ge && be.viewport(I.copy(ge)), he.length > 0 && Vn(he, se, _e), je.length > 0 && Vn(je, se, _e), Rt.length > 0 && Vn(Rt, se, _e), be.buffers.depth.setTest(!0), be.buffers.depth.setMask(!0), be.buffers.color.setMask(!0), be.setPolygonOffset(!1);
    }
    function en(k, se, _e, ge) {
      if ((_e.isScene === !0 ? _e.overrideMaterial : null) !== null)
        return;
      const je = He.isWebGL2;
      Je === null && (Je = new ko(1, 1, {
        generateMipmaps: !0,
        type: Ee.has("EXT_color_buffer_half_float") ? kp : Sl,
        minFilter: Tl,
        samples: je ? 4 : 0
      })), C.getDrawingBufferSize(At), je ? Je.setSize(At.x, At.y) : Je.setSize(Cx(At.x), Cx(At.y));
      const Rt = C.getRenderTarget();
      C.setRenderTarget(Je), C.getClearColor(fe), j = C.getClearAlpha(), j < 1 && C.setClearColor(16777215, 0.5), C.clear();
      const Ft = C.toneMapping;
      C.toneMapping = xl, Vn(k, _e, ge), X.updateMultisampleRenderTarget(Je), X.updateRenderTargetMipmap(Je);
      let vt = !1;
      for (let It = 0, Xt = se.length; It < Xt; It++) {
        const $t = se[It], Kn = $t.object, ai = $t.geometry, bn = $t.material, ti = $t.group;
        if (bn.side === Ho && Kn.layers.test(ge.layers)) {
          const Qt = bn.side;
          bn.side = zs, bn.needsUpdate = !0, Yt(Kn, _e, ge, ai, bn, ti), bn.side = Qt, bn.needsUpdate = !0, vt = !0;
        }
      }
      vt === !0 && (X.updateMultisampleRenderTarget(Je), X.updateRenderTargetMipmap(Je)), C.setRenderTarget(Rt), C.setClearColor(fe, j), C.toneMapping = Ft;
    }
    function Vn(k, se, _e) {
      const ge = se.isScene === !0 ? se.overrideMaterial : null;
      for (let he = 0, je = k.length; he < je; he++) {
        const Rt = k[he], Ft = Rt.object, vt = Rt.geometry, It = ge === null ? Rt.material : ge, Xt = Rt.group;
        Ft.layers.test(_e.layers) && Yt(Ft, se, _e, vt, It, Xt);
      }
    }
    function Yt(k, se, _e, ge, he, je) {
      k.onBeforeRender(C, se, _e, ge, he, je), k.modelViewMatrix.multiplyMatrices(_e.matrixWorldInverse, k.matrixWorld), k.normalMatrix.getNormalMatrix(k.modelViewMatrix), he.onBeforeRender(C, se, _e, ge, k, je), he.transparent === !0 && he.side === Ho && he.forceSinglePass === !1 ? (he.side = zs, he.needsUpdate = !0, C.renderBufferDirect(_e, se, ge, he, k, je), he.side = El, he.needsUpdate = !0, C.renderBufferDirect(_e, se, ge, he, k, je), he.side = Ho) : C.renderBufferDirect(_e, se, ge, he, k, je), k.onAfterRender(C, se, _e, ge, he, je);
    }
    function te(k, se, _e) {
      se.isScene !== !0 && (se = pt);
      const ge = nt.get(k), he = E.state.lights, je = E.state.shadowsArray, Rt = he.state.version, Ft = ct.getParameters(k, he.state, je, se, _e), vt = ct.getProgramCacheKey(Ft);
      let It = ge.programs;
      ge.environment = k.isMeshStandardMaterial ? se.environment : null, ge.fog = se.fog, ge.envMap = (k.isMeshStandardMaterial ? le : G).get(k.envMap || ge.environment), It === void 0 && (k.addEventListener("dispose", at), It = /* @__PURE__ */ new Map(), ge.programs = It);
      let Xt = It.get(vt);
      if (Xt !== void 0) {
        if (ge.currentProgram === Xt && ge.lightsStateVersion === Rt)
          return tt(k, Ft), Xt;
      } else
        Ft.uniforms = ct.getUniforms(k), k.onBuild(_e, Ft, C), k.onBeforeCompile(Ft, C), Xt = ct.acquireProgram(Ft, vt), It.set(vt, Xt), ge.uniforms = Ft.uniforms;
      const $t = ge.uniforms;
      return (!k.isShaderMaterial && !k.isRawShaderMaterial || k.clipping === !0) && ($t.clippingPlanes = zt.uniform), tt(k, Ft), ge.needsLights = tn(k), ge.lightsStateVersion = Rt, ge.needsLights && ($t.ambientLightColor.value = he.state.ambient, $t.lightProbe.value = he.state.probe, $t.directionalLights.value = he.state.directional, $t.directionalLightShadows.value = he.state.directionalShadow, $t.spotLights.value = he.state.spot, $t.spotLightShadows.value = he.state.spotShadow, $t.rectAreaLights.value = he.state.rectArea, $t.ltc_1.value = he.state.rectAreaLTC1, $t.ltc_2.value = he.state.rectAreaLTC2, $t.pointLights.value = he.state.point, $t.pointLightShadows.value = he.state.pointShadow, $t.hemisphereLights.value = he.state.hemi, $t.directionalShadowMap.value = he.state.directionalShadowMap, $t.directionalShadowMatrix.value = he.state.directionalShadowMatrix, $t.spotShadowMap.value = he.state.spotShadowMap, $t.spotLightMatrix.value = he.state.spotLightMatrix, $t.spotLightMap.value = he.state.spotLightMap, $t.pointShadowMap.value = he.state.pointShadowMap, $t.pointShadowMatrix.value = he.state.pointShadowMatrix), ge.currentProgram = Xt, ge.uniformsList = null, Xt;
    }
    function ze(k) {
      if (k.uniformsList === null) {
        const se = k.currentProgram.getUniforms();
        k.uniformsList = fx.seqWithValue(se.seq, k.uniforms);
      }
      return k.uniformsList;
    }
    function tt(k, se) {
      const _e = nt.get(k);
      _e.outputColorSpace = se.outputColorSpace, _e.batching = se.batching, _e.instancing = se.instancing, _e.instancingColor = se.instancingColor, _e.skinning = se.skinning, _e.morphTargets = se.morphTargets, _e.morphNormals = se.morphNormals, _e.morphColors = se.morphColors, _e.morphTargetsCount = se.morphTargetsCount, _e.numClippingPlanes = se.numClippingPlanes, _e.numIntersection = se.numClipIntersection, _e.vertexAlphas = se.vertexAlphas, _e.vertexTangents = se.vertexTangents, _e.toneMapping = se.toneMapping;
    }
    function gt(k, se, _e, ge, he) {
      se.isScene !== !0 && (se = pt), X.resetTextureUnits();
      const je = se.fog, Rt = ge.isMeshStandardMaterial ? se.environment : null, Ft = O === null ? C.outputColorSpace : O.isXRRenderTarget === !0 ? O.texture.colorSpace : bl, vt = (ge.isMeshStandardMaterial ? le : G).get(ge.envMap || Rt), It = ge.vertexColors === !0 && !!_e.attributes.color && _e.attributes.color.itemSize === 4, Xt = !!_e.attributes.tangent && (!!ge.normalMap || ge.anisotropy > 0), $t = !!_e.morphAttributes.position, Kn = !!_e.morphAttributes.normal, ai = !!_e.morphAttributes.color;
      let bn = xl;
      ge.toneMapped && (O === null || O.isXRRenderTarget === !0) && (bn = C.toneMapping);
      const ti = _e.morphAttributes.position || _e.morphAttributes.normal || _e.morphAttributes.color, Qt = ti !== void 0 ? ti.length : 0, ht = nt.get(ge), $r = E.state.lights;
      if (ye === !0 && (Xe === !0 || k !== L)) {
        const Gi = k === L && ge.id === V;
        zt.setState(ge, k, Gi);
      }
      let mn = !1;
      ge.version === ht.__version ? (ht.needsLights && ht.lightsStateVersion !== $r.state.version || ht.outputColorSpace !== Ft || he.isBatchedMesh && ht.batching === !1 || !he.isBatchedMesh && ht.batching === !0 || he.isInstancedMesh && ht.instancing === !1 || !he.isInstancedMesh && ht.instancing === !0 || he.isSkinnedMesh && ht.skinning === !1 || !he.isSkinnedMesh && ht.skinning === !0 || he.isInstancedMesh && ht.instancingColor === !0 && he.instanceColor === null || he.isInstancedMesh && ht.instancingColor === !1 && he.instanceColor !== null || ht.envMap !== vt || ge.fog === !0 && ht.fog !== je || ht.numClippingPlanes !== void 0 && (ht.numClippingPlanes !== zt.numPlanes || ht.numIntersection !== zt.numIntersection) || ht.vertexAlphas !== It || ht.vertexTangents !== Xt || ht.morphTargets !== $t || ht.morphNormals !== Kn || ht.morphColors !== ai || ht.toneMapping !== bn || He.isWebGL2 === !0 && ht.morphTargetsCount !== Qt) && (mn = !0) : (mn = !0, ht.__version = ge.version);
      let mi = ht.currentProgram;
      mn === !0 && (mi = te(ge, se, he));
      let Fa = !1, Gs = !1, $i = !1;
      const fi = mi.getUniforms(), ua = ht.uniforms;
      if (be.useProgram(mi.program) && (Fa = !0, Gs = !0, $i = !0), ge.id !== V && (V = ge.id, Gs = !0), Fa || L !== k) {
        fi.setValue(ne, "projectionMatrix", k.projectionMatrix), fi.setValue(ne, "viewMatrix", k.matrixWorldInverse);
        const Gi = fi.map.cameraPosition;
        Gi !== void 0 && Gi.setValue(ne, Ct.setFromMatrixPosition(k.matrixWorld)), He.logarithmicDepthBuffer && fi.setValue(
          ne,
          "logDepthBufFC",
          2 / (Math.log(k.far + 1) / Math.LN2)
        ), (ge.isMeshPhongMaterial || ge.isMeshToonMaterial || ge.isMeshLambertMaterial || ge.isMeshBasicMaterial || ge.isMeshStandardMaterial || ge.isShaderMaterial) && fi.setValue(ne, "isOrthographic", k.isOrthographicCamera === !0), L !== k && (L = k, Gs = !0, $i = !0);
      }
      if (he.isSkinnedMesh) {
        fi.setOptional(ne, he, "bindMatrix"), fi.setOptional(ne, he, "bindMatrixInverse");
        const Gi = he.skeleton;
        Gi && (He.floatVertexTextures ? (Gi.boneTexture === null && Gi.computeBoneTexture(), fi.setValue(ne, "boneTexture", Gi.boneTexture, X)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      he.isBatchedMesh && (fi.setOptional(ne, he, "batchingTexture"), fi.setValue(ne, "batchingTexture", he._matricesTexture, X));
      const Rl = _e.morphAttributes;
      if ((Rl.position !== void 0 || Rl.normal !== void 0 || Rl.color !== void 0 && He.isWebGL2 === !0) && De.update(he, _e, mi), (Gs || ht.receiveShadow !== he.receiveShadow) && (ht.receiveShadow = he.receiveShadow, fi.setValue(ne, "receiveShadow", he.receiveShadow)), ge.isMeshGouraudMaterial && ge.envMap !== null && (ua.envMap.value = vt, ua.flipEnvMap.value = vt.isCubeTexture && vt.isRenderTargetTexture === !1 ? -1 : 1), Gs && (fi.setValue(ne, "toneMappingExposure", C.toneMappingExposure), ht.needsLights && Ht(ua, $i), je && ge.fog === !0 && st.refreshFogUniforms(ua, je), st.refreshMaterialUniforms(ua, ge, pe, re, Je), fx.upload(ne, ze(ht), ua, X)), ge.isShaderMaterial && ge.uniformsNeedUpdate === !0 && (fx.upload(ne, ze(ht), ua, X), ge.uniformsNeedUpdate = !1), ge.isSpriteMaterial && fi.setValue(ne, "center", he.center), fi.setValue(ne, "modelViewMatrix", he.modelViewMatrix), fi.setValue(ne, "normalMatrix", he.normalMatrix), fi.setValue(ne, "modelMatrix", he.matrixWorld), ge.isShaderMaterial || ge.isRawShaderMaterial) {
        const Gi = ge.uniformsGroups;
        for (let Bl = 0, es = Gi.length; Bl < es; Bl++)
          if (He.isWebGL2) {
            const Cd = Gi[Bl];
            Ke.update(Cd, mi), Ke.bind(Cd, mi);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return mi;
    }
    function Ht(k, se) {
      k.ambientLightColor.needsUpdate = se, k.lightProbe.needsUpdate = se, k.directionalLights.needsUpdate = se, k.directionalLightShadows.needsUpdate = se, k.pointLights.needsUpdate = se, k.pointLightShadows.needsUpdate = se, k.spotLights.needsUpdate = se, k.spotLightShadows.needsUpdate = se, k.rectAreaLights.needsUpdate = se, k.hemisphereLights.needsUpdate = se;
    }
    function tn(k) {
      return k.isMeshLambertMaterial || k.isMeshToonMaterial || k.isMeshPhongMaterial || k.isMeshStandardMaterial || k.isShadowMaterial || k.isShaderMaterial && k.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return N;
    }, this.getActiveMipmapLevel = function() {
      return U;
    }, this.getRenderTarget = function() {
      return O;
    }, this.setRenderTargetTextures = function(k, se, _e) {
      nt.get(k.texture).__webglTexture = se, nt.get(k.depthTexture).__webglTexture = _e;
      const ge = nt.get(k);
      ge.__hasExternalTextures = !0, ge.__hasExternalTextures && (ge.__autoAllocateDepthBuffer = _e === void 0, ge.__autoAllocateDepthBuffer || Ee.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ge.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(k, se) {
      const _e = nt.get(k);
      _e.__webglFramebuffer = se, _e.__useDefaultFramebuffer = se === void 0;
    }, this.setRenderTarget = function(k, se = 0, _e = 0) {
      O = k, N = se, U = _e;
      let ge = !0, he = null, je = !1, Rt = !1;
      if (k) {
        const vt = nt.get(k);
        vt.__useDefaultFramebuffer !== void 0 ? (be.bindFramebuffer(ne.FRAMEBUFFER, null), ge = !1) : vt.__webglFramebuffer === void 0 ? X.setupRenderTarget(k) : vt.__hasExternalTextures && X.rebindTextures(k, nt.get(k.texture).__webglTexture, nt.get(k.depthTexture).__webglTexture);
        const It = k.texture;
        (It.isData3DTexture || It.isDataArrayTexture || It.isCompressedArrayTexture) && (Rt = !0);
        const Xt = nt.get(k).__webglFramebuffer;
        k.isWebGLCubeRenderTarget ? (Array.isArray(Xt[se]) ? he = Xt[se][_e] : he = Xt[se], je = !0) : He.isWebGL2 && k.samples > 0 && X.useMultisampledRTT(k) === !1 ? he = nt.get(k).__webglMultisampledFramebuffer : Array.isArray(Xt) ? he = Xt[_e] : he = Xt, I.copy(k.viewport), Y.copy(k.scissor), Q = k.scissorTest;
      } else
        I.copy(H).multiplyScalar(pe).floor(), Y.copy(ue).multiplyScalar(pe).floor(), Q = Se;
      if (be.bindFramebuffer(ne.FRAMEBUFFER, he) && He.drawBuffers && ge && be.drawBuffers(k, he), be.viewport(I), be.scissor(Y), be.setScissorTest(Q), je) {
        const vt = nt.get(k.texture);
        ne.framebufferTexture2D(ne.FRAMEBUFFER, ne.COLOR_ATTACHMENT0, ne.TEXTURE_CUBE_MAP_POSITIVE_X + se, vt.__webglTexture, _e);
      } else if (Rt) {
        const vt = nt.get(k.texture), It = se || 0;
        ne.framebufferTextureLayer(ne.FRAMEBUFFER, ne.COLOR_ATTACHMENT0, vt.__webglTexture, _e || 0, It);
      }
      V = -1;
    }, this.readRenderTargetPixels = function(k, se, _e, ge, he, je, Rt) {
      if (!(k && k.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Ft = nt.get(k).__webglFramebuffer;
      if (k.isWebGLCubeRenderTarget && Rt !== void 0 && (Ft = Ft[Rt]), Ft) {
        be.bindFramebuffer(ne.FRAMEBUFFER, Ft);
        try {
          const vt = k.texture, It = vt.format, Xt = vt.type;
          if (It !== Ns && rt.convert(It) !== ne.getParameter(ne.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const $t = Xt === kp && (Ee.has("EXT_color_buffer_half_float") || He.isWebGL2 && Ee.has("EXT_color_buffer_float"));
          if (Xt !== Sl && rt.convert(Xt) !== ne.getParameter(ne.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(Xt === zo && (He.isWebGL2 || Ee.has("OES_texture_float") || Ee.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !$t) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          se >= 0 && se <= k.width - ge && _e >= 0 && _e <= k.height - he && ne.readPixels(se, _e, ge, he, rt.convert(It), rt.convert(Xt), je);
        } finally {
          const vt = O !== null ? nt.get(O).__webglFramebuffer : null;
          be.bindFramebuffer(ne.FRAMEBUFFER, vt);
        }
      }
    }, this.copyFramebufferToTexture = function(k, se, _e = 0) {
      const ge = Math.pow(2, -_e), he = Math.floor(se.image.width * ge), je = Math.floor(se.image.height * ge);
      X.setTexture2D(se, 0), ne.copyTexSubImage2D(ne.TEXTURE_2D, _e, 0, 0, k.x, k.y, he, je), be.unbindTexture();
    }, this.copyTextureToTexture = function(k, se, _e, ge = 0) {
      const he = se.image.width, je = se.image.height, Rt = rt.convert(_e.format), Ft = rt.convert(_e.type);
      X.setTexture2D(_e, 0), ne.pixelStorei(ne.UNPACK_FLIP_Y_WEBGL, _e.flipY), ne.pixelStorei(ne.UNPACK_PREMULTIPLY_ALPHA_WEBGL, _e.premultiplyAlpha), ne.pixelStorei(ne.UNPACK_ALIGNMENT, _e.unpackAlignment), se.isDataTexture ? ne.texSubImage2D(ne.TEXTURE_2D, ge, k.x, k.y, he, je, Rt, Ft, se.image.data) : se.isCompressedTexture ? ne.compressedTexSubImage2D(ne.TEXTURE_2D, ge, k.x, k.y, se.mipmaps[0].width, se.mipmaps[0].height, Rt, se.mipmaps[0].data) : ne.texSubImage2D(ne.TEXTURE_2D, ge, k.x, k.y, Rt, Ft, se.image), ge === 0 && _e.generateMipmaps && ne.generateMipmap(ne.TEXTURE_2D), be.unbindTexture();
    }, this.copyTextureToTexture3D = function(k, se, _e, ge, he = 0) {
      if (C.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const je = k.max.x - k.min.x + 1, Rt = k.max.y - k.min.y + 1, Ft = k.max.z - k.min.z + 1, vt = rt.convert(ge.format), It = rt.convert(ge.type);
      let Xt;
      if (ge.isData3DTexture)
        X.setTexture3D(ge, 0), Xt = ne.TEXTURE_3D;
      else if (ge.isDataArrayTexture || ge.isCompressedArrayTexture)
        X.setTexture2DArray(ge, 0), Xt = ne.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      ne.pixelStorei(ne.UNPACK_FLIP_Y_WEBGL, ge.flipY), ne.pixelStorei(ne.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ge.premultiplyAlpha), ne.pixelStorei(ne.UNPACK_ALIGNMENT, ge.unpackAlignment);
      const $t = ne.getParameter(ne.UNPACK_ROW_LENGTH), Kn = ne.getParameter(ne.UNPACK_IMAGE_HEIGHT), ai = ne.getParameter(ne.UNPACK_SKIP_PIXELS), bn = ne.getParameter(ne.UNPACK_SKIP_ROWS), ti = ne.getParameter(ne.UNPACK_SKIP_IMAGES), Qt = _e.isCompressedTexture ? _e.mipmaps[he] : _e.image;
      ne.pixelStorei(ne.UNPACK_ROW_LENGTH, Qt.width), ne.pixelStorei(ne.UNPACK_IMAGE_HEIGHT, Qt.height), ne.pixelStorei(ne.UNPACK_SKIP_PIXELS, k.min.x), ne.pixelStorei(ne.UNPACK_SKIP_ROWS, k.min.y), ne.pixelStorei(ne.UNPACK_SKIP_IMAGES, k.min.z), _e.isDataTexture || _e.isData3DTexture ? ne.texSubImage3D(Xt, he, se.x, se.y, se.z, je, Rt, Ft, vt, It, Qt.data) : _e.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), ne.compressedTexSubImage3D(Xt, he, se.x, se.y, se.z, je, Rt, Ft, vt, Qt.data)) : ne.texSubImage3D(Xt, he, se.x, se.y, se.z, je, Rt, Ft, vt, It, Qt), ne.pixelStorei(ne.UNPACK_ROW_LENGTH, $t), ne.pixelStorei(ne.UNPACK_IMAGE_HEIGHT, Kn), ne.pixelStorei(ne.UNPACK_SKIP_PIXELS, ai), ne.pixelStorei(ne.UNPACK_SKIP_ROWS, bn), ne.pixelStorei(ne.UNPACK_SKIP_IMAGES, ti), he === 0 && ge.generateMipmaps && ne.generateMipmap(Xt), be.unbindTexture();
    }, this.initTexture = function(k) {
      k.isCubeTexture ? X.setTextureCube(k, 0) : k.isData3DTexture ? X.setTexture3D(k, 0) : k.isDataArrayTexture || k.isCompressedArrayTexture ? X.setTexture2DArray(k, 0) : X.setTexture2D(k, 0), be.unbindTexture();
    }, this.resetState = function() {
      N = 0, U = 0, O = null, be.reset(), Fe.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Go;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === qx ? "display-p3" : "srgb", t.unpackColorSpace = Zn.workingColorSpace === Vv ? "display-p3" : "srgb";
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === Sr ? wc : wb;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === wc ? Sr : bl;
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(e) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
  }
}
class WP extends Hb {
}
WP.prototype.isWebGL1Renderer = !0;
class Zx {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Tt(e), this.density = t;
  }
  clone() {
    return new Zx(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class $x {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Tt(e), this.near = t, this.far = n;
  }
  clone() {
    return new $x(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class zb extends On {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
}
class Kv {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Ev, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = Da();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let i = 0, r = this.stride; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Da()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Da()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Bs = /* @__PURE__ */ new q();
class Uc {
  constructor(e, t, n, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Bs.fromBufferAttribute(this, t), Bs.applyMatrix4(e), this.setXYZ(t, Bs.x, Bs.y, Bs.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Bs.fromBufferAttribute(this, t), Bs.applyNormalMatrix(e), this.setXYZ(t, Bs.x, Bs.y, Bs.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Bs.fromBufferAttribute(this, t), Bs.transformDirection(e), this.setXYZ(t, Bs.x, Bs.y, Bs.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = ia(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = ia(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = ia(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = ia(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = xn(t, this.array), n = xn(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array), r = xn(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[i + r]);
      }
      return new Hn(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Uc(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[i + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class Gb extends Mr {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Tt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let lp;
const Dg = /* @__PURE__ */ new q(), up = /* @__PURE__ */ new q(), cp = /* @__PURE__ */ new q(), fp = /* @__PURE__ */ new qe(), Lg = /* @__PURE__ */ new qe(), XP = /* @__PURE__ */ new sn(), p0 = /* @__PURE__ */ new q(), Pg = /* @__PURE__ */ new q(), m0 = /* @__PURE__ */ new q(), _B = /* @__PURE__ */ new qe(), oE = /* @__PURE__ */ new qe(), yB = /* @__PURE__ */ new qe();
class JP extends On {
  constructor(e = new Gb()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", lp === void 0) {
      lp = new pn();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new Kv(t, 5);
      lp.setIndex([0, 1, 2, 0, 2, 3]), lp.setAttribute("position", new Uc(n, 3, 0, !1)), lp.setAttribute("uv", new Uc(n, 2, 3, !1));
    }
    this.geometry = lp, this.material = e, this.center = new qe(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), up.setFromMatrixScale(this.matrixWorld), XP.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), cp.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && up.multiplyScalar(-cp.z);
    const n = this.material.rotation;
    let i, r;
    n !== 0 && (r = Math.cos(n), i = Math.sin(n));
    const o = this.center;
    g0(p0.set(-0.5, -0.5, 0), cp, o, up, i, r), g0(Pg.set(0.5, -0.5, 0), cp, o, up, i, r), g0(m0.set(0.5, 0.5, 0), cp, o, up, i, r), _B.set(0, 0), oE.set(1, 0), yB.set(1, 1);
    let u = e.ray.intersectTriangle(p0, Pg, m0, !1, Dg);
    if (u === null && (g0(Pg.set(-0.5, 0.5, 0), cp, o, up, i, r), oE.set(0, 1), u = e.ray.intersectTriangle(p0, m0, Pg, !1, Dg), u === null))
      return;
    const c = e.ray.origin.distanceTo(Dg);
    c < e.near || c > e.far || t.push({
      distance: c,
      point: Dg.clone(),
      uv: na.getInterpolation(Dg, p0, Pg, m0, _B, oE, yB, new qe()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function g0(s, e, t, n, i, r) {
  fp.subVectors(s, t).addScalar(0.5).multiply(n), i !== void 0 ? (Lg.x = r * fp.x - i * fp.y, Lg.y = i * fp.x + r * fp.y) : Lg.copy(fp), s.copy(e), s.x += Lg.x, s.y += Lg.y, s.applyMatrix4(XP);
}
const v0 = /* @__PURE__ */ new q(), xB = /* @__PURE__ */ new q();
class YP extends On {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      this.addLevel(r.object.clone(), r.distance, r.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let r;
    for (r = 0; r < i.length && !(t < i[r].distance); r++)
      ;
    return i.splice(r, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, i;
      for (n = 1, i = t.length; n < i; n++) {
        let r = t[n].distance;
        if (t[n].object.visible && (r -= r * t[n].hysteresis), e < r)
          break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      v0.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(v0);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      v0.setFromMatrixPosition(e.matrixWorld), xB.setFromMatrixPosition(this.matrixWorld);
      const n = v0.distanceTo(xB) / e.zoom;
      t[0].object.visible = !0;
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let o = t[i].distance;
        if (t[i].object.visible && (o -= o * t[i].hysteresis), n >= o)
          t[i - 1].object.visible = !1, t[i].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = i - 1; i < r; i++)
        t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let i = 0, r = n.length; i < r; i++) {
      const o = n[i];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis
      });
    }
    return t;
  }
}
const SB = /* @__PURE__ */ new q(), AB = /* @__PURE__ */ new $n(), MB = /* @__PURE__ */ new $n(), d4 = /* @__PURE__ */ new q(), EB = /* @__PURE__ */ new sn(), _0 = /* @__PURE__ */ new q(), lE = /* @__PURE__ */ new Qr(), TB = /* @__PURE__ */ new sn(), uE = /* @__PURE__ */ new im();
class kb extends ur {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = oT, this.bindMatrix = new sn(), this.bindMatrixInverse = new sn(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new xs()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, _0), this.boundingBox.expandByPoint(_0);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Qr()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, _0), this.boundingSphere.expandByPoint(_0);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, i = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), lE.copy(this.boundingSphere), lE.applyMatrix4(i), e.ray.intersectsSphere(lE) !== !1 && (TB.copy(i).invert(), uE.copy(e.ray).applyMatrix4(TB), !(this.boundingBox !== null && uE.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, uE)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new $n(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === oT ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === sP ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton, i = this.geometry;
    AB.fromBufferAttribute(i.attributes.skinIndex, e), MB.fromBufferAttribute(i.attributes.skinWeight, e), SB.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const o = MB.getComponent(r);
      if (o !== 0) {
        const u = AB.getComponent(r);
        EB.multiplyMatrices(n.bones[u].matrixWorld, n.boneInverses[u]), t.addScaledVector(d4.copy(SB).applyMatrix4(EB), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t);
  }
}
class eS extends On {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class rd extends Ri {
  constructor(e = null, t = 1, n = 1, i, r, o, u, c, d = Oi, p = Oi, g, v) {
    super(null, o, u, c, d, p, i, r, g, v), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const bB = /* @__PURE__ */ new sn(), h4 = /* @__PURE__ */ new sn();
class qv {
  constructor(e = [], t = []) {
    this.uuid = Da(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new sn());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new sn();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
    for (let r = 0, o = e.length; r < o; r++) {
      const u = e[r] ? e[r].matrixWorld : h4;
      bB.multiplyMatrices(u, t[r]), bB.toArray(n, r * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new qv(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new rd(t, e, e, Ns, zo);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const r = e.bones[n];
      let o = t[r];
      o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), o = new eS()), this.bones.push(o), this.boneInverses.push(new sn().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      e.bones.push(o.uuid);
      const u = n[i];
      e.boneInverses.push(u.toArray());
    }
    return e;
  }
}
class md extends Hn {
  constructor(e, t, n, i = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const dp = /* @__PURE__ */ new sn(), CB = /* @__PURE__ */ new sn(), y0 = [], wB = /* @__PURE__ */ new xs(), p4 = /* @__PURE__ */ new sn(), Ig = /* @__PURE__ */ new ur(), Ug = /* @__PURE__ */ new Qr();
class Vb extends ur {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new md(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < n; i++)
      this.setMatrixAt(i, p4);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new xs()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, dp), wB.copy(e.boundingBox).applyMatrix4(dp), this.boundingBox.union(wB);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Qr()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, dp), Ug.copy(e.boundingSphere).applyMatrix4(dp), this.boundingSphere.union(Ug);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld, i = this.count;
    if (Ig.geometry = this.geometry, Ig.material = this.material, Ig.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ug.copy(this.boundingSphere), Ug.applyMatrix4(n), e.ray.intersectsSphere(Ug) !== !1))
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, dp), CB.multiplyMatrices(n, dp), Ig.matrixWorld = CB, Ig.raycast(e, y0);
        for (let o = 0, u = y0.length; o < u; o++) {
          const c = y0[o];
          c.instanceId = r, c.object = this, t.push(c);
        }
        y0.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new md(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function m4(s, e) {
  return s.z - e.z;
}
function g4(s, e) {
  return e.z - s.z;
}
class v4 {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t) {
    const n = this.pool, i = this.list;
    this.index >= n.length && n.push({
      start: -1,
      count: -1,
      z: -1
    });
    const r = n[this.index];
    i.push(r), this.index++, r.start = e.start, r.count = e.count, r.z = t;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const hp = "batchId", dc = /* @__PURE__ */ new sn(), RB = /* @__PURE__ */ new sn(), _4 = /* @__PURE__ */ new sn(), BB = /* @__PURE__ */ new sn(), cE = /* @__PURE__ */ new Jv(), x0 = /* @__PURE__ */ new xs(), Lf = /* @__PURE__ */ new Qr(), Fg = /* @__PURE__ */ new q(), fE = /* @__PURE__ */ new v4(), ps = /* @__PURE__ */ new ur(), S0 = [];
function y4(s, e, t = 0) {
  const n = e.itemSize;
  if (s.isInterleavedBufferAttribute || s.array.constructor !== e.array.constructor) {
    const i = s.count;
    for (let r = 0; r < i; r++)
      for (let o = 0; o < n; o++)
        e.setComponent(r + t, o, s.getComponent(r, o));
  } else
    e.array.set(s.array, t * n);
  e.needsUpdate = !0;
}
class KP extends ur {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, n = t * 2, i) {
    super(new pn(), i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), n = new rd(t, e, e, Ns, zo);
    this._matricesTexture = n;
  }
  _initializeGeometry(e) {
    const t = this.geometry, n = this._maxVertexCount, i = this._maxGeometryCount, r = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const u in e.attributes) {
        const c = e.getAttribute(u), { array: d, itemSize: p, normalized: g } = c, v = new d.constructor(n * p), y = new c.constructor(v, p, g);
        y.setUsage(c.usage), t.setAttribute(u, y);
      }
      if (e.getIndex() !== null) {
        const u = n > 65536 ? new Uint32Array(r) : new Uint16Array(r);
        t.setIndex(new Hn(u, 1));
      }
      const o = i > 65536 ? new Uint32Array(n) : new Uint16Array(n);
      t.setAttribute(hp, new Hn(o, 1)), this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry atributes
  _validateGeometry(e) {
    if (e.getAttribute(hp))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${hp}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const n in t.attributes) {
      if (n === hp)
        continue;
      if (!e.hasAttribute(n))
        throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
      const i = e.getAttribute(n), r = t.getAttribute(n);
      if (i.itemSize !== r.itemSize || i.normalized !== r.normalized)
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new xs());
    const e = this._geometryCount, t = this.boundingBox, n = this._active;
    t.makeEmpty();
    for (let i = 0; i < e; i++)
      n[i] !== !1 && (this.getMatrixAt(i, dc), this.getBoundingBoxAt(i, x0).applyMatrix4(dc), t.union(x0));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Qr());
    const e = this._geometryCount, t = this.boundingSphere, n = this._active;
    t.makeEmpty();
    for (let i = 0; i < e; i++)
      n[i] !== !1 && (this.getMatrixAt(i, dc), this.getBoundingSphereAt(i, Lf).applyMatrix4(dc), t.union(Lf));
  }
  addGeometry(e, t = -1, n = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1
    };
    let r = null;
    const o = this._reservedRanges, u = this._drawRanges, c = this._bounds;
    this._geometryCount !== 0 && (r = o[o.length - 1]), t === -1 ? i.vertexCount = e.getAttribute("position").count : i.vertexCount = t, r === null ? i.vertexStart = 0 : i.vertexStart = r.vertexStart + r.vertexCount;
    const d = e.getIndex(), p = d !== null;
    if (p && (n === -1 ? i.indexCount = d.count : i.indexCount = n, r === null ? i.indexStart = 0 : i.indexStart = r.indexStart + r.indexCount), i.indexStart !== -1 && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount)
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const g = this._visibility, v = this._active, y = this._matricesTexture, S = this._matricesTexture.image.data;
    g.push(!0), v.push(!0);
    const T = this._geometryCount;
    this._geometryCount++, _4.toArray(S, T * 16), y.needsUpdate = !0, o.push(i), u.push({
      start: p ? i.indexStart : i.vertexStart,
      count: -1
    }), c.push({
      boxInitialized: !1,
      box: new xs(),
      sphereInitialized: !1,
      sphere: new Qr()
    });
    const E = this.geometry.getAttribute(hp);
    for (let M = 0; M < i.vertexCount; M++)
      E.setX(i.vertexStart + M, T);
    return E.needsUpdate = !0, this.setGeometryAt(T, e), T;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry, i = n.getIndex() !== null, r = n.getIndex(), o = t.getIndex(), u = this._reservedRanges[e];
    if (i && o.count > u.indexCount || t.attributes.position.count > u.vertexCount)
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const c = u.vertexStart, d = u.vertexCount;
    for (const y in n.attributes) {
      if (y === hp)
        continue;
      const S = t.getAttribute(y), T = n.getAttribute(y);
      y4(S, T, c);
      const E = S.itemSize;
      for (let M = S.count, w = d; M < w; M++) {
        const C = c + M;
        for (let D = 0; D < E; D++)
          T.setComponent(C, D, 0);
      }
      T.needsUpdate = !0;
    }
    if (i) {
      const y = u.indexStart;
      for (let S = 0; S < o.count; S++)
        r.setX(y + S, c + o.getX(S));
      for (let S = o.count, T = u.indexCount; S < T; S++)
        r.setX(y + S, c);
      r.needsUpdate = !0;
    }
    const p = this._bounds[e];
    t.boundingBox !== null ? (p.box.copy(t.boundingBox), p.boxInitialized = !0) : p.boxInitialized = !1, t.boundingSphere !== null ? (p.sphere.copy(t.boundingSphere), p.sphereInitialized = !0) : p.sphereInitialized = !1;
    const g = this._drawRanges[e], v = t.getAttribute("position");
    return g.count = i ? o.count : v.count, this._visibilityChanged = !0, e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === !1 ? this : (t[e] = !1, this._visibilityChanged = !0, this);
  }
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(e, t) {
    if (this._active[e] === !1)
      return this;
    const i = this._bounds[e], r = i.box, o = this.geometry;
    if (i.boxInitialized === !1) {
      r.makeEmpty();
      const u = o.index, c = o.attributes.position, d = this._drawRanges[e];
      for (let p = d.start, g = d.start + d.count; p < g; p++) {
        let v = p;
        u && (v = u.getX(v)), r.expandByPoint(Fg.fromBufferAttribute(c, v));
      }
      i.boxInitialized = !0;
    }
    return t.copy(r), t;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(e, t) {
    if (this._active[e] === !1)
      return this;
    const i = this._bounds[e], r = i.sphere, o = this.geometry;
    if (i.sphereInitialized === !1) {
      r.makeEmpty(), this.getBoundingBoxAt(e, x0), x0.getCenter(r.center);
      const u = o.index, c = o.attributes.position, d = this._drawRanges[e];
      let p = 0;
      for (let g = d.start, v = d.start + d.count; g < v; g++) {
        let y = g;
        u && (y = u.getX(y)), Fg.fromBufferAttribute(c, y), p = Math.max(p, r.center.distanceToSquared(Fg));
      }
      r.radius = Math.sqrt(p), i.sphereInitialized = !0;
    }
    return t.copy(r), t;
  }
  setMatrixAt(e, t) {
    const n = this._active, i = this._matricesTexture, r = this._matricesTexture.image.data, o = this._geometryCount;
    return e >= o || n[e] === !1 ? this : (t.toArray(r, e * 16), i.needsUpdate = !0, this);
  }
  getMatrixAt(e, t) {
    const n = this._active, i = this._matricesTexture.image.data, r = this._geometryCount;
    return e >= r || n[e] === !1 ? null : t.fromArray(i, e * 16);
  }
  setVisibleAt(e, t) {
    const n = this._visibility, i = this._active, r = this._geometryCount;
    return e >= r || i[e] === !1 || n[e] === t ? this : (n[e] = t, this._visibilityChanged = !0, this);
  }
  getVisibleAt(e) {
    const t = this._visibility, n = this._active, i = this._geometryCount;
    return e >= i || n[e] === !1 ? !1 : t[e];
  }
  raycast(e, t) {
    const n = this._visibility, i = this._active, r = this._drawRanges, o = this._geometryCount, u = this.matrixWorld, c = this.geometry;
    ps.material = this.material, ps.geometry.index = c.index, ps.geometry.attributes = c.attributes, ps.geometry.boundingBox === null && (ps.geometry.boundingBox = new xs()), ps.geometry.boundingSphere === null && (ps.geometry.boundingSphere = new Qr());
    for (let d = 0; d < o; d++) {
      if (!n[d] || !i[d])
        continue;
      const p = r[d];
      ps.geometry.setDrawRange(p.start, p.count), this.getMatrixAt(d, ps.matrixWorld).premultiply(u), this.getBoundingBoxAt(d, ps.geometry.boundingBox), this.getBoundingSphereAt(d, ps.geometry.boundingSphere), ps.raycast(e, S0);
      for (let g = 0, v = S0.length; g < v; g++) {
        const y = S0[g];
        y.object = this, y.batchId = d, t.push(y);
      }
      S0.length = 0;
    }
    ps.material = null, ps.geometry.index = null, ps.geometry.attributes = {}, ps.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((t) => ({
      boxInitialized: t.boxInitialized,
      box: t.box.clone(),
      sphereInitialized: t.sphereInitialized,
      sphere: t.sphere.clone()
    })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
  }
  onBeforeRender(e, t, n, i, r) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const o = i.getIndex(), u = o === null ? 1 : o.array.BYTES_PER_ELEMENT, c = this._visibility, d = this._multiDrawStarts, p = this._multiDrawCounts, g = this._drawRanges, v = this.perObjectFrustumCulled;
    v && (BB.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), cE.setFromProjectionMatrix(
      BB,
      e.isWebGPURenderer ? Wp : Go
    ));
    let y = 0;
    if (this.sortObjects) {
      RB.copy(this.matrixWorld).invert(), Fg.setFromMatrixPosition(n.matrixWorld).applyMatrix4(RB);
      for (let E = 0, M = c.length; E < M; E++)
        if (c[E]) {
          this.getMatrixAt(E, dc), this.getBoundingSphereAt(E, Lf).applyMatrix4(dc);
          let w = !1;
          if (v && (w = !cE.intersectsSphere(Lf)), !w) {
            const C = Fg.distanceTo(Lf.center);
            fE.push(g[E], C);
          }
        }
      const S = fE.list, T = this.customSort;
      T === null ? S.sort(r.transparent ? g4 : m4) : T.call(this, S, n);
      for (let E = 0, M = S.length; E < M; E++) {
        const w = S[E];
        d[y] = w.start * u, p[y] = w.count, y++;
      }
      fE.reset();
    } else
      for (let S = 0, T = c.length; S < T; S++)
        if (c[S]) {
          let E = !1;
          if (v && (this.getMatrixAt(S, dc), this.getBoundingSphereAt(S, Lf).applyMatrix4(dc), E = !cE.intersectsSphere(Lf)), !E) {
            const M = g[S];
            d[y] = M.start * u, p[y] = M.count, y++;
          }
        }
    this._multiDrawCount = y, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, n, i, r, o) {
    this.onBeforeRender(e, null, i, r, o);
  }
}
class As extends Mr {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Tt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const DB = /* @__PURE__ */ new q(), LB = /* @__PURE__ */ new q(), PB = /* @__PURE__ */ new sn(), dE = /* @__PURE__ */ new im(), A0 = /* @__PURE__ */ new Qr();
class gu extends On {
  constructor(e = new pn(), t = new As()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let i = 1, r = t.count; i < r; i++)
        DB.fromBufferAttribute(t, i - 1), LB.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += DB.distanceTo(LB);
      e.setAttribute("lineDistance", new Kt(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), A0.copy(n.boundingSphere), A0.applyMatrix4(i), A0.radius += r, e.ray.intersectsSphere(A0) === !1) return;
    PB.copy(i).invert(), dE.copy(e.ray).applyMatrix4(PB);
    const u = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = u * u, d = new q(), p = new q(), g = new q(), v = new q(), y = this.isLineSegments ? 2 : 1, S = n.index, E = n.attributes.position;
    if (S !== null) {
      const M = Math.max(0, o.start), w = Math.min(S.count, o.start + o.count);
      for (let C = M, D = w - 1; C < D; C += y) {
        const N = S.getX(C), U = S.getX(C + 1);
        if (d.fromBufferAttribute(E, N), p.fromBufferAttribute(E, U), dE.distanceSqToSegment(d, p, v, g) > c) continue;
        v.applyMatrix4(this.matrixWorld);
        const V = e.ray.origin.distanceTo(v);
        V < e.near || V > e.far || t.push({
          distance: V,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: g.clone().applyMatrix4(this.matrixWorld),
          index: C,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const M = Math.max(0, o.start), w = Math.min(E.count, o.start + o.count);
      for (let C = M, D = w - 1; C < D; C += y) {
        if (d.fromBufferAttribute(E, C), p.fromBufferAttribute(E, C + 1), dE.distanceSqToSegment(d, p, v, g) > c) continue;
        v.applyMatrix4(this.matrixWorld);
        const U = e.ray.origin.distanceTo(v);
        U < e.near || U > e.far || t.push({
          distance: U,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: g.clone().applyMatrix4(this.matrixWorld),
          index: C,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = i.length; r < o; r++) {
          const u = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = r;
        }
      }
    }
  }
}
const IB = /* @__PURE__ */ new q(), UB = /* @__PURE__ */ new q();
class Vo extends gu {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let i = 0, r = t.count; i < r; i += 2)
        IB.fromBufferAttribute(t, i), UB.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + IB.distanceTo(UB);
      e.setAttribute("lineDistance", new Kt(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class Wb extends gu {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class tS extends Mr {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Tt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const FB = /* @__PURE__ */ new sn(), OT = /* @__PURE__ */ new im(), M0 = /* @__PURE__ */ new Qr(), E0 = /* @__PURE__ */ new q();
class Xb extends On {
  constructor(e = new pn(), t = new tS()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), M0.copy(n.boundingSphere), M0.applyMatrix4(i), M0.radius += r, e.ray.intersectsSphere(M0) === !1) return;
    FB.copy(i).invert(), OT.copy(e.ray).applyMatrix4(FB);
    const u = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = u * u, d = n.index, g = n.attributes.position;
    if (d !== null) {
      const v = Math.max(0, o.start), y = Math.min(d.count, o.start + o.count);
      for (let S = v, T = y; S < T; S++) {
        const E = d.getX(S);
        E0.fromBufferAttribute(g, E), NB(E0, E, c, i, e, t, this);
      }
    } else {
      const v = Math.max(0, o.start), y = Math.min(g.count, o.start + o.count);
      for (let S = v, T = y; S < T; S++)
        E0.fromBufferAttribute(g, S), NB(E0, S, c, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = i.length; r < o; r++) {
          const u = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[u] = r;
        }
      }
    }
  }
}
function NB(s, e, t, n, i, r, o) {
  const u = OT.distanceSqToPoint(s);
  if (u < t) {
    const c = new q();
    OT.closestPointToPoint(s, c), c.applyMatrix4(n);
    const d = i.ray.origin.distanceTo(c);
    if (d < i.near || d > i.far) return;
    r.push({
      distance: d,
      distanceToRay: Math.sqrt(u),
      point: c,
      index: e,
      face: null,
      object: o
    });
  }
}
class x4 extends Ri {
  constructor(e, t, n, i, r, o, u, c, d) {
    super(e, t, n, i, r, o, u, c, d), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : bi, this.magFilter = r !== void 0 ? r : bi, this.generateMipmaps = !1;
    const p = this;
    function g() {
      p.needsUpdate = !0, e.requestVideoFrameCallback(g);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(g);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class S4 extends Ri {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = Oi, this.minFilter = Oi, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class nS extends Ri {
  constructor(e, t, n, i, r, o, u, c, d, p, g, v) {
    super(null, o, u, c, d, p, i, r, g, v), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class A4 extends nS {
  constructor(e, t, n, i, r, o) {
    super(e, t, n, r, o), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = qr;
  }
}
class M4 extends nS {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, mu), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class E4 extends Ri {
  constructor(e, t, n, i, r, o, u, c, d) {
    super(e, t, n, i, r, o, u, c, d), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Wo {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, i = this.getPoint(0), r = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      n = this.getPoint(o / e), r += n.distanceTo(i), t.push(r), i = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const r = n.length;
    let o;
    t ? o = t : o = e * n[r - 1];
    let u = 0, c = r - 1, d;
    for (; u <= c; )
      if (i = Math.floor(u + (c - u) / 2), d = n[i] - o, d < 0)
        u = i + 1;
      else if (d > 0)
        c = i - 1;
      else {
        c = i;
        break;
      }
    if (i = c, n[i] === o)
      return i / (r - 1);
    const p = n[i], v = n[i + 1] - p, y = (o - p) / v;
    return (i + y) / (r - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let i = e - 1e-4, r = e + 1e-4;
    i < 0 && (i = 0), r > 1 && (r = 1);
    const o = this.getPoint(i), u = this.getPoint(r), c = t || (o.isVector2 ? new qe() : new q());
    return c.copy(u).sub(o).normalize(), c;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new q(), i = [], r = [], o = [], u = new q(), c = new sn();
    for (let y = 0; y <= e; y++) {
      const S = y / e;
      i[y] = this.getTangentAt(S, new q());
    }
    r[0] = new q(), o[0] = new q();
    let d = Number.MAX_VALUE;
    const p = Math.abs(i[0].x), g = Math.abs(i[0].y), v = Math.abs(i[0].z);
    p <= d && (d = p, n.set(1, 0, 0)), g <= d && (d = g, n.set(0, 1, 0)), v <= d && n.set(0, 0, 1), u.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], u), o[0].crossVectors(i[0], r[0]);
    for (let y = 1; y <= e; y++) {
      if (r[y] = r[y - 1].clone(), o[y] = o[y - 1].clone(), u.crossVectors(i[y - 1], i[y]), u.length() > Number.EPSILON) {
        u.normalize();
        const S = Math.acos(Hi(i[y - 1].dot(i[y]), -1, 1));
        r[y].applyMatrix4(c.makeRotationAxis(u, S));
      }
      o[y].crossVectors(i[y], r[y]);
    }
    if (t === !0) {
      let y = Math.acos(Hi(r[0].dot(r[e]), -1, 1));
      y /= e, i[0].dot(u.crossVectors(r[0], r[e])) > 0 && (y = -y);
      for (let S = 1; S <= e; S++)
        r[S].applyMatrix4(c.makeRotationAxis(i[S], y * S)), o[S].crossVectors(i[S], r[S]);
    }
    return {
      tangents: i,
      normals: r,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class iS extends Wo {
  constructor(e = 0, t = 0, n = 1, i = 1, r = 0, o = Math.PI * 2, u = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = u, this.aRotation = c;
  }
  getPoint(e, t) {
    const n = t || new qe(), i = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += i;
    for (; r > i; ) r -= i;
    r < Number.EPSILON && (o ? r = 0 : r = i), this.aClockwise === !0 && !o && (r === i ? r = -i : r = r - i);
    const u = this.aStartAngle + e * r;
    let c = this.aX + this.xRadius * Math.cos(u), d = this.aY + this.yRadius * Math.sin(u);
    if (this.aRotation !== 0) {
      const p = Math.cos(this.aRotation), g = Math.sin(this.aRotation), v = c - this.aX, y = d - this.aY;
      c = v * p - y * g + this.aX, d = v * g + y * p + this.aY;
    }
    return n.set(c, d);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class qP extends iS {
  constructor(e, t, n, i, r, o) {
    super(e, t, n, n, i, r, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Jb() {
  let s = 0, e = 0, t = 0, n = 0;
  function i(r, o, u, c) {
    s = r, e = u, t = -3 * r + 3 * o - 2 * u - c, n = 2 * r - 2 * o + u + c;
  }
  return {
    initCatmullRom: function(r, o, u, c, d) {
      i(o, u, d * (u - r), d * (c - o));
    },
    initNonuniformCatmullRom: function(r, o, u, c, d, p, g) {
      let v = (o - r) / d - (u - r) / (d + p) + (u - o) / p, y = (u - o) / p - (c - o) / (p + g) + (c - u) / g;
      v *= p, y *= p, i(o, u, v, y);
    },
    calc: function(r) {
      const o = r * r, u = o * r;
      return s + e * r + t * o + n * u;
    }
  };
}
const T0 = /* @__PURE__ */ new q(), hE = /* @__PURE__ */ new Jb(), pE = /* @__PURE__ */ new Jb(), mE = /* @__PURE__ */ new Jb();
class jP extends Wo {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
  }
  getPoint(e, t = new q()) {
    const n = t, i = this.points, r = i.length, o = (r - (this.closed ? 0 : 1)) * e;
    let u = Math.floor(o), c = o - u;
    this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / r) + 1) * r : c === 0 && u === r - 1 && (u = r - 2, c = 1);
    let d, p;
    this.closed || u > 0 ? d = i[(u - 1) % r] : (T0.subVectors(i[0], i[1]).add(i[0]), d = T0);
    const g = i[u % r], v = i[(u + 1) % r];
    if (this.closed || u + 2 < r ? p = i[(u + 2) % r] : (T0.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), p = T0), this.curveType === "centripetal" || this.curveType === "chordal") {
      const y = this.curveType === "chordal" ? 0.5 : 0.25;
      let S = Math.pow(d.distanceToSquared(g), y), T = Math.pow(g.distanceToSquared(v), y), E = Math.pow(v.distanceToSquared(p), y);
      T < 1e-4 && (T = 1), S < 1e-4 && (S = T), E < 1e-4 && (E = T), hE.initNonuniformCatmullRom(d.x, g.x, v.x, p.x, S, T, E), pE.initNonuniformCatmullRom(d.y, g.y, v.y, p.y, S, T, E), mE.initNonuniformCatmullRom(d.z, g.z, v.z, p.z, S, T, E);
    } else this.curveType === "catmullrom" && (hE.initCatmullRom(d.x, g.x, v.x, p.x, this.tension), pE.initCatmullRom(d.y, g.y, v.y, p.y, this.tension), mE.initCatmullRom(d.z, g.z, v.z, p.z, this.tension));
    return n.set(
      hE.calc(c),
      pE.calc(c),
      mE.calc(c)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new q().fromArray(i));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function OB(s, e, t, n, i) {
  const r = (n - e) * 0.5, o = (i - t) * 0.5, u = s * s, c = s * u;
  return (2 * t - 2 * n + r + o) * c + (-3 * t + 3 * n - 2 * r - o) * u + r * s + t;
}
function T4(s, e) {
  const t = 1 - s;
  return t * t * e;
}
function b4(s, e) {
  return 2 * (1 - s) * s * e;
}
function C4(s, e) {
  return s * s * e;
}
function nv(s, e, t, n) {
  return T4(s, e) + b4(s, t) + C4(s, n);
}
function w4(s, e) {
  const t = 1 - s;
  return t * t * t * e;
}
function R4(s, e) {
  const t = 1 - s;
  return 3 * t * t * s * e;
}
function B4(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function D4(s, e) {
  return s * s * s * e;
}
function iv(s, e, t, n, i) {
  return w4(s, e) + R4(s, t) + B4(s, n) + D4(s, i);
}
class Yb extends Wo {
  constructor(e = new qe(), t = new qe(), n = new qe(), i = new qe()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new qe()) {
    const n = t, i = this.v0, r = this.v1, o = this.v2, u = this.v3;
    return n.set(
      iv(e, i.x, r.x, o.x, u.x),
      iv(e, i.y, r.y, o.y, u.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class QP extends Wo {
  constructor(e = new q(), t = new q(), n = new q(), i = new q()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new q()) {
    const n = t, i = this.v0, r = this.v1, o = this.v2, u = this.v3;
    return n.set(
      iv(e, i.x, r.x, o.x, u.x),
      iv(e, i.y, r.y, o.y, u.y),
      iv(e, i.z, r.z, o.z, u.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Kb extends Wo {
  constructor(e = new qe(), t = new qe()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new qe()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new qe()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class ZP extends Wo {
  constructor(e = new q(), t = new q()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new q()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new q()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class qb extends Wo {
  constructor(e = new qe(), t = new qe(), n = new qe()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new qe()) {
    const n = t, i = this.v0, r = this.v1, o = this.v2;
    return n.set(
      nv(e, i.x, r.x, o.x),
      nv(e, i.y, r.y, o.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class jb extends Wo {
  constructor(e = new q(), t = new q(), n = new q()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new q()) {
    const n = t, i = this.v0, r = this.v1, o = this.v2;
    return n.set(
      nv(e, i.x, r.x, o.x),
      nv(e, i.y, r.y, o.y),
      nv(e, i.z, r.z, o.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Qb extends Wo {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new qe()) {
    const n = t, i = this.points, r = (i.length - 1) * e, o = Math.floor(r), u = r - o, c = i[o === 0 ? o : o - 1], d = i[o], p = i[o > i.length - 2 ? i.length - 1 : o + 1], g = i[o > i.length - 3 ? i.length - 1 : o + 2];
    return n.set(
      OB(u, c.x, d.x, p.x, g.x),
      OB(u, c.y, d.y, p.y, g.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new qe().fromArray(i));
    }
    return this;
  }
}
var wx = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: qP,
  CatmullRomCurve3: jP,
  CubicBezierCurve: Yb,
  CubicBezierCurve3: QP,
  EllipseCurve: iS,
  LineCurve: Kb,
  LineCurve3: ZP,
  QuadraticBezierCurve: qb,
  QuadraticBezierCurve3: jb,
  SplineCurve: Qb
});
class $P extends Wo {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new wx[n](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const n = e * this.getLength(), i = this.getCurveLengths();
    let r = 0;
    for (; r < i.length; ) {
      if (i[r] >= n) {
        const o = i[r] - n, u = this.curves[r], c = u.getLength(), d = c === 0 ? 0 : 1 - o / c;
        return u.getPointAt(d, t);
      }
      r++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, r = this.curves; i < r.length; i++) {
      const o = r[i], u = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, c = o.getPoints(u);
      for (let d = 0; d < c.length; d++) {
        const p = c[d];
        n && n.equals(p) || (t.push(p), n = p);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new wx[i.type]().fromJSON(i));
    }
    return this;
  }
}
class bv extends $P {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new qe(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new Kb(this.currentPoint.clone(), new qe(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const r = new qb(
      this.currentPoint.clone(),
      new qe(e, t),
      new qe(n, i)
    );
    return this.curves.push(r), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, r, o) {
    const u = new Yb(
      this.currentPoint.clone(),
      new qe(e, t),
      new qe(n, i),
      new qe(r, o)
    );
    return this.curves.push(u), this.currentPoint.set(r, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new Qb(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, r, o) {
    const u = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      e + u,
      t + c,
      n,
      i,
      r,
      o
    ), this;
  }
  absarc(e, t, n, i, r, o) {
    return this.absellipse(e, t, n, n, i, r, o), this;
  }
  ellipse(e, t, n, i, r, o, u, c) {
    const d = this.currentPoint.x, p = this.currentPoint.y;
    return this.absellipse(e + d, t + p, n, i, r, o, u, c), this;
  }
  absellipse(e, t, n, i, r, o, u, c) {
    const d = new iS(e, t, n, i, r, o, u, c);
    if (this.curves.length > 0) {
      const g = d.getPoint(0);
      g.equals(this.currentPoint) || this.lineTo(g.x, g.y);
    }
    this.curves.push(d);
    const p = d.getPoint(1);
    return this.currentPoint.copy(p), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class jv extends pn {
  constructor(e = [new qe(0, -0.5), new qe(0.5, 0), new qe(0, 0.5)], t = 12, n = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: i
    }, t = Math.floor(t), i = Hi(i, 0, Math.PI * 2);
    const r = [], o = [], u = [], c = [], d = [], p = 1 / t, g = new q(), v = new qe(), y = new q(), S = new q(), T = new q();
    let E = 0, M = 0;
    for (let w = 0; w <= e.length - 1; w++)
      switch (w) {
        case 0:
          E = e[w + 1].x - e[w].x, M = e[w + 1].y - e[w].y, y.x = M * 1, y.y = -E, y.z = M * 0, T.copy(y), y.normalize(), c.push(y.x, y.y, y.z);
          break;
        case e.length - 1:
          c.push(T.x, T.y, T.z);
          break;
        default:
          E = e[w + 1].x - e[w].x, M = e[w + 1].y - e[w].y, y.x = M * 1, y.y = -E, y.z = M * 0, S.copy(y), y.x += T.x, y.y += T.y, y.z += T.z, y.normalize(), c.push(y.x, y.y, y.z), T.copy(S);
      }
    for (let w = 0; w <= t; w++) {
      const C = n + w * p * i, D = Math.sin(C), N = Math.cos(C);
      for (let U = 0; U <= e.length - 1; U++) {
        g.x = e[U].x * D, g.y = e[U].y, g.z = e[U].x * N, o.push(g.x, g.y, g.z), v.x = w / t, v.y = U / (e.length - 1), u.push(v.x, v.y);
        const O = c[3 * U + 0] * D, V = c[3 * U + 1], L = c[3 * U + 0] * N;
        d.push(O, V, L);
      }
    }
    for (let w = 0; w < t; w++)
      for (let C = 0; C < e.length - 1; C++) {
        const D = C + w * e.length, N = D, U = D + e.length, O = D + e.length + 1, V = D + 1;
        r.push(N, U, V), r.push(O, V, U);
      }
    this.setIndex(r), this.setAttribute("position", new Kt(o, 3)), this.setAttribute("uv", new Kt(u, 2)), this.setAttribute("normal", new Kt(d, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new jv(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class rS extends jv {
  constructor(e = 1, t = 1, n = 4, i = 8) {
    const r = new bv();
    r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(r.getPoints(n), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: n,
      radialSegments: i
    };
  }
  static fromJSON(e) {
    return new rS(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class sS extends pn {
  constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: i
    }, t = Math.max(3, t);
    const r = [], o = [], u = [], c = [], d = new q(), p = new qe();
    o.push(0, 0, 0), u.push(0, 0, 1), c.push(0.5, 0.5);
    for (let g = 0, v = 3; g <= t; g++, v += 3) {
      const y = n + g / t * i;
      d.x = e * Math.cos(y), d.y = e * Math.sin(y), o.push(d.x, d.y, d.z), u.push(0, 0, 1), p.x = (o[v] / e + 1) / 2, p.y = (o[v + 1] / e + 1) / 2, c.push(p.x, p.y);
    }
    for (let g = 1; g <= t; g++)
      r.push(g, g + 1, 0);
    this.setIndex(r), this.setAttribute("position", new Kt(o, 3)), this.setAttribute("normal", new Kt(u, 3)), this.setAttribute("uv", new Kt(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new sS(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class om extends pn {
  constructor(e = 1, t = 1, n = 1, i = 32, r = 1, o = !1, u = 0, c = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: i,
      heightSegments: r,
      openEnded: o,
      thetaStart: u,
      thetaLength: c
    };
    const d = this;
    i = Math.floor(i), r = Math.floor(r);
    const p = [], g = [], v = [], y = [];
    let S = 0;
    const T = [], E = n / 2;
    let M = 0;
    w(), o === !1 && (e > 0 && C(!0), t > 0 && C(!1)), this.setIndex(p), this.setAttribute("position", new Kt(g, 3)), this.setAttribute("normal", new Kt(v, 3)), this.setAttribute("uv", new Kt(y, 2));
    function w() {
      const D = new q(), N = new q();
      let U = 0;
      const O = (t - e) / n;
      for (let V = 0; V <= r; V++) {
        const L = [], I = V / r, Y = I * (t - e) + e;
        for (let Q = 0; Q <= i; Q++) {
          const fe = Q / i, j = fe * c + u, ie = Math.sin(j), re = Math.cos(j);
          N.x = Y * ie, N.y = -I * n + E, N.z = Y * re, g.push(N.x, N.y, N.z), D.set(ie, O, re).normalize(), v.push(D.x, D.y, D.z), y.push(fe, 1 - I), L.push(S++);
        }
        T.push(L);
      }
      for (let V = 0; V < i; V++)
        for (let L = 0; L < r; L++) {
          const I = T[L][V], Y = T[L + 1][V], Q = T[L + 1][V + 1], fe = T[L][V + 1];
          p.push(I, Y, fe), p.push(Y, Q, fe), U += 6;
        }
      d.addGroup(M, U, 0), M += U;
    }
    function C(D) {
      const N = S, U = new qe(), O = new q();
      let V = 0;
      const L = D === !0 ? e : t, I = D === !0 ? 1 : -1;
      for (let Q = 1; Q <= i; Q++)
        g.push(0, E * I, 0), v.push(0, I, 0), y.push(0.5, 0.5), S++;
      const Y = S;
      for (let Q = 0; Q <= i; Q++) {
        const j = Q / i * c + u, ie = Math.cos(j), re = Math.sin(j);
        O.x = L * re, O.y = E * I, O.z = L * ie, g.push(O.x, O.y, O.z), v.push(0, I, 0), U.x = ie * 0.5 + 0.5, U.y = re * 0.5 * I + 0.5, y.push(U.x, U.y), S++;
      }
      for (let Q = 0; Q < i; Q++) {
        const fe = N + Q, j = Y + Q;
        D === !0 ? p.push(j, j + 1, fe) : p.push(j + 1, j, fe), V += 3;
      }
      d.addGroup(M, V, D === !0 ? 1 : 2), M += V;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new om(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class aS extends om {
  constructor(e = 1, t = 1, n = 32, i = 1, r = !1, o = 0, u = Math.PI * 2) {
    super(0, e, t, n, i, r, o, u), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: n,
      heightSegments: i,
      openEnded: r,
      thetaStart: o,
      thetaLength: u
    };
  }
  static fromJSON(e) {
    return new aS(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Gc extends pn {
  constructor(e = [], t = [], n = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: i
    };
    const r = [], o = [];
    u(i), d(n), p(), this.setAttribute("position", new Kt(r, 3)), this.setAttribute("normal", new Kt(r.slice(), 3)), this.setAttribute("uv", new Kt(o, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function u(w) {
      const C = new q(), D = new q(), N = new q();
      for (let U = 0; U < t.length; U += 3)
        y(t[U + 0], C), y(t[U + 1], D), y(t[U + 2], N), c(C, D, N, w);
    }
    function c(w, C, D, N) {
      const U = N + 1, O = [];
      for (let V = 0; V <= U; V++) {
        O[V] = [];
        const L = w.clone().lerp(D, V / U), I = C.clone().lerp(D, V / U), Y = U - V;
        for (let Q = 0; Q <= Y; Q++)
          Q === 0 && V === U ? O[V][Q] = L : O[V][Q] = L.clone().lerp(I, Q / Y);
      }
      for (let V = 0; V < U; V++)
        for (let L = 0; L < 2 * (U - V) - 1; L++) {
          const I = Math.floor(L / 2);
          L % 2 === 0 ? (v(O[V][I + 1]), v(O[V + 1][I]), v(O[V][I])) : (v(O[V][I + 1]), v(O[V + 1][I + 1]), v(O[V + 1][I]));
        }
    }
    function d(w) {
      const C = new q();
      for (let D = 0; D < r.length; D += 3)
        C.x = r[D + 0], C.y = r[D + 1], C.z = r[D + 2], C.normalize().multiplyScalar(w), r[D + 0] = C.x, r[D + 1] = C.y, r[D + 2] = C.z;
    }
    function p() {
      const w = new q();
      for (let C = 0; C < r.length; C += 3) {
        w.x = r[C + 0], w.y = r[C + 1], w.z = r[C + 2];
        const D = E(w) / 2 / Math.PI + 0.5, N = M(w) / Math.PI + 0.5;
        o.push(D, 1 - N);
      }
      S(), g();
    }
    function g() {
      for (let w = 0; w < o.length; w += 6) {
        const C = o[w + 0], D = o[w + 2], N = o[w + 4], U = Math.max(C, D, N), O = Math.min(C, D, N);
        U > 0.9 && O < 0.1 && (C < 0.2 && (o[w + 0] += 1), D < 0.2 && (o[w + 2] += 1), N < 0.2 && (o[w + 4] += 1));
      }
    }
    function v(w) {
      r.push(w.x, w.y, w.z);
    }
    function y(w, C) {
      const D = w * 3;
      C.x = e[D + 0], C.y = e[D + 1], C.z = e[D + 2];
    }
    function S() {
      const w = new q(), C = new q(), D = new q(), N = new q(), U = new qe(), O = new qe(), V = new qe();
      for (let L = 0, I = 0; L < r.length; L += 9, I += 6) {
        w.set(r[L + 0], r[L + 1], r[L + 2]), C.set(r[L + 3], r[L + 4], r[L + 5]), D.set(r[L + 6], r[L + 7], r[L + 8]), U.set(o[I + 0], o[I + 1]), O.set(o[I + 2], o[I + 3]), V.set(o[I + 4], o[I + 5]), N.copy(w).add(C).add(D).divideScalar(3);
        const Y = E(N);
        T(U, I + 0, w, Y), T(O, I + 2, C, Y), T(V, I + 4, D, Y);
      }
    }
    function T(w, C, D, N) {
      N < 0 && w.x === 1 && (o[C] = w.x - 1), D.x === 0 && D.z === 0 && (o[C] = N / 2 / Math.PI + 0.5);
    }
    function E(w) {
      return Math.atan2(w.z, -w.x);
    }
    function M(w) {
      return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Gc(e.vertices, e.indices, e.radius, e.details);
  }
}
class oS extends Gc {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, r = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      // (±1/φ, ±φ, 0)
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      0,
      // (±φ, 0, ±1/φ)
      -n,
      0,
      -i,
      n,
      0,
      -i,
      -n,
      0,
      i,
      n,
      0,
      i
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(r, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new oS(e.radius, e.detail);
  }
}
const b0 = /* @__PURE__ */ new q(), C0 = /* @__PURE__ */ new q(), gE = /* @__PURE__ */ new q(), w0 = /* @__PURE__ */ new na();
class e2 extends pn {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const i = Math.pow(10, 4), r = Math.cos(nd * t), o = e.getIndex(), u = e.getAttribute("position"), c = o ? o.count : u.count, d = [0, 0, 0], p = ["a", "b", "c"], g = new Array(3), v = {}, y = [];
      for (let S = 0; S < c; S += 3) {
        o ? (d[0] = o.getX(S), d[1] = o.getX(S + 1), d[2] = o.getX(S + 2)) : (d[0] = S, d[1] = S + 1, d[2] = S + 2);
        const { a: T, b: E, c: M } = w0;
        if (T.fromBufferAttribute(u, d[0]), E.fromBufferAttribute(u, d[1]), M.fromBufferAttribute(u, d[2]), w0.getNormal(gE), g[0] = `${Math.round(T.x * i)},${Math.round(T.y * i)},${Math.round(T.z * i)}`, g[1] = `${Math.round(E.x * i)},${Math.round(E.y * i)},${Math.round(E.z * i)}`, g[2] = `${Math.round(M.x * i)},${Math.round(M.y * i)},${Math.round(M.z * i)}`, !(g[0] === g[1] || g[1] === g[2] || g[2] === g[0]))
          for (let w = 0; w < 3; w++) {
            const C = (w + 1) % 3, D = g[w], N = g[C], U = w0[p[w]], O = w0[p[C]], V = `${D}_${N}`, L = `${N}_${D}`;
            L in v && v[L] ? (gE.dot(v[L].normal) <= r && (y.push(U.x, U.y, U.z), y.push(O.x, O.y, O.z)), v[L] = null) : V in v || (v[V] = {
              index0: d[w],
              index1: d[C],
              normal: gE.clone()
            });
          }
      }
      for (const S in v)
        if (v[S]) {
          const { index0: T, index1: E } = v[S];
          b0.fromBufferAttribute(u, T), C0.fromBufferAttribute(u, E), y.push(b0.x, b0.y, b0.z), y.push(C0.x, C0.y, C0.z);
        }
      this.setAttribute("position", new Kt(y, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class sd extends bv {
  constructor(e) {
    super(e), this.uuid = Da(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new bv().fromJSON(i));
    }
    return this;
  }
}
const L4 = {
  triangulate: function(s, e, t = 2) {
    const n = e && e.length, i = n ? e[0] * t : s.length;
    let r = t2(s, 0, i, t, !0);
    const o = [];
    if (!r || r.next === r.prev) return o;
    let u, c, d, p, g, v, y;
    if (n && (r = N4(s, e, r, t)), s.length > 80 * t) {
      u = d = s[0], c = p = s[1];
      for (let S = t; S < i; S += t)
        g = s[S], v = s[S + 1], g < u && (u = g), v < c && (c = v), g > d && (d = g), v > p && (p = v);
      y = Math.max(d - u, p - c), y = y !== 0 ? 32767 / y : 0;
    }
    return Cv(r, o, t, u, c, y, 0), o;
  }
};
function t2(s, e, t, n, i) {
  let r, o;
  if (i === K4(s, e, t, n) > 0)
    for (r = e; r < t; r += n) o = HB(r, s[r], s[r + 1], o);
  else
    for (r = t - n; r >= e; r -= n) o = HB(r, s[r], s[r + 1], o);
  return o && lS(o, o.next) && (Rv(o), o = o.next), o;
}
function gd(s, e) {
  if (!s) return s;
  e || (e = s);
  let t = s, n;
  do
    if (n = !1, !t.steiner && (lS(t, t.next) || Ci(t.prev, t, t.next) === 0)) {
      if (Rv(t), t = e = t.prev, t === t.next) break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function Cv(s, e, t, n, i, r, o) {
  if (!s) return;
  !o && r && k4(s, n, i, r);
  let u = s, c, d;
  for (; s.prev !== s.next; ) {
    if (c = s.prev, d = s.next, r ? I4(s, n, i, r) : P4(s)) {
      e.push(c.i / t | 0), e.push(s.i / t | 0), e.push(d.i / t | 0), Rv(s), s = d.next, u = d.next;
      continue;
    }
    if (s = d, s === u) {
      o ? o === 1 ? (s = U4(gd(s), e, t), Cv(s, e, t, n, i, r, 2)) : o === 2 && F4(s, e, t, n, i, r) : Cv(gd(s), e, t, n, i, r, 1);
      break;
    }
  }
}
function P4(s) {
  const e = s.prev, t = s, n = s.next;
  if (Ci(e, t, n) >= 0) return !1;
  const i = e.x, r = t.x, o = n.x, u = e.y, c = t.y, d = n.y, p = i < r ? i < o ? i : o : r < o ? r : o, g = u < c ? u < d ? u : d : c < d ? c : d, v = i > r ? i > o ? i : o : r > o ? r : o, y = u > c ? u > d ? u : d : c > d ? c : d;
  let S = n.next;
  for (; S !== e; ) {
    if (S.x >= p && S.x <= v && S.y >= g && S.y <= y && bp(i, u, r, c, o, d, S.x, S.y) && Ci(S.prev, S, S.next) >= 0) return !1;
    S = S.next;
  }
  return !0;
}
function I4(s, e, t, n) {
  const i = s.prev, r = s, o = s.next;
  if (Ci(i, r, o) >= 0) return !1;
  const u = i.x, c = r.x, d = o.x, p = i.y, g = r.y, v = o.y, y = u < c ? u < d ? u : d : c < d ? c : d, S = p < g ? p < v ? p : v : g < v ? g : v, T = u > c ? u > d ? u : d : c > d ? c : d, E = p > g ? p > v ? p : v : g > v ? g : v, M = HT(y, S, e, t, n), w = HT(T, E, e, t, n);
  let C = s.prevZ, D = s.nextZ;
  for (; C && C.z >= M && D && D.z <= w; ) {
    if (C.x >= y && C.x <= T && C.y >= S && C.y <= E && C !== i && C !== o && bp(u, p, c, g, d, v, C.x, C.y) && Ci(C.prev, C, C.next) >= 0 || (C = C.prevZ, D.x >= y && D.x <= T && D.y >= S && D.y <= E && D !== i && D !== o && bp(u, p, c, g, d, v, D.x, D.y) && Ci(D.prev, D, D.next) >= 0)) return !1;
    D = D.nextZ;
  }
  for (; C && C.z >= M; ) {
    if (C.x >= y && C.x <= T && C.y >= S && C.y <= E && C !== i && C !== o && bp(u, p, c, g, d, v, C.x, C.y) && Ci(C.prev, C, C.next) >= 0) return !1;
    C = C.prevZ;
  }
  for (; D && D.z <= w; ) {
    if (D.x >= y && D.x <= T && D.y >= S && D.y <= E && D !== i && D !== o && bp(u, p, c, g, d, v, D.x, D.y) && Ci(D.prev, D, D.next) >= 0) return !1;
    D = D.nextZ;
  }
  return !0;
}
function U4(s, e, t) {
  let n = s;
  do {
    const i = n.prev, r = n.next.next;
    !lS(i, r) && n2(i, n, n.next, r) && wv(i, r) && wv(r, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(r.i / t | 0), Rv(n), Rv(n.next), n = s = r), n = n.next;
  } while (n !== s);
  return gd(n);
}
function F4(s, e, t, n, i, r) {
  let o = s;
  do {
    let u = o.next.next;
    for (; u !== o.prev; ) {
      if (o.i !== u.i && X4(o, u)) {
        let c = i2(o, u);
        o = gd(o, o.next), c = gd(c, c.next), Cv(o, e, t, n, i, r, 0), Cv(c, e, t, n, i, r, 0);
        return;
      }
      u = u.next;
    }
    o = o.next;
  } while (o !== s);
}
function N4(s, e, t, n) {
  const i = [];
  let r, o, u, c, d;
  for (r = 0, o = e.length; r < o; r++)
    u = e[r] * n, c = r < o - 1 ? e[r + 1] * n : s.length, d = t2(s, u, c, n, !1), d === d.next && (d.steiner = !0), i.push(W4(d));
  for (i.sort(O4), r = 0; r < i.length; r++)
    t = H4(i[r], t);
  return t;
}
function O4(s, e) {
  return s.x - e.x;
}
function H4(s, e) {
  const t = z4(s, e);
  if (!t)
    return e;
  const n = i2(t, s);
  return gd(n, n.next), gd(t, t.next);
}
function z4(s, e) {
  let t = e, n = -1 / 0, i;
  const r = s.x, o = s.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const v = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (v <= r && v > n && (n = v, i = t.x < t.next.x ? t : t.next, v === r))
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const u = i, c = i.x, d = i.y;
  let p = 1 / 0, g;
  t = i;
  do
    r >= t.x && t.x >= c && r !== t.x && bp(o < d ? r : n, o, c, d, o < d ? n : r, o, t.x, t.y) && (g = Math.abs(o - t.y) / (r - t.x), wv(t, s) && (g < p || g === p && (t.x > i.x || t.x === i.x && G4(i, t))) && (i = t, p = g)), t = t.next;
  while (t !== u);
  return i;
}
function G4(s, e) {
  return Ci(s.prev, s, e.prev) < 0 && Ci(e.next, s, s.next) < 0;
}
function k4(s, e, t, n) {
  let i = s;
  do
    i.z === 0 && (i.z = HT(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== s);
  i.prevZ.nextZ = null, i.prevZ = null, V4(i);
}
function V4(s) {
  let e, t, n, i, r, o, u, c, d = 1;
  do {
    for (t = s, s = null, r = null, o = 0; t; ) {
      for (o++, n = t, u = 0, e = 0; e < d && (u++, n = n.nextZ, !!n); e++)
        ;
      for (c = d; u > 0 || c > 0 && n; )
        u !== 0 && (c === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, u--) : (i = n, n = n.nextZ, c--), r ? r.nextZ = i : s = i, i.prevZ = r, r = i;
      t = n;
    }
    r.nextZ = null, d *= 2;
  } while (o > 1);
  return s;
}
function HT(s, e, t, n, i) {
  return s = (s - t) * i | 0, e = (e - n) * i | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function W4(s) {
  let e = s, t = s;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== s);
  return t;
}
function bp(s, e, t, n, i, r, o, u) {
  return (i - o) * (e - u) >= (s - o) * (r - u) && (s - o) * (n - u) >= (t - o) * (e - u) && (t - o) * (r - u) >= (i - o) * (n - u);
}
function X4(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !J4(s, e) && // dones't intersect other edges
  (wv(s, e) && wv(e, s) && Y4(s, e) && // locally visible
  (Ci(s.prev, s, e.prev) || Ci(s, e.prev, e)) || // does not create opposite-facing sectors
  lS(s, e) && Ci(s.prev, s, s.next) > 0 && Ci(e.prev, e, e.next) > 0);
}
function Ci(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function lS(s, e) {
  return s.x === e.x && s.y === e.y;
}
function n2(s, e, t, n) {
  const i = B0(Ci(s, e, t)), r = B0(Ci(s, e, n)), o = B0(Ci(t, n, s)), u = B0(Ci(t, n, e));
  return !!(i !== r && o !== u || i === 0 && R0(s, t, e) || r === 0 && R0(s, n, e) || o === 0 && R0(t, s, n) || u === 0 && R0(t, e, n));
}
function R0(s, e, t) {
  return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
}
function B0(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function J4(s, e) {
  let t = s;
  do {
    if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && n2(t, t.next, s, e)) return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function wv(s, e) {
  return Ci(s.prev, s, s.next) < 0 ? Ci(s, e, s.next) >= 0 && Ci(s, s.prev, e) >= 0 : Ci(s, e, s.prev) < 0 || Ci(s, s.next, e) < 0;
}
function Y4(s, e) {
  let t = s, n = !1;
  const i = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && i < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== s);
  return n;
}
function i2(s, e) {
  const t = new zT(s.i, s.x, s.y), n = new zT(e.i, e.x, e.y), i = s.next, r = e.prev;
  return s.next = e, e.prev = s, t.next = i, i.prev = t, n.next = t, t.prev = n, r.next = n, n.prev = r, n;
}
function HB(s, e, t, n) {
  const i = new zT(s, e, t);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function Rv(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function zT(s, e, t) {
  this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function K4(s, e, t, n) {
  let i = 0;
  for (let r = e, o = t - n; r < t; r += n)
    i += (s[o] - s[r]) * (s[r + 1] + s[o + 1]), o = r;
  return i;
}
class Al {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, r = 0; r < t; i = r++)
      n += e[i].x * e[r].y - e[r].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return Al.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], i = [], r = [];
    zB(e), GB(n, e);
    let o = e.length;
    t.forEach(zB);
    for (let c = 0; c < t.length; c++)
      i.push(o), o += t[c].length, GB(n, t[c]);
    const u = L4.triangulate(n, i);
    for (let c = 0; c < u.length; c += 3)
      r.push(u.slice(c, c + 3));
    return r;
  }
}
function zB(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function GB(s, e) {
  for (let t = 0; t < e.length; t++)
    s.push(e[t].x), s.push(e[t].y);
}
class uS extends pn {
  constructor(e = new sd([new qe(0.5, 0.5), new qe(-0.5, 0.5), new qe(-0.5, -0.5), new qe(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const n = this, i = [], r = [];
    for (let u = 0, c = e.length; u < c; u++) {
      const d = e[u];
      o(d);
    }
    this.setAttribute("position", new Kt(i, 3)), this.setAttribute("uv", new Kt(r, 2)), this.computeVertexNormals();
    function o(u) {
      const c = [], d = t.curveSegments !== void 0 ? t.curveSegments : 12, p = t.steps !== void 0 ? t.steps : 1, g = t.depth !== void 0 ? t.depth : 1;
      let v = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, y = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, S = t.bevelSize !== void 0 ? t.bevelSize : y - 0.1, T = t.bevelOffset !== void 0 ? t.bevelOffset : 0, E = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const M = t.extrudePath, w = t.UVGenerator !== void 0 ? t.UVGenerator : q4;
      let C, D = !1, N, U, O, V;
      M && (C = M.getSpacedPoints(p), D = !0, v = !1, N = M.computeFrenetFrames(p, !1), U = new q(), O = new q(), V = new q()), v || (E = 0, y = 0, S = 0, T = 0);
      const L = u.extractPoints(d);
      let I = L.shape;
      const Y = L.holes;
      if (!Al.isClockWise(I)) {
        I = I.reverse();
        for (let ne = 0, we = Y.length; ne < we; ne++) {
          const Ee = Y[ne];
          Al.isClockWise(Ee) && (Y[ne] = Ee.reverse());
        }
      }
      const fe = Al.triangulateShape(I, Y), j = I;
      for (let ne = 0, we = Y.length; ne < we; ne++) {
        const Ee = Y[ne];
        I = I.concat(Ee);
      }
      function ie(ne, we, Ee) {
        return we || console.error("THREE.ExtrudeGeometry: vec does not exist"), ne.clone().addScaledVector(we, Ee);
      }
      const re = I.length, pe = fe.length;
      function J(ne, we, Ee) {
        let He, be, ce;
        const nt = ne.x - we.x, X = ne.y - we.y, G = Ee.x - ne.x, le = Ee.y - ne.y, Ue = nt * nt + X * X, Ve = nt * le - X * G;
        if (Math.abs(Ve) > Number.EPSILON) {
          const Oe = Math.sqrt(Ue), ct = Math.sqrt(G * G + le * le), st = we.x - X / Oe, it = we.y + nt / Oe, Lt = Ee.x - le / ct, zt = Ee.y + G / ct, ee = ((Lt - st) * le - (zt - it) * G) / (nt * le - X * G);
          He = st + nt * ee - ne.x, be = it + X * ee - ne.y;
          const Re = He * He + be * be;
          if (Re <= 2)
            return new qe(He, be);
          ce = Math.sqrt(Re / 2);
        } else {
          let Oe = !1;
          nt > Number.EPSILON ? G > Number.EPSILON && (Oe = !0) : nt < -Number.EPSILON ? G < -Number.EPSILON && (Oe = !0) : Math.sign(X) === Math.sign(le) && (Oe = !0), Oe ? (He = -X, be = nt, ce = Math.sqrt(Ue)) : (He = nt, be = X, ce = Math.sqrt(Ue / 2));
        }
        return new qe(He / ce, be / ce);
      }
      const Z = [];
      for (let ne = 0, we = j.length, Ee = we - 1, He = ne + 1; ne < we; ne++, Ee++, He++)
        Ee === we && (Ee = 0), He === we && (He = 0), Z[ne] = J(j[ne], j[Ee], j[He]);
      const H = [];
      let ue, Se = Z.concat();
      for (let ne = 0, we = Y.length; ne < we; ne++) {
        const Ee = Y[ne];
        ue = [];
        for (let He = 0, be = Ee.length, ce = be - 1, nt = He + 1; He < be; He++, ce++, nt++)
          ce === be && (ce = 0), nt === be && (nt = 0), ue[He] = J(Ee[He], Ee[ce], Ee[nt]);
        H.push(ue), Se = Se.concat(ue);
      }
      for (let ne = 0; ne < E; ne++) {
        const we = ne / E, Ee = y * Math.cos(we * Math.PI / 2), He = S * Math.sin(we * Math.PI / 2) + T;
        for (let be = 0, ce = j.length; be < ce; be++) {
          const nt = ie(j[be], Z[be], He);
          Ye(nt.x, nt.y, -Ee);
        }
        for (let be = 0, ce = Y.length; be < ce; be++) {
          const nt = Y[be];
          ue = H[be];
          for (let X = 0, G = nt.length; X < G; X++) {
            const le = ie(nt[X], ue[X], He);
            Ye(le.x, le.y, -Ee);
          }
        }
      }
      const me = S + T;
      for (let ne = 0; ne < re; ne++) {
        const we = v ? ie(I[ne], Se[ne], me) : I[ne];
        D ? (O.copy(N.normals[0]).multiplyScalar(we.x), U.copy(N.binormals[0]).multiplyScalar(we.y), V.copy(C[0]).add(O).add(U), Ye(V.x, V.y, V.z)) : Ye(we.x, we.y, 0);
      }
      for (let ne = 1; ne <= p; ne++)
        for (let we = 0; we < re; we++) {
          const Ee = v ? ie(I[we], Se[we], me) : I[we];
          D ? (O.copy(N.normals[ne]).multiplyScalar(Ee.x), U.copy(N.binormals[ne]).multiplyScalar(Ee.y), V.copy(C[ne]).add(O).add(U), Ye(V.x, V.y, V.z)) : Ye(Ee.x, Ee.y, g / p * ne);
        }
      for (let ne = E - 1; ne >= 0; ne--) {
        const we = ne / E, Ee = y * Math.cos(we * Math.PI / 2), He = S * Math.sin(we * Math.PI / 2) + T;
        for (let be = 0, ce = j.length; be < ce; be++) {
          const nt = ie(j[be], Z[be], He);
          Ye(nt.x, nt.y, g + Ee);
        }
        for (let be = 0, ce = Y.length; be < ce; be++) {
          const nt = Y[be];
          ue = H[be];
          for (let X = 0, G = nt.length; X < G; X++) {
            const le = ie(nt[X], ue[X], He);
            D ? Ye(le.x, le.y + C[p - 1].y, C[p - 1].x + Ee) : Ye(le.x, le.y, g + Ee);
          }
        }
      }
      ye(), Xe();
      function ye() {
        const ne = i.length / 3;
        if (v) {
          let we = 0, Ee = re * we;
          for (let He = 0; He < pe; He++) {
            const be = fe[He];
            At(be[2] + Ee, be[1] + Ee, be[0] + Ee);
          }
          we = p + E * 2, Ee = re * we;
          for (let He = 0; He < pe; He++) {
            const be = fe[He];
            At(be[0] + Ee, be[1] + Ee, be[2] + Ee);
          }
        } else {
          for (let we = 0; we < pe; we++) {
            const Ee = fe[we];
            At(Ee[2], Ee[1], Ee[0]);
          }
          for (let we = 0; we < pe; we++) {
            const Ee = fe[we];
            At(Ee[0] + re * p, Ee[1] + re * p, Ee[2] + re * p);
          }
        }
        n.addGroup(ne, i.length / 3 - ne, 0);
      }
      function Xe() {
        const ne = i.length / 3;
        let we = 0;
        Je(j, we), we += j.length;
        for (let Ee = 0, He = Y.length; Ee < He; Ee++) {
          const be = Y[Ee];
          Je(be, we), we += be.length;
        }
        n.addGroup(ne, i.length / 3 - ne, 1);
      }
      function Je(ne, we) {
        let Ee = ne.length;
        for (; --Ee >= 0; ) {
          const He = Ee;
          let be = Ee - 1;
          be < 0 && (be = ne.length - 1);
          for (let ce = 0, nt = p + E * 2; ce < nt; ce++) {
            const X = re * ce, G = re * (ce + 1), le = we + He + X, Ue = we + be + X, Ve = we + be + G, Oe = we + He + G;
            Ct(le, Ue, Ve, Oe);
          }
        }
      }
      function Ye(ne, we, Ee) {
        c.push(ne), c.push(we), c.push(Ee);
      }
      function At(ne, we, Ee) {
        pt(ne), pt(we), pt(Ee);
        const He = i.length / 3, be = w.generateTopUV(n, i, He - 3, He - 2, He - 1);
        mt(be[0]), mt(be[1]), mt(be[2]);
      }
      function Ct(ne, we, Ee, He) {
        pt(ne), pt(we), pt(He), pt(we), pt(Ee), pt(He);
        const be = i.length / 3, ce = w.generateSideWallUV(n, i, be - 6, be - 3, be - 2, be - 1);
        mt(ce[0]), mt(ce[1]), mt(ce[3]), mt(ce[1]), mt(ce[2]), mt(ce[3]);
      }
      function pt(ne) {
        i.push(c[ne * 3 + 0]), i.push(c[ne * 3 + 1]), i.push(c[ne * 3 + 2]);
      }
      function mt(ne) {
        r.push(ne.x), r.push(ne.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
    return j4(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, o = e.shapes.length; r < o; r++) {
      const u = t[e.shapes[r]];
      n.push(u);
    }
    const i = e.options.extrudePath;
    return i !== void 0 && (e.options.extrudePath = new wx[i.type]().fromJSON(i)), new uS(n, e.options);
  }
}
const q4 = {
  generateTopUV: function(s, e, t, n, i) {
    const r = e[t * 3], o = e[t * 3 + 1], u = e[n * 3], c = e[n * 3 + 1], d = e[i * 3], p = e[i * 3 + 1];
    return [
      new qe(r, o),
      new qe(u, c),
      new qe(d, p)
    ];
  },
  generateSideWallUV: function(s, e, t, n, i, r) {
    const o = e[t * 3], u = e[t * 3 + 1], c = e[t * 3 + 2], d = e[n * 3], p = e[n * 3 + 1], g = e[n * 3 + 2], v = e[i * 3], y = e[i * 3 + 1], S = e[i * 3 + 2], T = e[r * 3], E = e[r * 3 + 1], M = e[r * 3 + 2];
    return Math.abs(u - p) < Math.abs(o - d) ? [
      new qe(o, 1 - c),
      new qe(d, 1 - g),
      new qe(v, 1 - S),
      new qe(T, 1 - M)
    ] : [
      new qe(u, 1 - c),
      new qe(p, 1 - g),
      new qe(y, 1 - S),
      new qe(E, 1 - M)
    ];
  }
};
function j4(s, e, t) {
  if (t.shapes = [], Array.isArray(s))
    for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      t.shapes.push(r.uuid);
    }
  else
    t.shapes.push(s.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class cS extends Gc {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], r = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new cS(e.radius, e.detail);
  }
}
class Qv extends Gc {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Qv(e.radius, e.detail);
  }
}
class fS extends pn {
  constructor(e = 0.5, t = 1, n = 32, i = 1, r = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: i,
      thetaStart: r,
      thetaLength: o
    }, n = Math.max(3, n), i = Math.max(1, i);
    const u = [], c = [], d = [], p = [];
    let g = e;
    const v = (t - e) / i, y = new q(), S = new qe();
    for (let T = 0; T <= i; T++) {
      for (let E = 0; E <= n; E++) {
        const M = r + E / n * o;
        y.x = g * Math.cos(M), y.y = g * Math.sin(M), c.push(y.x, y.y, y.z), d.push(0, 0, 1), S.x = (y.x / t + 1) / 2, S.y = (y.y / t + 1) / 2, p.push(S.x, S.y);
      }
      g += v;
    }
    for (let T = 0; T < i; T++) {
      const E = T * (n + 1);
      for (let M = 0; M < n; M++) {
        const w = M + E, C = w, D = w + n + 1, N = w + n + 2, U = w + 1;
        u.push(C, D, U), u.push(D, N, U);
      }
    }
    this.setIndex(u), this.setAttribute("position", new Kt(c, 3)), this.setAttribute("normal", new Kt(d, 3)), this.setAttribute("uv", new Kt(p, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new fS(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class dS extends pn {
  constructor(e = new sd([new qe(0, 0.5), new qe(-0.5, -0.5), new qe(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const n = [], i = [], r = [], o = [];
    let u = 0, c = 0;
    if (Array.isArray(e) === !1)
      d(e);
    else
      for (let p = 0; p < e.length; p++)
        d(e[p]), this.addGroup(u, c, p), u += c, c = 0;
    this.setIndex(n), this.setAttribute("position", new Kt(i, 3)), this.setAttribute("normal", new Kt(r, 3)), this.setAttribute("uv", new Kt(o, 2));
    function d(p) {
      const g = i.length / 3, v = p.extractPoints(t);
      let y = v.shape;
      const S = v.holes;
      Al.isClockWise(y) === !1 && (y = y.reverse());
      for (let E = 0, M = S.length; E < M; E++) {
        const w = S[E];
        Al.isClockWise(w) === !0 && (S[E] = w.reverse());
      }
      const T = Al.triangulateShape(y, S);
      for (let E = 0, M = S.length; E < M; E++) {
        const w = S[E];
        y = y.concat(w);
      }
      for (let E = 0, M = y.length; E < M; E++) {
        const w = y[E];
        i.push(w.x, w.y, 0), r.push(0, 0, 1), o.push(w.x, w.y);
      }
      for (let E = 0, M = T.length; E < M; E++) {
        const w = T[E], C = w[0] + g, D = w[1] + g, N = w[2] + g;
        n.push(C, D, N), c += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return Q4(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, r = e.shapes.length; i < r; i++) {
      const o = t[e.shapes[i]];
      n.push(o);
    }
    return new dS(n, e.curveSegments);
  }
}
function Q4(s, e) {
  if (e.shapes = [], Array.isArray(s))
    for (let t = 0, n = s.length; t < n; t++) {
      const i = s[t];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(s.uuid);
  return e;
}
class Zv extends pn {
  constructor(e = 1, t = 32, n = 16, i = 0, r = Math.PI * 2, o = 0, u = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: i,
      phiLength: r,
      thetaStart: o,
      thetaLength: u
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const c = Math.min(o + u, Math.PI);
    let d = 0;
    const p = [], g = new q(), v = new q(), y = [], S = [], T = [], E = [];
    for (let M = 0; M <= n; M++) {
      const w = [], C = M / n;
      let D = 0;
      M === 0 && o === 0 ? D = 0.5 / t : M === n && c === Math.PI && (D = -0.5 / t);
      for (let N = 0; N <= t; N++) {
        const U = N / t;
        g.x = -e * Math.cos(i + U * r) * Math.sin(o + C * u), g.y = e * Math.cos(o + C * u), g.z = e * Math.sin(i + U * r) * Math.sin(o + C * u), S.push(g.x, g.y, g.z), v.copy(g).normalize(), T.push(v.x, v.y, v.z), E.push(U + D, 1 - C), w.push(d++);
      }
      p.push(w);
    }
    for (let M = 0; M < n; M++)
      for (let w = 0; w < t; w++) {
        const C = p[M][w + 1], D = p[M][w], N = p[M + 1][w], U = p[M + 1][w + 1];
        (M !== 0 || o > 0) && y.push(C, D, U), (M !== n - 1 || c < Math.PI) && y.push(D, N, U);
      }
    this.setIndex(y), this.setAttribute("position", new Kt(S, 3)), this.setAttribute("normal", new Kt(T, 3)), this.setAttribute("uv", new Kt(E, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Zv(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class hS extends Gc {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new hS(e.radius, e.detail);
  }
}
class pS extends pn {
  constructor(e = 1, t = 0.4, n = 12, i = 48, r = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: i,
      arc: r
    }, n = Math.floor(n), i = Math.floor(i);
    const o = [], u = [], c = [], d = [], p = new q(), g = new q(), v = new q();
    for (let y = 0; y <= n; y++)
      for (let S = 0; S <= i; S++) {
        const T = S / i * r, E = y / n * Math.PI * 2;
        g.x = (e + t * Math.cos(E)) * Math.cos(T), g.y = (e + t * Math.cos(E)) * Math.sin(T), g.z = t * Math.sin(E), u.push(g.x, g.y, g.z), p.x = e * Math.cos(T), p.y = e * Math.sin(T), v.subVectors(g, p).normalize(), c.push(v.x, v.y, v.z), d.push(S / i), d.push(y / n);
      }
    for (let y = 1; y <= n; y++)
      for (let S = 1; S <= i; S++) {
        const T = (i + 1) * y + S - 1, E = (i + 1) * (y - 1) + S - 1, M = (i + 1) * (y - 1) + S, w = (i + 1) * y + S;
        o.push(T, E, w), o.push(E, M, w);
      }
    this.setIndex(o), this.setAttribute("position", new Kt(u, 3)), this.setAttribute("normal", new Kt(c, 3)), this.setAttribute("uv", new Kt(d, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new pS(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class mS extends pn {
  constructor(e = 1, t = 0.4, n = 64, i = 8, r = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: i,
      p: r,
      q: o
    }, n = Math.floor(n), i = Math.floor(i);
    const u = [], c = [], d = [], p = [], g = new q(), v = new q(), y = new q(), S = new q(), T = new q(), E = new q(), M = new q();
    for (let C = 0; C <= n; ++C) {
      const D = C / n * r * Math.PI * 2;
      w(D, r, o, e, y), w(D + 0.01, r, o, e, S), E.subVectors(S, y), M.addVectors(S, y), T.crossVectors(E, M), M.crossVectors(T, E), T.normalize(), M.normalize();
      for (let N = 0; N <= i; ++N) {
        const U = N / i * Math.PI * 2, O = -t * Math.cos(U), V = t * Math.sin(U);
        g.x = y.x + (O * M.x + V * T.x), g.y = y.y + (O * M.y + V * T.y), g.z = y.z + (O * M.z + V * T.z), c.push(g.x, g.y, g.z), v.subVectors(g, y).normalize(), d.push(v.x, v.y, v.z), p.push(C / n), p.push(N / i);
      }
    }
    for (let C = 1; C <= n; C++)
      for (let D = 1; D <= i; D++) {
        const N = (i + 1) * (C - 1) + (D - 1), U = (i + 1) * C + (D - 1), O = (i + 1) * C + D, V = (i + 1) * (C - 1) + D;
        u.push(N, U, V), u.push(U, O, V);
      }
    this.setIndex(u), this.setAttribute("position", new Kt(c, 3)), this.setAttribute("normal", new Kt(d, 3)), this.setAttribute("uv", new Kt(p, 2));
    function w(C, D, N, U, O) {
      const V = Math.cos(C), L = Math.sin(C), I = N / D * C, Y = Math.cos(I);
      O.x = U * (2 + Y) * 0.5 * V, O.y = U * (2 + Y) * L * 0.5, O.z = U * Math.sin(I) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new mS(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class gS extends pn {
  constructor(e = new jb(new q(-1, -1, 0), new q(-1, 1, 0), new q(1, 1, 0)), t = 64, n = 1, i = 8, r = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: n,
      radialSegments: i,
      closed: r
    };
    const o = e.computeFrenetFrames(t, r);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const u = new q(), c = new q(), d = new qe();
    let p = new q();
    const g = [], v = [], y = [], S = [];
    T(), this.setIndex(S), this.setAttribute("position", new Kt(g, 3)), this.setAttribute("normal", new Kt(v, 3)), this.setAttribute("uv", new Kt(y, 2));
    function T() {
      for (let C = 0; C < t; C++)
        E(C);
      E(r === !1 ? t : 0), w(), M();
    }
    function E(C) {
      p = e.getPointAt(C / t, p);
      const D = o.normals[C], N = o.binormals[C];
      for (let U = 0; U <= i; U++) {
        const O = U / i * Math.PI * 2, V = Math.sin(O), L = -Math.cos(O);
        c.x = L * D.x + V * N.x, c.y = L * D.y + V * N.y, c.z = L * D.z + V * N.z, c.normalize(), v.push(c.x, c.y, c.z), u.x = p.x + n * c.x, u.y = p.y + n * c.y, u.z = p.z + n * c.z, g.push(u.x, u.y, u.z);
      }
    }
    function M() {
      for (let C = 1; C <= t; C++)
        for (let D = 1; D <= i; D++) {
          const N = (i + 1) * (C - 1) + (D - 1), U = (i + 1) * C + (D - 1), O = (i + 1) * C + D, V = (i + 1) * (C - 1) + D;
          S.push(N, U, V), S.push(U, O, V);
        }
    }
    function w() {
      for (let C = 0; C <= t; C++)
        for (let D = 0; D <= i; D++)
          d.x = C / t, d.y = D / i, y.push(d.x, d.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new gS(
      new wx[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class r2 extends pn {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), i = new q(), r = new q();
      if (e.index !== null) {
        const o = e.attributes.position, u = e.index;
        let c = e.groups;
        c.length === 0 && (c = [{ start: 0, count: u.count, materialIndex: 0 }]);
        for (let d = 0, p = c.length; d < p; ++d) {
          const g = c[d], v = g.start, y = g.count;
          for (let S = v, T = v + y; S < T; S += 3)
            for (let E = 0; E < 3; E++) {
              const M = u.getX(S + E), w = u.getX(S + (E + 1) % 3);
              i.fromBufferAttribute(o, M), r.fromBufferAttribute(o, w), kB(i, r, n) === !0 && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let u = 0, c = o.count / 3; u < c; u++)
          for (let d = 0; d < 3; d++) {
            const p = 3 * u + d, g = 3 * u + (d + 1) % 3;
            i.fromBufferAttribute(o, p), r.fromBufferAttribute(o, g), kB(i, r, n) === !0 && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
          }
      }
      this.setAttribute("position", new Kt(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function kB(s, e, t) {
  const n = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
  return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
}
var VB = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Md,
  CapsuleGeometry: rS,
  CircleGeometry: sS,
  ConeGeometry: aS,
  CylinderGeometry: om,
  DodecahedronGeometry: oS,
  EdgesGeometry: e2,
  ExtrudeGeometry: uS,
  IcosahedronGeometry: cS,
  LatheGeometry: jv,
  OctahedronGeometry: Qv,
  PlaneGeometry: Yv,
  PolyhedronGeometry: Gc,
  RingGeometry: fS,
  ShapeGeometry: dS,
  SphereGeometry: Zv,
  TetrahedronGeometry: hS,
  TorusGeometry: pS,
  TorusKnotGeometry: mS,
  TubeGeometry: gS,
  WireframeGeometry: r2
});
class s2 extends Mr {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Tt(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class a2 extends Cl {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class $v extends Mr {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Tt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zc, this.normalScale = new qe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class po extends $v {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new qe(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Hi(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Tt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Tt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Tt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class o2 extends Mr {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Tt(16777215), this.specular = new Tt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zc, this.normalScale = new qe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = kv, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class l2 extends Mr {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Tt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zc, this.normalScale = new qe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class u2 extends Mr {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zc, this.normalScale = new qe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class c2 extends Mr {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Tt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Tt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zc, this.normalScale = new qe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = kv, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class f2 extends Mr {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Tt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zc, this.normalScale = new qe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class d2 extends As {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function jf(s, e, t) {
  return !s || // let 'undefined' and 'null' pass
  !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s);
}
function h2(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function p2(s) {
  function e(i, r) {
    return s[i] - s[r];
  }
  const t = s.length, n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function GT(s, e, t) {
  const n = s.length, i = new s.constructor(n);
  for (let r = 0, o = 0; o !== n; ++r) {
    const u = t[r] * e;
    for (let c = 0; c !== e; ++c)
      i[o++] = s[u + c];
  }
  return i;
}
function Zb(s, e, t, n) {
  let i = 1, r = s[0];
  for (; r !== void 0 && r[n] === void 0; )
    r = s[i++];
  if (r === void 0) return;
  let o = r[n];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        o = r[n], o !== void 0 && (e.push(r.time), t.push.apply(t, o)), r = s[i++];
      while (r !== void 0);
    else if (o.toArray !== void 0)
      do
        o = r[n], o !== void 0 && (e.push(r.time), o.toArray(t, t.length)), r = s[i++];
      while (r !== void 0);
    else
      do
        o = r[n], o !== void 0 && (e.push(r.time), t.push(o)), r = s[i++];
      while (r !== void 0);
}
function Z4(s, e, t, n, i = 30) {
  const r = s.clone();
  r.name = e;
  const o = [];
  for (let c = 0; c < r.tracks.length; ++c) {
    const d = r.tracks[c], p = d.getValueSize(), g = [], v = [];
    for (let y = 0; y < d.times.length; ++y) {
      const S = d.times[y] * i;
      if (!(S < t || S >= n)) {
        g.push(d.times[y]);
        for (let T = 0; T < p; ++T)
          v.push(d.values[y * p + T]);
      }
    }
    g.length !== 0 && (d.times = jf(g, d.times.constructor), d.values = jf(v, d.values.constructor), o.push(d));
  }
  r.tracks = o;
  let u = 1 / 0;
  for (let c = 0; c < r.tracks.length; ++c)
    u > r.tracks[c].times[0] && (u = r.tracks[c].times[0]);
  for (let c = 0; c < r.tracks.length; ++c)
    r.tracks[c].shift(-1 * u);
  return r.resetDuration(), r;
}
function $4(s, e = 0, t = s, n = 30) {
  n <= 0 && (n = 30);
  const i = t.tracks.length, r = e / n;
  for (let o = 0; o < i; ++o) {
    const u = t.tracks[o], c = u.ValueTypeName;
    if (c === "bool" || c === "string") continue;
    const d = s.tracks.find(function(M) {
      return M.name === u.name && M.ValueTypeName === c;
    });
    if (d === void 0) continue;
    let p = 0;
    const g = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = g / 3);
    let v = 0;
    const y = d.getValueSize();
    d.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (v = y / 3);
    const S = u.times.length - 1;
    let T;
    if (r <= u.times[0]) {
      const M = p, w = g - p;
      T = u.values.slice(M, w);
    } else if (r >= u.times[S]) {
      const M = S * g + p, w = M + g - p;
      T = u.values.slice(M, w);
    } else {
      const M = u.createInterpolant(), w = p, C = g - p;
      M.evaluate(r), T = M.resultBuffer.slice(w, C);
    }
    c === "quaternion" && new ys().fromArray(T).normalize().conjugate().toArray(T);
    const E = d.times.length;
    for (let M = 0; M < E; ++M) {
      const w = M * y + v;
      if (c === "quaternion")
        ys.multiplyQuaternionsFlat(
          d.values,
          w,
          T,
          0,
          d.values,
          w
        );
      else {
        const C = y - v * 2;
        for (let D = 0; D < C; ++D)
          d.values[w + D] -= T[D];
      }
    }
  }
  return s.blendMode = bb, s;
}
const e9 = {
  convertArray: jf,
  isTypedArray: h2,
  getKeyframeOrder: p2,
  sortedArray: GT,
  flattenJSON: Zb,
  subclip: Z4,
  makeClipAdditive: $4
};
class lm {
  constructor(e, t, n, i) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, i = t[n], r = t[n - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < i)) {
            for (let u = n + 2; ; ) {
              if (i === void 0) {
                if (e < r) break i;
                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
              }
              if (n === u) break;
              if (r = i, i = t[++n], e < i)
                break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= r)) {
            const u = t[1];
            e < u && (n = 2, r = u);
            for (let c = n - 2; ; ) {
              if (r === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === c) break;
              if (i = r, r = t[--n - 1], e >= r)
                break t;
            }
            o = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < o; ) {
          const u = n + o >>> 1;
          e < t[u] ? o = u : n = u + 1;
        }
        if (i = t[n], r = t[n - 1], r === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i;
    for (let o = 0; o !== i; ++o)
      t[o] = n[r + o];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class m2 extends lm {
  constructor(e, t, n, i) {
    super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: Yf,
      endingEnd: Yf
    };
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let r = e - 2, o = e + 1, u = i[r], c = i[o];
    if (u === void 0)
      switch (this.getSettings_().endingStart) {
        case Kf:
          r = e, u = 2 * t - n;
          break;
        case xv:
          r = i.length - 2, u = t + i[r] - i[r + 1];
          break;
        default:
          r = e, u = n;
      }
    if (c === void 0)
      switch (this.getSettings_().endingEnd) {
        case Kf:
          o = e, c = 2 * n - t;
          break;
        case xv:
          o = 1, c = n + i[1] - i[0];
          break;
        default:
          o = e - 1, c = t;
      }
    const d = (n - t) * 0.5, p = this.valueSize;
    this._weightPrev = d / (t - u), this._weightNext = d / (c - n), this._offsetPrev = r * p, this._offsetNext = o * p;
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, o = this.sampleValues, u = this.valueSize, c = e * u, d = c - u, p = this._offsetPrev, g = this._offsetNext, v = this._weightPrev, y = this._weightNext, S = (n - t) / (i - t), T = S * S, E = T * S, M = -v * E + 2 * v * T - v * S, w = (1 + v) * E + (-1.5 - 2 * v) * T + (-0.5 + v) * S + 1, C = (-1 - y) * E + (1.5 + y) * T + 0.5 * S, D = y * E - y * T;
    for (let N = 0; N !== u; ++N)
      r[N] = M * o[p + N] + w * o[d + N] + C * o[c + N] + D * o[g + N];
    return r;
  }
}
class $b extends lm {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, o = this.sampleValues, u = this.valueSize, c = e * u, d = c - u, p = (n - t) / (i - t), g = 1 - p;
    for (let v = 0; v !== u; ++v)
      r[v] = o[d + v] * g + o[c + v] * p;
    return r;
  }
}
class g2 extends lm {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Xo {
  constructor(e, t, n, i) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = jf(t, this.TimeBufferType), this.values = jf(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: jf(e.times, Array),
        values: jf(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new g2(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new $b(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new m2(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Vp:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case pd:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case cx:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Vp;
      case this.InterpolantFactoryMethodLinear:
        return pd;
      case this.InterpolantFactoryMethodSmooth:
        return cx;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const n = this.times, i = n.length;
    let r = 0, o = i - 1;
    for (; r !== i && n[r] < e; )
      ++r;
    for (; o !== -1 && n[o] > t; )
      --o;
    if (++o, r !== 0 || o !== i) {
      r >= o && (o = Math.max(o, 1), r = o - 1);
      const u = this.getValueSize();
      this.times = n.slice(r, o), this.values = this.values.slice(r * u, o * u);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, i = this.values, r = n.length;
    r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let o = null;
    for (let u = 0; u !== r; u++) {
      const c = n[u];
      if (typeof c == "number" && isNaN(c)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, u, c), e = !1;
        break;
      }
      if (o !== null && o > c) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, u, c, o), e = !1;
        break;
      }
      o = c;
    }
    if (i !== void 0 && h2(i))
      for (let u = 0, c = i.length; u !== c; ++u) {
        const d = i[u];
        if (isNaN(d)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, u, d), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === cx, r = e.length - 1;
    let o = 1;
    for (let u = 1; u < r; ++u) {
      let c = !1;
      const d = e[u], p = e[u + 1];
      if (d !== p && (u !== 1 || d !== e[0]))
        if (i)
          c = !0;
        else {
          const g = u * n, v = g - n, y = g + n;
          for (let S = 0; S !== n; ++S) {
            const T = t[g + S];
            if (T !== t[v + S] || T !== t[y + S]) {
              c = !0;
              break;
            }
          }
        }
      if (c) {
        if (u !== o) {
          e[o] = e[u];
          const g = u * n, v = o * n;
          for (let y = 0; y !== n; ++y)
            t[v + y] = t[g + y];
        }
        ++o;
      }
    }
    if (r > 0) {
      e[o] = e[r];
      for (let u = r * n, c = o * n, d = 0; d !== n; ++d)
        t[c + d] = t[u + d];
      ++o;
    }
    return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = this.constructor, i = new n(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
Xo.prototype.TimeBufferType = Float32Array;
Xo.prototype.ValueBufferType = Float32Array;
Xo.prototype.DefaultInterpolation = pd;
class Ed extends Xo {
}
Ed.prototype.ValueTypeName = "bool";
Ed.prototype.ValueBufferType = Array;
Ed.prototype.DefaultInterpolation = Vp;
Ed.prototype.InterpolantFactoryMethodLinear = void 0;
Ed.prototype.InterpolantFactoryMethodSmooth = void 0;
class eC extends Xo {
}
eC.prototype.ValueTypeName = "color";
class vd extends Xo {
}
vd.prototype.ValueTypeName = "number";
class v2 extends lm {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, o = this.sampleValues, u = this.valueSize, c = (n - t) / (i - t);
    let d = e * u;
    for (let p = d + u; d !== p; d += 4)
      ys.slerpFlat(r, 0, o, d - u, o, d, c);
    return r;
  }
}
class Fc extends Xo {
  InterpolantFactoryMethodLinear(e) {
    return new v2(this.times, this.values, this.getValueSize(), e);
  }
}
Fc.prototype.ValueTypeName = "quaternion";
Fc.prototype.DefaultInterpolation = pd;
Fc.prototype.InterpolantFactoryMethodSmooth = void 0;
class Td extends Xo {
}
Td.prototype.ValueTypeName = "string";
Td.prototype.ValueBufferType = Array;
Td.prototype.DefaultInterpolation = Vp;
Td.prototype.InterpolantFactoryMethodLinear = void 0;
Td.prototype.InterpolantFactoryMethodSmooth = void 0;
class _d extends Xo {
}
_d.prototype.ValueTypeName = "vector";
class Yp {
  constructor(e, t = -1, n, i = Kx) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = Da(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, i = 1 / (e.fps || 1);
    for (let o = 0, u = n.length; o !== u; ++o)
      t.push(n9(n[o]).scale(i));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return r.uuid = e.uuid, r;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, i = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let r = 0, o = n.length; r !== o; ++r)
      t.push(Xo.toJSON(n[r]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const r = t.length, o = [];
    for (let u = 0; u < r; u++) {
      let c = [], d = [];
      c.push(
        (u + r - 1) % r,
        u,
        (u + 1) % r
      ), d.push(0, 1, 0);
      const p = p2(c);
      c = GT(c, 1, p), d = GT(d, 1, p), !i && c[0] === 0 && (c.push(r), d.push(d[0])), o.push(
        new vd(
          ".morphTargetInfluences[" + t[u].name + "]",
          c,
          d
        ).scale(1 / n)
      );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < n.length; i++)
      if (n[i].name === t)
        return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {}, r = /^([\w-]*?)([\d]+)$/;
    for (let u = 0, c = e.length; u < c; u++) {
      const d = e[u], p = d.name.match(r);
      if (p && p.length > 1) {
        const g = p[1];
        let v = i[g];
        v || (i[g] = v = []), v.push(d);
      }
    }
    const o = [];
    for (const u in i)
      o.push(this.CreateFromMorphTargetSequence(u, i[u], t, n));
    return o;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(g, v, y, S, T) {
      if (y.length !== 0) {
        const E = [], M = [];
        Zb(y, E, M, S), E.length !== 0 && T.push(new g(v, E, M));
      }
    }, i = [], r = e.name || "default", o = e.fps || 30, u = e.blendMode;
    let c = e.length || -1;
    const d = e.hierarchy || [];
    for (let g = 0; g < d.length; g++) {
      const v = d[g].keys;
      if (!(!v || v.length === 0))
        if (v[0].morphTargets) {
          const y = {};
          let S;
          for (S = 0; S < v.length; S++)
            if (v[S].morphTargets)
              for (let T = 0; T < v[S].morphTargets.length; T++)
                y[v[S].morphTargets[T]] = -1;
          for (const T in y) {
            const E = [], M = [];
            for (let w = 0; w !== v[S].morphTargets.length; ++w) {
              const C = v[S];
              E.push(C.time), M.push(C.morphTarget === T ? 1 : 0);
            }
            i.push(new vd(".morphTargetInfluence[" + T + "]", E, M));
          }
          c = y.length * o;
        } else {
          const y = ".bones[" + t[g].name + "]";
          n(
            _d,
            y + ".position",
            v,
            "pos",
            i
          ), n(
            Fc,
            y + ".quaternion",
            v,
            "rot",
            i
          ), n(
            _d,
            y + ".scale",
            v,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(r, c, i, u);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const r = this.tracks[n];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function t9(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return vd;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return _d;
    case "color":
      return eC;
    case "quaternion":
      return Fc;
    case "bool":
    case "boolean":
      return Ed;
    case "string":
      return Td;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function n9(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = t9(s.type);
  if (s.times === void 0) {
    const t = [], n = [];
    Zb(s.keys, t, n, "value"), s.times = t, s.values = n;
  }
  return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation);
}
const cu = {
  enabled: !1,
  files: {},
  add: function(s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function(s) {
    if (this.enabled !== !1)
      return this.files[s];
  },
  remove: function(s) {
    delete this.files[s];
  },
  clear: function() {
    this.files = {};
  }
};
class tC {
  constructor(e, t, n) {
    const i = this;
    let r = !1, o = 0, u = 0, c;
    const d = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(p) {
      u++, r === !1 && i.onStart !== void 0 && i.onStart(p, o, u), r = !0;
    }, this.itemEnd = function(p) {
      o++, i.onProgress !== void 0 && i.onProgress(p, o, u), o === u && (r = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(p) {
      i.onError !== void 0 && i.onError(p);
    }, this.resolveURL = function(p) {
      return c ? c(p) : p;
    }, this.setURLModifier = function(p) {
      return c = p, this;
    }, this.addHandler = function(p, g) {
      return d.push(p, g), this;
    }, this.removeHandler = function(p) {
      const g = d.indexOf(p);
      return g !== -1 && d.splice(g, 2), this;
    }, this.getHandler = function(p) {
      for (let g = 0, v = d.length; g < v; g += 2) {
        const y = d[g], S = d[g + 1];
        if (y.global && (y.lastIndex = 0), y.test(p))
          return S;
      }
      return null;
    };
  }
}
const _2 = /* @__PURE__ */ new tC();
class Ms {
  constructor(e) {
    this.manager = e !== void 0 ? e : _2, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(i, r) {
      n.load(e, i, t, r);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Ms.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const nu = {};
class i9 extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class Pa extends Ms {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = cu.get(e);
    if (r !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(r), this.manager.itemEnd(e);
      }, 0), r;
    if (nu[e] !== void 0) {
      nu[e].push({
        onLoad: t,
        onProgress: n,
        onError: i
      });
      return;
    }
    nu[e] = [], nu[e].push({
      onLoad: t,
      onProgress: n,
      onError: i
    });
    const o = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), u = this.mimeType, c = this.responseType;
    fetch(o).then((d) => {
      if (d.status === 200 || d.status === 0) {
        if (d.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || d.body === void 0 || d.body.getReader === void 0)
          return d;
        const p = nu[e], g = d.body.getReader(), v = d.headers.get("Content-Length") || d.headers.get("X-File-Size"), y = v ? parseInt(v) : 0, S = y !== 0;
        let T = 0;
        const E = new ReadableStream({
          start(M) {
            w();
            function w() {
              g.read().then(({ done: C, value: D }) => {
                if (C)
                  M.close();
                else {
                  T += D.byteLength;
                  const N = new ProgressEvent("progress", { lengthComputable: S, loaded: T, total: y });
                  for (let U = 0, O = p.length; U < O; U++) {
                    const V = p[U];
                    V.onProgress && V.onProgress(N);
                  }
                  M.enqueue(D), w();
                }
              });
            }
          }
        });
        return new Response(E);
      } else
        throw new i9(`fetch for "${d.url}" responded with ${d.status}: ${d.statusText}`, d);
    }).then((d) => {
      switch (c) {
        case "arraybuffer":
          return d.arrayBuffer();
        case "blob":
          return d.blob();
        case "document":
          return d.text().then((p) => new DOMParser().parseFromString(p, u));
        case "json":
          return d.json();
        default:
          if (u === void 0)
            return d.text();
          {
            const g = /charset="?([^;"\s]*)"?/i.exec(u), v = g && g[1] ? g[1].toLowerCase() : void 0, y = new TextDecoder(v);
            return d.arrayBuffer().then((S) => y.decode(S));
          }
      }
    }).then((d) => {
      cu.add(e, d);
      const p = nu[e];
      delete nu[e];
      for (let g = 0, v = p.length; g < v; g++) {
        const y = p[g];
        y.onLoad && y.onLoad(d);
      }
    }).catch((d) => {
      const p = nu[e];
      if (p === void 0)
        throw this.manager.itemError(e), d;
      delete nu[e];
      for (let g = 0, v = p.length; g < v; g++) {
        const y = p[g];
        y.onError && y.onError(d);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class r9 extends Ms {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = new Pa(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(u) {
      try {
        t(r.parse(JSON.parse(u)));
      } catch (c) {
        i ? i(c) : console.error(c), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const i = Yp.parse(e[n]);
      t.push(i);
    }
    return t;
  }
}
class s9 extends Ms {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = [], u = new nS(), c = new Pa(this.manager);
    c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(r.withCredentials);
    let d = 0;
    function p(g) {
      c.load(e[g], function(v) {
        const y = r.parse(v, !0);
        o[g] = {
          width: y.width,
          height: y.height,
          format: y.format,
          mipmaps: y.mipmaps
        }, d += 1, d === 6 && (y.mipmapCount === 1 && (u.minFilter = bi), u.image = o, u.format = y.format, u.needsUpdate = !0, t && t(u));
      }, n, i);
    }
    if (Array.isArray(e))
      for (let g = 0, v = e.length; g < v; ++g)
        p(g);
    else
      c.load(e, function(g) {
        const v = r.parse(g, !0);
        if (v.isCubemap) {
          const y = v.mipmaps.length / v.mipmapCount;
          for (let S = 0; S < y; S++) {
            o[S] = { mipmaps: [] };
            for (let T = 0; T < v.mipmapCount; T++)
              o[S].mipmaps.push(v.mipmaps[S * v.mipmapCount + T]), o[S].format = v.format, o[S].width = v.width, o[S].height = v.height;
          }
          u.image = o;
        } else
          u.image.width = v.width, u.image.height = v.height, u.mipmaps = v.mipmaps;
        v.mipmapCount === 1 && (u.minFilter = bi), u.format = v.format, u.needsUpdate = !0, t && t(u);
      }, n, i);
    return u;
  }
}
class Bv extends Ms {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, o = cu.get(e);
    if (o !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(o), r.manager.itemEnd(e);
      }, 0), o;
    const u = Tv("img");
    function c() {
      p(), cu.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function d(g) {
      p(), i && i(g), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function p() {
      u.removeEventListener("load", c, !1), u.removeEventListener("error", d, !1);
    }
    return u.addEventListener("load", c, !1), u.addEventListener("error", d, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (u.crossOrigin = this.crossOrigin), r.manager.itemStart(e), u.src = e, u;
  }
}
class a9 extends Ms {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new Xv();
    r.colorSpace = Sr;
    const o = new Bv(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let u = 0;
    function c(d) {
      o.load(e[d], function(p) {
        r.images[d] = p, u++, u === 6 && (r.needsUpdate = !0, t && t(r));
      }, void 0, i);
    }
    for (let d = 0; d < e.length; ++d)
      c(d);
    return r;
  }
}
class o9 extends Ms {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = new rd(), u = new Pa(this.manager);
    return u.setResponseType("arraybuffer"), u.setRequestHeader(this.requestHeader), u.setPath(this.path), u.setWithCredentials(r.withCredentials), u.load(e, function(c) {
      let d;
      try {
        d = r.parse(c);
      } catch (p) {
        if (i !== void 0)
          i(p);
        else {
          console.error(p);
          return;
        }
      }
      d.image !== void 0 ? o.image = d.image : d.data !== void 0 && (o.image.width = d.width, o.image.height = d.height, o.image.data = d.data), o.wrapS = d.wrapS !== void 0 ? d.wrapS : qr, o.wrapT = d.wrapT !== void 0 ? d.wrapT : qr, o.magFilter = d.magFilter !== void 0 ? d.magFilter : bi, o.minFilter = d.minFilter !== void 0 ? d.minFilter : bi, o.anisotropy = d.anisotropy !== void 0 ? d.anisotropy : 1, d.colorSpace !== void 0 ? o.colorSpace = d.colorSpace : d.encoding !== void 0 && (o.encoding = d.encoding), d.flipY !== void 0 && (o.flipY = d.flipY), d.format !== void 0 && (o.format = d.format), d.type !== void 0 && (o.type = d.type), d.mipmaps !== void 0 && (o.mipmaps = d.mipmaps, o.minFilter = Tl), d.mipmapCount === 1 && (o.minFilter = bi), d.generateMipmaps !== void 0 && (o.generateMipmaps = d.generateMipmaps), o.needsUpdate = !0, t && t(o, d);
    }, n, i), o;
  }
}
class y2 extends Ms {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new Ri(), o = new Bv(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(u) {
      r.image = u, r.needsUpdate = !0, t !== void 0 && t(r);
    }, n, i), r;
  }
}
class kc extends On {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Tt(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class x2 extends kc {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(On.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Tt(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const vE = /* @__PURE__ */ new sn(), WB = /* @__PURE__ */ new q(), XB = /* @__PURE__ */ new q();
class nC {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new qe(512, 512), this.map = null, this.mapPass = null, this.matrix = new sn(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Jv(), this._frameExtents = new qe(1, 1), this._viewportCount = 1, this._viewports = [
      new $n(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    WB.setFromMatrixPosition(e.matrixWorld), t.position.copy(WB), XB.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(XB), t.updateMatrixWorld(), vE.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(vE), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(vE);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class l9 extends nC {
  constructor() {
    super(new Ar(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = Xp * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class iC extends kc {
  constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(On.DEFAULT_UP), this.updateMatrix(), this.target = new On(), this.distance = n, this.angle = i, this.penumbra = r, this.decay = o, this.map = null, this.shadow = new l9();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const JB = /* @__PURE__ */ new sn(), Ng = /* @__PURE__ */ new q(), _E = /* @__PURE__ */ new q();
class u9 extends nC {
  constructor() {
    super(new Ar(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new qe(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new $n(2, 1, 1, 1),
      // negative X
      new $n(0, 1, 1, 1),
      // positive Z
      new $n(3, 1, 1, 1),
      // negative Z
      new $n(1, 1, 1, 1),
      // positive Y
      new $n(3, 0, 1, 1),
      // negative Y
      new $n(1, 0, 1, 1)
    ], this._cubeDirections = [
      new q(1, 0, 0),
      new q(-1, 0, 0),
      new q(0, 0, 1),
      new q(0, 0, -1),
      new q(0, 1, 0),
      new q(0, -1, 0)
    ], this._cubeUps = [
      new q(0, 1, 0),
      new q(0, 1, 0),
      new q(0, 1, 0),
      new q(0, 1, 0),
      new q(0, 0, 1),
      new q(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, i = this.matrix, r = e.distance || n.far;
    r !== n.far && (n.far = r, n.updateProjectionMatrix()), Ng.setFromMatrixPosition(e.matrixWorld), n.position.copy(Ng), _E.copy(n.position), _E.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(_E), n.updateMatrixWorld(), i.makeTranslation(-Ng.x, -Ng.y, -Ng.z), JB.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(JB);
  }
}
class rC extends kc {
  constructor(e, t, n = 0, i = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new u9();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class c9 extends nC {
  constructor() {
    super(new sm(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class sC extends kc {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(On.DEFAULT_UP), this.updateMatrix(), this.target = new On(), this.shadow = new c9();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class S2 extends kc {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class A2 extends kc {
  constructor(e, t, n = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class M2 {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new q());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const n = e.x, i = e.y, r = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * i), t.addScaledVector(o[2], 0.488603 * r), t.addScaledVector(o[3], 0.488603 * n), t.addScaledVector(o[4], 1.092548 * (n * i)), t.addScaledVector(o[5], 1.092548 * (i * r)), t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(o[7], 1.092548 * (n * r)), t.addScaledVector(o[8], 0.546274 * (n * n - i * i)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const n = e.x, i = e.y, r = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 2 * 0.511664 * i), t.addScaledVector(o[2], 2 * 0.511664 * r), t.addScaledVector(o[3], 2 * 0.511664 * n), t.addScaledVector(o[4], 2 * 0.429043 * n * i), t.addScaledVector(o[5], 2 * 0.429043 * i * r), t.addScaledVector(o[6], 0.743125 * r * r - 0.247708), t.addScaledVector(o[7], 2 * 0.429043 * n * r), t.addScaledVector(o[8], 0.429043 * (n * n - i * i)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].toArray(e, t + i * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const n = e.x, i = e.y, r = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * r, t[3] = 0.488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = 0.546274 * (n * n - i * i);
  }
}
class E2 extends kc {
  constructor(e = new M2(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class vS extends Ms {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, n, i) {
    const r = this, o = new Pa(r.manager);
    o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(u) {
      try {
        t(r.parse(JSON.parse(u)));
      } catch (c) {
        i ? i(c) : console.error(c), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = this.textures;
    function n(r) {
      return t[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), t[r];
    }
    const i = vS.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new Tt().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const r in e.uniforms) {
        const o = e.uniforms[r];
        switch (i.uniforms[r] = {}, o.type) {
          case "t":
            i.uniforms[r].value = n(o.value);
            break;
          case "c":
            i.uniforms[r].value = new Tt().setHex(o.value);
            break;
          case "v2":
            i.uniforms[r].value = new qe().fromArray(o.value);
            break;
          case "v3":
            i.uniforms[r].value = new q().fromArray(o.value);
            break;
          case "v4":
            i.uniforms[r].value = new $n().fromArray(o.value);
            break;
          case "m3":
            i.uniforms[r].value = new Mn().fromArray(o.value);
            break;
          case "m4":
            i.uniforms[r].value = new sn().fromArray(o.value);
            break;
          default:
            i.uniforms[r].value = o.value;
        }
      }
    if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const r in e.extensions)
        i.extensions[r] = e.extensions[r];
    if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let r = e.normalScale;
      Array.isArray(r) === !1 && (r = [r, r]), i.normalScale = new qe().fromArray(r);
    }
    return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new qe().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: s2,
      SpriteMaterial: Gb,
      RawShaderMaterial: a2,
      ShaderMaterial: Cl,
      PointsMaterial: tS,
      MeshPhysicalMaterial: po,
      MeshStandardMaterial: $v,
      MeshPhongMaterial: o2,
      MeshToonMaterial: l2,
      MeshNormalMaterial: u2,
      MeshLambertMaterial: c2,
      MeshDepthMaterial: Nb,
      MeshDistanceMaterial: Ob,
      MeshBasicMaterial: Ra,
      MeshMatcapMaterial: f2,
      LineDashedMaterial: d2,
      LineBasicMaterial: As,
      Material: Mr
    };
    return new t[e]();
  }
}
class Rc {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class T2 extends pn {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class b2 extends Ms {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = new Pa(r.manager);
    o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(u) {
      try {
        t(r.parse(JSON.parse(u)));
      } catch (c) {
        i ? i(c) : console.error(c), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = {}, n = {};
    function i(y, S) {
      if (t[S] !== void 0) return t[S];
      const E = y.interleavedBuffers[S], M = r(y, E.buffer), w = Mp(E.type, M), C = new Kv(w, E.stride);
      return C.uuid = E.uuid, t[S] = C, C;
    }
    function r(y, S) {
      if (n[S] !== void 0) return n[S];
      const E = y.arrayBuffers[S], M = new Uint32Array(E).buffer;
      return n[S] = M, M;
    }
    const o = e.isInstancedBufferGeometry ? new T2() : new pn(), u = e.data.index;
    if (u !== void 0) {
      const y = Mp(u.type, u.array);
      o.setIndex(new Hn(y, 1));
    }
    const c = e.data.attributes;
    for (const y in c) {
      const S = c[y];
      let T;
      if (S.isInterleavedBufferAttribute) {
        const E = i(e.data, S.data);
        T = new Uc(E, S.itemSize, S.offset, S.normalized);
      } else {
        const E = Mp(S.type, S.array), M = S.isInstancedBufferAttribute ? md : Hn;
        T = new M(E, S.itemSize, S.normalized);
      }
      S.name !== void 0 && (T.name = S.name), S.usage !== void 0 && T.setUsage(S.usage), o.setAttribute(y, T);
    }
    const d = e.data.morphAttributes;
    if (d)
      for (const y in d) {
        const S = d[y], T = [];
        for (let E = 0, M = S.length; E < M; E++) {
          const w = S[E];
          let C;
          if (w.isInterleavedBufferAttribute) {
            const D = i(e.data, w.data);
            C = new Uc(D, w.itemSize, w.offset, w.normalized);
          } else {
            const D = Mp(w.type, w.array);
            C = new Hn(D, w.itemSize, w.normalized);
          }
          w.name !== void 0 && (C.name = w.name), T.push(C);
        }
        o.morphAttributes[y] = T;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const g = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (g !== void 0)
      for (let y = 0, S = g.length; y !== S; ++y) {
        const T = g[y];
        o.addGroup(T.start, T.count, T.materialIndex);
      }
    const v = e.data.boundingSphere;
    if (v !== void 0) {
      const y = new q();
      v.center !== void 0 && y.fromArray(v.center), o.boundingSphere = new Qr(y, v.radius);
    }
    return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
  }
}
class f9 extends Ms {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = this.path === "" ? Rc.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const u = new Pa(this.manager);
    u.setPath(this.path), u.setRequestHeader(this.requestHeader), u.setWithCredentials(this.withCredentials), u.load(e, function(c) {
      let d = null;
      try {
        d = JSON.parse(c);
      } catch (g) {
        i !== void 0 && i(g), console.error("THREE:ObjectLoader: Can't parse " + e + ".", g.message);
        return;
      }
      const p = d.metadata;
      if (p === void 0 || p.type === void 0 || p.type.toLowerCase() === "geometry") {
        i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      r.parse(d, t);
    }, n, i);
  }
  async loadAsync(e, t) {
    const n = this, i = this.path === "" ? Rc.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const r = new Pa(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
    const o = await r.loadAsync(e, t), u = JSON.parse(o), c = u.metadata;
    if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(u);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), o = this.parseImages(e.images, function() {
      t !== void 0 && t(d);
    }), u = this.parseTextures(e.textures, o), c = this.parseMaterials(e.materials, u), d = this.parseObject(e.object, r, c, u, n), p = this.parseSkeletons(e.skeletons, d);
    if (this.bindSkeletons(d, p), t !== void 0) {
      let g = !1;
      for (const v in o)
        if (o[v].data instanceof HTMLImageElement) {
          g = !0;
          break;
        }
      g === !1 && t(d);
    }
    return d;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, n), r = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, r), u = this.parseMaterials(e.materials, o), c = this.parseObject(e.object, i, u, o, t), d = this.parseSkeletons(e.skeletons, c);
    return this.bindSkeletons(c, d), c;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, i = e.length; n < i; n++) {
        const r = new sd().fromJSON(e[n]);
        t[r.uuid] = r;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {}, i = {};
    if (t.traverse(function(r) {
      r.isBone && (i[r.uuid] = r);
    }), e !== void 0)
      for (let r = 0, o = e.length; r < o; r++) {
        const u = new qv().fromJSON(e[r], i);
        n[u.uuid] = u;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const i = new b2();
      for (let r = 0, o = e.length; r < o; r++) {
        let u;
        const c = e[r];
        switch (c.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            u = i.parse(c);
            break;
          default:
            c.type in VB ? u = VB[c.type].fromJSON(c, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`);
        }
        u.uuid = c.uuid, c.name !== void 0 && (u.name = c.name), c.userData !== void 0 && (u.userData = c.userData), n[c.uuid] = u;
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {}, i = {};
    if (e !== void 0) {
      const r = new vS();
      r.setTextures(t);
      for (let o = 0, u = e.length; o < u; o++) {
        const c = e[o];
        n[c.uuid] === void 0 && (n[c.uuid] = r.parse(c)), i[c.uuid] = n[c.uuid];
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const i = e[n], r = Yp.parse(i);
        t[r.uuid] = r;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this, i = {};
    let r;
    function o(c) {
      return n.manager.itemStart(c), r.load(c, function() {
        n.manager.itemEnd(c);
      }, void 0, function() {
        n.manager.itemError(c), n.manager.itemEnd(c);
      });
    }
    function u(c) {
      if (typeof c == "string") {
        const d = c, p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : n.resourcePath + d;
        return o(p);
      } else
        return c.data ? {
          data: Mp(c.type, c.data),
          width: c.width,
          height: c.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const c = new tC(t);
      r = new Bv(c), r.setCrossOrigin(this.crossOrigin);
      for (let d = 0, p = e.length; d < p; d++) {
        const g = e[d], v = g.url;
        if (Array.isArray(v)) {
          const y = [];
          for (let S = 0, T = v.length; S < T; S++) {
            const E = v[S], M = u(E);
            M !== null && (M instanceof HTMLImageElement ? y.push(M) : y.push(new rd(M.data, M.width, M.height)));
          }
          i[g.uuid] = new qf(y);
        } else {
          const y = u(g.url);
          i[g.uuid] = new qf(y);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this, n = {};
    let i;
    async function r(o) {
      if (typeof o == "string") {
        const u = o, c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : t.resourcePath + u;
        return await i.loadAsync(c);
      } else
        return o.data ? {
          data: Mp(o.type, o.data),
          width: o.width,
          height: o.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      i = new Bv(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let o = 0, u = e.length; o < u; o++) {
        const c = e[o], d = c.url;
        if (Array.isArray(d)) {
          const p = [];
          for (let g = 0, v = d.length; g < v; g++) {
            const y = d[g], S = await r(y);
            S !== null && (S instanceof HTMLImageElement ? p.push(S) : p.push(new rd(S.data, S.width, S.height)));
          }
          n[c.uuid] = new qf(p);
        } else {
          const p = await r(c.url);
          n[c.uuid] = new qf(p);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(r, o) {
      return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), o[r]);
    }
    const i = {};
    if (e !== void 0)
      for (let r = 0, o = e.length; r < o; r++) {
        const u = e[r];
        u.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', u.uuid), t[u.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", u.image);
        const c = t[u.image], d = c.data;
        let p;
        Array.isArray(d) ? (p = new Xv(), d.length === 6 && (p.needsUpdate = !0)) : (d && d.data ? p = new rd() : p = new Ri(), d && (p.needsUpdate = !0)), p.source = c, p.uuid = u.uuid, u.name !== void 0 && (p.name = u.name), u.mapping !== void 0 && (p.mapping = n(u.mapping, d9)), u.channel !== void 0 && (p.channel = u.channel), u.offset !== void 0 && p.offset.fromArray(u.offset), u.repeat !== void 0 && p.repeat.fromArray(u.repeat), u.center !== void 0 && p.center.fromArray(u.center), u.rotation !== void 0 && (p.rotation = u.rotation), u.wrap !== void 0 && (p.wrapS = n(u.wrap[0], YB), p.wrapT = n(u.wrap[1], YB)), u.format !== void 0 && (p.format = u.format), u.internalFormat !== void 0 && (p.internalFormat = u.internalFormat), u.type !== void 0 && (p.type = u.type), u.colorSpace !== void 0 && (p.colorSpace = u.colorSpace), u.encoding !== void 0 && (p.encoding = u.encoding), u.minFilter !== void 0 && (p.minFilter = n(u.minFilter, KB)), u.magFilter !== void 0 && (p.magFilter = n(u.magFilter, KB)), u.anisotropy !== void 0 && (p.anisotropy = u.anisotropy), u.flipY !== void 0 && (p.flipY = u.flipY), u.generateMipmaps !== void 0 && (p.generateMipmaps = u.generateMipmaps), u.premultiplyAlpha !== void 0 && (p.premultiplyAlpha = u.premultiplyAlpha), u.unpackAlignment !== void 0 && (p.unpackAlignment = u.unpackAlignment), u.compareFunction !== void 0 && (p.compareFunction = u.compareFunction), u.userData !== void 0 && (p.userData = u.userData), i[u.uuid] = p;
      }
    return i;
  }
  parseObject(e, t, n, i, r) {
    let o;
    function u(v) {
      return t[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", v), t[v];
    }
    function c(v) {
      if (v !== void 0) {
        if (Array.isArray(v)) {
          const y = [];
          for (let S = 0, T = v.length; S < T; S++) {
            const E = v[S];
            n[E] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", E), y.push(n[E]);
          }
          return y;
        }
        return n[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), n[v];
      }
    }
    function d(v) {
      return i[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", v), i[v];
    }
    let p, g;
    switch (e.type) {
      case "Scene":
        o = new zb(), e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Tt(e.background) : o.background = d(e.background)), e.environment !== void 0 && (o.environment = d(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new $x(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new Zx(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        o = new Ar(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        o = new sm(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new S2(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new sC(e.color, e.intensity);
        break;
      case "PointLight":
        o = new rC(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new A2(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new iC(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        o = new x2(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new E2().fromJSON(e);
        break;
      case "SkinnedMesh":
        p = u(e.geometry), g = c(e.material), o = new kb(p, g), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        p = u(e.geometry), g = c(e.material), o = new ur(p, g);
        break;
      case "InstancedMesh":
        p = u(e.geometry), g = c(e.material);
        const v = e.count, y = e.instanceMatrix, S = e.instanceColor;
        o = new Vb(p, g, v), o.instanceMatrix = new md(new Float32Array(y.array), 16), S !== void 0 && (o.instanceColor = new md(new Float32Array(S.array), S.itemSize));
        break;
      case "BatchedMesh":
        p = u(e.geometry), g = c(e.material), o = new KP(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, g), o.geometry = p, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map((T) => {
          const E = new xs();
          E.min.fromArray(T.boxMin), E.max.fromArray(T.boxMax);
          const M = new Qr();
          return M.radius = T.sphereRadius, M.center.fromArray(T.sphereCenter), {
            boxInitialized: T.boxInitialized,
            box: E,
            sphereInitialized: T.sphereInitialized,
            sphere: M
          };
        }), o._maxGeometryCount = e.maxGeometryCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = d(e.matricesTexture.uuid);
        break;
      case "LOD":
        o = new YP();
        break;
      case "Line":
        o = new gu(u(e.geometry), c(e.material));
        break;
      case "LineLoop":
        o = new Wb(u(e.geometry), c(e.material));
        break;
      case "LineSegments":
        o = new Vo(u(e.geometry), c(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new Xb(u(e.geometry), c(e.material));
        break;
      case "Sprite":
        o = new JP(c(e.material));
        break;
      case "Group":
        o = new uu();
        break;
      case "Bone":
        o = new eS();
        break;
      default:
        o = new On();
    }
    if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
      const v = e.children;
      for (let y = 0; y < v.length; y++)
        o.add(this.parseObject(v[y], t, n, i, r));
    }
    if (e.animations !== void 0) {
      const v = e.animations;
      for (let y = 0; y < v.length; y++) {
        const S = v[y];
        o.animations.push(r[S]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const v = e.levels;
      for (let y = 0; y < v.length; y++) {
        const S = v[y], T = o.getObjectByProperty("uuid", S.object);
        T !== void 0 && o.addLevel(T, S.distance, S.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const i = t[n.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix);
      }
    });
  }
}
const d9 = {
  UVMapping: Xx,
  CubeReflectionMapping: mu,
  CubeRefractionMapping: Pc,
  EquirectangularReflectionMapping: vv,
  EquirectangularRefractionMapping: _v,
  CubeUVReflectionMapping: nm
}, YB = {
  RepeatWrapping: Ic,
  ClampToEdgeWrapping: qr,
  MirroredRepeatWrapping: Gp
}, KB = {
  NearestFilter: Oi,
  NearestMipmapNearestFilter: yv,
  NearestMipmapLinearFilter: Dp,
  LinearFilter: bi,
  LinearMipmapNearestFilter: Jx,
  LinearMipmapLinearFilter: Tl
};
class C2 extends Ms {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, o = cu.get(e);
    if (o !== void 0) {
      if (r.manager.itemStart(e), o.then) {
        o.then((d) => {
          t && t(d), r.manager.itemEnd(e);
        }).catch((d) => {
          i && i(d);
        });
        return;
      }
      return setTimeout(function() {
        t && t(o), r.manager.itemEnd(e);
      }, 0), o;
    }
    const u = {};
    u.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", u.headers = this.requestHeader;
    const c = fetch(e, u).then(function(d) {
      return d.blob();
    }).then(function(d) {
      return createImageBitmap(d, Object.assign(r.options, { colorSpaceConversion: "none" }));
    }).then(function(d) {
      return cu.add(e, d), t && t(d), r.manager.itemEnd(e), d;
    }).catch(function(d) {
      i && i(d), cu.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
    });
    cu.add(e, c), r.manager.itemStart(e);
  }
}
let D0;
class aC {
  static getContext() {
    return D0 === void 0 && (D0 = new (window.AudioContext || window.webkitAudioContext)()), D0;
  }
  static setContext(e) {
    D0 = e;
  }
}
class h9 extends Ms {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = new Pa(this.manager);
    o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(c) {
      try {
        const d = c.slice(0);
        aC.getContext().decodeAudioData(d, function(g) {
          t(g);
        }).catch(u);
      } catch (d) {
        u(d);
      }
    }, n, i);
    function u(c) {
      i ? i(c) : console.error(c), r.manager.itemError(e);
    }
  }
}
const qB = /* @__PURE__ */ new sn(), jB = /* @__PURE__ */ new sn(), Pf = /* @__PURE__ */ new sn();
class p9 {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Ar(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ar(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Pf.copy(e.projectionMatrix);
      const i = t.eyeSep / 2, r = i * t.near / t.focus, o = t.near * Math.tan(nd * t.fov * 0.5) / t.zoom;
      let u, c;
      jB.elements[12] = -i, qB.elements[12] = i, u = -o * t.aspect + r, c = o * t.aspect + r, Pf.elements[0] = 2 * t.near / (c - u), Pf.elements[8] = (c + u) / (c - u), this.cameraL.projectionMatrix.copy(Pf), u = -o * t.aspect - r, c = o * t.aspect - r, Pf.elements[0] = 2 * t.near / (c - u), Pf.elements[8] = (c + u) / (c - u), this.cameraR.projectionMatrix.copy(Pf);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(jB), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(qB);
  }
}
class oC {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = QB(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = QB();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function QB() {
  return (typeof performance > "u" ? Date : performance).now();
}
const If = /* @__PURE__ */ new q(), ZB = /* @__PURE__ */ new ys(), m9 = /* @__PURE__ */ new q(), Uf = /* @__PURE__ */ new q();
class g9 extends On {
  constructor() {
    super(), this.type = "AudioListener", this.context = aC.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new oC();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(If, ZB, m9), Uf.set(0, 0, -1).applyQuaternion(ZB), t.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(If.x, i), t.positionY.linearRampToValueAtTime(If.y, i), t.positionZ.linearRampToValueAtTime(If.z, i), t.forwardX.linearRampToValueAtTime(Uf.x, i), t.forwardY.linearRampToValueAtTime(Uf.y, i), t.forwardZ.linearRampToValueAtTime(Uf.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i);
    } else
      t.setPosition(If.x, If.y, If.z), t.setOrientation(Uf.x, Uf.y, Uf.z, n.x, n.y, n.z);
  }
}
class w2 extends On {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const Ff = /* @__PURE__ */ new q(), $B = /* @__PURE__ */ new ys(), v9 = /* @__PURE__ */ new q(), Nf = /* @__PURE__ */ new q();
class _9 extends w2 {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(Ff, $B, v9), Nf.set(0, 0, 1).applyQuaternion($B);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Ff.x, n), t.positionY.linearRampToValueAtTime(Ff.y, n), t.positionZ.linearRampToValueAtTime(Ff.z, n), t.orientationX.linearRampToValueAtTime(Nf.x, n), t.orientationY.linearRampToValueAtTime(Nf.y, n), t.orientationZ.linearRampToValueAtTime(Nf.z, n);
    } else
      t.setPosition(Ff.x, Ff.y, Ff.z), t.setOrientation(Nf.x, Nf.y, Nf.z);
  }
}
class y9 {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++)
      e += t[n];
    return e / t.length;
  }
}
class R2 {
  constructor(e, t, n) {
    this.binding = e, this.valueSize = n;
    let i, r, o;
    switch (t) {
      case "quaternion":
        i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
        break;
      default:
        i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const n = this.buffer, i = this.valueSize, r = e * i + i;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let u = 0; u !== i; ++u)
        n[r + u] = n[u];
      o = t;
    } else {
      o += t;
      const u = t / o;
      this._mixBufferRegion(n, r, 0, u, i);
    }
    this.cumulativeWeight = o;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, n = this.buffer, i = e * t + t, r = this.cumulativeWeight, o = this.cumulativeWeightAdditive, u = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
      const c = t * this._origIndex;
      this._mixBufferRegion(
        n,
        i,
        c,
        1 - r,
        t
      );
    }
    o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let c = t, d = t + t; c !== d; ++c)
      if (n[c] !== n[c + t]) {
        u.setValue(n, i);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
    e.getValue(t, i);
    for (let r = n, o = i; r !== o; ++r)
      t[r] = t[i + r % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  // mix functions
  _select(e, t, n, i, r) {
    if (i >= 0.5)
      for (let o = 0; o !== r; ++o)
        e[t + o] = e[n + o];
  }
  _slerp(e, t, n, i) {
    ys.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, r) {
    const o = this._workIndex * r;
    ys.multiplyQuaternionsFlat(e, o, e, t, e, n), ys.slerpFlat(e, t, e, t, e, o, i);
  }
  _lerp(e, t, n, i, r) {
    const o = 1 - i;
    for (let u = 0; u !== r; ++u) {
      const c = t + u;
      e[c] = e[c] * o + e[n + u] * i;
    }
  }
  _lerpAdditive(e, t, n, i, r) {
    for (let o = 0; o !== r; ++o) {
      const u = t + o;
      e[u] = e[u] + e[n + o] * i;
    }
  }
}
const lC = "\\[\\]\\.:\\/", x9 = new RegExp("[" + lC + "]", "g"), uC = "[^" + lC + "]", S9 = "[^" + lC.replace("\\.", "") + "]", A9 = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", uC), M9 = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", S9), E9 = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", uC), T9 = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", uC), b9 = new RegExp(
  "^" + A9 + M9 + E9 + T9 + "$"
), C9 = ["material", "materials", "bones", "map"];
class w9 {
  constructor(e, t, n) {
    const i = n || Nn.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, i);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Nn {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || Nn.parseTrackName(t), this.node = Nn.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new Nn.Composite(e, t, n) : new Nn(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(x9, "");
  }
  static parseTrackName(e) {
    const t = b9.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const r = n.nodeName.substring(i + 1);
      C9.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(r) {
        for (let o = 0; o < r.length; o++) {
          const u = r[o];
          if (u.name === t || u.uuid === t)
            return u;
          const c = n(u.children);
          if (c) return c;
        }
        return null;
      }, i = n(e.children);
      if (i)
        return i;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, i = t.propertyName;
    let r = t.propertyIndex;
    if (e || (e = Nn.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let d = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let p = 0; p < e.length; p++)
            if (e[p].name === d) {
              d = p;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (d !== void 0) {
        if (e[d] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[d];
      }
    }
    const o = e[i];
    if (o === void 0) {
      const d = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + d + "." + i + " but it wasn't found.", e);
      return;
    }
    let u = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? u = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (u = this.Versioning.MatrixWorldNeedsUpdate);
    let c = this.BindingType.Direct;
    if (r !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
      }
      c = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][u];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Nn.Composite = w9;
Nn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Nn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Nn.prototype.GetterByBindingType = [
  Nn.prototype._getValue_direct,
  Nn.prototype._getValue_array,
  Nn.prototype._getValue_arrayElement,
  Nn.prototype._getValue_toArray
];
Nn.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Nn.prototype._setValue_direct,
    Nn.prototype._setValue_direct_setNeedsUpdate,
    Nn.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Nn.prototype._setValue_array,
    Nn.prototype._setValue_array_setNeedsUpdate,
    Nn.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Nn.prototype._setValue_arrayElement,
    Nn.prototype._setValue_arrayElement_setNeedsUpdate,
    Nn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Nn.prototype._setValue_fromArray,
    Nn.prototype._setValue_fromArray_setNeedsUpdate,
    Nn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class R9 {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = Da(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, i = arguments.length; n !== i; ++n)
      e[arguments[n].uuid] = n;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, r = this._bindings, o = r.length;
    let u, c = e.length, d = this.nCachedObjects_;
    for (let p = 0, g = arguments.length; p !== g; ++p) {
      const v = arguments[p], y = v.uuid;
      let S = t[y];
      if (S === void 0) {
        S = c++, t[y] = S, e.push(v);
        for (let T = 0, E = o; T !== E; ++T)
          r[T].push(new Nn(v, n[T], i[T]));
      } else if (S < d) {
        u = e[S];
        const T = --d, E = e[T];
        t[E.uuid] = S, e[S] = E, t[y] = T, e[T] = v;
        for (let M = 0, w = o; M !== w; ++M) {
          const C = r[M], D = C[T];
          let N = C[S];
          C[S] = D, N === void 0 && (N = new Nn(v, n[M], i[M])), C[T] = N;
        }
      } else e[S] !== u && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = d;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let r = this.nCachedObjects_;
    for (let o = 0, u = arguments.length; o !== u; ++o) {
      const c = arguments[o], d = c.uuid, p = t[d];
      if (p !== void 0 && p >= r) {
        const g = r++, v = e[g];
        t[v.uuid] = p, e[p] = v, t[d] = g, e[g] = c;
        for (let y = 0, S = i; y !== S; ++y) {
          const T = n[y], E = T[g], M = T[p];
          T[p] = E, T[g] = M;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let r = this.nCachedObjects_, o = e.length;
    for (let u = 0, c = arguments.length; u !== c; ++u) {
      const d = arguments[u], p = d.uuid, g = t[p];
      if (g !== void 0)
        if (delete t[p], g < r) {
          const v = --r, y = e[v], S = --o, T = e[S];
          t[y.uuid] = g, e[g] = y, t[T.uuid] = v, e[v] = T, e.pop();
          for (let E = 0, M = i; E !== M; ++E) {
            const w = n[E], C = w[v], D = w[S];
            w[g] = C, w[v] = D, w.pop();
          }
        } else {
          const v = --o, y = e[v];
          v > 0 && (t[y.uuid] = g), e[g] = y, e.pop();
          for (let S = 0, T = i; S !== T; ++S) {
            const E = n[S];
            E[g] = E[v], E.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let i = n[e];
    const r = this._bindings;
    if (i !== void 0) return r[i];
    const o = this._paths, u = this._parsedPaths, c = this._objects, d = c.length, p = this.nCachedObjects_, g = new Array(d);
    i = r.length, n[e] = i, o.push(e), u.push(t), r.push(g);
    for (let v = p, y = c.length; v !== y; ++v) {
      const S = c[v];
      g[v] = new Nn(S, e, t);
    }
    return g;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (n !== void 0) {
      const i = this._paths, r = this._parsedPaths, o = this._bindings, u = o.length - 1, c = o[u], d = e[u];
      t[d] = n, o[n] = c, o.pop(), r[n] = r[u], r.pop(), i[n] = i[u], i.pop();
    }
  }
}
class B2 {
  constructor(e, t, n = null, i = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
    const r = t.tracks, o = r.length, u = new Array(o), c = {
      endingStart: Yf,
      endingEnd: Yf
    };
    for (let d = 0; d !== o; ++d) {
      const p = r[d].createInterpolant(null);
      u[d] = p, p.settings = c;
    }
    this._interpolantSettings = c, this._interpolants = u, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = mP, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const i = this._clip.duration, r = e._clip.duration, o = r / i, u = i / r;
      e.warp(1, o, t), this.warp(u, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer, r = i.time, o = this.timeScale;
    let u = this._timeScaleInterpolant;
    u === null && (u = i._lendControlInterpolant(), this._timeScaleInterpolant = u);
    const c = u.parameterPositions, d = u.sampleValues;
    return c[0] = r, c[1] = r + n, d[0] = e / o, d[1] = t / o, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const c = (e - r) * n;
      c < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * c);
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t), u = this._updateWeight(e);
    if (u > 0) {
      const c = this._interpolants, d = this._propertyBindings;
      switch (this.blendMode) {
        case bb:
          for (let p = 0, g = c.length; p !== g; ++p)
            c[p].evaluate(o), d[p].accumulateAdditive(u);
          break;
        case Kx:
        default:
          for (let p = 0, g = c.length; p !== g; ++p)
            c[p].evaluate(o), d[p].accumulate(i, u);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let i = this.time + e, r = this._loopCount;
    const o = n === gP;
    if (e === 0)
      return r === -1 ? i : o && (r & 1) === 1 ? t - i : i;
    if (n === pP) {
      r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (i >= t)
          i = t;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), i >= t || i < 0) {
        const u = Math.floor(i / t);
        i -= t * u, r += Math.abs(u);
        const c = this.repetitions - r;
        if (c <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (c === 1) {
            const d = e < 0;
            this._setEndings(d, !d, o);
          } else
            this._setEndings(!1, !1, o);
          this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: u
          });
        }
      } else
        this.time = i;
      if (o && (r & 1) === 1)
        return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n ? (i.endingStart = Kf, i.endingEnd = Kf) : (e ? i.endingStart = this.zeroSlopeAtStart ? Kf : Yf : i.endingStart = xv, t ? i.endingEnd = this.zeroSlopeAtEnd ? Kf : Yf : i.endingEnd = xv);
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer, r = i.time;
    let o = this._weightInterpolant;
    o === null && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
    const u = o.parameterPositions, c = o.sampleValues;
    return u[0] = r, c[0] = t, u[1] = r + e, c[1] = n, this;
  }
}
const B9 = new Float32Array(1);
class D9 extends yu {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, i = e._clip.tracks, r = i.length, o = e._propertyBindings, u = e._interpolants, c = n.uuid, d = this._bindingsByRootAndName;
    let p = d[c];
    p === void 0 && (p = {}, d[c] = p);
    for (let g = 0; g !== r; ++g) {
      const v = i[g], y = v.name;
      let S = p[y];
      if (S !== void 0)
        ++S.referenceCount, o[g] = S;
      else {
        if (S = o[g], S !== void 0) {
          S._cacheIndex === null && (++S.referenceCount, this._addInactiveBinding(S, c, y));
          continue;
        }
        const T = t && t._propertyBindings[g].binding.parsedPath;
        S = new R2(
          Nn.create(n, y, T),
          v.ValueTypeName,
          v.getValueSize()
        ), ++S.referenceCount, this._addInactiveBinding(S, c, y), o[g] = S;
      }
      u[g].resultBuffer = S.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid, i = e._clip.uuid, r = this._actionsByClip[i];
        this._bindAction(
          e,
          r && r.knownActions[0]
        ), this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions, r = this._actionsByClip;
    let o = r[t];
    if (o === void 0)
      o = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = o;
    else {
      const u = o.knownActions;
      e._byClipCacheIndex = u.length, u.push(e);
    }
    e._cacheIndex = i.length, i.push(e), o.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
    const r = e._clip.uuid, o = this._actionsByClip, u = o[r], c = u.knownActions, d = c[c.length - 1], p = e._byClipCacheIndex;
    d._byClipCacheIndex = p, c[p] = d, c.pop(), e._byClipCacheIndex = null;
    const g = u.actionByRoot, v = (e._localRoot || this._root).uuid;
    delete g[v], c.length === 0 && delete o[r], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const r = t[n];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName, r = this._bindings;
    let o = i[t];
    o === void 0 && (o = {}, i[t] = o), o[n] = e, e._cacheIndex = r.length, r.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, i = n.rootNode.uuid, r = n.path, o = this._bindingsByRootAndName, u = o[i], c = t[t.length - 1], d = e._cacheIndex;
    c._cacheIndex = d, t[d] = c, t.pop(), delete u[r], Object.keys(u).length === 0 && delete o[i];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return n === void 0 && (n = new $b(
      new Float32Array(2),
      new Float32Array(2),
      1,
      B9
    ), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, r = t[i];
    e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, n) {
    const i = t || this._root, r = i.uuid;
    let o = typeof e == "string" ? Yp.findByName(i, e) : e;
    const u = o !== null ? o.uuid : e, c = this._actionsByClip[u];
    let d = null;
    if (n === void 0 && (o !== null ? n = o.blendMode : n = Kx), c !== void 0) {
      const g = c.actionByRoot[r];
      if (g !== void 0 && g.blendMode === n)
        return g;
      d = c.knownActions[0], o === null && (o = d._clip);
    }
    if (o === null) return null;
    const p = new B2(this, o, t, n);
    return this._bindAction(p, d), this._addInactiveAction(p, u, r), p;
  }
  // get an existing action
  existingAction(e, t) {
    const n = t || this._root, i = n.uuid, r = typeof e == "string" ? Yp.findByName(n, e) : e, o = r ? r.uuid : e, u = this._actionsByClip[o];
    return u !== void 0 && u.actionByRoot[i] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n)
      e[n].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1;
    for (let d = 0; d !== n; ++d)
      t[d]._update(i, e, r, o);
    const u = this._bindings, c = this._nActiveBindings;
    for (let d = 0; d !== c; ++d)
      u[d].apply(o);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, i = this._actionsByClip, r = i[n];
    if (r !== void 0) {
      const o = r.knownActions;
      for (let u = 0, c = o.length; u !== c; ++u) {
        const d = o[u];
        this._deactivateAction(d);
        const p = d._cacheIndex, g = t[t.length - 1];
        d._cacheIndex = null, d._byClipCacheIndex = null, g._cacheIndex = p, t[p] = g, t.pop(), this._removeInactiveBindingsForAction(d);
      }
      delete i[n];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const o in n) {
      const u = n[o].actionByRoot, c = u[t];
      c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c));
    }
    const i = this._bindingsByRootAndName, r = i[t];
    if (r !== void 0)
      for (const o in r) {
        const u = r[o];
        u.restoreOriginalState(), this._removeInactiveBinding(u);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class cC {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new cC(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let L9 = 0;
class P9 extends yu {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: L9++ }), this.name = "", this.usage = Ev, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let o = 0; o < r.length; o++)
        this.uniforms.push(r[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class I9 extends Kv {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class U9 {
  constructor(e, t, n, i, r) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class D2 {
  constructor(e, t, n = 0, i = 1 / 0) {
    this.ray = new im(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new id(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, n = []) {
    return kT(e, this, n, t), n.sort(eD), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, r = e.length; i < r; i++)
      kT(e[i], this, n, t);
    return n.sort(eD), n;
  }
}
function eD(s, e) {
  return s.distance - e.distance;
}
function kT(s, e, t, n) {
  if (s.layers.test(e.layers) && s.raycast(e, t), n === !0) {
    const i = s.children;
    for (let r = 0, o = i.length; r < o; r++)
      kT(i[r], e, t, !0);
  }
}
class F9 {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Hi(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class N9 {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const tD = /* @__PURE__ */ new qe();
class O9 {
  constructor(e = new qe(1 / 0, 1 / 0), t = new qe(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = tD.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, tD).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const nD = /* @__PURE__ */ new q(), L0 = /* @__PURE__ */ new q();
class H9 {
  constructor(e = new q(), t = new q()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    nD.subVectors(e, this.start), L0.subVectors(this.end, this.start);
    const n = L0.dot(L0);
    let r = L0.dot(nD) / n;
    return t && (r = Hi(r, 0, 1)), r;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const iD = /* @__PURE__ */ new q();
class z9 extends On {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const n = new pn(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let o = 0, u = 1, c = 32; o < c; o++, u++) {
      const d = o / c * Math.PI * 2, p = u / c * Math.PI * 2;
      i.push(
        Math.cos(d),
        Math.sin(d),
        1,
        Math.cos(p),
        Math.sin(p),
        1
      );
    }
    n.setAttribute("position", new Kt(i, 3));
    const r = new As({ fog: !1, toneMapped: !1 });
    this.cone = new Vo(n, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), iD.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(iD), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const hc = /* @__PURE__ */ new q(), P0 = /* @__PURE__ */ new sn(), yE = /* @__PURE__ */ new sn();
class G9 extends Vo {
  constructor(e) {
    const t = L2(e), n = new pn(), i = [], r = [], o = new Tt(0, 0, 1), u = new Tt(0, 1, 0);
    for (let d = 0; d < t.length; d++) {
      const p = t[d];
      p.parent && p.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(u.r, u.g, u.b));
    }
    n.setAttribute("position", new Kt(i, 3)), n.setAttribute("color", new Kt(r, 3));
    const c = new As({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(n, c), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, n = this.geometry, i = n.getAttribute("position");
    yE.copy(this.root.matrixWorld).invert();
    for (let r = 0, o = 0; r < t.length; r++) {
      const u = t[r];
      u.parent && u.parent.isBone && (P0.multiplyMatrices(yE, u.matrixWorld), hc.setFromMatrixPosition(P0), i.setXYZ(o, hc.x, hc.y, hc.z), P0.multiplyMatrices(yE, u.parent.matrixWorld), hc.setFromMatrixPosition(P0), i.setXYZ(o + 1, hc.x, hc.y, hc.z), o += 2);
    }
    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function L2(s) {
  const e = [];
  s.isBone === !0 && e.push(s);
  for (let t = 0; t < s.children.length; t++)
    e.push.apply(e, L2(s.children[t]));
  return e;
}
class k9 extends ur {
  constructor(e, t, n) {
    const i = new Zv(t, 4, 2), r = new Ra({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, r), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const V9 = /* @__PURE__ */ new q(), rD = /* @__PURE__ */ new Tt(), sD = /* @__PURE__ */ new Tt();
class W9 extends On {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
    const i = new Qv(t);
    i.rotateY(Math.PI * 0.5), this.material = new Ra({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = i.getAttribute("position"), o = new Float32Array(r.count * 3);
    i.setAttribute("color", new Hn(o, 3)), this.add(new ur(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      rD.copy(this.light.color), sD.copy(this.light.groundColor);
      for (let n = 0, i = t.count; n < i; n++) {
        const r = n < i / 2 ? rD : sD;
        t.setXYZ(n, r.r, r.g, r.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(V9.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class X9 extends Vo {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    n = new Tt(n), i = new Tt(i);
    const r = t / 2, o = e / t, u = e / 2, c = [], d = [];
    for (let v = 0, y = 0, S = -u; v <= t; v++, S += o) {
      c.push(-u, 0, S, u, 0, S), c.push(S, 0, -u, S, 0, u);
      const T = v === r ? n : i;
      T.toArray(d, y), y += 3, T.toArray(d, y), y += 3, T.toArray(d, y), y += 3, T.toArray(d, y), y += 3;
    }
    const p = new pn();
    p.setAttribute("position", new Kt(c, 3)), p.setAttribute("color", new Kt(d, 3));
    const g = new As({ vertexColors: !0, toneMapped: !1 });
    super(p, g), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class J9 extends Vo {
  constructor(e = 10, t = 16, n = 8, i = 64, r = 4473924, o = 8947848) {
    r = new Tt(r), o = new Tt(o);
    const u = [], c = [];
    if (t > 1)
      for (let g = 0; g < t; g++) {
        const v = g / t * (Math.PI * 2), y = Math.sin(v) * e, S = Math.cos(v) * e;
        u.push(0, 0, 0), u.push(y, 0, S);
        const T = g & 1 ? r : o;
        c.push(T.r, T.g, T.b), c.push(T.r, T.g, T.b);
      }
    for (let g = 0; g < n; g++) {
      const v = g & 1 ? r : o, y = e - e / n * g;
      for (let S = 0; S < i; S++) {
        let T = S / i * (Math.PI * 2), E = Math.sin(T) * y, M = Math.cos(T) * y;
        u.push(E, 0, M), c.push(v.r, v.g, v.b), T = (S + 1) / i * (Math.PI * 2), E = Math.sin(T) * y, M = Math.cos(T) * y, u.push(E, 0, M), c.push(v.r, v.g, v.b);
      }
    }
    const d = new pn();
    d.setAttribute("position", new Kt(u, 3)), d.setAttribute("color", new Kt(c, 3));
    const p = new As({ vertexColors: !0, toneMapped: !1 });
    super(d, p), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const aD = /* @__PURE__ */ new q(), I0 = /* @__PURE__ */ new q(), oD = /* @__PURE__ */ new q();
class Y9 extends On {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let i = new pn();
    i.setAttribute("position", new Kt([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const r = new As({ fog: !1, toneMapped: !1 });
    this.lightPlane = new gu(i, r), this.add(this.lightPlane), i = new pn(), i.setAttribute("position", new Kt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new gu(i, r), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), aD.setFromMatrixPosition(this.light.matrixWorld), I0.setFromMatrixPosition(this.light.target.matrixWorld), oD.subVectors(I0, aD), this.lightPlane.lookAt(I0), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(I0), this.targetLine.scale.z = oD.length();
  }
}
const U0 = /* @__PURE__ */ new q(), Ni = /* @__PURE__ */ new Wv();
class K9 extends Vo {
  constructor(e) {
    const t = new pn(), n = new As({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], r = [], o = {};
    u("n1", "n2"), u("n2", "n4"), u("n4", "n3"), u("n3", "n1"), u("f1", "f2"), u("f2", "f4"), u("f4", "f3"), u("f3", "f1"), u("n1", "f1"), u("n2", "f2"), u("n3", "f3"), u("n4", "f4"), u("p", "n1"), u("p", "n2"), u("p", "n3"), u("p", "n4"), u("u1", "u2"), u("u2", "u3"), u("u3", "u1"), u("c", "t"), u("p", "c"), u("cn1", "cn2"), u("cn3", "cn4"), u("cf1", "cf2"), u("cf3", "cf4");
    function u(S, T) {
      c(S), c(T);
    }
    function c(S) {
      i.push(0, 0, 0), r.push(0, 0, 0), o[S] === void 0 && (o[S] = []), o[S].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new Kt(i, 3)), t.setAttribute("color", new Kt(r, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
    const d = new Tt(16755200), p = new Tt(16711680), g = new Tt(43775), v = new Tt(16777215), y = new Tt(3355443);
    this.setColors(d, p, g, v, y);
  }
  setColors(e, t, n, i, r) {
    const u = this.geometry.getAttribute("color");
    u.setXYZ(0, e.r, e.g, e.b), u.setXYZ(1, e.r, e.g, e.b), u.setXYZ(2, e.r, e.g, e.b), u.setXYZ(3, e.r, e.g, e.b), u.setXYZ(4, e.r, e.g, e.b), u.setXYZ(5, e.r, e.g, e.b), u.setXYZ(6, e.r, e.g, e.b), u.setXYZ(7, e.r, e.g, e.b), u.setXYZ(8, e.r, e.g, e.b), u.setXYZ(9, e.r, e.g, e.b), u.setXYZ(10, e.r, e.g, e.b), u.setXYZ(11, e.r, e.g, e.b), u.setXYZ(12, e.r, e.g, e.b), u.setXYZ(13, e.r, e.g, e.b), u.setXYZ(14, e.r, e.g, e.b), u.setXYZ(15, e.r, e.g, e.b), u.setXYZ(16, e.r, e.g, e.b), u.setXYZ(17, e.r, e.g, e.b), u.setXYZ(18, e.r, e.g, e.b), u.setXYZ(19, e.r, e.g, e.b), u.setXYZ(20, e.r, e.g, e.b), u.setXYZ(21, e.r, e.g, e.b), u.setXYZ(22, e.r, e.g, e.b), u.setXYZ(23, e.r, e.g, e.b), u.setXYZ(24, t.r, t.g, t.b), u.setXYZ(25, t.r, t.g, t.b), u.setXYZ(26, t.r, t.g, t.b), u.setXYZ(27, t.r, t.g, t.b), u.setXYZ(28, t.r, t.g, t.b), u.setXYZ(29, t.r, t.g, t.b), u.setXYZ(30, t.r, t.g, t.b), u.setXYZ(31, t.r, t.g, t.b), u.setXYZ(32, n.r, n.g, n.b), u.setXYZ(33, n.r, n.g, n.b), u.setXYZ(34, n.r, n.g, n.b), u.setXYZ(35, n.r, n.g, n.b), u.setXYZ(36, n.r, n.g, n.b), u.setXYZ(37, n.r, n.g, n.b), u.setXYZ(38, i.r, i.g, i.b), u.setXYZ(39, i.r, i.g, i.b), u.setXYZ(40, r.r, r.g, r.b), u.setXYZ(41, r.r, r.g, r.b), u.setXYZ(42, r.r, r.g, r.b), u.setXYZ(43, r.r, r.g, r.b), u.setXYZ(44, r.r, r.g, r.b), u.setXYZ(45, r.r, r.g, r.b), u.setXYZ(46, r.r, r.g, r.b), u.setXYZ(47, r.r, r.g, r.b), u.setXYZ(48, r.r, r.g, r.b), u.setXYZ(49, r.r, r.g, r.b), u.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, n = 1, i = 1;
    Ni.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), qi("c", t, e, Ni, 0, 0, -1), qi("t", t, e, Ni, 0, 0, 1), qi("n1", t, e, Ni, -n, -i, -1), qi("n2", t, e, Ni, n, -i, -1), qi("n3", t, e, Ni, -n, i, -1), qi("n4", t, e, Ni, n, i, -1), qi("f1", t, e, Ni, -n, -i, 1), qi("f2", t, e, Ni, n, -i, 1), qi("f3", t, e, Ni, -n, i, 1), qi("f4", t, e, Ni, n, i, 1), qi("u1", t, e, Ni, n * 0.7, i * 1.1, -1), qi("u2", t, e, Ni, -n * 0.7, i * 1.1, -1), qi("u3", t, e, Ni, 0, i * 2, -1), qi("cf1", t, e, Ni, -n, 0, 1), qi("cf2", t, e, Ni, n, 0, 1), qi("cf3", t, e, Ni, 0, -i, 1), qi("cf4", t, e, Ni, 0, i, 1), qi("cn1", t, e, Ni, -n, 0, -1), qi("cn2", t, e, Ni, n, 0, -1), qi("cn3", t, e, Ni, 0, -i, -1), qi("cn4", t, e, Ni, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function qi(s, e, t, n, i, r, o) {
  U0.set(i, r, o).unproject(n);
  const u = e[s];
  if (u !== void 0) {
    const c = t.getAttribute("position");
    for (let d = 0, p = u.length; d < p; d++)
      c.setXYZ(u[d], U0.x, U0.y, U0.z);
  }
}
const F0 = /* @__PURE__ */ new xs();
class q9 extends Vo {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(24), r = new pn();
    r.setIndex(new Hn(n, 1)), r.setAttribute("position", new Hn(i, 3)), super(r, new As({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && F0.setFromObject(this.object), F0.isEmpty()) return;
    const t = F0.min, n = F0.max, i = this.geometry.attributes.position, r = i.array;
    r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class j9 extends Vo {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], r = new pn();
    r.setIndex(new Hn(n, 1)), r.setAttribute("position", new Kt(i, 3)), super(r, new As({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Q9 extends gu {
  constructor(e, t = 1, n = 16776960) {
    const i = n, r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new pn();
    o.setAttribute("position", new Kt(r, 3)), o.computeBoundingSphere(), super(o, new As({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const u = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], c = new pn();
    c.setAttribute("position", new Kt(u, 3)), c.computeBoundingSphere(), this.add(new ur(c, new Ra({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const lD = /* @__PURE__ */ new q();
let N0, xE;
class Z9 extends On {
  // dir is assumed to be normalized
  constructor(e = new q(0, 0, 1), t = new q(0, 0, 0), n = 1, i = 16776960, r = n * 0.2, o = r * 0.2) {
    super(), this.type = "ArrowHelper", N0 === void 0 && (N0 = new pn(), N0.setAttribute("position", new Kt([0, 0, 0, 0, 1, 0], 3)), xE = new om(0, 0.5, 1, 5, 1), xE.translate(0, -0.5, 0)), this.position.copy(t), this.line = new gu(N0, new As({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ur(xE, new Ra({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, o);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      lD.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(lD, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class $9 extends Vo {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new pn();
    i.setAttribute("position", new Kt(t, 3)), i.setAttribute("color", new Kt(n, 3));
    const r = new As({ vertexColors: !0, toneMapped: !1 });
    super(i, r), this.type = "AxesHelper";
  }
  setColors(e, t, n) {
    const i = new Tt(), r = this.geometry.attributes.color.array;
    return i.set(e), i.toArray(r, 0), i.toArray(r, 3), i.set(t), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class e5 {
  constructor() {
    this.type = "ShapePath", this.color = new Tt(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new bv(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
  }
  bezierCurveTo(e, t, n, i, r, o) {
    return this.currentPath.bezierCurveTo(e, t, n, i, r, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(M) {
      const w = [];
      for (let C = 0, D = M.length; C < D; C++) {
        const N = M[C], U = new sd();
        U.curves = N.curves, w.push(U);
      }
      return w;
    }
    function n(M, w) {
      const C = w.length;
      let D = !1;
      for (let N = C - 1, U = 0; U < C; N = U++) {
        let O = w[N], V = w[U], L = V.x - O.x, I = V.y - O.y;
        if (Math.abs(I) > Number.EPSILON) {
          if (I < 0 && (O = w[U], L = -L, V = w[N], I = -I), M.y < O.y || M.y > V.y) continue;
          if (M.y === O.y) {
            if (M.x === O.x) return !0;
          } else {
            const Y = I * (M.x - O.x) - L * (M.y - O.y);
            if (Y === 0) return !0;
            if (Y < 0) continue;
            D = !D;
          }
        } else {
          if (M.y !== O.y) continue;
          if (V.x <= M.x && M.x <= O.x || O.x <= M.x && M.x <= V.x) return !0;
        }
      }
      return D;
    }
    const i = Al.isClockWise, r = this.subPaths;
    if (r.length === 0) return [];
    let o, u, c;
    const d = [];
    if (r.length === 1)
      return u = r[0], c = new sd(), c.curves = u.curves, d.push(c), d;
    let p = !i(r[0].getPoints());
    p = e ? !p : p;
    const g = [], v = [];
    let y = [], S = 0, T;
    v[S] = void 0, y[S] = [];
    for (let M = 0, w = r.length; M < w; M++)
      u = r[M], T = u.getPoints(), o = i(T), o = e ? !o : o, o ? (!p && v[S] && S++, v[S] = { s: new sd(), p: T }, v[S].s.curves = u.curves, p && S++, y[S] = []) : y[S].push({ h: u, p: T[0] });
    if (!v[0]) return t(r);
    if (v.length > 1) {
      let M = !1, w = 0;
      for (let C = 0, D = v.length; C < D; C++)
        g[C] = [];
      for (let C = 0, D = v.length; C < D; C++) {
        const N = y[C];
        for (let U = 0; U < N.length; U++) {
          const O = N[U];
          let V = !0;
          for (let L = 0; L < v.length; L++)
            n(O.p, v[L].p) && (C !== L && w++, V ? (V = !1, g[L].push(O)) : M = !0);
          V && g[C].push(O);
        }
      }
      w > 0 && M === !1 && (y = g);
    }
    let E;
    for (let M = 0, w = v.length; M < w; M++) {
      c = v[M].s, d.push(c), E = y[M];
      for (let C = 0, D = E.length; C < D; C++)
        c.holes.push(E[C].h);
    }
    return d;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Gv
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Gv);
const t5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: _b,
  AddEquation: yc,
  AddOperation: $L,
  AdditiveAnimationBlendMode: bb,
  AdditiveBlending: nT,
  AgXToneMapping: rP,
  AlphaFormat: lP,
  AlwaysCompare: CP,
  AlwaysDepth: JL,
  AlwaysStencilFunc: PT,
  AmbientLight: S2,
  AnimationAction: B2,
  AnimationClip: Yp,
  AnimationLoader: r9,
  AnimationMixer: D9,
  AnimationObjectGroup: R9,
  AnimationUtils: e9,
  ArcCurve: qP,
  ArrayCamera: VP,
  ArrowHelper: Z9,
  AttachedBindMode: oT,
  Audio: w2,
  AudioAnalyser: y9,
  AudioContext: aC,
  AudioListener: g9,
  AudioLoader: h9,
  AxesHelper: $9,
  BackSide: zs,
  BasicDepthPacking: _P,
  BasicShadowMap: wL,
  BatchedMesh: KP,
  Bone: eS,
  BooleanKeyframeTrack: Ed,
  Box2: O9,
  Box3: xs,
  Box3Helper: j9,
  BoxGeometry: Md,
  BoxHelper: q9,
  BufferAttribute: Hn,
  BufferGeometry: pn,
  BufferGeometryLoader: b2,
  ByteType: aP,
  Cache: cu,
  Camera: Wv,
  CameraHelper: K9,
  CanvasTexture: E4,
  CapsuleGeometry: rS,
  CatmullRomCurve3: jP,
  CineonToneMapping: nP,
  CircleGeometry: sS,
  ClampToEdgeWrapping: qr,
  Clock: oC,
  Color: Tt,
  ColorKeyframeTrack: eC,
  ColorManagement: Zn,
  CompressedArrayTexture: A4,
  CompressedCubeTexture: M4,
  CompressedTexture: nS,
  CompressedTextureLoader: s9,
  ConeGeometry: aS,
  ConstantAlphaFactor: VL,
  ConstantColorFactor: GL,
  CubeCamera: IP,
  CubeReflectionMapping: mu,
  CubeRefractionMapping: Pc,
  CubeTexture: Xv,
  CubeTextureLoader: a9,
  CubeUVReflectionMapping: nm,
  CubicBezierCurve: Yb,
  CubicBezierCurve3: QP,
  CubicInterpolant: m2,
  CullFaceBack: tT,
  CullFaceFront: CL,
  CullFaceFrontBack: m3,
  CullFaceNone: bL,
  Curve: Wo,
  CurvePath: $P,
  CustomBlending: RL,
  CustomToneMapping: iP,
  CylinderGeometry: om,
  Cylindrical: N9,
  Data3DTexture: Lb,
  DataArrayTexture: jx,
  DataTexture: rd,
  DataTextureLoader: o9,
  DataUtils: SH,
  DecrementStencilOp: E3,
  DecrementWrapStencilOp: b3,
  DefaultLoadingManager: _2,
  DepthFormat: Cc,
  DepthStencilFormat: hd,
  DepthTexture: Fb,
  DetachedBindMode: sP,
  DirectionalLight: sC,
  DirectionalLightHelper: Y9,
  DiscreteInterpolant: g2,
  DisplayP3ColorSpace: qx,
  DodecahedronGeometry: oS,
  DoubleSide: Ho,
  DstAlphaFactor: FL,
  DstColorFactor: OL,
  DynamicCopyUsage: G3,
  DynamicDrawUsage: U3,
  DynamicReadUsage: O3,
  EdgesGeometry: e2,
  EllipseCurve: iS,
  EqualCompare: MP,
  EqualDepth: KL,
  EqualStencilFunc: B3,
  EquirectangularReflectionMapping: vv,
  EquirectangularRefractionMapping: _v,
  Euler: rm,
  EventDispatcher: yu,
  ExtrudeGeometry: uS,
  FileLoader: Pa,
  Float16BufferAttribute: CH,
  Float32BufferAttribute: Kt,
  Float64BufferAttribute: wH,
  FloatType: zo,
  Fog: $x,
  FogExp2: Zx,
  FramebufferTexture: S4,
  FrontSide: El,
  Frustum: Jv,
  GLBufferAttribute: U9,
  GLSL1: V3,
  GLSL3: IT,
  GreaterCompare: EP,
  GreaterDepth: jL,
  GreaterEqualCompare: bP,
  GreaterEqualDepth: qL,
  GreaterEqualStencilFunc: I3,
  GreaterStencilFunc: L3,
  GridHelper: X9,
  Group: uu,
  HalfFloatType: kp,
  HemisphereLight: x2,
  HemisphereLightHelper: W9,
  IcosahedronGeometry: cS,
  ImageBitmapLoader: C2,
  ImageLoader: Bv,
  ImageUtils: Db,
  IncrementStencilOp: M3,
  IncrementWrapStencilOp: T3,
  InstancedBufferAttribute: md,
  InstancedBufferGeometry: T2,
  InstancedInterleavedBuffer: I9,
  InstancedMesh: Vb,
  Int16BufferAttribute: TH,
  Int32BufferAttribute: bH,
  Int8BufferAttribute: AH,
  IntType: yb,
  InterleavedBuffer: Kv,
  InterleavedBufferAttribute: Uc,
  Interpolant: lm,
  InterpolateDiscrete: Vp,
  InterpolateLinear: pd,
  InterpolateSmooth: cx,
  InvertStencilOp: C3,
  KeepStencilOp: Gf,
  KeyframeTrack: Xo,
  LOD: YP,
  LatheGeometry: jv,
  Layers: id,
  LessCompare: AP,
  LessDepth: YL,
  LessEqualCompare: Rb,
  LessEqualDepth: gv,
  LessEqualStencilFunc: D3,
  LessStencilFunc: R3,
  Light: kc,
  LightProbe: E2,
  Line: gu,
  Line3: H9,
  LineBasicMaterial: As,
  LineCurve: Kb,
  LineCurve3: ZP,
  LineDashedMaterial: d2,
  LineLoop: Wb,
  LineSegments: Vo,
  LinearDisplayP3ColorSpace: Vv,
  LinearEncoding: wb,
  LinearFilter: bi,
  LinearInterpolant: $b,
  LinearMipMapLinearFilter: x3,
  LinearMipMapNearestFilter: y3,
  LinearMipmapLinearFilter: Tl,
  LinearMipmapNearestFilter: Jx,
  LinearSRGBColorSpace: bl,
  LinearToneMapping: eP,
  LinearTransfer: Sv,
  Loader: Ms,
  LoaderUtils: Rc,
  LoadingManager: tC,
  LoopOnce: pP,
  LoopPingPong: gP,
  LoopRepeat: mP,
  LuminanceAlphaFormat: cP,
  LuminanceFormat: uP,
  MOUSE: h3,
  Material: Mr,
  MaterialLoader: vS,
  MathUtils: ev,
  Matrix3: Mn,
  Matrix4: sn,
  MaxEquation: aT,
  Mesh: ur,
  MeshBasicMaterial: Ra,
  MeshDepthMaterial: Nb,
  MeshDistanceMaterial: Ob,
  MeshLambertMaterial: c2,
  MeshMatcapMaterial: f2,
  MeshNormalMaterial: u2,
  MeshPhongMaterial: o2,
  MeshPhysicalMaterial: po,
  MeshStandardMaterial: $v,
  MeshToonMaterial: l2,
  MinEquation: sT,
  MirroredRepeatWrapping: Gp,
  MixOperation: ZL,
  MultiplyBlending: rT,
  MultiplyOperation: kv,
  NearestFilter: Oi,
  NearestMipMapLinearFilter: _3,
  NearestMipMapNearestFilter: v3,
  NearestMipmapLinearFilter: Dp,
  NearestMipmapNearestFilter: yv,
  NeverCompare: SP,
  NeverDepth: XL,
  NeverStencilFunc: w3,
  NoBlending: du,
  NoColorSpace: ba,
  NoToneMapping: xl,
  NormalAnimationBlendMode: Kx,
  NormalBlending: td,
  NotEqualCompare: TP,
  NotEqualDepth: QL,
  NotEqualStencilFunc: P3,
  NumberKeyframeTrack: vd,
  Object3D: On,
  ObjectLoader: f9,
  ObjectSpaceNormalMap: xP,
  OctahedronGeometry: Qv,
  OneFactor: PL,
  OneMinusConstantAlphaFactor: WL,
  OneMinusConstantColorFactor: kL,
  OneMinusDstAlphaFactor: NL,
  OneMinusDstColorFactor: HL,
  OneMinusSrcAlphaFactor: Ex,
  OneMinusSrcColorFactor: UL,
  OrthographicCamera: sm,
  P3Primaries: Mv,
  PCFShadowMap: Wx,
  PCFSoftShadowMap: Zg,
  PMREMGenerator: FT,
  Path: bv,
  PerspectiveCamera: Ar,
  Plane: _c,
  PlaneGeometry: Yv,
  PlaneHelper: Q9,
  PointLight: rC,
  PointLightHelper: k9,
  Points: Xb,
  PointsMaterial: tS,
  PolarGridHelper: J9,
  PolyhedronGeometry: Gc,
  PositionalAudio: _9,
  PropertyBinding: Nn,
  PropertyMixer: R2,
  QuadraticBezierCurve: qb,
  QuadraticBezierCurve3: jb,
  Quaternion: ys,
  QuaternionKeyframeTrack: Fc,
  QuaternionLinearInterpolant: v2,
  RED_GREEN_RGTC2_Format: DT,
  RED_RGTC1_Format: hP,
  REVISION: Gv,
  RGBADepthPacking: yP,
  RGBAFormat: Ns,
  RGBAIntegerFormat: Eb,
  RGBA_ASTC_10x10_Format: TT,
  RGBA_ASTC_10x5_Format: AT,
  RGBA_ASTC_10x6_Format: MT,
  RGBA_ASTC_10x8_Format: ET,
  RGBA_ASTC_12x10_Format: bT,
  RGBA_ASTC_12x12_Format: CT,
  RGBA_ASTC_4x4_Format: pT,
  RGBA_ASTC_5x4_Format: mT,
  RGBA_ASTC_5x5_Format: gT,
  RGBA_ASTC_6x5_Format: vT,
  RGBA_ASTC_6x6_Format: _T,
  RGBA_ASTC_8x5_Format: yT,
  RGBA_ASTC_8x6_Format: xT,
  RGBA_ASTC_8x8_Format: ST,
  RGBA_BPTC_Format: ux,
  RGBA_ETC2_EAC_Format: hT,
  RGBA_PVRTC_2BPPV1_Format: fT,
  RGBA_PVRTC_4BPPV1_Format: cT,
  RGBA_S3TC_DXT1_Format: ax,
  RGBA_S3TC_DXT3_Format: ox,
  RGBA_S3TC_DXT5_Format: lx,
  RGB_BPTC_SIGNED_Format: wT,
  RGB_BPTC_UNSIGNED_Format: RT,
  RGB_ETC1_Format: Tb,
  RGB_ETC2_Format: dT,
  RGB_PVRTC_2BPPV1_Format: uT,
  RGB_PVRTC_4BPPV1_Format: lT,
  RGB_S3TC_DXT1_Format: sx,
  RGFormat: dP,
  RGIntegerFormat: Mb,
  RawShaderMaterial: a2,
  Ray: im,
  Raycaster: D2,
  Rec709Primaries: Av,
  RectAreaLight: A2,
  RedFormat: fP,
  RedIntegerFormat: Ab,
  ReinhardToneMapping: tP,
  RenderTarget: BP,
  RepeatWrapping: Ic,
  ReplaceStencilOp: A3,
  ReverseSubtractEquation: DL,
  RingGeometry: fS,
  SIGNED_RED_GREEN_RGTC2_Format: LT,
  SIGNED_RED_RGTC1_Format: BT,
  SRGBColorSpace: Sr,
  SRGBTransfer: li,
  Scene: zb,
  ShaderChunk: yn,
  ShaderLib: Oo,
  ShaderMaterial: Cl,
  ShadowMaterial: s2,
  Shape: sd,
  ShapeGeometry: dS,
  ShapePath: e5,
  ShapeUtils: Al,
  ShortType: oP,
  Skeleton: qv,
  SkeletonHelper: G9,
  SkinnedMesh: kb,
  Source: qf,
  Sphere: Qr,
  SphereGeometry: Zv,
  Spherical: F9,
  SphericalHarmonics3: M2,
  SplineCurve: Qb,
  SpotLight: iC,
  SpotLightHelper: z9,
  Sprite: JP,
  SpriteMaterial: Gb,
  SrcAlphaFactor: Mx,
  SrcAlphaSaturateFactor: zL,
  SrcColorFactor: IL,
  StaticCopyUsage: z3,
  StaticDrawUsage: Ev,
  StaticReadUsage: N3,
  StereoCamera: p9,
  StreamCopyUsage: k3,
  StreamDrawUsage: F3,
  StreamReadUsage: H3,
  StringKeyframeTrack: Td,
  SubtractEquation: BL,
  SubtractiveBlending: iT,
  TOUCH: p3,
  TangentSpaceNormalMap: zc,
  TetrahedronGeometry: hS,
  Texture: Ri,
  TextureLoader: y2,
  TorusGeometry: pS,
  TorusKnotGeometry: mS,
  Triangle: na,
  TriangleFanDrawMode: Tx,
  TriangleStripDrawMode: Cb,
  TrianglesDrawMode: vP,
  TubeGeometry: gS,
  TwoPassDoubleSide: g3,
  UVMapping: Xx,
  Uint16BufferAttribute: Pb,
  Uint32BufferAttribute: Ib,
  Uint8BufferAttribute: MH,
  Uint8ClampedBufferAttribute: EH,
  Uniform: cC,
  UniformsGroup: P9,
  UniformsLib: xt,
  UniformsUtils: PP,
  UnsignedByteType: Sl,
  UnsignedInt248Type: bc,
  UnsignedIntType: lu,
  UnsignedShort4444Type: xb,
  UnsignedShort5551Type: Sb,
  UnsignedShortType: Yx,
  VSMShadowMap: No,
  Vector2: qe,
  Vector3: q,
  Vector4: $n,
  VectorKeyframeTrack: _d,
  VideoTexture: x4,
  WebGL1Renderer: WP,
  WebGL3DRenderTarget: uH,
  WebGLArrayRenderTarget: lH,
  WebGLCoordinateSystem: Go,
  WebGLCubeRenderTarget: UP,
  WebGLMultipleRenderTargets: cH,
  WebGLRenderTarget: ko,
  WebGLRenderer: Hb,
  WebGLUtils: kP,
  WebGPUCoordinateSystem: Wp,
  WireframeGeometry: r2,
  WrapAroundEnding: xv,
  ZeroCurvatureEnding: Yf,
  ZeroFactor: LL,
  ZeroSlopeEnding: Kf,
  ZeroStencilOp: S3,
  _SRGBAFormat: bx,
  createCanvasElement: RP,
  sRGBEncoding: wc
}, Symbol.toStringTag, { value: "Module" }));
var O0 = { exports: {} }, pc = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uD;
function n5() {
  return uD || (uD = 1, pc.ConcurrentRoot = 1, pc.ContinuousEventPriority = 4, pc.DefaultEventPriority = 16, pc.DiscreteEventPriority = 1, pc.IdleEventPriority = 536870912, pc.LegacyRoot = 0), pc;
}
var mc = {};
/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cD;
function i5() {
  return cD || (cD = 1, process.env.NODE_ENV !== "production" && function() {
    var s = (
      /*                        */
      1
    ), e = (
      /*            */
      4
    ), t = (
      /*                    */
      16
    ), n = (
      /*                       */
      536870912
    ), i = s, r = e, o = t, u = n, c = 0, d = 1;
    mc.ConcurrentRoot = d, mc.ContinuousEventPriority = r, mc.DefaultEventPriority = o, mc.DiscreteEventPriority = i, mc.IdleEventPriority = u, mc.LegacyRoot = c;
  }()), mc;
}
var fD;
function r5() {
  return fD || (fD = 1, process.env.NODE_ENV === "production" ? O0.exports = n5() : O0.exports = i5()), O0.exports;
}
var Cp = r5();
function s5(s) {
  let e;
  const t = /* @__PURE__ */ new Set(), n = (d, p) => {
    const g = typeof d == "function" ? d(e) : d;
    if (g !== e) {
      const v = e;
      e = p ? g : Object.assign({}, e, g), t.forEach((y) => y(e, v));
    }
  }, i = () => e, r = (d, p = i, g = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let v = p(e);
    function y() {
      const S = p(e);
      if (!g(v, S)) {
        const T = v;
        d(v = S, T);
      }
    }
    return t.add(y), () => t.delete(y);
  }, c = { setState: n, getState: i, subscribe: (d, p, g) => p || g ? r(d, p, g) : (t.add(d), () => t.delete(d)), destroy: () => t.clear() };
  return e = s(n, i, c), c;
}
const a5 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), dD = a5 ? Tc : TL;
function o5(s) {
  const e = typeof s == "function" ? s5(s) : s, t = (n = e.getState, i = Object.is) => {
    const [, r] = a3((E) => E + 1, 0), o = e.getState(), u = gl(o), c = gl(n), d = gl(i), p = gl(!1), g = gl();
    g.current === void 0 && (g.current = n(o));
    let v, y = !1;
    (u.current !== o || c.current !== n || d.current !== i || p.current) && (v = n(o), y = !i(g.current, v)), dD(() => {
      y && (g.current = v), u.current = o, c.current = n, d.current = i, p.current = !1;
    });
    const S = gl(o);
    dD(() => {
      const E = () => {
        try {
          const w = e.getState(), C = c.current(w);
          d.current(g.current, C) || (u.current = w, g.current = C, r());
        } catch {
          p.current = !0, r();
        }
      }, M = e.subscribe(E);
      return e.getState() !== S.current && E(), M;
    }, []);
    const T = y ? v : g.current;
    return o3(T), T;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const n = [t, e];
    return {
      next() {
        const i = n.length <= 0;
        return { value: n.shift(), done: i };
      }
    };
  }, t;
}
const l5 = (s) => typeof s == "object" && typeof s.then == "function", Qf = [];
function P2(s, e, t = (n, i) => n === i) {
  if (s === e) return !0;
  if (!s || !e) return !1;
  const n = s.length;
  if (e.length !== n) return !1;
  for (let i = 0; i < n; i++) if (!t(s[i], e[i])) return !1;
  return !0;
}
function I2(s, e = null, t = !1, n = {}) {
  e === null && (e = [s]);
  for (const r of Qf)
    if (P2(e, r.keys, r.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(r, "error")) throw r.error;
      if (Object.prototype.hasOwnProperty.call(r, "response"))
        return n.lifespan && n.lifespan > 0 && (r.timeout && clearTimeout(r.timeout), r.timeout = setTimeout(r.remove, n.lifespan)), r.response;
      if (!t) throw r.promise;
    }
  const i = {
    keys: e,
    equal: n.equal,
    remove: () => {
      const r = Qf.indexOf(i);
      r !== -1 && Qf.splice(r, 1);
    },
    promise: (
      // Execute the promise
      (l5(s) ? s : s(...e)).then((r) => {
        i.response = r, n.lifespan && n.lifespan > 0 && (i.timeout = setTimeout(i.remove, n.lifespan));
      }).catch((r) => i.error = r)
    )
  };
  if (Qf.push(i), !t) throw i.promise;
}
const u5 = (s, e, t) => I2(s, e, !1, t), c5 = (s, e, t) => void I2(s, e, !0, t), f5 = (s) => {
  if (s === void 0 || s.length === 0) Qf.splice(0, Qf.length);
  else {
    const e = Qf.find((t) => P2(s, t.keys, t.equal));
    e && e.remove();
  }
};
var H0 = { exports: {} }, z0 = { exports: {} }, SE = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hD;
function d5() {
  return hD || (hD = 1, function(s) {
    function e(J, Z) {
      var H = J.length;
      J.push(Z);
      e: for (; 0 < H; ) {
        var ue = H - 1 >>> 1, Se = J[ue];
        if (0 < i(Se, Z)) J[ue] = Z, J[H] = Se, H = ue;
        else break e;
      }
    }
    function t(J) {
      return J.length === 0 ? null : J[0];
    }
    function n(J) {
      if (J.length === 0) return null;
      var Z = J[0], H = J.pop();
      if (H !== Z) {
        J[0] = H;
        e: for (var ue = 0, Se = J.length, me = Se >>> 1; ue < me; ) {
          var ye = 2 * (ue + 1) - 1, Xe = J[ye], Je = ye + 1, Ye = J[Je];
          if (0 > i(Xe, H)) Je < Se && 0 > i(Ye, Xe) ? (J[ue] = Ye, J[Je] = H, ue = Je) : (J[ue] = Xe, J[ye] = H, ue = ye);
          else if (Je < Se && 0 > i(Ye, H)) J[ue] = Ye, J[Je] = H, ue = Je;
          else break e;
        }
      }
      return Z;
    }
    function i(J, Z) {
      var H = J.sortIndex - Z.sortIndex;
      return H !== 0 ? H : J.id - Z.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var r = performance;
      s.unstable_now = function() {
        return r.now();
      };
    } else {
      var o = Date, u = o.now();
      s.unstable_now = function() {
        return o.now() - u;
      };
    }
    var c = [], d = [], p = 1, g = null, v = 3, y = !1, S = !1, T = !1, E = typeof setTimeout == "function" ? setTimeout : null, M = typeof clearTimeout == "function" ? clearTimeout : null, w = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function C(J) {
      for (var Z = t(d); Z !== null; ) {
        if (Z.callback === null) n(d);
        else if (Z.startTime <= J) n(d), Z.sortIndex = Z.expirationTime, e(c, Z);
        else break;
        Z = t(d);
      }
    }
    function D(J) {
      if (T = !1, C(J), !S) if (t(c) !== null) S = !0, re(N);
      else {
        var Z = t(d);
        Z !== null && pe(D, Z.startTime - J);
      }
    }
    function N(J, Z) {
      S = !1, T && (T = !1, M(V), V = -1), y = !0;
      var H = v;
      try {
        for (C(Z), g = t(c); g !== null && (!(g.expirationTime > Z) || J && !Y()); ) {
          var ue = g.callback;
          if (typeof ue == "function") {
            g.callback = null, v = g.priorityLevel;
            var Se = ue(g.expirationTime <= Z);
            Z = s.unstable_now(), typeof Se == "function" ? g.callback = Se : g === t(c) && n(c), C(Z);
          } else n(c);
          g = t(c);
        }
        if (g !== null) var me = !0;
        else {
          var ye = t(d);
          ye !== null && pe(D, ye.startTime - Z), me = !1;
        }
        return me;
      } finally {
        g = null, v = H, y = !1;
      }
    }
    var U = !1, O = null, V = -1, L = 5, I = -1;
    function Y() {
      return !(s.unstable_now() - I < L);
    }
    function Q() {
      if (O !== null) {
        var J = s.unstable_now();
        I = J;
        var Z = !0;
        try {
          Z = O(!0, J);
        } finally {
          Z ? fe() : (U = !1, O = null);
        }
      } else U = !1;
    }
    var fe;
    if (typeof w == "function") fe = function() {
      w(Q);
    };
    else if (typeof MessageChannel < "u") {
      var j = new MessageChannel(), ie = j.port2;
      j.port1.onmessage = Q, fe = function() {
        ie.postMessage(null);
      };
    } else fe = function() {
      E(Q, 0);
    };
    function re(J) {
      O = J, U || (U = !0, fe());
    }
    function pe(J, Z) {
      V = E(function() {
        J(s.unstable_now());
      }, Z);
    }
    s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(J) {
      J.callback = null;
    }, s.unstable_continueExecution = function() {
      S || y || (S = !0, re(N));
    }, s.unstable_forceFrameRate = function(J) {
      0 > J || 125 < J ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : L = 0 < J ? Math.floor(1e3 / J) : 5;
    }, s.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, s.unstable_getFirstCallbackNode = function() {
      return t(c);
    }, s.unstable_next = function(J) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var Z = 3;
          break;
        default:
          Z = v;
      }
      var H = v;
      v = Z;
      try {
        return J();
      } finally {
        v = H;
      }
    }, s.unstable_pauseExecution = function() {
    }, s.unstable_requestPaint = function() {
    }, s.unstable_runWithPriority = function(J, Z) {
      switch (J) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          J = 3;
      }
      var H = v;
      v = J;
      try {
        return Z();
      } finally {
        v = H;
      }
    }, s.unstable_scheduleCallback = function(J, Z, H) {
      var ue = s.unstable_now();
      switch (typeof H == "object" && H !== null ? (H = H.delay, H = typeof H == "number" && 0 < H ? ue + H : ue) : H = ue, J) {
        case 1:
          var Se = -1;
          break;
        case 2:
          Se = 250;
          break;
        case 5:
          Se = 1073741823;
          break;
        case 4:
          Se = 1e4;
          break;
        default:
          Se = 5e3;
      }
      return Se = H + Se, J = { id: p++, callback: Z, priorityLevel: J, startTime: H, expirationTime: Se, sortIndex: -1 }, H > ue ? (J.sortIndex = H, e(d, J), t(c) === null && J === t(d) && (T ? (M(V), V = -1) : T = !0, pe(D, H - ue))) : (J.sortIndex = Se, e(c, J), S || y || (S = !0, re(N))), J;
    }, s.unstable_shouldYield = Y, s.unstable_wrapCallback = function(J) {
      var Z = v;
      return function() {
        var H = v;
        v = Z;
        try {
          return J.apply(this, arguments);
        } finally {
          v = H;
        }
      };
    };
  }(SE)), SE;
}
var AE = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pD;
function h5() {
  return pD || (pD = 1, function(s) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = 5;
      function n(ee, Re) {
        var De = ee.length;
        ee.push(Re), o(ee, Re, De);
      }
      function i(ee) {
        return ee.length === 0 ? null : ee[0];
      }
      function r(ee) {
        if (ee.length === 0)
          return null;
        var Re = ee[0], De = ee.pop();
        return De !== Re && (ee[0] = De, u(ee, De, 0)), Re;
      }
      function o(ee, Re, De) {
        for (var Ie = De; Ie > 0; ) {
          var Qe = Ie - 1 >>> 1, rt = ee[Qe];
          if (c(rt, Re) > 0)
            ee[Qe] = Re, ee[Ie] = rt, Ie = Qe;
          else
            return;
        }
      }
      function u(ee, Re, De) {
        for (var Ie = De, Qe = ee.length, rt = Qe >>> 1; Ie < rt; ) {
          var Fe = (Ie + 1) * 2 - 1, Ke = ee[Fe], Dt = Fe + 1, We = ee[Dt];
          if (c(Ke, Re) < 0)
            Dt < Qe && c(We, Ke) < 0 ? (ee[Ie] = We, ee[Dt] = Re, Ie = Dt) : (ee[Ie] = Ke, ee[Fe] = Re, Ie = Fe);
          else if (Dt < Qe && c(We, Re) < 0)
            ee[Ie] = We, ee[Dt] = Re, Ie = Dt;
          else
            return;
        }
      }
      function c(ee, Re) {
        var De = ee.sortIndex - Re.sortIndex;
        return De !== 0 ? De : ee.id - Re.id;
      }
      var d = 1, p = 2, g = 3, v = 4, y = 5;
      function S(ee, Re) {
      }
      var T = typeof performance == "object" && typeof performance.now == "function";
      if (T) {
        var E = performance;
        s.unstable_now = function() {
          return E.now();
        };
      } else {
        var M = Date, w = M.now();
        s.unstable_now = function() {
          return M.now() - w;
        };
      }
      var C = 1073741823, D = -1, N = 250, U = 5e3, O = 1e4, V = C, L = [], I = [], Y = 1, Q = null, fe = g, j = !1, ie = !1, re = !1, pe = typeof setTimeout == "function" ? setTimeout : null, J = typeof clearTimeout == "function" ? clearTimeout : null, Z = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function H(ee) {
        for (var Re = i(I); Re !== null; ) {
          if (Re.callback === null)
            r(I);
          else if (Re.startTime <= ee)
            r(I), Re.sortIndex = Re.expirationTime, n(L, Re);
          else
            return;
          Re = i(I);
        }
      }
      function ue(ee) {
        if (re = !1, H(ee), !ie)
          if (i(L) !== null)
            ie = !0, ct(Se);
          else {
            var Re = i(I);
            Re !== null && st(ue, Re.startTime - ee);
          }
      }
      function Se(ee, Re) {
        ie = !1, re && (re = !1, it()), j = !0;
        var De = fe;
        try {
          var Ie;
          if (!e) return me(ee, Re);
        } finally {
          Q = null, fe = De, j = !1;
        }
      }
      function me(ee, Re) {
        var De = Re;
        for (H(De), Q = i(L); Q !== null && !(Q.expirationTime > De && (!ee || nt())); ) {
          var Ie = Q.callback;
          if (typeof Ie == "function") {
            Q.callback = null, fe = Q.priorityLevel;
            var Qe = Q.expirationTime <= De, rt = Ie(Qe);
            De = s.unstable_now(), typeof rt == "function" ? Q.callback = rt : Q === i(L) && r(L), H(De);
          } else
            r(L);
          Q = i(L);
        }
        if (Q !== null)
          return !0;
        var Fe = i(I);
        return Fe !== null && st(ue, Fe.startTime - De), !1;
      }
      function ye(ee, Re) {
        switch (ee) {
          case d:
          case p:
          case g:
          case v:
          case y:
            break;
          default:
            ee = g;
        }
        var De = fe;
        fe = ee;
        try {
          return Re();
        } finally {
          fe = De;
        }
      }
      function Xe(ee) {
        var Re;
        switch (fe) {
          case d:
          case p:
          case g:
            Re = g;
            break;
          default:
            Re = fe;
            break;
        }
        var De = fe;
        fe = Re;
        try {
          return ee();
        } finally {
          fe = De;
        }
      }
      function Je(ee) {
        var Re = fe;
        return function() {
          var De = fe;
          fe = Re;
          try {
            return ee.apply(this, arguments);
          } finally {
            fe = De;
          }
        };
      }
      function Ye(ee, Re, De) {
        var Ie = s.unstable_now(), Qe;
        if (typeof De == "object" && De !== null) {
          var rt = De.delay;
          typeof rt == "number" && rt > 0 ? Qe = Ie + rt : Qe = Ie;
        } else
          Qe = Ie;
        var Fe;
        switch (ee) {
          case d:
            Fe = D;
            break;
          case p:
            Fe = N;
            break;
          case y:
            Fe = V;
            break;
          case v:
            Fe = O;
            break;
          case g:
          default:
            Fe = U;
            break;
        }
        var Ke = Qe + Fe, Dt = {
          id: Y++,
          callback: Re,
          priorityLevel: ee,
          startTime: Qe,
          expirationTime: Ke,
          sortIndex: -1
        };
        return Qe > Ie ? (Dt.sortIndex = Qe, n(I, Dt), i(L) === null && Dt === i(I) && (re ? it() : re = !0, st(ue, Qe - Ie))) : (Dt.sortIndex = Ke, n(L, Dt), !ie && !j && (ie = !0, ct(Se))), Dt;
      }
      function At() {
      }
      function Ct() {
        !ie && !j && (ie = !0, ct(Se));
      }
      function pt() {
        return i(L);
      }
      function mt(ee) {
        ee.callback = null;
      }
      function ne() {
        return fe;
      }
      var we = !1, Ee = null, He = -1, be = t, ce = -1;
      function nt() {
        var ee = s.unstable_now() - ce;
        return !(ee < be);
      }
      function X() {
      }
      function G(ee) {
        if (ee < 0 || ee > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ee > 0 ? be = Math.floor(1e3 / ee) : be = t;
      }
      var le = function() {
        if (Ee !== null) {
          var ee = s.unstable_now();
          ce = ee;
          var Re = !0, De = !0;
          try {
            De = Ee(Re, ee);
          } finally {
            De ? Ue() : (we = !1, Ee = null);
          }
        } else
          we = !1;
      }, Ue;
      if (typeof Z == "function")
        Ue = function() {
          Z(le);
        };
      else if (typeof MessageChannel < "u") {
        var Ve = new MessageChannel(), Oe = Ve.port2;
        Ve.port1.onmessage = le, Ue = function() {
          Oe.postMessage(null);
        };
      } else
        Ue = function() {
          pe(le, 0);
        };
      function ct(ee) {
        Ee = ee, we || (we = !0, Ue());
      }
      function st(ee, Re) {
        He = pe(function() {
          ee(s.unstable_now());
        }, Re);
      }
      function it() {
        J(He), He = -1;
      }
      var Lt = X, zt = null;
      s.unstable_IdlePriority = y, s.unstable_ImmediatePriority = d, s.unstable_LowPriority = v, s.unstable_NormalPriority = g, s.unstable_Profiling = zt, s.unstable_UserBlockingPriority = p, s.unstable_cancelCallback = mt, s.unstable_continueExecution = Ct, s.unstable_forceFrameRate = G, s.unstable_getCurrentPriorityLevel = ne, s.unstable_getFirstCallbackNode = pt, s.unstable_next = Xe, s.unstable_pauseExecution = At, s.unstable_requestPaint = Lt, s.unstable_runWithPriority = ye, s.unstable_scheduleCallback = Ye, s.unstable_shouldYield = nt, s.unstable_wrapCallback = Je, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(AE)), AE;
}
var mD;
function U2() {
  return mD || (mD = 1, process.env.NODE_ENV === "production" ? z0.exports = d5() : z0.exports = h5()), z0.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ME, gD;
function p5() {
  return gD || (gD = 1, ME = function(e) {
    var t = {}, n = Vx, i = U2(), r = Object.assign;
    function o(f) {
      for (var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + f, x = 1; x < arguments.length; x++) h += "&args[]=" + encodeURIComponent(arguments[x]);
      return "Minified React error #" + f + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var u = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, c = Symbol.for("react.element"), d = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), g = Symbol.for("react.strict_mode"), v = Symbol.for("react.profiler"), y = Symbol.for("react.provider"), S = Symbol.for("react.context"), T = Symbol.for("react.forward_ref"), E = Symbol.for("react.suspense"), M = Symbol.for("react.suspense_list"), w = Symbol.for("react.memo"), C = Symbol.for("react.lazy"), D = Symbol.for("react.offscreen"), N = Symbol.iterator;
    function U(f) {
      return f === null || typeof f != "object" ? null : (f = N && f[N] || f["@@iterator"], typeof f == "function" ? f : null);
    }
    function O(f) {
      if (f == null) return null;
      if (typeof f == "function") return f.displayName || f.name || null;
      if (typeof f == "string") return f;
      switch (f) {
        case p:
          return "Fragment";
        case d:
          return "Portal";
        case v:
          return "Profiler";
        case g:
          return "StrictMode";
        case E:
          return "Suspense";
        case M:
          return "SuspenseList";
      }
      if (typeof f == "object") switch (f.$$typeof) {
        case S:
          return (f.displayName || "Context") + ".Consumer";
        case y:
          return (f._context.displayName || "Context") + ".Provider";
        case T:
          var h = f.render;
          return f = f.displayName, f || (f = h.displayName || h.name || "", f = f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef"), f;
        case w:
          return h = f.displayName || null, h !== null ? h : O(f.type) || "Memo";
        case C:
          h = f._payload, f = f._init;
          try {
            return O(f(h));
          } catch {
          }
      }
      return null;
    }
    function V(f) {
      var h = f.type;
      switch (f.tag) {
        case 24:
          return "Cache";
        case 9:
          return (h.displayName || "Context") + ".Consumer";
        case 10:
          return (h._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return f = h.render, f = f.displayName || f.name || "", h.displayName || (f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return h;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return O(h);
        case 8:
          return h === g ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof h == "function") return h.displayName || h.name || null;
          if (typeof h == "string") return h;
      }
      return null;
    }
    function L(f) {
      var h = f, x = f;
      if (f.alternate) for (; h.return; ) h = h.return;
      else {
        f = h;
        do
          h = f, (h.flags & 4098) !== 0 && (x = h.return), f = h.return;
        while (f);
      }
      return h.tag === 3 ? x : null;
    }
    function I(f) {
      if (L(f) !== f) throw Error(o(188));
    }
    function Y(f) {
      var h = f.alternate;
      if (!h) {
        if (h = L(f), h === null) throw Error(o(188));
        return h !== f ? null : f;
      }
      for (var x = f, b = h; ; ) {
        var B = x.return;
        if (B === null) break;
        var F = B.alternate;
        if (F === null) {
          if (b = B.return, b !== null) {
            x = b;
            continue;
          }
          break;
        }
        if (B.child === F.child) {
          for (F = B.child; F; ) {
            if (F === x) return I(B), f;
            if (F === b) return I(B), h;
            F = F.sibling;
          }
          throw Error(o(188));
        }
        if (x.return !== b.return) x = B, b = F;
        else {
          for (var K = !1, de = B.child; de; ) {
            if (de === x) {
              K = !0, x = B, b = F;
              break;
            }
            if (de === b) {
              K = !0, b = B, x = F;
              break;
            }
            de = de.sibling;
          }
          if (!K) {
            for (de = F.child; de; ) {
              if (de === x) {
                K = !0, x = F, b = B;
                break;
              }
              if (de === b) {
                K = !0, b = F, x = B;
                break;
              }
              de = de.sibling;
            }
            if (!K) throw Error(o(189));
          }
        }
        if (x.alternate !== b) throw Error(o(190));
      }
      if (x.tag !== 3) throw Error(o(188));
      return x.stateNode.current === x ? f : h;
    }
    function Q(f) {
      return f = Y(f), f !== null ? fe(f) : null;
    }
    function fe(f) {
      if (f.tag === 5 || f.tag === 6) return f;
      for (f = f.child; f !== null; ) {
        var h = fe(f);
        if (h !== null) return h;
        f = f.sibling;
      }
      return null;
    }
    function j(f) {
      if (f.tag === 5 || f.tag === 6) return f;
      for (f = f.child; f !== null; ) {
        if (f.tag !== 4) {
          var h = j(f);
          if (h !== null) return h;
        }
        f = f.sibling;
      }
      return null;
    }
    var ie = Array.isArray, re = e.getPublicInstance, pe = e.getRootHostContext, J = e.getChildHostContext, Z = e.prepareForCommit, H = e.resetAfterCommit, ue = e.createInstance, Se = e.appendInitialChild, me = e.finalizeInitialChildren, ye = e.prepareUpdate, Xe = e.shouldSetTextContent, Je = e.createTextInstance, Ye = e.scheduleTimeout, At = e.cancelTimeout, Ct = e.noTimeout, pt = e.isPrimaryRenderer, mt = e.supportsMutation, ne = e.supportsPersistence, we = e.supportsHydration, Ee = e.getInstanceFromNode, He = e.preparePortalMount, be = e.getCurrentEventPriority, ce = e.detachDeletedInstance, nt = e.supportsMicrotasks, X = e.scheduleMicrotask, G = e.supportsTestSelectors, le = e.findFiberRoot, Ue = e.getBoundingRect, Ve = e.getTextContent, Oe = e.isHiddenSubtree, ct = e.matchAccessibilityRole, st = e.setFocusIfFocusable, it = e.setupIntersectionObserver, Lt = e.appendChild, zt = e.appendChildToContainer, ee = e.commitTextUpdate, Re = e.commitMount, De = e.commitUpdate, Ie = e.insertBefore, Qe = e.insertInContainerBefore, rt = e.removeChild, Fe = e.removeChildFromContainer, Ke = e.resetTextContent, Dt = e.hideInstance, We = e.hideTextInstance, Pe = e.unhideInstance, ae = e.unhideTextInstance, et = e.clearContainer, at = e.cloneInstance, Wt = e.createContainerChildSet, ot = e.appendChildToContainerChildSet, an = e.finalizeContainerChildren, un = e.replaceContainerChildren, wt = e.cloneHiddenInstance, St = e.cloneHiddenTextInstance, bt = e.canHydrateInstance, lt = e.canHydrateTextInstance, Ot = e.canHydrateSuspenseInstance, kt = e.isSuspenseInstancePending, en = e.isSuspenseInstanceFallback, Vn = e.registerSuspenseInstanceRetry, Yt = e.getNextHydratableSibling, te = e.getFirstHydratableChild, ze = e.getFirstHydratableChildWithinContainer, tt = e.getFirstHydratableChildWithinSuspenseInstance, gt = e.hydrateInstance, Ht = e.hydrateTextInstance, tn = e.hydrateSuspenseInstance, k = e.getNextHydratableInstanceAfterSuspenseInstance, se = e.commitHydratedContainer, _e = e.commitHydratedSuspenseInstance, ge = e.clearSuspenseBoundary, he = e.clearSuspenseBoundaryFromContainer, je = e.shouldDeleteUnhydratedTailInstances, Rt = e.didNotMatchHydratedContainerTextInstance, Ft = e.didNotMatchHydratedTextInstance, vt;
    function It(f) {
      if (vt === void 0) try {
        throw Error();
      } catch (x) {
        var h = x.stack.trim().match(/\n( *(at )?)/);
        vt = h && h[1] || "";
      }
      return `
` + vt + f;
    }
    var Xt = !1;
    function $t(f, h) {
      if (!f || Xt) return "";
      Xt = !0;
      var x = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (h) if (h = function() {
          throw Error();
        }, Object.defineProperty(h.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(h, []);
          } catch (ft) {
            var b = ft;
          }
          Reflect.construct(f, [], h);
        } else {
          try {
            h.call();
          } catch (ft) {
            b = ft;
          }
          f.call(h.prototype);
        }
        else {
          try {
            throw Error();
          } catch (ft) {
            b = ft;
          }
          f();
        }
      } catch (ft) {
        if (ft && b && typeof ft.stack == "string") {
          for (var B = ft.stack.split(`
`), F = b.stack.split(`
`), K = B.length - 1, de = F.length - 1; 1 <= K && 0 <= de && B[K] !== F[de]; ) de--;
          for (; 1 <= K && 0 <= de; K--, de--) if (B[K] !== F[de]) {
            if (K !== 1 || de !== 1)
              do
                if (K--, de--, 0 > de || B[K] !== F[de]) {
                  var Le = `
` + B[K].replace(" at new ", " at ");
                  return f.displayName && Le.includes("<anonymous>") && (Le = Le.replace("<anonymous>", f.displayName)), Le;
                }
              while (1 <= K && 0 <= de);
            break;
          }
        }
      } finally {
        Xt = !1, Error.prepareStackTrace = x;
      }
      return (f = f ? f.displayName || f.name : "") ? It(f) : "";
    }
    var Kn = Object.prototype.hasOwnProperty, ai = [], bn = -1;
    function ti(f) {
      return { current: f };
    }
    function Qt(f) {
      0 > bn || (f.current = ai[bn], ai[bn] = null, bn--);
    }
    function ht(f, h) {
      bn++, ai[bn] = f.current, f.current = h;
    }
    var $r = {}, mn = ti($r), mi = ti(!1), Fa = $r;
    function Gs(f, h) {
      var x = f.type.contextTypes;
      if (!x) return $r;
      var b = f.stateNode;
      if (b && b.__reactInternalMemoizedUnmaskedChildContext === h) return b.__reactInternalMemoizedMaskedChildContext;
      var B = {}, F;
      for (F in x) B[F] = h[F];
      return b && (f = f.stateNode, f.__reactInternalMemoizedUnmaskedChildContext = h, f.__reactInternalMemoizedMaskedChildContext = B), B;
    }
    function $i(f) {
      return f = f.childContextTypes, f != null;
    }
    function fi() {
      Qt(mi), Qt(mn);
    }
    function ua(f, h, x) {
      if (mn.current !== $r) throw Error(o(168));
      ht(mn, h), ht(mi, x);
    }
    function Rl(f, h, x) {
      var b = f.stateNode;
      if (h = h.childContextTypes, typeof b.getChildContext != "function") return x;
      b = b.getChildContext();
      for (var B in b) if (!(B in h)) throw Error(o(108, V(f) || "Unknown", B));
      return r({}, x, b);
    }
    function Gi(f) {
      return f = (f = f.stateNode) && f.__reactInternalMemoizedMergedChildContext || $r, Fa = mn.current, ht(mn, f), ht(mi, mi.current), !0;
    }
    function Bl(f, h, x) {
      var b = f.stateNode;
      if (!b) throw Error(o(169));
      x ? (f = Rl(f, h, Fa), b.__reactInternalMemoizedMergedChildContext = f, Qt(mi), Qt(mn), ht(mn, f)) : Qt(mi), ht(mi, x);
    }
    var es = Math.clz32 ? Math.clz32 : wd, Cd = Math.log, um = Math.LN2;
    function wd(f) {
      return f >>>= 0, f === 0 ? 32 : 31 - (Cd(f) / um | 0) | 0;
    }
    var Rd = 64, ts = 4194304;
    function Jo(f) {
      switch (f & -f) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return f & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return f & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return f;
      }
    }
    function br(f, h) {
      var x = f.pendingLanes;
      if (x === 0) return 0;
      var b = 0, B = f.suspendedLanes, F = f.pingedLanes, K = x & 268435455;
      if (K !== 0) {
        var de = K & ~B;
        de !== 0 ? b = Jo(de) : (F &= K, F !== 0 && (b = Jo(F)));
      } else K = x & ~B, K !== 0 ? b = Jo(K) : F !== 0 && (b = Jo(F));
      if (b === 0) return 0;
      if (h !== 0 && h !== b && (h & B) === 0 && (B = b & -b, F = h & -h, B >= F || B === 16 && (F & 4194240) !== 0)) return h;
      if ((b & 4) !== 0 && (b |= x & 16), h = f.entangledLanes, h !== 0) for (f = f.entanglements, h &= b; 0 < h; ) x = 31 - es(h), B = 1 << x, b |= f[x], h &= ~B;
      return b;
    }
    function AS(f, h) {
      switch (f) {
        case 1:
        case 2:
        case 4:
          return h + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return h + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function MS(f, h) {
      for (var x = f.suspendedLanes, b = f.pingedLanes, B = f.expirationTimes, F = f.pendingLanes; 0 < F; ) {
        var K = 31 - es(F), de = 1 << K, Le = B[K];
        Le === -1 ? ((de & x) === 0 || (de & b) !== 0) && (B[K] = AS(de, h)) : Le <= h && (f.expiredLanes |= de), F &= ~de;
      }
    }
    function cm(f) {
      return f = f.pendingLanes & -1073741825, f !== 0 ? f : f & 1073741824 ? 1073741824 : 0;
    }
    function fm(f) {
      for (var h = [], x = 0; 31 > x; x++) h.push(f);
      return h;
    }
    function Wc(f, h, x) {
      f.pendingLanes |= h, h !== 536870912 && (f.suspendedLanes = 0, f.pingedLanes = 0), f = f.eventTimes, h = 31 - es(h), f[h] = x;
    }
    function ES(f, h) {
      var x = f.pendingLanes & ~h;
      f.pendingLanes = h, f.suspendedLanes = 0, f.pingedLanes = 0, f.expiredLanes &= h, f.mutableReadLanes &= h, f.entangledLanes &= h, h = f.entanglements;
      var b = f.eventTimes;
      for (f = f.expirationTimes; 0 < x; ) {
        var B = 31 - es(x), F = 1 << B;
        h[B] = 0, b[B] = -1, f[B] = -1, x &= ~F;
      }
    }
    function Yo(f, h) {
      var x = f.entangledLanes |= h;
      for (f = f.entanglements; x; ) {
        var b = 31 - es(x), B = 1 << b;
        B & h | f[b] & h && (f[b] |= h), x &= ~B;
      }
    }
    var Fn = 0;
    function i_(f) {
      return f &= -f, 1 < f ? 4 < f ? (f & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
    }
    var dm = i.unstable_scheduleCallback, xu = i.unstable_cancelCallback, TS = i.unstable_shouldYield, bS = i.unstable_requestPaint, er = i.unstable_now, hm = i.unstable_ImmediatePriority, CS = i.unstable_UserBlockingPriority, pm = i.unstable_NormalPriority, wS = i.unstable_IdlePriority, Bd = null, Na = null;
    function RS(f) {
      if (Na && typeof Na.onCommitFiberRoot == "function") try {
        Na.onCommitFiberRoot(Bd, f, void 0, (f.current.flags & 128) === 128);
      } catch {
      }
    }
    function BS(f, h) {
      return f === h && (f !== 0 || 1 / f === 1 / h) || f !== f && h !== h;
    }
    var Oa = typeof Object.is == "function" ? Object.is : BS, Ha = null, Dd = !1, mm = !1;
    function r_(f) {
      Ha === null ? Ha = [f] : Ha.push(f);
    }
    function DS(f) {
      Dd = !0, r_(f);
    }
    function za() {
      if (!mm && Ha !== null) {
        mm = !0;
        var f = 0, h = Fn;
        try {
          var x = Ha;
          for (Fn = 1; f < x.length; f++) {
            var b = x[f];
            do
              b = b(!0);
            while (b !== null);
          }
          Ha = null, Dd = !1;
        } catch (B) {
          throw Ha !== null && (Ha = Ha.slice(f + 1)), dm(hm, za), B;
        } finally {
          Fn = h, mm = !1;
        }
      }
      return null;
    }
    var LS = u.ReactCurrentBatchConfig;
    function Xc(f, h) {
      if (Oa(f, h)) return !0;
      if (typeof f != "object" || f === null || typeof h != "object" || h === null) return !1;
      var x = Object.keys(f), b = Object.keys(h);
      if (x.length !== b.length) return !1;
      for (b = 0; b < x.length; b++) {
        var B = x[b];
        if (!Kn.call(h, B) || !Oa(f[B], h[B])) return !1;
      }
      return !0;
    }
    function s_(f) {
      switch (f.tag) {
        case 5:
          return It(f.type);
        case 16:
          return It("Lazy");
        case 13:
          return It("Suspense");
        case 19:
          return It("SuspenseList");
        case 0:
        case 2:
        case 15:
          return f = $t(f.type, !1), f;
        case 11:
          return f = $t(f.type.render, !1), f;
        case 1:
          return f = $t(f.type, !0), f;
        default:
          return "";
      }
    }
    function ca(f, h) {
      if (f && f.defaultProps) {
        h = r({}, h), f = f.defaultProps;
        for (var x in f) h[x] === void 0 && (h[x] = f[x]);
        return h;
      }
      return h;
    }
    var Jc = ti(null), Yc = null, Dl = null, gm = null;
    function vm() {
      gm = Dl = Yc = null;
    }
    function a_(f, h, x) {
      pt ? (ht(Jc, h._currentValue), h._currentValue = x) : (ht(Jc, h._currentValue2), h._currentValue2 = x);
    }
    function Ld(f) {
      var h = Jc.current;
      Qt(Jc), pt ? f._currentValue = h : f._currentValue2 = h;
    }
    function Kc(f, h, x) {
      for (; f !== null; ) {
        var b = f.alternate;
        if ((f.childLanes & h) !== h ? (f.childLanes |= h, b !== null && (b.childLanes |= h)) : b !== null && (b.childLanes & h) !== h && (b.childLanes |= h), f === x) break;
        f = f.return;
      }
    }
    function Su(f, h) {
      Yc = f, gm = Dl = null, f = f.dependencies, f !== null && f.firstContext !== null && ((f.lanes & h) !== 0 && (Ts = !0), f.firstContext = null);
    }
    function Ir(f) {
      var h = pt ? f._currentValue : f._currentValue2;
      if (gm !== f) if (f = { context: f, memoizedValue: h, next: null }, Dl === null) {
        if (Yc === null) throw Error(o(308));
        Dl = f, Yc.dependencies = { lanes: 0, firstContext: f };
      } else Dl = Dl.next = f;
      return h;
    }
    var Ga = null, Ko = !1;
    function _m(f) {
      f.updateQueue = { baseState: f.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function o_(f, h) {
      f = f.updateQueue, h.updateQueue === f && (h.updateQueue = { baseState: f.baseState, firstBaseUpdate: f.firstBaseUpdate, lastBaseUpdate: f.lastBaseUpdate, shared: f.shared, effects: f.effects });
    }
    function mo(f, h) {
      return { eventTime: f, lane: h, tag: 0, payload: null, callback: null, next: null };
    }
    function qo(f, h) {
      var x = f.updateQueue;
      x !== null && (x = x.shared, Pi !== null && (f.mode & 1) !== 0 && (vn & 2) === 0 ? (f = x.interleaved, f === null ? (h.next = h, Ga === null ? Ga = [x] : Ga.push(x)) : (h.next = f.next, f.next = h), x.interleaved = h) : (f = x.pending, f === null ? h.next = h : (h.next = f.next, f.next = h), x.pending = h));
    }
    function Pd(f, h, x) {
      if (h = h.updateQueue, h !== null && (h = h.shared, (x & 4194240) !== 0)) {
        var b = h.lanes;
        b &= f.pendingLanes, x |= b, h.lanes = x, Yo(f, x);
      }
    }
    function ym(f, h) {
      var x = f.updateQueue, b = f.alternate;
      if (b !== null && (b = b.updateQueue, x === b)) {
        var B = null, F = null;
        if (x = x.firstBaseUpdate, x !== null) {
          do {
            var K = { eventTime: x.eventTime, lane: x.lane, tag: x.tag, payload: x.payload, callback: x.callback, next: null };
            F === null ? B = F = K : F = F.next = K, x = x.next;
          } while (x !== null);
          F === null ? B = F = h : F = F.next = h;
        } else B = F = h;
        x = { baseState: b.baseState, firstBaseUpdate: B, lastBaseUpdate: F, shared: b.shared, effects: b.effects }, f.updateQueue = x;
        return;
      }
      f = x.lastBaseUpdate, f === null ? x.firstBaseUpdate = h : f.next = h, x.lastBaseUpdate = h;
    }
    function Id(f, h, x, b) {
      var B = f.updateQueue;
      Ko = !1;
      var F = B.firstBaseUpdate, K = B.lastBaseUpdate, de = B.shared.pending;
      if (de !== null) {
        B.shared.pending = null;
        var Le = de, ft = Le.next;
        Le.next = null, K === null ? F = ft : K.next = ft, K = Le;
        var Nt = f.alternate;
        Nt !== null && (Nt = Nt.updateQueue, de = Nt.lastBaseUpdate, de !== K && (de === null ? Nt.firstBaseUpdate = ft : de.next = ft, Nt.lastBaseUpdate = Le));
      }
      if (F !== null) {
        var ln = B.baseState;
        K = 0, Nt = ft = Le = null, de = F;
        do {
          var jt = de.lane, Xn = de.eventTime;
          if ((b & jt) === jt) {
            Nt !== null && (Nt = Nt.next = {
              eventTime: Xn,
              lane: 0,
              tag: de.tag,
              payload: de.payload,
              callback: de.callback,
              next: null
            });
            e: {
              var Jt = f, nr = de;
              switch (jt = h, Xn = x, nr.tag) {
                case 1:
                  if (Jt = nr.payload, typeof Jt == "function") {
                    ln = Jt.call(Xn, ln, jt);
                    break e;
                  }
                  ln = Jt;
                  break e;
                case 3:
                  Jt.flags = Jt.flags & -65537 | 128;
                case 0:
                  if (Jt = nr.payload, jt = typeof Jt == "function" ? Jt.call(Xn, ln, jt) : Jt, jt == null) break e;
                  ln = r({}, ln, jt);
                  break e;
                case 2:
                  Ko = !0;
              }
            }
            de.callback !== null && de.lane !== 0 && (f.flags |= 64, jt = B.effects, jt === null ? B.effects = [de] : jt.push(de));
          } else Xn = { eventTime: Xn, lane: jt, tag: de.tag, payload: de.payload, callback: de.callback, next: null }, Nt === null ? (ft = Nt = Xn, Le = ln) : Nt = Nt.next = Xn, K |= jt;
          if (de = de.next, de === null) {
            if (de = B.shared.pending, de === null) break;
            jt = de, de = jt.next, jt.next = null, B.lastBaseUpdate = jt, B.shared.pending = null;
          }
        } while (!0);
        if (Nt === null && (Le = ln), B.baseState = Le, B.firstBaseUpdate = ft, B.lastBaseUpdate = Nt, h = B.shared.interleaved, h !== null) {
          B = h;
          do
            K |= B.lane, B = B.next;
          while (B !== h);
        } else F === null && (B.shared.lanes = 0);
        zu |= K, f.lanes = K, f.memoizedState = ln;
      }
    }
    function l_(f, h, x) {
      if (f = h.effects, h.effects = null, f !== null) for (h = 0; h < f.length; h++) {
        var b = f[h], B = b.callback;
        if (B !== null) {
          if (b.callback = null, b = x, typeof B != "function") throw Error(o(191, B));
          B.call(b);
        }
      }
    }
    var u_ = new n.Component().refs;
    function xm(f, h, x, b) {
      h = f.memoizedState, x = x(b, h), x = x == null ? h : r({}, h, x), f.memoizedState = x, f.lanes === 0 && (f.updateQueue.baseState = x);
    }
    var Ud = { isMounted: function(f) {
      return (f = f._reactInternals) ? L(f) === f : !1;
    }, enqueueSetState: function(f, h, x) {
      f = f._reactInternals;
      var b = Hr(), B = Ji(f), F = mo(b, B);
      F.payload = h, x != null && (F.callback = x), qo(f, F), h = Ui(f, B, b), h !== null && Pd(h, f, B);
    }, enqueueReplaceState: function(f, h, x) {
      f = f._reactInternals;
      var b = Hr(), B = Ji(f), F = mo(b, B);
      F.tag = 1, F.payload = h, x != null && (F.callback = x), qo(f, F), h = Ui(f, B, b), h !== null && Pd(h, f, B);
    }, enqueueForceUpdate: function(f, h) {
      f = f._reactInternals;
      var x = Hr(), b = Ji(f), B = mo(
        x,
        b
      );
      B.tag = 2, h != null && (B.callback = h), qo(f, B), h = Ui(f, b, x), h !== null && Pd(h, f, b);
    } };
    function c_(f, h, x, b, B, F, K) {
      return f = f.stateNode, typeof f.shouldComponentUpdate == "function" ? f.shouldComponentUpdate(b, F, K) : h.prototype && h.prototype.isPureReactComponent ? !Xc(x, b) || !Xc(B, F) : !0;
    }
    function f_(f, h, x) {
      var b = !1, B = $r, F = h.contextType;
      return typeof F == "object" && F !== null ? F = Ir(F) : (B = $i(h) ? Fa : mn.current, b = h.contextTypes, F = (b = b != null) ? Gs(f, B) : $r), h = new h(x, F), f.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, h.updater = Ud, f.stateNode = h, h._reactInternals = f, b && (f = f.stateNode, f.__reactInternalMemoizedUnmaskedChildContext = B, f.__reactInternalMemoizedMaskedChildContext = F), h;
    }
    function d_(f, h, x, b) {
      f = h.state, typeof h.componentWillReceiveProps == "function" && h.componentWillReceiveProps(x, b), typeof h.UNSAFE_componentWillReceiveProps == "function" && h.UNSAFE_componentWillReceiveProps(x, b), h.state !== f && Ud.enqueueReplaceState(h, h.state, null);
    }
    function Sm(f, h, x, b) {
      var B = f.stateNode;
      B.props = x, B.state = f.memoizedState, B.refs = u_, _m(f);
      var F = h.contextType;
      typeof F == "object" && F !== null ? B.context = Ir(F) : (F = $i(h) ? Fa : mn.current, B.context = Gs(f, F)), B.state = f.memoizedState, F = h.getDerivedStateFromProps, typeof F == "function" && (xm(f, h, F, x), B.state = f.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof B.getSnapshotBeforeUpdate == "function" || typeof B.UNSAFE_componentWillMount != "function" && typeof B.componentWillMount != "function" || (h = B.state, typeof B.componentWillMount == "function" && B.componentWillMount(), typeof B.UNSAFE_componentWillMount == "function" && B.UNSAFE_componentWillMount(), h !== B.state && Ud.enqueueReplaceState(B, B.state, null), Id(f, x, B, b), B.state = f.memoizedState), typeof B.componentDidMount == "function" && (f.flags |= 4194308);
    }
    var Au = [], Mu = 0, Fd = null, Nd = 0, ks = [], Vs = 0, Ll = null, go = 1, vo = "";
    function Pl(f, h) {
      Au[Mu++] = Nd, Au[Mu++] = Fd, Fd = f, Nd = h;
    }
    function Eu(f, h, x) {
      ks[Vs++] = go, ks[Vs++] = vo, ks[Vs++] = Ll, Ll = f;
      var b = go;
      f = vo;
      var B = 32 - es(b) - 1;
      b &= ~(1 << B), x += 1;
      var F = 32 - es(h) + B;
      if (30 < F) {
        var K = B - B % 5;
        F = (b & (1 << K) - 1).toString(32), b >>= K, B -= K, go = 1 << 32 - es(h) + B | x << B | b, vo = F + f;
      } else go = 1 << F | x << B | b, vo = f;
    }
    function Od(f) {
      f.return !== null && (Pl(f, 1), Eu(f, 1, 0));
    }
    function Hd(f) {
      for (; f === Fd; ) Fd = Au[--Mu], Au[Mu] = null, Nd = Au[--Mu], Au[Mu] = null;
      for (; f === Ll; ) Ll = ks[--Vs], ks[Vs] = null, vo = ks[--Vs], ks[Vs] = null, go = ks[--Vs], ks[Vs] = null;
    }
    var ns = null, is = null, ni = !1, Tu = !1, Ws = null;
    function Am(f, h) {
      var x = Gr(5, null, null, 0);
      x.elementType = "DELETED", x.stateNode = h, x.return = f, h = f.deletions, h === null ? (f.deletions = [x], f.flags |= 16) : h.push(x);
    }
    function h_(f, h) {
      switch (f.tag) {
        case 5:
          return h = bt(h, f.type, f.pendingProps), h !== null ? (f.stateNode = h, ns = f, is = te(h), !0) : !1;
        case 6:
          return h = lt(h, f.pendingProps), h !== null ? (f.stateNode = h, ns = f, is = null, !0) : !1;
        case 13:
          if (h = Ot(h), h !== null) {
            var x = Ll !== null ? { id: go, overflow: vo } : null;
            return f.memoizedState = { dehydrated: h, treeContext: x, retryLane: 1073741824 }, x = Gr(18, null, null, 0), x.stateNode = h, x.return = f, f.child = x, ns = f, is = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function Mm(f) {
      return (f.mode & 1) !== 0 && (f.flags & 128) === 0;
    }
    function qc(f) {
      if (ni) {
        var h = is;
        if (h) {
          var x = h;
          if (!h_(f, h)) {
            if (Mm(f)) throw Error(o(418));
            h = Yt(x);
            var b = ns;
            h && h_(f, h) ? Am(b, x) : (f.flags = f.flags & -4097 | 2, ni = !1, ns = f);
          }
        } else {
          if (Mm(f)) throw Error(o(418));
          f.flags = f.flags & -4097 | 2, ni = !1, ns = f;
        }
      }
    }
    function zd(f) {
      for (f = f.return; f !== null && f.tag !== 5 && f.tag !== 3 && f.tag !== 13; ) f = f.return;
      ns = f;
    }
    function Xs(f) {
      if (!we || f !== ns) return !1;
      if (!ni) return zd(f), ni = !0, !1;
      if (f.tag !== 3 && (f.tag !== 5 || je(f.type) && !Xe(f.type, f.memoizedProps))) {
        var h = is;
        if (h) {
          if (Mm(f)) {
            for (f = is; f; ) f = Yt(f);
            throw Error(o(418));
          }
          for (; h; ) Am(f, h), h = Yt(h);
        }
      }
      if (zd(f), f.tag === 13) {
        if (!we) throw Error(o(316));
        if (f = f.memoizedState, f = f !== null ? f.dehydrated : null, !f) throw Error(o(317));
        is = k(f);
      } else is = ns ? Yt(f.stateNode) : null;
      return !0;
    }
    function jo() {
      we && (is = ns = null, Tu = ni = !1);
    }
    function bu(f) {
      Ws === null ? Ws = [f] : Ws.push(f);
    }
    function jc(f, h, x) {
      if (f = x.ref, f !== null && typeof f != "function" && typeof f != "object") {
        if (x._owner) {
          if (x = x._owner, x) {
            if (x.tag !== 1) throw Error(o(309));
            var b = x.stateNode;
          }
          if (!b) throw Error(o(147, f));
          var B = b, F = "" + f;
          return h !== null && h.ref !== null && typeof h.ref == "function" && h.ref._stringRef === F ? h.ref : (h = function(K) {
            var de = B.refs;
            de === u_ && (de = B.refs = {}), K === null ? delete de[F] : de[F] = K;
          }, h._stringRef = F, h);
        }
        if (typeof f != "string") throw Error(o(284));
        if (!x._owner) throw Error(o(290, f));
      }
      return f;
    }
    function Cu(f, h) {
      throw f = Object.prototype.toString.call(h), Error(o(31, f === "[object Object]" ? "object with keys {" + Object.keys(h).join(", ") + "}" : f));
    }
    function p_(f) {
      var h = f._init;
      return h(f._payload);
    }
    function Gd(f) {
      function h(Me, ve) {
        if (f) {
          var Ce = Me.deletions;
          Ce === null ? (Me.deletions = [ve], Me.flags |= 16) : Ce.push(ve);
        }
      }
      function x(Me, ve) {
        if (!f) return null;
        for (; ve !== null; ) h(Me, ve), ve = ve.sibling;
        return null;
      }
      function b(Me, ve) {
        for (Me = /* @__PURE__ */ new Map(); ve !== null; ) ve.key !== null ? Me.set(ve.key, ve) : Me.set(ve.index, ve), ve = ve.sibling;
        return Me;
      }
      function B(Me, ve) {
        return Me = bo(Me, ve), Me.index = 0, Me.sibling = null, Me;
      }
      function F(Me, ve, Ce) {
        return Me.index = Ce, f ? (Ce = Me.alternate, Ce !== null ? (Ce = Ce.index, Ce < ve ? (Me.flags |= 2, ve) : Ce) : (Me.flags |= 2, ve)) : (Me.flags |= 1048576, ve);
      }
      function K(Me) {
        return f && Me.alternate === null && (Me.flags |= 2), Me;
      }
      function de(Me, ve, Ce, _t) {
        return ve === null || ve.tag !== 6 ? (ve = Cs(Ce, Me.mode, _t), ve.return = Me, ve) : (ve = B(ve, Ce), ve.return = Me, ve);
      }
      function Le(Me, ve, Ce, _t) {
        var Vt = Ce.type;
        return Vt === p ? Nt(Me, ve, Ce.props.children, _t, Ce.key) : ve !== null && (ve.elementType === Vt || typeof Vt == "object" && Vt !== null && Vt.$$typeof === C && p_(Vt) === ve.type) ? (_t = B(ve, Ce.props), _t.ref = jc(Me, ve, Ce), _t.return = Me, _t) : (_t = Ku(Ce.type, Ce.key, Ce.props, null, Me.mode, _t), _t.ref = jc(Me, ve, Ce), _t.return = Me, _t);
      }
      function ft(Me, ve, Ce, _t) {
        return ve === null || ve.tag !== 4 || ve.stateNode.containerInfo !== Ce.containerInfo || ve.stateNode.implementation !== Ce.implementation ? (ve = qu(Ce, Me.mode, _t), ve.return = Me, ve) : (ve = B(ve, Ce.children || []), ve.return = Me, ve);
      }
      function Nt(Me, ve, Ce, _t, Vt) {
        return ve === null || ve.tag !== 7 ? (ve = kl(Ce, Me.mode, _t, Vt), ve.return = Me, ve) : (ve = B(ve, Ce), ve.return = Me, ve);
      }
      function ln(Me, ve, Ce) {
        if (typeof ve == "string" && ve !== "" || typeof ve == "number") return ve = Cs("" + ve, Me.mode, Ce), ve.return = Me, ve;
        if (typeof ve == "object" && ve !== null) {
          switch (ve.$$typeof) {
            case c:
              return Ce = Ku(ve.type, ve.key, ve.props, null, Me.mode, Ce), Ce.ref = jc(Me, null, ve), Ce.return = Me, Ce;
            case d:
              return ve = qu(ve, Me.mode, Ce), ve.return = Me, ve;
            case C:
              var _t = ve._init;
              return ln(Me, _t(ve._payload), Ce);
          }
          if (ie(ve) || U(ve)) return ve = kl(ve, Me.mode, Ce, null), ve.return = Me, ve;
          Cu(Me, ve);
        }
        return null;
      }
      function jt(Me, ve, Ce, _t) {
        var Vt = ve !== null ? ve.key : null;
        if (typeof Ce == "string" && Ce !== "" || typeof Ce == "number") return Vt !== null ? null : de(Me, ve, "" + Ce, _t);
        if (typeof Ce == "object" && Ce !== null) {
          switch (Ce.$$typeof) {
            case c:
              return Ce.key === Vt ? Le(Me, ve, Ce, _t) : null;
            case d:
              return Ce.key === Vt ? ft(Me, ve, Ce, _t) : null;
            case C:
              return Vt = Ce._init, jt(
                Me,
                ve,
                Vt(Ce._payload),
                _t
              );
          }
          if (ie(Ce) || U(Ce)) return Vt !== null ? null : Nt(Me, ve, Ce, _t, null);
          Cu(Me, Ce);
        }
        return null;
      }
      function Xn(Me, ve, Ce, _t, Vt) {
        if (typeof _t == "string" && _t !== "" || typeof _t == "number") return Me = Me.get(Ce) || null, de(ve, Me, "" + _t, Vt);
        if (typeof _t == "object" && _t !== null) {
          switch (_t.$$typeof) {
            case c:
              return Me = Me.get(_t.key === null ? Ce : _t.key) || null, Le(ve, Me, _t, Vt);
            case d:
              return Me = Me.get(_t.key === null ? Ce : _t.key) || null, ft(ve, Me, _t, Vt);
            case C:
              var dn = _t._init;
              return Xn(Me, ve, Ce, dn(_t._payload), Vt);
          }
          if (ie(_t) || U(_t)) return Me = Me.get(Ce) || null, Nt(ve, Me, _t, Vt, null);
          Cu(ve, _t);
        }
        return null;
      }
      function Jt(Me, ve, Ce, _t) {
        for (var Vt = null, dn = null, fn = ve, Bn = ve = 0, ir = null; fn !== null && Bn < Ce.length; Bn++) {
          fn.index > Bn ? (ir = fn, fn = null) : ir = fn.sibling;
          var In = jt(Me, fn, Ce[Bn], _t);
          if (In === null) {
            fn === null && (fn = ir);
            break;
          }
          f && fn && In.alternate === null && h(Me, fn), ve = F(In, ve, Bn), dn === null ? Vt = In : dn.sibling = In, dn = In, fn = ir;
        }
        if (Bn === Ce.length) return x(Me, fn), ni && Pl(Me, Bn), Vt;
        if (fn === null) {
          for (; Bn < Ce.length; Bn++) fn = ln(Me, Ce[Bn], _t), fn !== null && (ve = F(fn, ve, Bn), dn === null ? Vt = fn : dn.sibling = fn, dn = fn);
          return ni && Pl(Me, Bn), Vt;
        }
        for (fn = b(Me, fn); Bn < Ce.length; Bn++) ir = Xn(fn, Me, Bn, Ce[Bn], _t), ir !== null && (f && ir.alternate !== null && fn.delete(ir.key === null ? Bn : ir.key), ve = F(ir, ve, Bn), dn === null ? Vt = ir : dn.sibling = ir, dn = ir);
        return f && fn.forEach(function(ma) {
          return h(Me, ma);
        }), ni && Pl(Me, Bn), Vt;
      }
      function nr(Me, ve, Ce, _t) {
        var Vt = U(Ce);
        if (typeof Vt != "function") throw Error(o(150));
        if (Ce = Vt.call(Ce), Ce == null) throw Error(o(151));
        for (var dn = Vt = null, fn = ve, Bn = ve = 0, ir = null, In = Ce.next(); fn !== null && !In.done; Bn++, In = Ce.next()) {
          fn.index > Bn ? (ir = fn, fn = null) : ir = fn.sibling;
          var ma = jt(Me, fn, In.value, _t);
          if (ma === null) {
            fn === null && (fn = ir);
            break;
          }
          f && fn && ma.alternate === null && h(Me, fn), ve = F(ma, ve, Bn), dn === null ? Vt = ma : dn.sibling = ma, dn = ma, fn = ir;
        }
        if (In.done) return x(
          Me,
          fn
        ), ni && Pl(Me, Bn), Vt;
        if (fn === null) {
          for (; !In.done; Bn++, In = Ce.next()) In = ln(Me, In.value, _t), In !== null && (ve = F(In, ve, Bn), dn === null ? Vt = In : dn.sibling = In, dn = In);
          return ni && Pl(Me, Bn), Vt;
        }
        for (fn = b(Me, fn); !In.done; Bn++, In = Ce.next()) In = Xn(fn, Me, Bn, In.value, _t), In !== null && (f && In.alternate !== null && fn.delete(In.key === null ? Bn : In.key), ve = F(In, ve, Bn), dn === null ? Vt = In : dn.sibling = In, dn = In);
        return f && fn.forEach(function(U_) {
          return h(Me, U_);
        }), ni && Pl(Me, Bn), Vt;
      }
      function kr(Me, ve, Ce, _t) {
        if (typeof Ce == "object" && Ce !== null && Ce.type === p && Ce.key === null && (Ce = Ce.props.children), typeof Ce == "object" && Ce !== null) {
          switch (Ce.$$typeof) {
            case c:
              e: {
                for (var Vt = Ce.key, dn = ve; dn !== null; ) {
                  if (dn.key === Vt) {
                    if (Vt = Ce.type, Vt === p) {
                      if (dn.tag === 7) {
                        x(Me, dn.sibling), ve = B(dn, Ce.props.children), ve.return = Me, Me = ve;
                        break e;
                      }
                    } else if (dn.elementType === Vt || typeof Vt == "object" && Vt !== null && Vt.$$typeof === C && p_(Vt) === dn.type) {
                      x(Me, dn.sibling), ve = B(dn, Ce.props), ve.ref = jc(Me, dn, Ce), ve.return = Me, Me = ve;
                      break e;
                    }
                    x(Me, dn);
                    break;
                  } else h(Me, dn);
                  dn = dn.sibling;
                }
                Ce.type === p ? (ve = kl(Ce.props.children, Me.mode, _t, Ce.key), ve.return = Me, Me = ve) : (_t = Ku(Ce.type, Ce.key, Ce.props, null, Me.mode, _t), _t.ref = jc(Me, ve, Ce), _t.return = Me, Me = _t);
              }
              return K(Me);
            case d:
              e: {
                for (dn = Ce.key; ve !== null; ) {
                  if (ve.key === dn) if (ve.tag === 4 && ve.stateNode.containerInfo === Ce.containerInfo && ve.stateNode.implementation === Ce.implementation) {
                    x(Me, ve.sibling), ve = B(ve, Ce.children || []), ve.return = Me, Me = ve;
                    break e;
                  } else {
                    x(Me, ve);
                    break;
                  }
                  else h(Me, ve);
                  ve = ve.sibling;
                }
                ve = qu(Ce, Me.mode, _t), ve.return = Me, Me = ve;
              }
              return K(Me);
            case C:
              return dn = Ce._init, kr(Me, ve, dn(Ce._payload), _t);
          }
          if (ie(Ce)) return Jt(Me, ve, Ce, _t);
          if (U(Ce)) return nr(Me, ve, Ce, _t);
          Cu(Me, Ce);
        }
        return typeof Ce == "string" && Ce !== "" || typeof Ce == "number" ? (Ce = "" + Ce, ve !== null && ve.tag === 6 ? (x(Me, ve.sibling), ve = B(ve, Ce), ve.return = Me, Me = ve) : (x(Me, ve), ve = Cs(Ce, Me.mode, _t), ve.return = Me, Me = ve), K(Me)) : x(Me, ve);
      }
      return kr;
    }
    var wu = Gd(!0), kd = Gd(!1), Ru = {}, Es = ti(Ru), Bu = ti(Ru), _o = ti(Ru);
    function Bi(f) {
      if (f === Ru) throw Error(o(174));
      return f;
    }
    function Qc(f, h) {
      ht(_o, h), ht(Bu, f), ht(Es, Ru), f = pe(h), Qt(Es), ht(Es, f);
    }
    function yo() {
      Qt(Es), Qt(Bu), Qt(_o);
    }
    function ka(f) {
      var h = Bi(_o.current), x = Bi(Es.current);
      h = J(x, f.type, h), x !== h && (ht(Bu, f), ht(Es, h));
    }
    function Va(f) {
      Bu.current === f && (Qt(Es), Qt(Bu));
    }
    var Sn = ti(0);
    function Di(f) {
      for (var h = f; h !== null; ) {
        if (h.tag === 13) {
          var x = h.memoizedState;
          if (x !== null && (x = x.dehydrated, x === null || kt(x) || en(x))) return h;
        } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) {
          if ((h.flags & 128) !== 0) return h;
        } else if (h.child !== null) {
          h.child.return = h, h = h.child;
          continue;
        }
        if (h === f) break;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === f) return null;
          h = h.return;
        }
        h.sibling.return = h.return, h = h.sibling;
      }
      return null;
    }
    var Zc = [];
    function Ur() {
      for (var f = 0; f < Zc.length; f++) {
        var h = Zc[f];
        pt ? h._workInProgressVersionPrimary = null : h._workInProgressVersionSecondary = null;
      }
      Zc.length = 0;
    }
    var Js = u.ReactCurrentDispatcher, vi = u.ReactCurrentBatchConfig, Qo = 0, jn = null, cr = null, di = null, Il = !1, rs = !1, Zo = 0, Em = 0;
    function fr() {
      throw Error(o(321));
    }
    function Vd(f, h) {
      if (h === null) return !1;
      for (var x = 0; x < h.length && x < f.length; x++) if (!Oa(f[x], h[x])) return !1;
      return !0;
    }
    function Du(f, h, x, b, B, F) {
      if (Qo = F, jn = h, h.memoizedState = null, h.updateQueue = null, h.lanes = 0, Js.current = f === null || f.memoizedState === null ? Bm : Dm, f = x(b, B), rs) {
        F = 0;
        do {
          if (rs = !1, Zo = 0, 25 <= F) throw Error(o(301));
          F += 1, di = cr = null, h.updateQueue = null, Js.current = Lm, f = x(b, B);
        } while (rs);
      }
      if (Js.current = Pu, h = cr !== null && cr.next !== null, Qo = 0, di = cr = jn = null, Il = !1, h) throw Error(o(300));
      return f;
    }
    function Wd() {
      var f = Zo !== 0;
      return Zo = 0, f;
    }
    function xo() {
      var f = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return di === null ? jn.memoizedState = di = f : di = di.next = f, di;
    }
    function Fr() {
      if (cr === null) {
        var f = jn.alternate;
        f = f !== null ? f.memoizedState : null;
      } else f = cr.next;
      var h = di === null ? jn.memoizedState : di.next;
      if (h !== null) di = h, cr = f;
      else {
        if (f === null) throw Error(o(310));
        cr = f, f = { memoizedState: cr.memoizedState, baseState: cr.baseState, baseQueue: cr.baseQueue, queue: cr.queue, next: null }, di === null ? jn.memoizedState = di = f : di = di.next = f;
      }
      return di;
    }
    function $o(f, h) {
      return typeof h == "function" ? h(f) : h;
    }
    function rn(f) {
      var h = Fr(), x = h.queue;
      if (x === null) throw Error(o(311));
      x.lastRenderedReducer = f;
      var b = cr, B = b.baseQueue, F = x.pending;
      if (F !== null) {
        if (B !== null) {
          var K = B.next;
          B.next = F.next, F.next = K;
        }
        b.baseQueue = B = F, x.pending = null;
      }
      if (B !== null) {
        F = B.next, b = b.baseState;
        var de = K = null, Le = null, ft = F;
        do {
          var Nt = ft.lane;
          if ((Qo & Nt) === Nt) Le !== null && (Le = Le.next = { lane: 0, action: ft.action, hasEagerState: ft.hasEagerState, eagerState: ft.eagerState, next: null }), b = ft.hasEagerState ? ft.eagerState : f(b, ft.action);
          else {
            var ln = {
              lane: Nt,
              action: ft.action,
              hasEagerState: ft.hasEagerState,
              eagerState: ft.eagerState,
              next: null
            };
            Le === null ? (de = Le = ln, K = b) : Le = Le.next = ln, jn.lanes |= Nt, zu |= Nt;
          }
          ft = ft.next;
        } while (ft !== null && ft !== F);
        Le === null ? K = b : Le.next = de, Oa(b, h.memoizedState) || (Ts = !0), h.memoizedState = b, h.baseState = K, h.baseQueue = Le, x.lastRenderedState = b;
      }
      if (f = x.interleaved, f !== null) {
        B = f;
        do
          F = B.lane, jn.lanes |= F, zu |= F, B = B.next;
        while (B !== f);
      } else B === null && (x.lanes = 0);
      return [h.memoizedState, x.dispatch];
    }
    function zn(f) {
      var h = Fr(), x = h.queue;
      if (x === null) throw Error(o(311));
      x.lastRenderedReducer = f;
      var b = x.dispatch, B = x.pending, F = h.memoizedState;
      if (B !== null) {
        x.pending = null;
        var K = B = B.next;
        do
          F = f(F, K.action), K = K.next;
        while (K !== B);
        Oa(F, h.memoizedState) || (Ts = !0), h.memoizedState = F, h.baseQueue === null && (h.baseState = F), x.lastRenderedState = F;
      }
      return [F, b];
    }
    function Pn() {
    }
    function _i(f, h) {
      var x = jn, b = Fr(), B = h(), F = !Oa(b.memoizedState, B);
      if (F && (b.memoizedState = B, Ts = !0), b = b.queue, Ys(m_.bind(null, x, b, f), [f]), b.getSnapshot !== h || F || di !== null && di.memoizedState.tag & 1) {
        if (x.flags |= 2048, Ul(9, Tm.bind(null, x, b, B, h), void 0, null), Pi === null) throw Error(o(349));
        (Qo & 30) !== 0 || fa(x, h, B);
      }
      return B;
    }
    function fa(f, h, x) {
      f.flags |= 16384, f = { getSnapshot: h, value: x }, h = jn.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, jn.updateQueue = h, h.stores = [f]) : (x = h.stores, x === null ? h.stores = [f] : x.push(f));
    }
    function Tm(f, h, x, b) {
      h.value = x, h.getSnapshot = b, g_(h) && Ui(f, 1, -1);
    }
    function m_(f, h, x) {
      return x(function() {
        g_(h) && Ui(f, 1, -1);
      });
    }
    function g_(f) {
      var h = f.getSnapshot;
      f = f.value;
      try {
        var x = h();
        return !Oa(f, x);
      } catch {
        return !0;
      }
    }
    function bm(f) {
      var h = xo();
      return typeof f == "function" && (f = f()), h.memoizedState = h.baseState = f, f = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: $o, lastRenderedState: f }, h.queue = f, f = f.dispatch = Rm.bind(null, jn, f), [h.memoizedState, f];
    }
    function Ul(f, h, x, b) {
      return f = { tag: f, create: h, destroy: x, deps: b, next: null }, h = jn.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, jn.updateQueue = h, h.lastEffect = f.next = f) : (x = h.lastEffect, x === null ? h.lastEffect = f.next = f : (b = x.next, x.next = f, f.next = b, h.lastEffect = f)), f;
    }
    function Ze() {
      return Fr().memoizedState;
    }
    function yi(f, h, x, b) {
      var B = xo();
      jn.flags |= f, B.memoizedState = Ul(1 | h, x, void 0, b === void 0 ? null : b);
    }
    function gn(f, h, x, b) {
      var B = Fr();
      b = b === void 0 ? null : b;
      var F = void 0;
      if (cr !== null) {
        var K = cr.memoizedState;
        if (F = K.destroy, b !== null && Vd(b, K.deps)) {
          B.memoizedState = Ul(h, x, F, b);
          return;
        }
      }
      jn.flags |= f, B.memoizedState = Ul(1 | h, x, F, b);
    }
    function el(f, h) {
      return yi(8390656, 8, f, h);
    }
    function Ys(f, h) {
      return gn(2048, 8, f, h);
    }
    function tl(f, h) {
      return gn(4, 2, f, h);
    }
    function Wa(f, h) {
      return gn(4, 4, f, h);
    }
    function Lu(f, h) {
      if (typeof h == "function") return f = f(), h(f), function() {
        h(null);
      };
      if (h != null) return f = f(), h.current = f, function() {
        h.current = null;
      };
    }
    function Fl(f, h, x) {
      return x = x != null ? x.concat([f]) : null, gn(4, 4, Lu.bind(null, h, f), x);
    }
    function Nl() {
    }
    function Xd(f, h) {
      var x = Fr();
      h = h === void 0 ? null : h;
      var b = x.memoizedState;
      return b !== null && h !== null && Vd(h, b[1]) ? b[0] : (x.memoizedState = [f, h], f);
    }
    function Jd(f, h) {
      var x = Fr();
      h = h === void 0 ? null : h;
      var b = x.memoizedState;
      return b !== null && h !== null && Vd(h, b[1]) ? b[0] : (f = f(), x.memoizedState = [f, h], f);
    }
    function Cm(f, h) {
      var x = Fn;
      Fn = x !== 0 && 4 > x ? x : 4, f(!0);
      var b = vi.transition;
      vi.transition = {};
      try {
        f(!1), h();
      } finally {
        Fn = x, vi.transition = b;
      }
    }
    function Yd() {
      return Fr().memoizedState;
    }
    function wm(f, h, x) {
      var b = Ji(f);
      x = { lane: b, action: x, hasEagerState: !1, eagerState: null, next: null }, Kd(f) ? qd(h, x) : (jd(f, h, x), x = Hr(), f = Ui(f, b, x), f !== null && Qd(f, h, b));
    }
    function Rm(f, h, x) {
      var b = Ji(f), B = { lane: b, action: x, hasEagerState: !1, eagerState: null, next: null };
      if (Kd(f)) qd(h, B);
      else {
        jd(f, h, B);
        var F = f.alternate;
        if (f.lanes === 0 && (F === null || F.lanes === 0) && (F = h.lastRenderedReducer, F !== null)) try {
          var K = h.lastRenderedState, de = F(K, x);
          if (B.hasEagerState = !0, B.eagerState = de, Oa(de, K)) return;
        } catch {
        } finally {
        }
        x = Hr(), f = Ui(f, b, x), f !== null && Qd(f, h, b);
      }
    }
    function Kd(f) {
      var h = f.alternate;
      return f === jn || h !== null && h === jn;
    }
    function qd(f, h) {
      rs = Il = !0;
      var x = f.pending;
      x === null ? h.next = h : (h.next = x.next, x.next = h), f.pending = h;
    }
    function jd(f, h, x) {
      Pi !== null && (f.mode & 1) !== 0 && (vn & 2) === 0 ? (f = h.interleaved, f === null ? (x.next = x, Ga === null ? Ga = [h] : Ga.push(h)) : (x.next = f.next, f.next = x), h.interleaved = x) : (f = h.pending, f === null ? x.next = x : (x.next = f.next, f.next = x), h.pending = x);
    }
    function Qd(f, h, x) {
      if ((x & 4194240) !== 0) {
        var b = h.lanes;
        b &= f.pendingLanes, x |= b, h.lanes = x, Yo(f, x);
      }
    }
    var Pu = { readContext: Ir, useCallback: fr, useContext: fr, useEffect: fr, useImperativeHandle: fr, useInsertionEffect: fr, useLayoutEffect: fr, useMemo: fr, useReducer: fr, useRef: fr, useState: fr, useDebugValue: fr, useDeferredValue: fr, useTransition: fr, useMutableSource: fr, useSyncExternalStore: fr, useId: fr, unstable_isNewReconciler: !1 }, Bm = { readContext: Ir, useCallback: function(f, h) {
      return xo().memoizedState = [f, h === void 0 ? null : h], f;
    }, useContext: Ir, useEffect: el, useImperativeHandle: function(f, h, x) {
      return x = x != null ? x.concat([f]) : null, yi(
        4194308,
        4,
        Lu.bind(null, h, f),
        x
      );
    }, useLayoutEffect: function(f, h) {
      return yi(4194308, 4, f, h);
    }, useInsertionEffect: function(f, h) {
      return yi(4, 2, f, h);
    }, useMemo: function(f, h) {
      var x = xo();
      return h = h === void 0 ? null : h, f = f(), x.memoizedState = [f, h], f;
    }, useReducer: function(f, h, x) {
      var b = xo();
      return h = x !== void 0 ? x(h) : h, b.memoizedState = b.baseState = h, f = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: f, lastRenderedState: h }, b.queue = f, f = f.dispatch = wm.bind(null, jn, f), [b.memoizedState, f];
    }, useRef: function(f) {
      var h = xo();
      return f = { current: f }, h.memoizedState = f;
    }, useState: bm, useDebugValue: Nl, useDeferredValue: function(f) {
      var h = bm(f), x = h[0], b = h[1];
      return el(function() {
        var B = vi.transition;
        vi.transition = {};
        try {
          b(f);
        } finally {
          vi.transition = B;
        }
      }, [f]), x;
    }, useTransition: function() {
      var f = bm(!1), h = f[0];
      return f = Cm.bind(null, f[1]), xo().memoizedState = f, [h, f];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(f, h, x) {
      var b = jn, B = xo();
      if (ni) {
        if (x === void 0) throw Error(o(407));
        x = x();
      } else {
        if (x = h(), Pi === null) throw Error(o(349));
        (Qo & 30) !== 0 || fa(b, h, x);
      }
      B.memoizedState = x;
      var F = { value: x, getSnapshot: h };
      return B.queue = F, el(m_.bind(null, b, F, f), [f]), b.flags |= 2048, Ul(9, Tm.bind(null, b, F, x, h), void 0, null), x;
    }, useId: function() {
      var f = xo(), h = Pi.identifierPrefix;
      if (ni) {
        var x = vo, b = go;
        x = (b & ~(1 << 32 - es(b) - 1)).toString(32) + x, h = ":" + h + "R" + x, x = Zo++, 0 < x && (h += "H" + x.toString(32)), h += ":";
      } else x = Em++, h = ":" + h + "r" + x.toString(32) + ":";
      return f.memoizedState = h;
    }, unstable_isNewReconciler: !1 }, Dm = {
      readContext: Ir,
      useCallback: Xd,
      useContext: Ir,
      useEffect: Ys,
      useImperativeHandle: Fl,
      useInsertionEffect: tl,
      useLayoutEffect: Wa,
      useMemo: Jd,
      useReducer: rn,
      useRef: Ze,
      useState: function() {
        return rn($o);
      },
      useDebugValue: Nl,
      useDeferredValue: function(f) {
        var h = rn($o), x = h[0], b = h[1];
        return Ys(function() {
          var B = vi.transition;
          vi.transition = {};
          try {
            b(f);
          } finally {
            vi.transition = B;
          }
        }, [f]), x;
      },
      useTransition: function() {
        var f = rn($o)[0], h = Fr().memoizedState;
        return [f, h];
      },
      useMutableSource: Pn,
      useSyncExternalStore: _i,
      useId: Yd,
      unstable_isNewReconciler: !1
    }, Lm = {
      readContext: Ir,
      useCallback: Xd,
      useContext: Ir,
      useEffect: Ys,
      useImperativeHandle: Fl,
      useInsertionEffect: tl,
      useLayoutEffect: Wa,
      useMemo: Jd,
      useReducer: zn,
      useRef: Ze,
      useState: function() {
        return zn($o);
      },
      useDebugValue: Nl,
      useDeferredValue: function(f) {
        var h = zn($o), x = h[0], b = h[1];
        return Ys(function() {
          var B = vi.transition;
          vi.transition = {};
          try {
            b(f);
          } finally {
            vi.transition = B;
          }
        }, [f]), x;
      },
      useTransition: function() {
        var f = zn($o)[0], h = Fr().memoizedState;
        return [f, h];
      },
      useMutableSource: Pn,
      useSyncExternalStore: _i,
      useId: Yd,
      unstable_isNewReconciler: !1
    };
    function $c(f, h) {
      try {
        var x = "", b = h;
        do
          x += s_(b), b = b.return;
        while (b);
        var B = x;
      } catch (F) {
        B = `
Error generating stack: ` + F.message + `
` + F.stack;
      }
      return { value: f, source: h, stack: B };
    }
    function Iu(f, h) {
      try {
        console.error(h.value);
      } catch (x) {
        setTimeout(function() {
          throw x;
        });
      }
    }
    var Uu = typeof WeakMap == "function" ? WeakMap : Map;
    function Zd(f, h, x) {
      x = mo(-1, x), x.tag = 3, x.payload = { element: null };
      var b = h.value;
      return x.callback = function() {
        _h || (_h = !0, Wm = b), Iu(f, h);
      }, x;
    }
    function $d(f, h, x) {
      x = mo(-1, x), x.tag = 3;
      var b = f.type.getDerivedStateFromError;
      if (typeof b == "function") {
        var B = h.value;
        x.payload = function() {
          return b(B);
        }, x.callback = function() {
          Iu(f, h);
        };
      }
      var F = f.stateNode;
      return F !== null && typeof F.componentDidCatch == "function" && (x.callback = function() {
        Iu(f, h), typeof b != "function" && (al === null ? al = /* @__PURE__ */ new Set([this]) : al.add(this));
        var K = h.stack;
        this.componentDidCatch(h.value, { componentStack: K !== null ? K : "" });
      }), x;
    }
    function eh(f, h, x) {
      var b = f.pingCache;
      if (b === null) {
        b = f.pingCache = new Uu();
        var B = /* @__PURE__ */ new Set();
        b.set(h, B);
      } else B = b.get(h), B === void 0 && (B = /* @__PURE__ */ new Set(), b.set(h, B));
      B.has(x) || (B.add(x), f = cf.bind(null, f, h, x), h.then(f, f));
    }
    function th(f) {
      do {
        var h;
        if ((h = f.tag === 13) && (h = f.memoizedState, h = h !== null ? h.dehydrated !== null : !0), h) return f;
        f = f.return;
      } while (f !== null);
      return null;
    }
    function Pm(f, h, x, b, B) {
      return (f.mode & 1) === 0 ? (f === h ? f.flags |= 65536 : (f.flags |= 128, x.flags |= 131072, x.flags &= -52805, x.tag === 1 && (x.alternate === null ? x.tag = 17 : (h = mo(-1, 1), h.tag = 2, qo(x, h))), x.lanes |= 1), f) : (f.flags |= 65536, f.lanes = B, f);
    }
    function ss(f) {
      f.flags |= 4;
    }
    function Im(f, h) {
      if (f !== null && f.child === h.child) return !0;
      if ((h.flags & 16) !== 0) return !1;
      for (f = h.child; f !== null; ) {
        if ((f.flags & 12854) !== 0 || (f.subtreeFlags & 12854) !== 0) return !1;
        f = f.sibling;
      }
      return !0;
    }
    var So, da, Cr, nh;
    if (mt) So = function(f, h) {
      for (var x = h.child; x !== null; ) {
        if (x.tag === 5 || x.tag === 6) Se(f, x.stateNode);
        else if (x.tag !== 4 && x.child !== null) {
          x.child.return = x, x = x.child;
          continue;
        }
        if (x === h) break;
        for (; x.sibling === null; ) {
          if (x.return === null || x.return === h) return;
          x = x.return;
        }
        x.sibling.return = x.return, x = x.sibling;
      }
    }, da = function() {
    }, Cr = function(f, h, x, b, B) {
      if (f = f.memoizedProps, f !== b) {
        var F = h.stateNode, K = Bi(Es.current);
        x = ye(F, x, f, b, B, K), (h.updateQueue = x) && ss(h);
      }
    }, nh = function(f, h, x, b) {
      x !== b && ss(h);
    };
    else if (ne) {
      So = function(f, h, x, b) {
        for (var B = h.child; B !== null; ) {
          if (B.tag === 5) {
            var F = B.stateNode;
            x && b && (F = wt(F, B.type, B.memoizedProps, B)), Se(f, F);
          } else if (B.tag === 6) F = B.stateNode, x && b && (F = St(F, B.memoizedProps, B)), Se(f, F);
          else if (B.tag !== 4) {
            if (B.tag === 22 && B.memoizedState !== null) F = B.child, F !== null && (F.return = B), So(f, B, !0, !0);
            else if (B.child !== null) {
              B.child.return = B, B = B.child;
              continue;
            }
          }
          if (B === h) break;
          for (; B.sibling === null; ) {
            if (B.return === null || B.return === h) return;
            B = B.return;
          }
          B.sibling.return = B.return, B = B.sibling;
        }
      };
      var Qn = function(f, h, x, b) {
        for (var B = h.child; B !== null; ) {
          if (B.tag === 5) {
            var F = B.stateNode;
            x && b && (F = wt(F, B.type, B.memoizedProps, B)), ot(f, F);
          } else if (B.tag === 6) F = B.stateNode, x && b && (F = St(F, B.memoizedProps, B)), ot(f, F);
          else if (B.tag !== 4) {
            if (B.tag === 22 && B.memoizedState !== null) F = B.child, F !== null && (F.return = B), Qn(f, B, !0, !0);
            else if (B.child !== null) {
              B.child.return = B, B = B.child;
              continue;
            }
          }
          if (B === h) break;
          for (; B.sibling === null; ) {
            if (B.return === null || B.return === h) return;
            B = B.return;
          }
          B.sibling.return = B.return, B = B.sibling;
        }
      };
      da = function(f, h) {
        var x = h.stateNode;
        if (!Im(f, h)) {
          f = x.containerInfo;
          var b = Wt(f);
          Qn(b, h, !1, !1), x.pendingChildren = b, ss(h), an(f, b);
        }
      }, Cr = function(f, h, x, b, B) {
        var F = f.stateNode, K = f.memoizedProps;
        if ((f = Im(f, h)) && K === b) h.stateNode = F;
        else {
          var de = h.stateNode, Le = Bi(Es.current), ft = null;
          K !== b && (ft = ye(de, x, K, b, B, Le)), f && ft === null ? h.stateNode = F : (F = at(F, ft, x, K, b, h, f, de), me(F, x, b, B, Le) && ss(h), h.stateNode = F, f ? ss(h) : So(F, h, !1, !1));
        }
      }, nh = function(f, h, x, b) {
        x !== b ? (f = Bi(_o.current), x = Bi(Es.current), h.stateNode = Je(b, f, x, h), ss(h)) : h.stateNode = f.stateNode;
      };
    } else da = function() {
    }, Cr = function() {
    }, nh = function() {
    };
    function nl(f, h) {
      if (!ni) switch (f.tailMode) {
        case "hidden":
          h = f.tail;
          for (var x = null; h !== null; ) h.alternate !== null && (x = h), h = h.sibling;
          x === null ? f.tail = null : x.sibling = null;
          break;
        case "collapsed":
          x = f.tail;
          for (var b = null; x !== null; ) x.alternate !== null && (b = x), x = x.sibling;
          b === null ? h || f.tail === null ? f.tail = null : f.tail.sibling = null : b.sibling = null;
      }
    }
    function ki(f) {
      var h = f.alternate !== null && f.alternate.child === f.child, x = 0, b = 0;
      if (h) for (var B = f.child; B !== null; ) x |= B.lanes | B.childLanes, b |= B.subtreeFlags & 14680064, b |= B.flags & 14680064, B.return = f, B = B.sibling;
      else for (B = f.child; B !== null; ) x |= B.lanes | B.childLanes, b |= B.subtreeFlags, b |= B.flags, B.return = f, B = B.sibling;
      return f.subtreeFlags |= b, f.childLanes = x, h;
    }
    function ef(f, h, x) {
      var b = h.pendingProps;
      switch (Hd(h), h.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return ki(h), null;
        case 1:
          return $i(h.type) && fi(), ki(h), null;
        case 3:
          return b = h.stateNode, yo(), Qt(mi), Qt(mn), Ur(), b.pendingContext && (b.context = b.pendingContext, b.pendingContext = null), (f === null || f.child === null) && (Xs(h) ? ss(h) : f === null || f.memoizedState.isDehydrated && (h.flags & 256) === 0 || (h.flags |= 1024, Ws !== null && (Ah(Ws), Ws = null))), da(f, h), ki(h), null;
        case 5:
          Va(h), x = Bi(_o.current);
          var B = h.type;
          if (f !== null && h.stateNode != null) Cr(f, h, B, b, x), f.ref !== h.ref && (h.flags |= 512, h.flags |= 2097152);
          else {
            if (!b) {
              if (h.stateNode === null) throw Error(o(166));
              return ki(h), null;
            }
            if (f = Bi(Es.current), Xs(h)) {
              if (!we) throw Error(o(175));
              f = gt(h.stateNode, h.type, h.memoizedProps, x, f, h, !Tu), h.updateQueue = f, f !== null && ss(h);
            } else {
              var F = ue(B, b, x, f, h);
              So(F, h, !1, !1), h.stateNode = F, me(F, B, b, x, f) && ss(h);
            }
            h.ref !== null && (h.flags |= 512, h.flags |= 2097152);
          }
          return ki(h), null;
        case 6:
          if (f && h.stateNode != null) nh(f, h, f.memoizedProps, b);
          else {
            if (typeof b != "string" && h.stateNode === null) throw Error(o(166));
            if (f = Bi(_o.current), x = Bi(Es.current), Xs(h)) {
              if (!we) throw Error(o(176));
              if (f = h.stateNode, b = h.memoizedProps, (x = Ht(f, b, h, !Tu)) && (B = ns, B !== null)) switch (F = (B.mode & 1) !== 0, B.tag) {
                case 3:
                  Rt(B.stateNode.containerInfo, f, b, F);
                  break;
                case 5:
                  Ft(B.type, B.memoizedProps, B.stateNode, f, b, F);
              }
              x && ss(h);
            } else h.stateNode = Je(b, f, x, h);
          }
          return ki(h), null;
        case 13:
          if (Qt(Sn), b = h.memoizedState, ni && is !== null && (h.mode & 1) !== 0 && (h.flags & 128) === 0) {
            for (f = is; f; ) f = Yt(f);
            return jo(), h.flags |= 98560, h;
          }
          if (b !== null && b.dehydrated !== null) {
            if (b = Xs(h), f === null) {
              if (!b) throw Error(o(318));
              if (!we) throw Error(o(344));
              if (f = h.memoizedState, f = f !== null ? f.dehydrated : null, !f) throw Error(o(317));
              tn(f, h);
            } else jo(), (h.flags & 128) === 0 && (h.memoizedState = null), h.flags |= 4;
            return ki(h), null;
          }
          return Ws !== null && (Ah(Ws), Ws = null), (h.flags & 128) !== 0 ? (h.lanes = x, h) : (b = b !== null, x = !1, f === null ? Xs(h) : x = f.memoizedState !== null, b && !x && (h.child.flags |= 8192, (h.mode & 1) !== 0 && (f === null || (Sn.current & 1) !== 0 ? Xi === 0 && (Xi = 3) : Mh())), h.updateQueue !== null && (h.flags |= 4), ki(h), null);
        case 4:
          return yo(), da(f, h), f === null && He(h.stateNode.containerInfo), ki(h), null;
        case 10:
          return Ld(h.type._context), ki(h), null;
        case 17:
          return $i(h.type) && fi(), ki(h), null;
        case 19:
          if (Qt(Sn), B = h.memoizedState, B === null) return ki(h), null;
          if (b = (h.flags & 128) !== 0, F = B.rendering, F === null) if (b) nl(B, !1);
          else {
            if (Xi !== 0 || f !== null && (f.flags & 128) !== 0) for (f = h.child; f !== null; ) {
              if (F = Di(f), F !== null) {
                for (h.flags |= 128, nl(B, !1), f = F.updateQueue, f !== null && (h.updateQueue = f, h.flags |= 4), h.subtreeFlags = 0, f = x, b = h.child; b !== null; ) x = b, B = f, x.flags &= 14680066, F = x.alternate, F === null ? (x.childLanes = 0, x.lanes = B, x.child = null, x.subtreeFlags = 0, x.memoizedProps = null, x.memoizedState = null, x.updateQueue = null, x.dependencies = null, x.stateNode = null) : (x.childLanes = F.childLanes, x.lanes = F.lanes, x.child = F.child, x.subtreeFlags = 0, x.deletions = null, x.memoizedProps = F.memoizedProps, x.memoizedState = F.memoizedState, x.updateQueue = F.updateQueue, x.type = F.type, B = F.dependencies, x.dependencies = B === null ? null : { lanes: B.lanes, firstContext: B.firstContext }), b = b.sibling;
                return ht(Sn, Sn.current & 1 | 2), h.child;
              }
              f = f.sibling;
            }
            B.tail !== null && er() > Vm && (h.flags |= 128, b = !0, nl(B, !1), h.lanes = 4194304);
          }
          else {
            if (!b) if (f = Di(F), f !== null) {
              if (h.flags |= 128, b = !0, f = f.updateQueue, f !== null && (h.updateQueue = f, h.flags |= 4), nl(B, !0), B.tail === null && B.tailMode === "hidden" && !F.alternate && !ni) return ki(h), null;
            } else 2 * er() - B.renderingStartTime > Vm && x !== 1073741824 && (h.flags |= 128, b = !0, nl(B, !1), h.lanes = 4194304);
            B.isBackwards ? (F.sibling = h.child, h.child = F) : (f = B.last, f !== null ? f.sibling = F : h.child = F, B.last = F);
          }
          return B.tail !== null ? (h = B.tail, B.rendering = h, B.tail = h.sibling, B.renderingStartTime = er(), h.sibling = null, f = Sn.current, ht(Sn, b ? f & 1 | 2 : f & 1), h) : (ki(h), null);
        case 22:
        case 23:
          return Km(), b = h.memoizedState !== null, f !== null && f.memoizedState !== null !== b && (h.flags |= 8192), b && (h.mode & 1) !== 0 ? (dr & 1073741824) !== 0 && (ki(h), mt && h.subtreeFlags & 6 && (h.flags |= 8192)) : ki(h), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(o(156, h.tag));
    }
    var ih = u.ReactCurrentOwner, Ts = !1;
    function Nr(f, h, x, b) {
      h.child = f === null ? kd(h, null, x, b) : wu(h, f.child, x, b);
    }
    function v_(f, h, x, b, B) {
      x = x.render;
      var F = h.ref;
      return Su(h, B), b = Du(f, h, x, b, F, B), x = Wd(), f !== null && !Ts ? (h.updateQueue = f.updateQueue, h.flags &= -2053, f.lanes &= ~B, Xa(f, h, B)) : (ni && x && Od(h), h.flags |= 1, Nr(f, h, b, B), h.child);
    }
    function __(f, h, x, b, B) {
      if (f === null) {
        var F = x.type;
        return typeof F == "function" && !Eh(F) && F.defaultProps === void 0 && x.compare === null && x.defaultProps === void 0 ? (h.tag = 15, h.type = F, rh(f, h, F, b, B)) : (f = Ku(x.type, null, b, h, h.mode, B), f.ref = h.ref, f.return = h, h.child = f);
      }
      if (F = f.child, (f.lanes & B) === 0) {
        var K = F.memoizedProps;
        if (x = x.compare, x = x !== null ? x : Xc, x(K, b) && f.ref === h.ref) return Xa(f, h, B);
      }
      return h.flags |= 1, f = bo(F, b), f.ref = h.ref, f.return = h, h.child = f;
    }
    function rh(f, h, x, b, B) {
      if (f !== null && Xc(f.memoizedProps, b) && f.ref === h.ref) if (Ts = !1, (f.lanes & B) !== 0) (f.flags & 131072) !== 0 && (Ts = !0);
      else return h.lanes = f.lanes, Xa(f, h, B);
      return ah(f, h, x, b, B);
    }
    function y_(f, h, x) {
      var b = h.pendingProps, B = b.children, F = f !== null ? f.memoizedState : null;
      if (b.mode === "hidden") if ((h.mode & 1) === 0) h.memoizedState = { baseLanes: 0, cachePool: null }, ht(pa, dr), dr |= x;
      else if ((x & 1073741824) !== 0) h.memoizedState = { baseLanes: 0, cachePool: null }, b = F !== null ? F.baseLanes : x, ht(pa, dr), dr |= b;
      else return f = F !== null ? F.baseLanes | x : x, h.lanes = h.childLanes = 1073741824, h.memoizedState = { baseLanes: f, cachePool: null }, h.updateQueue = null, ht(pa, dr), dr |= f, null;
      else F !== null ? (b = F.baseLanes | x, h.memoizedState = null) : b = x, ht(pa, dr), dr |= b;
      return Nr(f, h, B, x), h.child;
    }
    function sh(f, h) {
      var x = h.ref;
      (f === null && x !== null || f !== null && f.ref !== x) && (h.flags |= 512, h.flags |= 2097152);
    }
    function ah(f, h, x, b, B) {
      var F = $i(x) ? Fa : mn.current;
      return F = Gs(h, F), Su(h, B), x = Du(f, h, x, b, F, B), b = Wd(), f !== null && !Ts ? (h.updateQueue = f.updateQueue, h.flags &= -2053, f.lanes &= ~B, Xa(f, h, B)) : (ni && b && Od(h), h.flags |= 1, Nr(f, h, x, B), h.child);
    }
    function x_(f, h, x, b, B) {
      if ($i(x)) {
        var F = !0;
        Gi(h);
      } else F = !1;
      if (Su(h, B), h.stateNode === null) f !== null && (f.alternate = null, h.alternate = null, h.flags |= 2), f_(h, x, b), Sm(h, x, b, B), b = !0;
      else if (f === null) {
        var K = h.stateNode, de = h.memoizedProps;
        K.props = de;
        var Le = K.context, ft = x.contextType;
        typeof ft == "object" && ft !== null ? ft = Ir(ft) : (ft = $i(x) ? Fa : mn.current, ft = Gs(h, ft));
        var Nt = x.getDerivedStateFromProps, ln = typeof Nt == "function" || typeof K.getSnapshotBeforeUpdate == "function";
        ln || typeof K.UNSAFE_componentWillReceiveProps != "function" && typeof K.componentWillReceiveProps != "function" || (de !== b || Le !== ft) && d_(h, K, b, ft), Ko = !1;
        var jt = h.memoizedState;
        K.state = jt, Id(h, b, K, B), Le = h.memoizedState, de !== b || jt !== Le || mi.current || Ko ? (typeof Nt == "function" && (xm(h, x, Nt, b), Le = h.memoizedState), (de = Ko || c_(h, x, de, b, jt, Le, ft)) ? (ln || typeof K.UNSAFE_componentWillMount != "function" && typeof K.componentWillMount != "function" || (typeof K.componentWillMount == "function" && K.componentWillMount(), typeof K.UNSAFE_componentWillMount == "function" && K.UNSAFE_componentWillMount()), typeof K.componentDidMount == "function" && (h.flags |= 4194308)) : (typeof K.componentDidMount == "function" && (h.flags |= 4194308), h.memoizedProps = b, h.memoizedState = Le), K.props = b, K.state = Le, K.context = ft, b = de) : (typeof K.componentDidMount == "function" && (h.flags |= 4194308), b = !1);
      } else {
        K = h.stateNode, o_(f, h), de = h.memoizedProps, ft = h.type === h.elementType ? de : ca(h.type, de), K.props = ft, ln = h.pendingProps, jt = K.context, Le = x.contextType, typeof Le == "object" && Le !== null ? Le = Ir(Le) : (Le = $i(x) ? Fa : mn.current, Le = Gs(h, Le));
        var Xn = x.getDerivedStateFromProps;
        (Nt = typeof Xn == "function" || typeof K.getSnapshotBeforeUpdate == "function") || typeof K.UNSAFE_componentWillReceiveProps != "function" && typeof K.componentWillReceiveProps != "function" || (de !== ln || jt !== Le) && d_(h, K, b, Le), Ko = !1, jt = h.memoizedState, K.state = jt, Id(h, b, K, B);
        var Jt = h.memoizedState;
        de !== ln || jt !== Jt || mi.current || Ko ? (typeof Xn == "function" && (xm(h, x, Xn, b), Jt = h.memoizedState), (ft = Ko || c_(h, x, ft, b, jt, Jt, Le) || !1) ? (Nt || typeof K.UNSAFE_componentWillUpdate != "function" && typeof K.componentWillUpdate != "function" || (typeof K.componentWillUpdate == "function" && K.componentWillUpdate(
          b,
          Jt,
          Le
        ), typeof K.UNSAFE_componentWillUpdate == "function" && K.UNSAFE_componentWillUpdate(b, Jt, Le)), typeof K.componentDidUpdate == "function" && (h.flags |= 4), typeof K.getSnapshotBeforeUpdate == "function" && (h.flags |= 1024)) : (typeof K.componentDidUpdate != "function" || de === f.memoizedProps && jt === f.memoizedState || (h.flags |= 4), typeof K.getSnapshotBeforeUpdate != "function" || de === f.memoizedProps && jt === f.memoizedState || (h.flags |= 1024), h.memoizedProps = b, h.memoizedState = Jt), K.props = b, K.state = Jt, K.context = Le, b = ft) : (typeof K.componentDidUpdate != "function" || de === f.memoizedProps && jt === f.memoizedState || (h.flags |= 4), typeof K.getSnapshotBeforeUpdate != "function" || de === f.memoizedProps && jt === f.memoizedState || (h.flags |= 1024), b = !1);
      }
      return Fu(f, h, x, b, F, B);
    }
    function Fu(f, h, x, b, B, F) {
      sh(f, h);
      var K = (h.flags & 128) !== 0;
      if (!b && !K) return B && Bl(h, x, !1), Xa(f, h, F);
      b = h.stateNode, ih.current = h;
      var de = K && typeof x.getDerivedStateFromError != "function" ? null : b.render();
      return h.flags |= 1, f !== null && K ? (h.child = wu(h, f.child, null, F), h.child = wu(h, null, de, F)) : Nr(f, h, de, F), h.memoizedState = b.state, B && Bl(h, x, !0), h.child;
    }
    function S_(f) {
      var h = f.stateNode;
      h.pendingContext ? ua(f, h.pendingContext, h.pendingContext !== h.context) : h.context && ua(f, h.context, !1), Qc(f, h.containerInfo);
    }
    function Um(f, h, x, b, B) {
      return jo(), bu(B), h.flags |= 256, Nr(f, h, x, b), h.child;
    }
    var oh = { dehydrated: null, treeContext: null, retryLane: 0 };
    function lh(f) {
      return { baseLanes: f, cachePool: null };
    }
    function il(f, h, x) {
      var b = h.pendingProps, B = Sn.current, F = !1, K = (h.flags & 128) !== 0, de;
      if ((de = K) || (de = f !== null && f.memoizedState === null ? !1 : (B & 2) !== 0), de ? (F = !0, h.flags &= -129) : (f === null || f.memoizedState !== null) && (B |= 1), ht(Sn, B & 1), f === null)
        return qc(h), f = h.memoizedState, f !== null && (f = f.dehydrated, f !== null) ? ((h.mode & 1) === 0 ? h.lanes = 1 : en(f) ? h.lanes = 8 : h.lanes = 1073741824, null) : (B = b.children, f = b.fallback, F ? (b = h.mode, F = h.child, B = { mode: "hidden", children: B }, (b & 1) === 0 && F !== null ? (F.childLanes = 0, F.pendingProps = B) : F = Th(B, b, 0, null), f = kl(f, b, x, null), F.return = h, f.return = h, F.sibling = f, h.child = F, h.child.memoizedState = lh(x), h.memoizedState = oh, f) : Ol(h, B));
      if (B = f.memoizedState, B !== null) {
        if (de = B.dehydrated, de !== null) {
          if (K)
            return h.flags & 256 ? (h.flags &= -257, wr(f, h, x, Error(o(422)))) : h.memoizedState !== null ? (h.child = f.child, h.flags |= 128, null) : (F = b.fallback, B = h.mode, b = Th({ mode: "visible", children: b.children }, B, 0, null), F = kl(F, B, x, null), F.flags |= 2, b.return = h, F.return = h, b.sibling = F, h.child = b, (h.mode & 1) !== 0 && wu(
              h,
              f.child,
              null,
              x
            ), h.child.memoizedState = lh(x), h.memoizedState = oh, F);
          if ((h.mode & 1) === 0) h = wr(f, h, x, null);
          else if (en(de)) h = wr(f, h, x, Error(o(419)));
          else if (b = (x & f.childLanes) !== 0, Ts || b) {
            if (b = Pi, b !== null) {
              switch (x & -x) {
                case 4:
                  F = 2;
                  break;
                case 16:
                  F = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  F = 32;
                  break;
                case 536870912:
                  F = 268435456;
                  break;
                default:
                  F = 0;
              }
              b = (F & (b.suspendedLanes | x)) !== 0 ? 0 : F, b !== 0 && b !== B.retryLane && (B.retryLane = b, Ui(f, b, -1));
            }
            Mh(), h = wr(f, h, x, Error(o(421)));
          } else kt(de) ? (h.flags |= 128, h.child = f.child, h = ff.bind(null, f), Vn(de, h), h = null) : (x = B.treeContext, we && (is = tt(de), ns = h, ni = !0, Ws = null, Tu = !1, x !== null && (ks[Vs++] = go, ks[Vs++] = vo, ks[Vs++] = Ll, go = x.id, vo = x.overflow, Ll = h)), h = Ol(h, h.pendingProps.children), h.flags |= 4096);
          return h;
        }
        return F ? (b = uh(f, h, b.children, b.fallback, x), F = h.child, B = f.child.memoizedState, F.memoizedState = B === null ? lh(x) : { baseLanes: B.baseLanes | x, cachePool: null }, F.childLanes = f.childLanes & ~x, h.memoizedState = oh, b) : (x = rl(f, h, b.children, x), h.memoizedState = null, x);
      }
      return F ? (b = uh(f, h, b.children, b.fallback, x), F = h.child, B = f.child.memoizedState, F.memoizedState = B === null ? lh(x) : { baseLanes: B.baseLanes | x, cachePool: null }, F.childLanes = f.childLanes & ~x, h.memoizedState = oh, b) : (x = rl(f, h, b.children, x), h.memoizedState = null, x);
    }
    function Ol(f, h) {
      return h = Th({ mode: "visible", children: h }, f.mode, 0, null), h.return = f, f.child = h;
    }
    function rl(f, h, x, b) {
      var B = f.child;
      return f = B.sibling, x = bo(B, { mode: "visible", children: x }), (h.mode & 1) === 0 && (x.lanes = b), x.return = h, x.sibling = null, f !== null && (b = h.deletions, b === null ? (h.deletions = [f], h.flags |= 16) : b.push(f)), h.child = x;
    }
    function uh(f, h, x, b, B) {
      var F = h.mode;
      f = f.child;
      var K = f.sibling, de = { mode: "hidden", children: x };
      return (F & 1) === 0 && h.child !== f ? (x = h.child, x.childLanes = 0, x.pendingProps = de, h.deletions = null) : (x = bo(f, de), x.subtreeFlags = f.subtreeFlags & 14680064), K !== null ? b = bo(K, b) : (b = kl(b, F, B, null), b.flags |= 2), b.return = h, x.return = h, x.sibling = b, h.child = x, b;
    }
    function wr(f, h, x, b) {
      return b !== null && bu(b), wu(h, f.child, null, x), f = Ol(h, h.pendingProps.children), f.flags |= 2, h.memoizedState = null, f;
    }
    function Hl(f, h, x) {
      f.lanes |= h;
      var b = f.alternate;
      b !== null && (b.lanes |= h), Kc(f.return, h, x);
    }
    function cn(f, h, x, b, B) {
      var F = f.memoizedState;
      F === null ? f.memoizedState = { isBackwards: h, rendering: null, renderingStartTime: 0, last: b, tail: x, tailMode: B } : (F.isBackwards = h, F.rendering = null, F.renderingStartTime = 0, F.last = b, F.tail = x, F.tailMode = B);
    }
    function tf(f, h, x) {
      var b = h.pendingProps, B = b.revealOrder, F = b.tail;
      if (Nr(f, h, b.children, x), b = Sn.current, (b & 2) !== 0) b = b & 1 | 2, h.flags |= 128;
      else {
        if (f !== null && (f.flags & 128) !== 0) e: for (f = h.child; f !== null; ) {
          if (f.tag === 13) f.memoizedState !== null && Hl(f, x, h);
          else if (f.tag === 19) Hl(f, x, h);
          else if (f.child !== null) {
            f.child.return = f, f = f.child;
            continue;
          }
          if (f === h) break e;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === h) break e;
            f = f.return;
          }
          f.sibling.return = f.return, f = f.sibling;
        }
        b &= 1;
      }
      if (ht(Sn, b), (h.mode & 1) === 0) h.memoizedState = null;
      else switch (B) {
        case "forwards":
          for (x = h.child, B = null; x !== null; ) f = x.alternate, f !== null && Di(f) === null && (B = x), x = x.sibling;
          x = B, x === null ? (B = h.child, h.child = null) : (B = x.sibling, x.sibling = null), cn(h, !1, B, x, F);
          break;
        case "backwards":
          for (x = null, B = h.child, h.child = null; B !== null; ) {
            if (f = B.alternate, f !== null && Di(f) === null) {
              h.child = B;
              break;
            }
            f = B.sibling, B.sibling = x, x = B, B = f;
          }
          cn(h, !0, x, null, F);
          break;
        case "together":
          cn(h, !1, null, null, void 0);
          break;
        default:
          h.memoizedState = null;
      }
      return h.child;
    }
    function Xa(f, h, x) {
      if (f !== null && (h.dependencies = f.dependencies), zu |= h.lanes, (x & h.childLanes) === 0) return null;
      if (f !== null && h.child !== f.child) throw Error(o(153));
      if (h.child !== null) {
        for (f = h.child, x = bo(f, f.pendingProps), h.child = x, x.return = h; f.sibling !== null; ) f = f.sibling, x = x.sibling = bo(f, f.pendingProps), x.return = h;
        x.sibling = null;
      }
      return h.child;
    }
    function zC(f, h, x) {
      switch (h.tag) {
        case 3:
          S_(h), jo();
          break;
        case 5:
          ka(h);
          break;
        case 1:
          $i(h.type) && Gi(h);
          break;
        case 4:
          Qc(h, h.stateNode.containerInfo);
          break;
        case 10:
          a_(h, h.type._context, h.memoizedProps.value);
          break;
        case 13:
          var b = h.memoizedState;
          if (b !== null)
            return b.dehydrated !== null ? (ht(Sn, Sn.current & 1), h.flags |= 128, null) : (x & h.child.childLanes) !== 0 ? il(f, h, x) : (ht(Sn, Sn.current & 1), f = Xa(f, h, x), f !== null ? f.sibling : null);
          ht(Sn, Sn.current & 1);
          break;
        case 19:
          if (b = (x & h.childLanes) !== 0, (f.flags & 128) !== 0) {
            if (b) return tf(
              f,
              h,
              x
            );
            h.flags |= 128;
          }
          var B = h.memoizedState;
          if (B !== null && (B.rendering = null, B.tail = null, B.lastEffect = null), ht(Sn, Sn.current), b) break;
          return null;
        case 22:
        case 23:
          return h.lanes = 0, y_(f, h, x);
      }
      return Xa(f, h, x);
    }
    function PS(f, h) {
      switch (Hd(h), h.tag) {
        case 1:
          return $i(h.type) && fi(), f = h.flags, f & 65536 ? (h.flags = f & -65537 | 128, h) : null;
        case 3:
          return yo(), Qt(mi), Qt(mn), Ur(), f = h.flags, (f & 65536) !== 0 && (f & 128) === 0 ? (h.flags = f & -65537 | 128, h) : null;
        case 5:
          return Va(h), null;
        case 13:
          if (Qt(Sn), f = h.memoizedState, f !== null && f.dehydrated !== null) {
            if (h.alternate === null) throw Error(o(340));
            jo();
          }
          return f = h.flags, f & 65536 ? (h.flags = f & -65537 | 128, h) : null;
        case 19:
          return Qt(Sn), null;
        case 4:
          return yo(), null;
        case 10:
          return Ld(h.type._context), null;
        case 22:
        case 23:
          return Km(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Nu = !1, ha = !1, IS = typeof WeakSet == "function" ? WeakSet : Set, Mt = null;
    function ch(f, h) {
      var x = f.ref;
      if (x !== null) if (typeof x == "function") try {
        x(null);
      } catch (b) {
        Fi(f, h, b);
      }
      else x.current = null;
    }
    function nf(f, h, x) {
      try {
        x();
      } catch (b) {
        Fi(f, h, b);
      }
    }
    var A_ = !1;
    function M_(f, h) {
      for (Z(f.containerInfo), Mt = h; Mt !== null; ) if (f = Mt, h = f.child, (f.subtreeFlags & 1028) !== 0 && h !== null) h.return = f, Mt = h;
      else for (; Mt !== null; ) {
        f = Mt;
        try {
          var x = f.alternate;
          if ((f.flags & 1024) !== 0) switch (f.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (x !== null) {
                var b = x.memoizedProps, B = x.memoizedState, F = f.stateNode, K = F.getSnapshotBeforeUpdate(f.elementType === f.type ? b : ca(f.type, b), B);
                F.__reactInternalSnapshotBeforeUpdate = K;
              }
              break;
            case 3:
              mt && et(f.stateNode.containerInfo);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(o(163));
          }
        } catch (de) {
          Fi(f, f.return, de);
        }
        if (h = f.sibling, h !== null) {
          h.return = f.return, Mt = h;
          break;
        }
        Mt = f.return;
      }
      return x = A_, A_ = !1, x;
    }
    function sl(f, h, x) {
      var b = h.updateQueue;
      if (b = b !== null ? b.lastEffect : null, b !== null) {
        var B = b = b.next;
        do {
          if ((B.tag & f) === f) {
            var F = B.destroy;
            B.destroy = void 0, F !== void 0 && nf(h, x, F);
          }
          B = B.next;
        } while (B !== b);
      }
    }
    function as(f, h) {
      if (h = h.updateQueue, h = h !== null ? h.lastEffect : null, h !== null) {
        var x = h = h.next;
        do {
          if ((x.tag & f) === f) {
            var b = x.create;
            x.destroy = b();
          }
          x = x.next;
        } while (x !== h);
      }
    }
    function zl(f) {
      var h = f.ref;
      if (h !== null) {
        var x = f.stateNode;
        switch (f.tag) {
          case 5:
            f = re(x);
            break;
          default:
            f = x;
        }
        typeof h == "function" ? h(f) : h.current = f;
      }
    }
    function Ou(f, h, x) {
      if (Na && typeof Na.onCommitFiberUnmount == "function") try {
        Na.onCommitFiberUnmount(Bd, h);
      } catch {
      }
      switch (h.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (f = h.updateQueue, f !== null && (f = f.lastEffect, f !== null)) {
            var b = f = f.next;
            do {
              var B = b, F = B.destroy;
              B = B.tag, F !== void 0 && ((B & 2) !== 0 || (B & 4) !== 0) && nf(h, x, F), b = b.next;
            } while (b !== f);
          }
          break;
        case 1:
          if (ch(h, x), f = h.stateNode, typeof f.componentWillUnmount == "function") try {
            f.props = h.memoizedProps, f.state = h.memoizedState, f.componentWillUnmount();
          } catch (K) {
            Fi(
              h,
              x,
              K
            );
          }
          break;
        case 5:
          ch(h, x);
          break;
        case 4:
          mt ? Om(f, h, x) : ne && ne && (h = h.stateNode.containerInfo, x = Wt(h), un(h, x));
      }
    }
    function fh(f, h, x) {
      for (var b = h; ; ) if (Ou(f, b, x), b.child === null || mt && b.tag === 4) {
        if (b === h) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === h) return;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      } else b.child.return = b, b = b.child;
    }
    function Hu(f) {
      var h = f.alternate;
      h !== null && (f.alternate = null, Hu(h)), f.child = null, f.deletions = null, f.sibling = null, f.tag === 5 && (h = f.stateNode, h !== null && ce(h)), f.stateNode = null, f.return = null, f.dependencies = null, f.memoizedProps = null, f.memoizedState = null, f.pendingProps = null, f.stateNode = null, f.updateQueue = null;
    }
    function Ks(f) {
      return f.tag === 5 || f.tag === 3 || f.tag === 4;
    }
    function Vi(f) {
      e: for (; ; ) {
        for (; f.sibling === null; ) {
          if (f.return === null || Ks(f.return)) return null;
          f = f.return;
        }
        for (f.sibling.return = f.return, f = f.sibling; f.tag !== 5 && f.tag !== 6 && f.tag !== 18; ) {
          if (f.flags & 2 || f.child === null || f.tag === 4) continue e;
          f.child.return = f, f = f.child;
        }
        if (!(f.flags & 2)) return f.stateNode;
      }
    }
    function E_(f) {
      if (mt) {
        e: {
          for (var h = f.return; h !== null; ) {
            if (Ks(h)) break e;
            h = h.return;
          }
          throw Error(o(160));
        }
        var x = h;
        switch (x.tag) {
          case 5:
            h = x.stateNode, x.flags & 32 && (Ke(h), x.flags &= -33), x = Vi(f), Nm(f, x, h);
            break;
          case 3:
          case 4:
            h = x.stateNode.containerInfo, x = Vi(f), Fm(f, x, h);
            break;
          default:
            throw Error(o(161));
        }
      }
    }
    function Fm(f, h, x) {
      var b = f.tag;
      if (b === 5 || b === 6) f = f.stateNode, h ? Qe(x, f, h) : zt(x, f);
      else if (b !== 4 && (f = f.child, f !== null)) for (Fm(f, h, x), f = f.sibling; f !== null; ) Fm(f, h, x), f = f.sibling;
    }
    function Nm(f, h, x) {
      var b = f.tag;
      if (b === 5 || b === 6) f = f.stateNode, h ? Ie(x, f, h) : Lt(x, f);
      else if (b !== 4 && (f = f.child, f !== null)) for (Nm(f, h, x), f = f.sibling; f !== null; ) Nm(f, h, x), f = f.sibling;
    }
    function Om(f, h, x) {
      for (var b = h, B = !1, F, K; ; ) {
        if (!B) {
          B = b.return;
          e: for (; ; ) {
            if (B === null) throw Error(o(160));
            switch (F = B.stateNode, B.tag) {
              case 5:
                K = !1;
                break e;
              case 3:
                F = F.containerInfo, K = !0;
                break e;
              case 4:
                F = F.containerInfo, K = !0;
                break e;
            }
            B = B.return;
          }
          B = !0;
        }
        if (b.tag === 5 || b.tag === 6) fh(f, b, x), K ? Fe(F, b.stateNode) : rt(F, b.stateNode);
        else if (b.tag === 18) K ? he(F, b.stateNode) : ge(F, b.stateNode);
        else if (b.tag === 4) {
          if (b.child !== null) {
            F = b.stateNode.containerInfo, K = !0, b.child.return = b, b = b.child;
            continue;
          }
        } else if (Ou(f, b, x), b.child !== null) {
          b.child.return = b, b = b.child;
          continue;
        }
        if (b === h) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === h) return;
          b = b.return, b.tag === 4 && (B = !1);
        }
        b.sibling.return = b.return, b = b.sibling;
      }
    }
    function dh(f, h) {
      if (mt) {
        switch (h.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            sl(3, h, h.return), as(3, h), sl(5, h, h.return);
            return;
          case 1:
            return;
          case 5:
            var x = h.stateNode;
            if (x != null) {
              var b = h.memoizedProps;
              f = f !== null ? f.memoizedProps : b;
              var B = h.type, F = h.updateQueue;
              h.updateQueue = null, F !== null && De(x, F, B, f, b, h);
            }
            return;
          case 6:
            if (h.stateNode === null) throw Error(o(162));
            x = h.memoizedProps, ee(h.stateNode, f !== null ? f.memoizedProps : x, x);
            return;
          case 3:
            we && f !== null && f.memoizedState.isDehydrated && se(h.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            rf(h);
            return;
          case 19:
            rf(h);
            return;
          case 17:
            return;
        }
        throw Error(o(163));
      }
      switch (h.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          sl(3, h, h.return), as(3, h), sl(5, h, h.return);
          return;
        case 12:
          return;
        case 13:
          rf(h);
          return;
        case 19:
          rf(h);
          return;
        case 3:
          we && f !== null && f.memoizedState.isDehydrated && se(h.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e: if (ne) {
        switch (h.tag) {
          case 1:
          case 5:
          case 6:
            break e;
          case 3:
          case 4:
            h = h.stateNode, un(h.containerInfo, h.pendingChildren);
            break e;
        }
        throw Error(o(163));
      }
    }
    function rf(f) {
      var h = f.updateQueue;
      if (h !== null) {
        f.updateQueue = null;
        var x = f.stateNode;
        x === null && (x = f.stateNode = new IS()), h.forEach(function(b) {
          var B = df.bind(null, f, b);
          x.has(b) || (x.add(b), b.then(B, B));
        });
      }
    }
    function US(f, h) {
      for (Mt = h; Mt !== null; ) {
        h = Mt;
        var x = h.deletions;
        if (x !== null) for (var b = 0; b < x.length; b++) {
          var B = x[b];
          try {
            var F = f;
            mt ? Om(F, B, h) : fh(F, B, h);
            var K = B.alternate;
            K !== null && (K.return = null), B.return = null;
          } catch (Vt) {
            Fi(B, h, Vt);
          }
        }
        if (x = h.child, (h.subtreeFlags & 12854) !== 0 && x !== null) x.return = h, Mt = x;
        else for (; Mt !== null; ) {
          h = Mt;
          try {
            var de = h.flags;
            if (de & 32 && mt && Ke(h.stateNode), de & 512) {
              var Le = h.alternate;
              if (Le !== null) {
                var ft = Le.ref;
                ft !== null && (typeof ft == "function" ? ft(null) : ft.current = null);
              }
            }
            if (de & 8192) switch (h.tag) {
              case 13:
                if (h.memoizedState !== null) {
                  var Nt = h.alternate;
                  (Nt === null || Nt.memoizedState === null) && (vh = er());
                }
                break;
              case 22:
                var ln = h.memoizedState !== null, jt = h.alternate, Xn = jt !== null && jt.memoizedState !== null;
                if (x = h, mt) {
                  e: if (b = x, B = ln, F = null, mt) for (var Jt = b; ; ) {
                    if (Jt.tag === 5) {
                      if (F === null) {
                        F = Jt;
                        var nr = Jt.stateNode;
                        B ? Dt(nr) : Pe(Jt.stateNode, Jt.memoizedProps);
                      }
                    } else if (Jt.tag === 6) {
                      if (F === null) {
                        var kr = Jt.stateNode;
                        B ? We(kr) : ae(kr, Jt.memoizedProps);
                      }
                    } else if ((Jt.tag !== 22 && Jt.tag !== 23 || Jt.memoizedState === null || Jt === b) && Jt.child !== null) {
                      Jt.child.return = Jt, Jt = Jt.child;
                      continue;
                    }
                    if (Jt === b) break;
                    for (; Jt.sibling === null; ) {
                      if (Jt.return === null || Jt.return === b) break e;
                      F === Jt && (F = null), Jt = Jt.return;
                    }
                    F === Jt && (F = null), Jt.sibling.return = Jt.return, Jt = Jt.sibling;
                  }
                }
                if (ln && !Xn && (x.mode & 1) !== 0) {
                  Mt = x;
                  for (var Me = x.child; Me !== null; ) {
                    for (x = Mt = Me; Mt !== null; ) {
                      b = Mt;
                      var ve = b.child;
                      switch (b.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                          sl(4, b, b.return);
                          break;
                        case 1:
                          ch(b, b.return);
                          var Ce = b.stateNode;
                          if (typeof Ce.componentWillUnmount == "function") {
                            var _t = b.return;
                            try {
                              Ce.props = b.memoizedProps, Ce.state = b.memoizedState, Ce.componentWillUnmount();
                            } catch (Vt) {
                              Fi(
                                b,
                                _t,
                                Vt
                              );
                            }
                          }
                          break;
                        case 5:
                          ch(b, b.return);
                          break;
                        case 22:
                          if (b.memoizedState !== null) {
                            sf(x);
                            continue;
                          }
                      }
                      ve !== null ? (ve.return = b, Mt = ve) : sf(x);
                    }
                    Me = Me.sibling;
                  }
                }
            }
            switch (de & 4102) {
              case 2:
                E_(h), h.flags &= -3;
                break;
              case 6:
                E_(h), h.flags &= -3, dh(h.alternate, h);
                break;
              case 4096:
                h.flags &= -4097;
                break;
              case 4100:
                h.flags &= -4097, dh(h.alternate, h);
                break;
              case 4:
                dh(h.alternate, h);
            }
          } catch (Vt) {
            Fi(h, h.return, Vt);
          }
          if (x = h.sibling, x !== null) {
            x.return = h.return, Mt = x;
            break;
          }
          Mt = h.return;
        }
      }
    }
    function FS(f, h, x) {
      Mt = f, T_(f);
    }
    function T_(f, h, x) {
      for (var b = (f.mode & 1) !== 0; Mt !== null; ) {
        var B = Mt, F = B.child;
        if (B.tag === 22 && b) {
          var K = B.memoizedState !== null || Nu;
          if (!K) {
            var de = B.alternate, Le = de !== null && de.memoizedState !== null || ha;
            de = Nu;
            var ft = ha;
            if (Nu = K, (ha = Le) && !ft) for (Mt = B; Mt !== null; ) K = Mt, Le = K.child, K.tag === 22 && K.memoizedState !== null ? Hm(B) : Le !== null ? (Le.return = K, Mt = Le) : Hm(B);
            for (; F !== null; ) Mt = F, T_(F), F = F.sibling;
            Mt = B, Nu = de, ha = ft;
          }
          Wi(f);
        } else (B.subtreeFlags & 8772) !== 0 && F !== null ? (F.return = B, Mt = F) : Wi(f);
      }
    }
    function Wi(f) {
      for (; Mt !== null; ) {
        var h = Mt;
        if ((h.flags & 8772) !== 0) {
          var x = h.alternate;
          try {
            if ((h.flags & 8772) !== 0) switch (h.tag) {
              case 0:
              case 11:
              case 15:
                ha || as(5, h);
                break;
              case 1:
                var b = h.stateNode;
                if (h.flags & 4 && !ha) if (x === null) b.componentDidMount();
                else {
                  var B = h.elementType === h.type ? x.memoizedProps : ca(h.type, x.memoizedProps);
                  b.componentDidUpdate(B, x.memoizedState, b.__reactInternalSnapshotBeforeUpdate);
                }
                var F = h.updateQueue;
                F !== null && l_(h, F, b);
                break;
              case 3:
                var K = h.updateQueue;
                if (K !== null) {
                  if (x = null, h.child !== null) switch (h.child.tag) {
                    case 5:
                      x = re(h.child.stateNode);
                      break;
                    case 1:
                      x = h.child.stateNode;
                  }
                  l_(h, K, x);
                }
                break;
              case 5:
                var de = h.stateNode;
                x === null && h.flags & 4 && Re(de, h.type, h.memoizedProps, h);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (we && h.memoizedState === null) {
                  var Le = h.alternate;
                  if (Le !== null) {
                    var ft = Le.memoizedState;
                    if (ft !== null) {
                      var Nt = ft.dehydrated;
                      Nt !== null && _e(Nt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
            ha || h.flags & 512 && zl(h);
          } catch (ln) {
            Fi(h, h.return, ln);
          }
        }
        if (h === f) {
          Mt = null;
          break;
        }
        if (x = h.sibling, x !== null) {
          x.return = h.return, Mt = x;
          break;
        }
        Mt = h.return;
      }
    }
    function sf(f) {
      for (; Mt !== null; ) {
        var h = Mt;
        if (h === f) {
          Mt = null;
          break;
        }
        var x = h.sibling;
        if (x !== null) {
          x.return = h.return, Mt = x;
          break;
        }
        Mt = h.return;
      }
    }
    function Hm(f) {
      for (; Mt !== null; ) {
        var h = Mt;
        try {
          switch (h.tag) {
            case 0:
            case 11:
            case 15:
              var x = h.return;
              try {
                as(4, h);
              } catch (Le) {
                Fi(h, x, Le);
              }
              break;
            case 1:
              var b = h.stateNode;
              if (typeof b.componentDidMount == "function") {
                var B = h.return;
                try {
                  b.componentDidMount();
                } catch (Le) {
                  Fi(h, B, Le);
                }
              }
              var F = h.return;
              try {
                zl(h);
              } catch (Le) {
                Fi(h, F, Le);
              }
              break;
            case 5:
              var K = h.return;
              try {
                zl(h);
              } catch (Le) {
                Fi(h, K, Le);
              }
          }
        } catch (Le) {
          Fi(h, h.return, Le);
        }
        if (h === f) {
          Mt = null;
          break;
        }
        var de = h.sibling;
        if (de !== null) {
          de.return = h.return, Mt = de;
          break;
        }
        Mt = h.return;
      }
    }
    var Ao = 0, af = 1, hh = 2, ph = 3, Mo = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var Li = Symbol.for;
      Ao = Li("selector.component"), af = Li("selector.has_pseudo_class"), hh = Li("selector.role"), ph = Li("selector.test_id"), Mo = Li("selector.text");
    }
    function Et(f) {
      var h = Ee(f);
      if (h != null) {
        if (typeof h.memoizedProps["data-testname"] != "string") throw Error(o(364));
        return h;
      }
      if (f = le(f), f === null) throw Error(o(362));
      return f.stateNode.current;
    }
    function qs(f, h) {
      switch (h.$$typeof) {
        case Ao:
          if (f.type === h.value) return !0;
          break;
        case af:
          e: {
            h = h.value, f = [f, 0];
            for (var x = 0; x < f.length; ) {
              var b = f[x++], B = f[x++], F = h[B];
              if (b.tag !== 5 || !Oe(b)) {
                for (; F != null && qs(b, F); ) B++, F = h[B];
                if (B === h.length) {
                  h = !0;
                  break e;
                } else for (b = b.child; b !== null; ) f.push(b, B), b = b.sibling;
              }
            }
            h = !1;
          }
          return h;
        case hh:
          if (f.tag === 5 && ct(f.stateNode, h.value)) return !0;
          break;
        case Mo:
          if ((f.tag === 5 || f.tag === 6) && (f = Ve(f), f !== null && 0 <= f.indexOf(h.value))) return !0;
          break;
        case ph:
          if (f.tag === 5 && (f = f.memoizedProps["data-testname"], typeof f == "string" && f.toLowerCase() === h.value.toLowerCase())) return !0;
          break;
        default:
          throw Error(o(365));
      }
      return !1;
    }
    function bs(f) {
      switch (f.$$typeof) {
        case Ao:
          return "<" + (O(f.value) || "Unknown") + ">";
        case af:
          return ":has(" + (bs(f) || "") + ")";
        case hh:
          return '[role="' + f.value + '"]';
        case Mo:
          return '"' + f.value + '"';
        case ph:
          return '[data-testname="' + f.value + '"]';
        default:
          throw Error(o(365));
      }
    }
    function b_(f, h) {
      var x = [];
      f = [f, 0];
      for (var b = 0; b < f.length; ) {
        var B = f[b++], F = f[b++], K = h[F];
        if (B.tag !== 5 || !Oe(B)) {
          for (; K != null && qs(B, K); ) F++, K = h[F];
          if (F === h.length) x.push(B);
          else for (B = B.child; B !== null; ) f.push(B, F), B = B.sibling;
        }
      }
      return x;
    }
    function zm(f, h) {
      if (!G) throw Error(o(363));
      f = Et(f), f = b_(f, h), h = [], f = Array.from(f);
      for (var x = 0; x < f.length; ) {
        var b = f[x++];
        if (b.tag === 5) Oe(b) || h.push(b.stateNode);
        else for (b = b.child; b !== null; ) f.push(b), b = b.sibling;
      }
      return h;
    }
    var NS = Math.ceil, mh = u.ReactCurrentDispatcher, Gm = u.ReactCurrentOwner, An = u.ReactCurrentBatchConfig, vn = 0, Pi = null, Ii = null, tr = 0, dr = 0, pa = ti(0), Xi = 0, of = null, zu = 0, gh = 0, km = 0, lf = null, Or = null, vh = 0, Vm = 1 / 0;
    function Gu() {
      Vm = er() + 500;
    }
    var _h = !1, Wm = null, al = null, yh = !1, Eo = null, xh = 0, ku = 0, Xm = null, Sh = -1, Vu = 0;
    function Hr() {
      return (vn & 6) !== 0 ? er() : Sh !== -1 ? Sh : Sh = er();
    }
    function Ji(f) {
      return (f.mode & 1) === 0 ? 1 : (vn & 2) !== 0 && tr !== 0 ? tr & -tr : LS.transition !== null ? (Vu === 0 && (f = Rd, Rd <<= 1, (Rd & 4194240) === 0 && (Rd = 64), Vu = f), Vu) : (f = Fn, f !== 0 ? f : be());
    }
    function Ui(f, h, x) {
      if (50 < ku) throw ku = 0, Xm = null, Error(o(185));
      var b = Wu(f, h);
      return b === null ? null : (Wc(b, h, x), ((vn & 2) === 0 || b !== Pi) && (b === Pi && ((vn & 2) === 0 && (gh |= h), Xi === 4 && To(b, tr)), Rr(b, x), h === 1 && vn === 0 && (f.mode & 1) === 0 && (Gu(), Dd && za())), b);
    }
    function Wu(f, h) {
      f.lanes |= h;
      var x = f.alternate;
      for (x !== null && (x.lanes |= h), x = f, f = f.return; f !== null; ) f.childLanes |= h, x = f.alternate, x !== null && (x.childLanes |= h), x = f, f = f.return;
      return x.tag === 3 ? x.stateNode : null;
    }
    function Rr(f, h) {
      var x = f.callbackNode;
      MS(f, h);
      var b = br(f, f === Pi ? tr : 0);
      if (b === 0) x !== null && xu(x), f.callbackNode = null, f.callbackPriority = 0;
      else if (h = b & -b, f.callbackPriority !== h) {
        if (x != null && xu(x), h === 1) f.tag === 0 ? DS(C_.bind(null, f)) : r_(C_.bind(null, f)), nt ? X(function() {
          vn === 0 && za();
        }) : dm(hm, za), x = null;
        else {
          switch (i_(b)) {
            case 1:
              x = hm;
              break;
            case 4:
              x = CS;
              break;
            case 16:
              x = pm;
              break;
            case 536870912:
              x = wS;
              break;
            default:
              x = pm;
          }
          x = Yu(x, Jm.bind(null, f));
        }
        f.callbackPriority = h, f.callbackNode = x;
      }
    }
    function Jm(f, h) {
      if (Sh = -1, Vu = 0, (vn & 6) !== 0) throw Error(o(327));
      var x = f.callbackNode;
      if (pr() && f.callbackNode !== x) return null;
      var b = br(f, f === Pi ? tr : 0);
      if (b === 0) return null;
      if ((b & 30) !== 0 || (b & f.expiredLanes) !== 0 || h) h = zr(f, b);
      else {
        h = b;
        var B = vn;
        vn |= 2;
        var F = qm();
        (Pi !== f || tr !== h) && (Gu(), Ya(f, h));
        do
          try {
            OS();
            break;
          } catch (de) {
            R_(f, de);
          }
        while (!0);
        vm(), mh.current = F, vn = B, Ii !== null ? h = 0 : (Pi = null, tr = 0, h = Xi);
      }
      if (h !== 0) {
        if (h === 2 && (B = cm(f), B !== 0 && (b = B, h = Ym(f, B))), h === 1) throw x = of, Ya(f, 0), To(f, b), Rr(f, er()), x;
        if (h === 6) To(f, b);
        else {
          if (B = f.current.alternate, (b & 30) === 0 && !Ja(B) && (h = zr(f, b), h === 2 && (F = cm(f), F !== 0 && (b = F, h = Ym(f, F))), h === 1)) throw x = of, Ya(f, 0), To(f, b), Rr(f, er()), x;
          switch (f.finishedWork = B, f.finishedLanes = b, h) {
            case 0:
            case 1:
              throw Error(o(345));
            case 2:
              oi(f, Or);
              break;
            case 3:
              if (To(f, b), (b & 130023424) === b && (h = vh + 500 - er(), 10 < h)) {
                if (br(f, 0) !== 0) break;
                if (B = f.suspendedLanes, (B & b) !== b) {
                  Hr(), f.pingedLanes |= f.suspendedLanes & B;
                  break;
                }
                f.timeoutHandle = Ye(oi.bind(null, f, Or), h);
                break;
              }
              oi(f, Or);
              break;
            case 4:
              if (To(f, b), (b & 4194240) === b) break;
              for (h = f.eventTimes, B = -1; 0 < b; ) {
                var K = 31 - es(b);
                F = 1 << K, K = h[K], K > B && (B = K), b &= ~F;
              }
              if (b = B, b = er() - b, b = (120 > b ? 120 : 480 > b ? 480 : 1080 > b ? 1080 : 1920 > b ? 1920 : 3e3 > b ? 3e3 : 4320 > b ? 4320 : 1960 * NS(b / 1960)) - b, 10 < b) {
                f.timeoutHandle = Ye(oi.bind(null, f, Or), b);
                break;
              }
              oi(f, Or);
              break;
            case 5:
              oi(f, Or);
              break;
            default:
              throw Error(o(329));
          }
        }
      }
      return Rr(f, er()), f.callbackNode === x ? Jm.bind(null, f) : null;
    }
    function Ym(f, h) {
      var x = lf;
      return f.current.memoizedState.isDehydrated && (Ya(f, h).flags |= 256), f = zr(f, h), f !== 2 && (h = Or, Or = x, h !== null && Ah(h)), f;
    }
    function Ah(f) {
      Or === null ? Or = f : Or.push.apply(Or, f);
    }
    function Ja(f) {
      for (var h = f; ; ) {
        if (h.flags & 16384) {
          var x = h.updateQueue;
          if (x !== null && (x = x.stores, x !== null)) for (var b = 0; b < x.length; b++) {
            var B = x[b], F = B.getSnapshot;
            B = B.value;
            try {
              if (!Oa(F(), B)) return !1;
            } catch {
              return !1;
            }
          }
        }
        if (x = h.child, h.subtreeFlags & 16384 && x !== null) x.return = h, h = x;
        else {
          if (h === f) break;
          for (; h.sibling === null; ) {
            if (h.return === null || h.return === f) return !0;
            h = h.return;
          }
          h.sibling.return = h.return, h = h.sibling;
        }
      }
      return !0;
    }
    function To(f, h) {
      for (h &= ~km, h &= ~gh, f.suspendedLanes |= h, f.pingedLanes &= ~h, f = f.expirationTimes; 0 < h; ) {
        var x = 31 - es(h), b = 1 << x;
        f[x] = -1, h &= ~b;
      }
    }
    function C_(f) {
      if ((vn & 6) !== 0) throw Error(o(327));
      pr();
      var h = br(f, 0);
      if ((h & 1) === 0) return Rr(f, er()), null;
      var x = zr(f, h);
      if (f.tag !== 0 && x === 2) {
        var b = cm(f);
        b !== 0 && (h = b, x = Ym(f, b));
      }
      if (x === 1) throw x = of, Ya(f, 0), To(f, h), Rr(f, er()), x;
      if (x === 6) throw Error(o(345));
      return f.finishedWork = f.current.alternate, f.finishedLanes = h, oi(f, Or), Rr(f, er()), null;
    }
    function w_(f) {
      Eo !== null && Eo.tag === 0 && (vn & 6) === 0 && pr();
      var h = vn;
      vn |= 1;
      var x = An.transition, b = Fn;
      try {
        if (An.transition = null, Fn = 1, f) return f();
      } finally {
        Fn = b, An.transition = x, vn = h, (vn & 6) === 0 && za();
      }
    }
    function Km() {
      dr = pa.current, Qt(pa);
    }
    function Ya(f, h) {
      f.finishedWork = null, f.finishedLanes = 0;
      var x = f.timeoutHandle;
      if (x !== Ct && (f.timeoutHandle = Ct, At(x)), Ii !== null) for (x = Ii.return; x !== null; ) {
        var b = x;
        switch (Hd(b), b.tag) {
          case 1:
            b = b.type.childContextTypes, b != null && fi();
            break;
          case 3:
            yo(), Qt(mi), Qt(mn), Ur();
            break;
          case 5:
            Va(b);
            break;
          case 4:
            yo();
            break;
          case 13:
            Qt(Sn);
            break;
          case 19:
            Qt(Sn);
            break;
          case 10:
            Ld(b.type._context);
            break;
          case 22:
          case 23:
            Km();
        }
        x = x.return;
      }
      if (Pi = f, Ii = f = bo(f.current, null), tr = dr = h, Xi = 0, of = null, km = gh = zu = 0, Or = lf = null, Ga !== null) {
        for (h = 0; h < Ga.length; h++) if (x = Ga[h], b = x.interleaved, b !== null) {
          x.interleaved = null;
          var B = b.next, F = x.pending;
          if (F !== null) {
            var K = F.next;
            F.next = B, b.next = K;
          }
          x.pending = b;
        }
        Ga = null;
      }
      return f;
    }
    function R_(f, h) {
      do {
        var x = Ii;
        try {
          if (vm(), Js.current = Pu, Il) {
            for (var b = jn.memoizedState; b !== null; ) {
              var B = b.queue;
              B !== null && (B.pending = null), b = b.next;
            }
            Il = !1;
          }
          if (Qo = 0, di = cr = jn = null, rs = !1, Zo = 0, Gm.current = null, x === null || x.return === null) {
            Xi = 1, of = h, Ii = null;
            break;
          }
          e: {
            var F = f, K = x.return, de = x, Le = h;
            if (h = tr, de.flags |= 32768, Le !== null && typeof Le == "object" && typeof Le.then == "function") {
              var ft = Le, Nt = de, ln = Nt.tag;
              if ((Nt.mode & 1) === 0 && (ln === 0 || ln === 11 || ln === 15)) {
                var jt = Nt.alternate;
                jt ? (Nt.updateQueue = jt.updateQueue, Nt.memoizedState = jt.memoizedState, Nt.lanes = jt.lanes) : (Nt.updateQueue = null, Nt.memoizedState = null);
              }
              var Xn = th(K);
              if (Xn !== null) {
                Xn.flags &= -257, Pm(Xn, K, de, F, h), Xn.mode & 1 && eh(F, ft, h), h = Xn, Le = ft;
                var Jt = h.updateQueue;
                if (Jt === null) {
                  var nr = /* @__PURE__ */ new Set();
                  nr.add(Le), h.updateQueue = nr;
                } else Jt.add(Le);
                break e;
              } else {
                if ((h & 1) === 0) {
                  eh(F, ft, h), Mh();
                  break e;
                }
                Le = Error(o(426));
              }
            } else if (ni && de.mode & 1) {
              var kr = th(K);
              if (kr !== null) {
                (kr.flags & 65536) === 0 && (kr.flags |= 256), Pm(kr, K, de, F, h), bu(Le);
                break e;
              }
            }
            F = Le, Xi !== 4 && (Xi = 2), lf === null ? lf = [F] : lf.push(F), Le = $c(Le, de), de = K;
            do {
              switch (de.tag) {
                case 3:
                  de.flags |= 65536, h &= -h, de.lanes |= h;
                  var Me = Zd(de, Le, h);
                  ym(de, Me);
                  break e;
                case 1:
                  F = Le;
                  var ve = de.type, Ce = de.stateNode;
                  if ((de.flags & 128) === 0 && (typeof ve.getDerivedStateFromError == "function" || Ce !== null && typeof Ce.componentDidCatch == "function" && (al === null || !al.has(Ce)))) {
                    de.flags |= 65536, h &= -h, de.lanes |= h;
                    var _t = $d(de, F, h);
                    ym(de, _t);
                    break e;
                  }
              }
              de = de.return;
            } while (de !== null);
          }
          hr(x);
        } catch (Vt) {
          h = Vt, Ii === x && x !== null && (Ii = x = x.return);
          continue;
        }
        break;
      } while (!0);
    }
    function qm() {
      var f = mh.current;
      return mh.current = Pu, f === null ? Pu : f;
    }
    function Mh() {
      (Xi === 0 || Xi === 3 || Xi === 2) && (Xi = 4), Pi === null || (zu & 268435455) === 0 && (gh & 268435455) === 0 || To(Pi, tr);
    }
    function zr(f, h) {
      var x = vn;
      vn |= 2;
      var b = qm();
      Pi === f && tr === h || Ya(f, h);
      do
        try {
          uf();
          break;
        } catch (B) {
          R_(f, B);
        }
      while (!0);
      if (vm(), vn = x, mh.current = b, Ii !== null) throw Error(o(261));
      return Pi = null, tr = 0, Xi;
    }
    function uf() {
      for (; Ii !== null; ) B_(Ii);
    }
    function OS() {
      for (; Ii !== null && !TS(); ) B_(Ii);
    }
    function B_(f) {
      var h = Ju(f.alternate, f, dr);
      f.memoizedProps = f.pendingProps, h === null ? hr(f) : Ii = h, Gm.current = null;
    }
    function hr(f) {
      var h = f;
      do {
        var x = h.alternate;
        if (f = h.return, (h.flags & 32768) === 0) {
          if (x = ef(x, h, dr), x !== null) {
            Ii = x;
            return;
          }
        } else {
          if (x = PS(x, h), x !== null) {
            x.flags &= 32767, Ii = x;
            return;
          }
          if (f !== null) f.flags |= 32768, f.subtreeFlags = 0, f.deletions = null;
          else {
            Xi = 6, Ii = null;
            return;
          }
        }
        if (h = h.sibling, h !== null) {
          Ii = h;
          return;
        }
        Ii = h = f;
      } while (h !== null);
      Xi === 0 && (Xi = 5);
    }
    function oi(f, h) {
      var x = Fn, b = An.transition;
      try {
        An.transition = null, Fn = 1, Ka(f, h, x);
      } finally {
        An.transition = b, Fn = x;
      }
      return null;
    }
    function Ka(f, h, x) {
      do
        pr();
      while (Eo !== null);
      if ((vn & 6) !== 0) throw Error(o(327));
      var b = f.finishedWork, B = f.finishedLanes;
      if (b === null) return null;
      if (f.finishedWork = null, f.finishedLanes = 0, b === f.current) throw Error(o(177));
      f.callbackNode = null, f.callbackPriority = 0;
      var F = b.lanes | b.childLanes;
      if (ES(f, F), f === Pi && (Ii = Pi = null, tr = 0), (b.subtreeFlags & 2064) === 0 && (b.flags & 2064) === 0 || yh || (yh = !0, Yu(pm, function() {
        return pr(), null;
      })), F = (b.flags & 15990) !== 0, (b.subtreeFlags & 15990) !== 0 || F) {
        F = An.transition, An.transition = null;
        var K = Fn;
        Fn = 1;
        var de = vn;
        vn |= 4, Gm.current = null, M_(f, b), US(f, b), H(f.containerInfo), f.current = b, FS(b), bS(), vn = de, Fn = K, An.transition = F;
      } else f.current = b;
      if (yh && (yh = !1, Eo = f, xh = B), F = f.pendingLanes, F === 0 && (al = null), RS(b.stateNode), Rr(f, er()), h !== null) for (x = f.onRecoverableError, b = 0; b < h.length; b++) x(h[b]);
      if (_h) throw _h = !1, f = Wm, Wm = null, f;
      return (xh & 1) !== 0 && f.tag !== 0 && pr(), F = f.pendingLanes, (F & 1) !== 0 ? f === Xm ? ku++ : (ku = 0, Xm = f) : ku = 0, za(), null;
    }
    function pr() {
      if (Eo !== null) {
        var f = i_(xh), h = An.transition, x = Fn;
        try {
          if (An.transition = null, Fn = 16 > f ? 16 : f, Eo === null) var b = !1;
          else {
            if (f = Eo, Eo = null, xh = 0, (vn & 6) !== 0) throw Error(o(331));
            var B = vn;
            for (vn |= 4, Mt = f.current; Mt !== null; ) {
              var F = Mt, K = F.child;
              if ((Mt.flags & 16) !== 0) {
                var de = F.deletions;
                if (de !== null) {
                  for (var Le = 0; Le < de.length; Le++) {
                    var ft = de[Le];
                    for (Mt = ft; Mt !== null; ) {
                      var Nt = Mt;
                      switch (Nt.tag) {
                        case 0:
                        case 11:
                        case 15:
                          sl(8, Nt, F);
                      }
                      var ln = Nt.child;
                      if (ln !== null) ln.return = Nt, Mt = ln;
                      else for (; Mt !== null; ) {
                        Nt = Mt;
                        var jt = Nt.sibling, Xn = Nt.return;
                        if (Hu(Nt), Nt === ft) {
                          Mt = null;
                          break;
                        }
                        if (jt !== null) {
                          jt.return = Xn, Mt = jt;
                          break;
                        }
                        Mt = Xn;
                      }
                    }
                  }
                  var Jt = F.alternate;
                  if (Jt !== null) {
                    var nr = Jt.child;
                    if (nr !== null) {
                      Jt.child = null;
                      do {
                        var kr = nr.sibling;
                        nr.sibling = null, nr = kr;
                      } while (nr !== null);
                    }
                  }
                  Mt = F;
                }
              }
              if ((F.subtreeFlags & 2064) !== 0 && K !== null) K.return = F, Mt = K;
              else e: for (; Mt !== null; ) {
                if (F = Mt, (F.flags & 2048) !== 0) switch (F.tag) {
                  case 0:
                  case 11:
                  case 15:
                    sl(9, F, F.return);
                }
                var Me = F.sibling;
                if (Me !== null) {
                  Me.return = F.return, Mt = Me;
                  break e;
                }
                Mt = F.return;
              }
            }
            var ve = f.current;
            for (Mt = ve; Mt !== null; ) {
              K = Mt;
              var Ce = K.child;
              if ((K.subtreeFlags & 2064) !== 0 && Ce !== null) Ce.return = K, Mt = Ce;
              else e: for (K = ve; Mt !== null; ) {
                if (de = Mt, (de.flags & 2048) !== 0) try {
                  switch (de.tag) {
                    case 0:
                    case 11:
                    case 15:
                      as(9, de);
                  }
                } catch (Vt) {
                  Fi(de, de.return, Vt);
                }
                if (de === K) {
                  Mt = null;
                  break e;
                }
                var _t = de.sibling;
                if (_t !== null) {
                  _t.return = de.return, Mt = _t;
                  break e;
                }
                Mt = de.return;
              }
            }
            if (vn = B, za(), Na && typeof Na.onPostCommitFiberRoot == "function") try {
              Na.onPostCommitFiberRoot(Bd, f);
            } catch {
            }
            b = !0;
          }
          return b;
        } finally {
          Fn = x, An.transition = h;
        }
      }
      return !1;
    }
    function D_(f, h, x) {
      h = $c(x, h), h = Zd(f, h, 1), qo(f, h), h = Hr(), f = Wu(f, 1), f !== null && (Wc(f, 1, h), Rr(f, h));
    }
    function Fi(f, h, x) {
      if (f.tag === 3) D_(f, f, x);
      else for (; h !== null; ) {
        if (h.tag === 3) {
          D_(h, f, x);
          break;
        } else if (h.tag === 1) {
          var b = h.stateNode;
          if (typeof h.type.getDerivedStateFromError == "function" || typeof b.componentDidCatch == "function" && (al === null || !al.has(b))) {
            f = $c(x, f), f = $d(h, f, 1), qo(h, f), f = Hr(), h = Wu(h, 1), h !== null && (Wc(h, 1, f), Rr(h, f));
            break;
          }
        }
        h = h.return;
      }
    }
    function cf(f, h, x) {
      var b = f.pingCache;
      b !== null && b.delete(h), h = Hr(), f.pingedLanes |= f.suspendedLanes & x, Pi === f && (tr & x) === x && (Xi === 4 || Xi === 3 && (tr & 130023424) === tr && 500 > er() - vh ? Ya(f, 0) : km |= x), Rr(f, h);
    }
    function Xu(f, h) {
      h === 0 && ((f.mode & 1) === 0 ? h = 1 : (h = ts, ts <<= 1, (ts & 130023424) === 0 && (ts = 4194304)));
      var x = Hr();
      f = Wu(f, h), f !== null && (Wc(f, h, x), Rr(f, x));
    }
    function ff(f) {
      var h = f.memoizedState, x = 0;
      h !== null && (x = h.retryLane), Xu(f, x);
    }
    function df(f, h) {
      var x = 0;
      switch (f.tag) {
        case 13:
          var b = f.stateNode, B = f.memoizedState;
          B !== null && (x = B.retryLane);
          break;
        case 19:
          b = f.stateNode;
          break;
        default:
          throw Error(o(314));
      }
      b !== null && b.delete(h), Xu(f, x);
    }
    var Ju;
    Ju = function(f, h, x) {
      if (f !== null) if (f.memoizedProps !== h.pendingProps || mi.current) Ts = !0;
      else {
        if ((f.lanes & x) === 0 && (h.flags & 128) === 0) return Ts = !1, zC(f, h, x);
        Ts = (f.flags & 131072) !== 0;
      }
      else Ts = !1, ni && (h.flags & 1048576) !== 0 && Eu(h, Nd, h.index);
      switch (h.lanes = 0, h.tag) {
        case 2:
          var b = h.type;
          f !== null && (f.alternate = null, h.alternate = null, h.flags |= 2), f = h.pendingProps;
          var B = Gs(h, mn.current);
          Su(h, x), B = Du(null, h, b, f, B, x);
          var F = Wd();
          return h.flags |= 1, typeof B == "object" && B !== null && typeof B.render == "function" && B.$$typeof === void 0 ? (h.tag = 1, h.memoizedState = null, h.updateQueue = null, $i(b) ? (F = !0, Gi(h)) : F = !1, h.memoizedState = B.state !== null && B.state !== void 0 ? B.state : null, _m(h), B.updater = Ud, h.stateNode = B, B._reactInternals = h, Sm(h, b, f, x), h = Fu(null, h, b, !0, F, x)) : (h.tag = 0, ni && F && Od(h), Nr(null, h, B, x), h = h.child), h;
        case 16:
          b = h.elementType;
          e: {
            switch (f !== null && (f.alternate = null, h.alternate = null, h.flags |= 2), f = h.pendingProps, B = b._init, b = B(b._payload), h.type = b, B = h.tag = L_(b), f = ca(b, f), B) {
              case 0:
                h = ah(null, h, b, f, x);
                break e;
              case 1:
                h = x_(
                  null,
                  h,
                  b,
                  f,
                  x
                );
                break e;
              case 11:
                h = v_(null, h, b, f, x);
                break e;
              case 14:
                h = __(null, h, b, ca(b.type, f), x);
                break e;
            }
            throw Error(o(306, b, ""));
          }
          return h;
        case 0:
          return b = h.type, B = h.pendingProps, B = h.elementType === b ? B : ca(b, B), ah(f, h, b, B, x);
        case 1:
          return b = h.type, B = h.pendingProps, B = h.elementType === b ? B : ca(b, B), x_(f, h, b, B, x);
        case 3:
          e: {
            if (S_(h), f === null) throw Error(o(387));
            b = h.pendingProps, F = h.memoizedState, B = F.element, o_(f, h), Id(h, b, null, x);
            var K = h.memoizedState;
            if (b = K.element, we && F.isDehydrated) if (F = {
              element: b,
              isDehydrated: !1,
              cache: K.cache,
              transitions: K.transitions
            }, h.updateQueue.baseState = F, h.memoizedState = F, h.flags & 256) {
              B = Error(o(423)), h = Um(f, h, b, x, B);
              break e;
            } else if (b !== B) {
              B = Error(o(424)), h = Um(f, h, b, x, B);
              break e;
            } else for (we && (is = ze(h.stateNode.containerInfo), ns = h, ni = !0, Ws = null, Tu = !1), x = kd(h, null, b, x), h.child = x; x; ) x.flags = x.flags & -3 | 4096, x = x.sibling;
            else {
              if (jo(), b === B) {
                h = Xa(f, h, x);
                break e;
              }
              Nr(f, h, b, x);
            }
            h = h.child;
          }
          return h;
        case 5:
          return ka(h), f === null && qc(h), b = h.type, B = h.pendingProps, F = f !== null ? f.memoizedProps : null, K = B.children, Xe(b, B) ? K = null : F !== null && Xe(b, F) && (h.flags |= 32), sh(f, h), Nr(f, h, K, x), h.child;
        case 6:
          return f === null && qc(h), null;
        case 13:
          return il(f, h, x);
        case 4:
          return Qc(h, h.stateNode.containerInfo), b = h.pendingProps, f === null ? h.child = wu(h, null, b, x) : Nr(f, h, b, x), h.child;
        case 11:
          return b = h.type, B = h.pendingProps, B = h.elementType === b ? B : ca(b, B), v_(f, h, b, B, x);
        case 7:
          return Nr(f, h, h.pendingProps, x), h.child;
        case 8:
          return Nr(f, h, h.pendingProps.children, x), h.child;
        case 12:
          return Nr(f, h, h.pendingProps.children, x), h.child;
        case 10:
          e: {
            if (b = h.type._context, B = h.pendingProps, F = h.memoizedProps, K = B.value, a_(h, b, K), F !== null) if (Oa(F.value, K)) {
              if (F.children === B.children && !mi.current) {
                h = Xa(f, h, x);
                break e;
              }
            } else for (F = h.child, F !== null && (F.return = h); F !== null; ) {
              var de = F.dependencies;
              if (de !== null) {
                K = F.child;
                for (var Le = de.firstContext; Le !== null; ) {
                  if (Le.context === b) {
                    if (F.tag === 1) {
                      Le = mo(-1, x & -x), Le.tag = 2;
                      var ft = F.updateQueue;
                      if (ft !== null) {
                        ft = ft.shared;
                        var Nt = ft.pending;
                        Nt === null ? Le.next = Le : (Le.next = Nt.next, Nt.next = Le), ft.pending = Le;
                      }
                    }
                    F.lanes |= x, Le = F.alternate, Le !== null && (Le.lanes |= x), Kc(F.return, x, h), de.lanes |= x;
                    break;
                  }
                  Le = Le.next;
                }
              } else if (F.tag === 10) K = F.type === h.type ? null : F.child;
              else if (F.tag === 18) {
                if (K = F.return, K === null) throw Error(o(341));
                K.lanes |= x, de = K.alternate, de !== null && (de.lanes |= x), Kc(K, x, h), K = F.sibling;
              } else K = F.child;
              if (K !== null) K.return = F;
              else for (K = F; K !== null; ) {
                if (K === h) {
                  K = null;
                  break;
                }
                if (F = K.sibling, F !== null) {
                  F.return = K.return, K = F;
                  break;
                }
                K = K.return;
              }
              F = K;
            }
            Nr(f, h, B.children, x), h = h.child;
          }
          return h;
        case 9:
          return B = h.type, b = h.pendingProps.children, Su(h, x), B = Ir(B), b = b(B), h.flags |= 1, Nr(f, h, b, x), h.child;
        case 14:
          return b = h.type, B = ca(b, h.pendingProps), B = ca(b.type, B), __(f, h, b, B, x);
        case 15:
          return rh(f, h, h.type, h.pendingProps, x);
        case 17:
          return b = h.type, B = h.pendingProps, B = h.elementType === b ? B : ca(b, B), f !== null && (f.alternate = null, h.alternate = null, h.flags |= 2), h.tag = 1, $i(b) ? (f = !0, Gi(h)) : f = !1, Su(h, x), f_(h, b, B), Sm(h, b, B, x), Fu(null, h, b, !0, f, x);
        case 19:
          return tf(f, h, x);
        case 22:
          return y_(f, h, x);
      }
      throw Error(o(156, h.tag));
    };
    function Yu(f, h) {
      return dm(f, h);
    }
    function Gl(f, h, x, b) {
      this.tag = f, this.key = x, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = h, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = b, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Gr(f, h, x, b) {
      return new Gl(f, h, x, b);
    }
    function Eh(f) {
      return f = f.prototype, !(!f || !f.isReactComponent);
    }
    function L_(f) {
      if (typeof f == "function") return Eh(f) ? 1 : 0;
      if (f != null) {
        if (f = f.$$typeof, f === T) return 11;
        if (f === w) return 14;
      }
      return 2;
    }
    function bo(f, h) {
      var x = f.alternate;
      return x === null ? (x = Gr(f.tag, h, f.key, f.mode), x.elementType = f.elementType, x.type = f.type, x.stateNode = f.stateNode, x.alternate = f, f.alternate = x) : (x.pendingProps = h, x.type = f.type, x.flags = 0, x.subtreeFlags = 0, x.deletions = null), x.flags = f.flags & 14680064, x.childLanes = f.childLanes, x.lanes = f.lanes, x.child = f.child, x.memoizedProps = f.memoizedProps, x.memoizedState = f.memoizedState, x.updateQueue = f.updateQueue, h = f.dependencies, x.dependencies = h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }, x.sibling = f.sibling, x.index = f.index, x.ref = f.ref, x;
    }
    function Ku(f, h, x, b, B, F) {
      var K = 2;
      if (b = f, typeof f == "function") Eh(f) && (K = 1);
      else if (typeof f == "string") K = 5;
      else e: switch (f) {
        case p:
          return kl(x.children, B, F, h);
        case g:
          K = 8, B |= 8;
          break;
        case v:
          return f = Gr(12, x, h, B | 2), f.elementType = v, f.lanes = F, f;
        case E:
          return f = Gr(13, x, h, B), f.elementType = E, f.lanes = F, f;
        case M:
          return f = Gr(19, x, h, B), f.elementType = M, f.lanes = F, f;
        case D:
          return Th(x, B, F, h);
        default:
          if (typeof f == "object" && f !== null) switch (f.$$typeof) {
            case y:
              K = 10;
              break e;
            case S:
              K = 9;
              break e;
            case T:
              K = 11;
              break e;
            case w:
              K = 14;
              break e;
            case C:
              K = 16, b = null;
              break e;
          }
          throw Error(o(130, f == null ? f : typeof f, ""));
      }
      return h = Gr(K, x, h, B), h.elementType = f, h.type = b, h.lanes = F, h;
    }
    function kl(f, h, x, b) {
      return f = Gr(7, f, b, h), f.lanes = x, f;
    }
    function Th(f, h, x, b) {
      return f = Gr(22, f, b, h), f.elementType = D, f.lanes = x, f.stateNode = {}, f;
    }
    function Cs(f, h, x) {
      return f = Gr(6, f, null, h), f.lanes = x, f;
    }
    function qu(f, h, x) {
      return h = Gr(4, f.children !== null ? f.children : [], f.key, h), h.lanes = x, h.stateNode = { containerInfo: f.containerInfo, pendingChildren: null, implementation: f.implementation }, h;
    }
    function hf(f, h, x, b, B) {
      this.tag = h, this.containerInfo = f, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Ct, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = fm(0), this.expirationTimes = fm(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = fm(0), this.identifierPrefix = b, this.onRecoverableError = B, we && (this.mutableSourceEagerHydrationData = null);
    }
    function pf(f, h, x, b, B, F, K, de, Le) {
      return f = new hf(f, h, x, de, Le), h === 1 ? (h = 1, F === !0 && (h |= 8)) : h = 0, F = Gr(3, null, null, h), f.current = F, F.stateNode = f, F.memoizedState = { element: b, isDehydrated: x, cache: null, transitions: null }, _m(F), f;
    }
    function Vl(f) {
      if (!f) return $r;
      f = f._reactInternals;
      e: {
        if (L(f) !== f || f.tag !== 1) throw Error(o(170));
        var h = f;
        do {
          switch (h.tag) {
            case 3:
              h = h.stateNode.context;
              break e;
            case 1:
              if ($i(h.type)) {
                h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          h = h.return;
        } while (h !== null);
        throw Error(o(171));
      }
      if (f.tag === 1) {
        var x = f.type;
        if ($i(x)) return Rl(f, x, h);
      }
      return h;
    }
    function bh(f) {
      var h = f._reactInternals;
      if (h === void 0)
        throw typeof f.render == "function" ? Error(o(188)) : (f = Object.keys(f).join(","), Error(o(268, f)));
      return f = Q(h), f === null ? null : f.stateNode;
    }
    function mf(f, h) {
      if (f = f.memoizedState, f !== null && f.dehydrated !== null) {
        var x = f.retryLane;
        f.retryLane = x !== 0 && x < h ? x : h;
      }
    }
    function ju(f, h) {
      mf(f, h), (f = f.alternate) && mf(f, h);
    }
    function P_(f) {
      return f = Q(f), f === null ? null : f.stateNode;
    }
    function I_() {
      return null;
    }
    return t.attemptContinuousHydration = function(f) {
      if (f.tag === 13) {
        var h = Hr();
        Ui(f, 134217728, h), ju(f, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(f) {
      if (f.tag === 13) {
        var h = Hr(), x = Ji(f);
        Ui(f, x, h), ju(f, x);
      }
    }, t.attemptSynchronousHydration = function(f) {
      switch (f.tag) {
        case 3:
          var h = f.stateNode;
          if (h.current.memoizedState.isDehydrated) {
            var x = Jo(h.pendingLanes);
            x !== 0 && (Yo(h, x | 1), Rr(h, er()), (vn & 6) === 0 && (Gu(), za()));
          }
          break;
        case 13:
          var b = Hr();
          w_(function() {
            return Ui(f, 1, b);
          }), ju(f, 1);
      }
    }, t.batchedUpdates = function(f, h) {
      var x = vn;
      vn |= 1;
      try {
        return f(h);
      } finally {
        vn = x, vn === 0 && (Gu(), Dd && za());
      }
    }, t.createComponentSelector = function(f) {
      return { $$typeof: Ao, value: f };
    }, t.createContainer = function(f, h, x, b, B, F, K) {
      return pf(f, h, !1, null, x, b, B, F, K);
    }, t.createHasPseudoClassSelector = function(f) {
      return { $$typeof: af, value: f };
    }, t.createHydrationContainer = function(f, h, x, b, B, F, K, de, Le) {
      return f = pf(x, b, !0, f, B, F, K, de, Le), f.context = Vl(null), x = f.current, b = Hr(), B = Ji(x), F = mo(b, B), F.callback = h ?? null, qo(x, F), f.current.lanes = B, Wc(f, B, b), Rr(f, b), f;
    }, t.createPortal = function(f, h, x) {
      var b = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: d, key: b == null ? null : "" + b, children: f, containerInfo: h, implementation: x };
    }, t.createRoleSelector = function(f) {
      return { $$typeof: hh, value: f };
    }, t.createTestNameSelector = function(f) {
      return { $$typeof: ph, value: f };
    }, t.createTextSelector = function(f) {
      return { $$typeof: Mo, value: f };
    }, t.deferredUpdates = function(f) {
      var h = Fn, x = An.transition;
      try {
        return An.transition = null, Fn = 16, f();
      } finally {
        Fn = h, An.transition = x;
      }
    }, t.discreteUpdates = function(f, h, x, b, B) {
      var F = Fn, K = An.transition;
      try {
        return An.transition = null, Fn = 1, f(h, x, b, B);
      } finally {
        Fn = F, An.transition = K, vn === 0 && Gu();
      }
    }, t.findAllNodes = zm, t.findBoundingRects = function(f, h) {
      if (!G) throw Error(o(363));
      h = zm(f, h), f = [];
      for (var x = 0; x < h.length; x++) f.push(Ue(h[x]));
      for (h = f.length - 1; 0 < h; h--) {
        x = f[h];
        for (var b = x.x, B = b + x.width, F = x.y, K = F + x.height, de = h - 1; 0 <= de; de--) if (h !== de) {
          var Le = f[de], ft = Le.x, Nt = ft + Le.width, ln = Le.y, jt = ln + Le.height;
          if (b >= ft && F >= ln && B <= Nt && K <= jt) {
            f.splice(h, 1);
            break;
          } else if (b !== ft || x.width !== Le.width || jt < F || ln > K) {
            if (!(F !== ln || x.height !== Le.height || Nt < b || ft > B)) {
              ft > b && (Le.width += ft - b, Le.x = b), Nt < B && (Le.width = B - ft), f.splice(h, 1);
              break;
            }
          } else {
            ln > F && (Le.height += ln - F, Le.y = F), jt < K && (Le.height = K - ln), f.splice(h, 1);
            break;
          }
        }
      }
      return f;
    }, t.findHostInstance = bh, t.findHostInstanceWithNoPortals = function(f) {
      return f = Y(f), f = f !== null ? j(f) : null, f === null ? null : f.stateNode;
    }, t.findHostInstanceWithWarning = function(f) {
      return bh(f);
    }, t.flushControlled = function(f) {
      var h = vn;
      vn |= 1;
      var x = An.transition, b = Fn;
      try {
        An.transition = null, Fn = 1, f();
      } finally {
        Fn = b, An.transition = x, vn = h, vn === 0 && (Gu(), za());
      }
    }, t.flushPassiveEffects = pr, t.flushSync = w_, t.focusWithin = function(f, h) {
      if (!G) throw Error(o(363));
      for (f = Et(f), h = b_(f, h), h = Array.from(h), f = 0; f < h.length; ) {
        var x = h[f++];
        if (!Oe(x)) {
          if (x.tag === 5 && st(x.stateNode)) return !0;
          for (x = x.child; x !== null; ) h.push(x), x = x.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return Fn;
    }, t.getFindAllNodesFailureDescription = function(f, h) {
      if (!G) throw Error(o(363));
      var x = 0, b = [];
      f = [Et(f), 0];
      for (var B = 0; B < f.length; ) {
        var F = f[B++], K = f[B++], de = h[K];
        if ((F.tag !== 5 || !Oe(F)) && (qs(F, de) && (b.push(bs(de)), K++, K > x && (x = K)), K < h.length)) for (F = F.child; F !== null; ) f.push(F, K), F = F.sibling;
      }
      if (x < h.length) {
        for (f = []; x < h.length; x++) f.push(bs(h[x]));
        return `findAllNodes was able to match part of the selector:
  ` + (b.join(" > ") + `

No matching component was found for:
  `) + f.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(f) {
      if (f = f.current, !f.child) return null;
      switch (f.child.tag) {
        case 5:
          return re(f.child.stateNode);
        default:
          return f.child.stateNode;
      }
    }, t.injectIntoDevTools = function(f) {
      if (f = { bundleType: f.bundleType, version: f.version, rendererPackageName: f.rendererPackageName, rendererConfig: f.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: u.ReactCurrentDispatcher, findHostInstanceByFiber: P_, findFiberByHostInstance: f.findFiberByHostInstance || I_, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") f = !1;
      else {
        var h = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (h.isDisabled || !h.supportsFiber) f = !0;
        else {
          try {
            Bd = h.inject(f), Na = h;
          } catch {
          }
          f = !!h.checkDCE;
        }
      }
      return f;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(f, h, x, b) {
      if (!G) throw Error(o(363));
      f = zm(f, h);
      var B = it(f, x, b).disconnect;
      return { disconnect: function() {
        B();
      } };
    }, t.registerMutableSourceForHydration = function(f, h) {
      var x = h._getVersion;
      x = x(h._source), f.mutableSourceEagerHydrationData == null ? f.mutableSourceEagerHydrationData = [h, x] : f.mutableSourceEagerHydrationData.push(h, x);
    }, t.runWithPriority = function(f, h) {
      var x = Fn;
      try {
        return Fn = f, h();
      } finally {
        Fn = x;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(f, h, x, b) {
      var B = h.current, F = Hr(), K = Ji(B);
      return x = Vl(x), h.context === null ? h.context = x : h.pendingContext = x, h = mo(F, K), h.payload = { element: f }, b = b === void 0 ? null : b, b !== null && (h.callback = b), qo(B, h), f = Ui(B, K, F), f !== null && Pd(f, B, K), K;
    }, t;
  }), ME;
}
var EE = { exports: {} };
/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var vD;
function m5() {
  return vD || (vD = 1, process.env.NODE_ENV !== "production" && (EE.exports = function(e) {
    var t = {}, n = Vx, i = U2(), r = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, o = !1;
    function u(a) {
      o = a;
    }
    function c(a) {
      if (!o) {
        for (var l = arguments.length, m = new Array(l > 1 ? l - 1 : 0), _ = 1; _ < l; _++)
          m[_ - 1] = arguments[_];
        p("warn", a, m);
      }
    }
    function d(a) {
      if (!o) {
        for (var l = arguments.length, m = new Array(l > 1 ? l - 1 : 0), _ = 1; _ < l; _++)
          m[_ - 1] = arguments[_];
        p("error", a, m);
      }
    }
    function p(a, l, m) {
      {
        var _ = r.ReactDebugCurrentFrame, A = _.getStackAddendum();
        A !== "" && (l += "%s", m = m.concat([A]));
        var R = m.map(function(P) {
          return String(P);
        });
        R.unshift("Warning: " + l), Function.prototype.apply.call(console[a], console, R);
      }
    }
    var g = Object.assign;
    function v(a) {
      return a._reactInternals;
    }
    function y(a, l) {
      a._reactInternals = l;
    }
    var S = !1, T = !1, E = !1, M = !1, w = !0, C = !0, D = !0, N = 0, U = 1, O = 2, V = 3, L = 4, I = 5, Y = 6, Q = 7, fe = 8, j = 9, ie = 10, re = 11, pe = 12, J = 13, Z = 14, H = 15, ue = 16, Se = 17, me = 18, ye = 19, Xe = 21, Je = 22, Ye = 23, At = 24, Ct = 25, pt = Symbol.for("react.element"), mt = Symbol.for("react.portal"), ne = Symbol.for("react.fragment"), we = Symbol.for("react.strict_mode"), Ee = Symbol.for("react.profiler"), He = Symbol.for("react.provider"), be = Symbol.for("react.context"), ce = Symbol.for("react.forward_ref"), nt = Symbol.for("react.suspense"), X = Symbol.for("react.suspense_list"), G = Symbol.for("react.memo"), le = Symbol.for("react.lazy"), Ue = Symbol.for("react.scope"), Ve = Symbol.for("react.debug_trace_mode"), Oe = Symbol.for("react.offscreen"), ct = Symbol.for("react.legacy_hidden"), st = Symbol.for("react.cache"), it = Symbol.for("react.tracing_marker"), Lt = Symbol.iterator, zt = "@@iterator";
    function ee(a) {
      if (a === null || typeof a != "object")
        return null;
      var l = Lt && a[Lt] || a[zt];
      return typeof l == "function" ? l : null;
    }
    function Re(a, l, m) {
      var _ = a.displayName;
      if (_)
        return _;
      var A = l.displayName || l.name || "";
      return A !== "" ? m + "(" + A + ")" : m;
    }
    function De(a) {
      return a.displayName || "Context";
    }
    function Ie(a) {
      if (a == null)
        return null;
      if (typeof a.tag == "number" && d("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof a == "function")
        return a.displayName || a.name || null;
      if (typeof a == "string")
        return a;
      switch (a) {
        case ne:
          return "Fragment";
        case mt:
          return "Portal";
        case Ee:
          return "Profiler";
        case we:
          return "StrictMode";
        case nt:
          return "Suspense";
        case X:
          return "SuspenseList";
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case be:
            var l = a;
            return De(l) + ".Consumer";
          case He:
            var m = a;
            return De(m._context) + ".Provider";
          case ce:
            return Re(a, a.render, "ForwardRef");
          case G:
            var _ = a.displayName || null;
            return _ !== null ? _ : Ie(a.type) || "Memo";
          case le: {
            var A = a, R = A._payload, P = A._init;
            try {
              return Ie(P(R));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Qe(a, l, m) {
      var _ = l.displayName || l.name || "";
      return a.displayName || (_ !== "" ? m + "(" + _ + ")" : m);
    }
    function rt(a) {
      return a.displayName || "Context";
    }
    function Fe(a) {
      var l = a.tag, m = a.type;
      switch (l) {
        case At:
          return "Cache";
        case j:
          var _ = m;
          return rt(_) + ".Consumer";
        case ie:
          var A = m;
          return rt(A._context) + ".Provider";
        case me:
          return "DehydratedFragment";
        case re:
          return Qe(m, m.render, "ForwardRef");
        case Q:
          return "Fragment";
        case I:
          return m;
        case L:
          return "Portal";
        case V:
          return "Root";
        case Y:
          return "Text";
        case ue:
          return Ie(m);
        case fe:
          return m === we ? "StrictMode" : "Mode";
        case Je:
          return "Offscreen";
        case pe:
          return "Profiler";
        case Xe:
          return "Scope";
        case J:
          return "Suspense";
        case ye:
          return "SuspenseList";
        case Ct:
          return "TracingMarker";
        // The display name for this tags come from the user-provided type:
        case U:
        case N:
        case Se:
        case O:
        case Z:
        case H:
          if (typeof m == "function")
            return m.displayName || m.name || null;
          if (typeof m == "string")
            return m;
          break;
      }
      return null;
    }
    var Ke = (
      /*                      */
      0
    ), Dt = (
      /*                */
      1
    ), We = (
      /*                    */
      2
    ), Pe = (
      /*                       */
      4
    ), ae = (
      /*           */
      We | Pe
    ), et = (
      /*                */
      16
    ), at = (
      /*                 */
      32
    ), Wt = (
      /*                     */
      64
    ), ot = (
      /*                   */
      128
    ), an = (
      /*            */
      256
    ), un = (
      /*                          */
      512
    ), wt = (
      /*                     */
      1024
    ), St = (
      /*                      */
      2048
    ), bt = (
      /*                    */
      4096
    ), lt = (
      /*           */
      bt | Pe
    ), Ot = (
      /*                   */
      8192
    ), kt = (
      /*             */
      16384
    ), en = (
      /*               */
      32767
    ), Vn = (
      /*                   */
      32768
    ), Yt = (
      /*                */
      65536
    ), te = (
      /* */
      131072
    ), ze = (
      /*                       */
      1048576
    ), tt = (
      /*                    */
      2097152
    ), gt = (
      /*                 */
      4194304
    ), Ht = (
      /*                */
      8388608
    ), tn = (
      /*               */
      16777216
    ), k = (
      /*              */
      33554432
    ), se = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Pe | wt | 0
    ), _e = We | Pe | et | at | un | bt | Ot, ge = Pe | Wt | un | Ot, he = St | et, je = gt | Ht | tt, Rt = r.ReactCurrentOwner;
    function Ft(a) {
      var l = a, m = a;
      if (a.alternate)
        for (; l.return; )
          l = l.return;
      else {
        var _ = l;
        do
          l = _, (l.flags & (We | bt)) !== Ke && (m = l.return), _ = l.return;
        while (_);
      }
      return l.tag === V ? m : null;
    }
    function vt(a) {
      return Ft(a) === a;
    }
    function It(a) {
      {
        var l = Rt.current;
        if (l !== null && l.tag === U) {
          var m = l, _ = m.stateNode;
          _._warnedAboutRefsInRender || d("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Fe(m) || "A component"), _._warnedAboutRefsInRender = !0;
        }
      }
      var A = v(a);
      return A ? Ft(A) === A : !1;
    }
    function Xt(a) {
      if (Ft(a) !== a)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function $t(a) {
      var l = a.alternate;
      if (!l) {
        var m = Ft(a);
        if (m === null)
          throw new Error("Unable to find node on an unmounted component.");
        return m !== a ? null : a;
      }
      for (var _ = a, A = l; ; ) {
        var R = _.return;
        if (R === null)
          break;
        var P = R.alternate;
        if (P === null) {
          var z = R.return;
          if (z !== null) {
            _ = A = z;
            continue;
          }
          break;
        }
        if (R.child === P.child) {
          for (var W = R.child; W; ) {
            if (W === _)
              return Xt(R), a;
            if (W === A)
              return Xt(R), l;
            W = W.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (_.return !== A.return)
          _ = R, A = P;
        else {
          for (var $ = !1, oe = R.child; oe; ) {
            if (oe === _) {
              $ = !0, _ = R, A = P;
              break;
            }
            if (oe === A) {
              $ = !0, A = R, _ = P;
              break;
            }
            oe = oe.sibling;
          }
          if (!$) {
            for (oe = P.child; oe; ) {
              if (oe === _) {
                $ = !0, _ = P, A = R;
                break;
              }
              if (oe === A) {
                $ = !0, A = P, _ = R;
                break;
              }
              oe = oe.sibling;
            }
            if (!$)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (_.alternate !== A)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (_.tag !== V)
        throw new Error("Unable to find node on an unmounted component.");
      return _.stateNode.current === _ ? a : l;
    }
    function Kn(a) {
      var l = $t(a);
      return l !== null ? ai(l) : null;
    }
    function ai(a) {
      if (a.tag === I || a.tag === Y)
        return a;
      for (var l = a.child; l !== null; ) {
        var m = ai(l);
        if (m !== null)
          return m;
        l = l.sibling;
      }
      return null;
    }
    function bn(a) {
      var l = $t(a);
      return l !== null ? ti(l) : null;
    }
    function ti(a) {
      if (a.tag === I || a.tag === Y)
        return a;
      for (var l = a.child; l !== null; ) {
        if (l.tag !== L) {
          var m = ti(l);
          if (m !== null)
            return m;
        }
        l = l.sibling;
      }
      return null;
    }
    var Qt = Array.isArray;
    function ht(a) {
      return Qt(a);
    }
    var $r = e.getPublicInstance, mn = e.getRootHostContext, mi = e.getChildHostContext, Fa = e.prepareForCommit, Gs = e.resetAfterCommit, $i = e.createInstance, fi = e.appendInitialChild, ua = e.finalizeInitialChildren, Rl = e.prepareUpdate, Gi = e.shouldSetTextContent, Bl = e.createTextInstance, es = e.scheduleTimeout, Cd = e.cancelTimeout, um = e.noTimeout;
    e.now;
    var wd = e.isPrimaryRenderer, Rd = e.warnsIfNotActing, ts = e.supportsMutation, Jo = e.supportsPersistence, br = e.supportsHydration, AS = e.getInstanceFromNode;
    e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
    var MS = e.preparePortalMount;
    e.preparePortalMount, e.getInstanceFromScope;
    var cm = e.getCurrentEventPriority, fm = e.detachDeletedInstance, Wc = e.supportsMicrotasks, ES = e.scheduleMicrotask, Yo = e.supportsTestSelectors, Fn = e.findFiberRoot, i_ = e.getBoundingRect, dm = e.getTextContent, xu = e.isHiddenSubtree, TS = e.matchAccessibilityRole, bS = e.setFocusIfFocusable, er = e.setupIntersectionObserver, hm = e.appendChild, CS = e.appendChildToContainer, pm = e.commitTextUpdate, wS = e.commitMount, Bd = e.commitUpdate, Na = e.insertBefore, RS = e.insertInContainerBefore, BS = e.removeChild, Oa = e.removeChildFromContainer, Ha = e.resetTextContent, Dd = e.hideInstance, mm = e.hideTextInstance, r_ = e.unhideInstance, DS = e.unhideTextInstance, za = e.clearContainer, LS = e.cloneInstance, Xc = e.createContainerChildSet, s_ = e.appendChildToContainerChildSet, ca = e.finalizeContainerChildren, Jc = e.replaceContainerChildren;
    e.getOffscreenContainerType, e.getOffscreenContainerProps;
    var Yc = e.cloneHiddenInstance, Dl = e.cloneHiddenTextInstance, gm = e.canHydrateInstance, vm = e.canHydrateTextInstance, a_ = e.canHydrateSuspenseInstance, Ld = e.isSuspenseInstancePending, Kc = e.isSuspenseInstanceFallback, Su = e.registerSuspenseInstanceRetry, Ir = e.getNextHydratableSibling, Ga = e.getFirstHydratableChild, Ko = e.getFirstHydratableChildWithinContainer, _m = e.getFirstHydratableChildWithinSuspenseInstance, o_ = e.hydrateInstance, mo = e.hydrateTextInstance, qo = e.hydrateSuspenseInstance, Pd = e.getNextHydratableInstanceAfterSuspenseInstance, ym = e.commitHydratedContainer, Id = e.commitHydratedSuspenseInstance, l_ = e.clearSuspenseBoundary, u_ = e.clearSuspenseBoundaryFromContainer, xm = e.shouldDeleteUnhydratedTailInstances, Ud = e.didNotMatchHydratedContainerTextInstance, c_ = e.didNotMatchHydratedTextInstance, f_ = e.didNotHydrateInstanceWithinContainer, d_ = e.didNotHydrateInstanceWithinSuspenseInstance, Sm = e.didNotHydrateInstance, Au = e.didNotFindHydratableInstanceWithinContainer, Mu = e.didNotFindHydratableTextInstanceWithinContainer, Fd = e.didNotFindHydratableSuspenseInstanceWithinContainer, Nd = e.didNotFindHydratableInstanceWithinSuspenseInstance, ks = e.didNotFindHydratableTextInstanceWithinSuspenseInstance, Vs = e.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance, Ll = e.didNotFindHydratableInstance, go = e.didNotFindHydratableTextInstance, vo = e.didNotFindHydratableSuspenseInstance, Pl = e.errorHydratingContainer, Eu = 0, Od, Hd, ns, is, ni, Tu, Ws;
    function Am() {
    }
    Am.__reactDisabledLog = !0;
    function h_() {
      {
        if (Eu === 0) {
          Od = console.log, Hd = console.info, ns = console.warn, is = console.error, ni = console.group, Tu = console.groupCollapsed, Ws = console.groupEnd;
          var a = {
            configurable: !0,
            enumerable: !0,
            value: Am,
            writable: !0
          };
          Object.defineProperties(console, {
            info: a,
            log: a,
            warn: a,
            error: a,
            group: a,
            groupCollapsed: a,
            groupEnd: a
          });
        }
        Eu++;
      }
    }
    function Mm() {
      {
        if (Eu--, Eu === 0) {
          var a = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: g({}, a, {
              value: Od
            }),
            info: g({}, a, {
              value: Hd
            }),
            warn: g({}, a, {
              value: ns
            }),
            error: g({}, a, {
              value: is
            }),
            group: g({}, a, {
              value: ni
            }),
            groupCollapsed: g({}, a, {
              value: Tu
            }),
            groupEnd: g({}, a, {
              value: Ws
            })
          });
        }
        Eu < 0 && d("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var qc = r.ReactCurrentDispatcher, zd;
    function Xs(a, l, m) {
      {
        if (zd === void 0)
          try {
            throw Error();
          } catch (A) {
            var _ = A.stack.trim().match(/\n( *(at )?)/);
            zd = _ && _[1] || "";
          }
        return `
` + zd + a;
      }
    }
    var jo = !1, bu;
    {
      var jc = typeof WeakMap == "function" ? WeakMap : Map;
      bu = new jc();
    }
    function Cu(a, l) {
      if (!a || jo)
        return "";
      {
        var m = bu.get(a);
        if (m !== void 0)
          return m;
      }
      var _;
      jo = !0;
      var A = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var R;
      R = qc.current, qc.current = null, h_();
      try {
        if (l) {
          var P = function() {
            throw Error();
          };
          if (Object.defineProperty(P.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(P, []);
            } catch ($e) {
              _ = $e;
            }
            Reflect.construct(a, [], P);
          } else {
            try {
              P.call();
            } catch ($e) {
              _ = $e;
            }
            a.call(P.prototype);
          }
        } else {
          try {
            throw Error();
          } catch ($e) {
            _ = $e;
          }
          a();
        }
      } catch ($e) {
        if ($e && _ && typeof $e.stack == "string") {
          for (var z = $e.stack.split(`
`), W = _.stack.split(`
`), $ = z.length - 1, oe = W.length - 1; $ >= 1 && oe >= 0 && z[$] !== W[oe]; )
            oe--;
          for (; $ >= 1 && oe >= 0; $--, oe--)
            if (z[$] !== W[oe]) {
              if ($ !== 1 || oe !== 1)
                do
                  if ($--, oe--, oe < 0 || z[$] !== W[oe]) {
                    var xe = `
` + z[$].replace(" at new ", " at ");
                    return a.displayName && xe.includes("<anonymous>") && (xe = xe.replace("<anonymous>", a.displayName)), typeof a == "function" && bu.set(a, xe), xe;
                  }
                while ($ >= 1 && oe >= 0);
              break;
            }
        }
      } finally {
        jo = !1, qc.current = R, Mm(), Error.prepareStackTrace = A;
      }
      var Be = a ? a.displayName || a.name : "", Ne = Be ? Xs(Be) : "";
      return typeof a == "function" && bu.set(a, Ne), Ne;
    }
    function p_(a, l, m) {
      return Cu(a, !0);
    }
    function Gd(a, l, m) {
      return Cu(a, !1);
    }
    function wu(a) {
      var l = a.prototype;
      return !!(l && l.isReactComponent);
    }
    function kd(a, l, m) {
      if (a == null)
        return "";
      if (typeof a == "function")
        return Cu(a, wu(a));
      if (typeof a == "string")
        return Xs(a);
      switch (a) {
        case nt:
          return Xs("Suspense");
        case X:
          return Xs("SuspenseList");
      }
      if (typeof a == "object")
        switch (a.$$typeof) {
          case ce:
            return Gd(a.render);
          case G:
            return kd(a.type, l, m);
          case le: {
            var _ = a, A = _._payload, R = _._init;
            try {
              return kd(R(A), l, m);
            } catch {
            }
          }
        }
      return "";
    }
    var Ru = Object.prototype.hasOwnProperty, Es = {}, Bu = r.ReactDebugCurrentFrame;
    function _o(a) {
      if (a) {
        var l = a._owner, m = kd(a.type, a._source, l ? l.type : null);
        Bu.setExtraStackFrame(m);
      } else
        Bu.setExtraStackFrame(null);
    }
    function Bi(a, l, m, _, A) {
      {
        var R = Function.call.bind(Ru);
        for (var P in a)
          if (R(a, P)) {
            var z = void 0;
            try {
              if (typeof a[P] != "function") {
                var W = Error((_ || "React class") + ": " + m + " type `" + P + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[P] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw W.name = "Invariant Violation", W;
              }
              z = a[P](l, P, _, m, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch ($) {
              z = $;
            }
            z && !(z instanceof Error) && (_o(A), d("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", _ || "React class", m, P, typeof z), _o(null)), z instanceof Error && !(z.message in Es) && (Es[z.message] = !0, _o(A), d("Failed %s type: %s", m, z.message), _o(null));
          }
      }
    }
    var Qc = [], yo;
    yo = [];
    var ka = -1;
    function Va(a) {
      return {
        current: a
      };
    }
    function Sn(a, l) {
      if (ka < 0) {
        d("Unexpected pop.");
        return;
      }
      l !== yo[ka] && d("Unexpected Fiber popped."), a.current = Qc[ka], Qc[ka] = null, yo[ka] = null, ka--;
    }
    function Di(a, l, m) {
      ka++, Qc[ka] = a.current, yo[ka] = m, a.current = l;
    }
    var Zc;
    Zc = {};
    var Ur = {};
    Object.freeze(Ur);
    var Js = Va(Ur), vi = Va(!1), Qo = Ur;
    function jn(a, l, m) {
      return m && rs(l) ? Qo : Js.current;
    }
    function cr(a, l, m) {
      {
        var _ = a.stateNode;
        _.__reactInternalMemoizedUnmaskedChildContext = l, _.__reactInternalMemoizedMaskedChildContext = m;
      }
    }
    function di(a, l) {
      {
        var m = a.type, _ = m.contextTypes;
        if (!_)
          return Ur;
        var A = a.stateNode;
        if (A && A.__reactInternalMemoizedUnmaskedChildContext === l)
          return A.__reactInternalMemoizedMaskedChildContext;
        var R = {};
        for (var P in _)
          R[P] = l[P];
        {
          var z = Fe(a) || "Unknown";
          Bi(_, R, "context", z);
        }
        return A && cr(a, l, R), R;
      }
    }
    function Il() {
      return vi.current;
    }
    function rs(a) {
      {
        var l = a.childContextTypes;
        return l != null;
      }
    }
    function Zo(a) {
      Sn(vi, a), Sn(Js, a);
    }
    function Em(a) {
      Sn(vi, a), Sn(Js, a);
    }
    function fr(a, l, m) {
      {
        if (Js.current !== Ur)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        Di(Js, l, a), Di(vi, m, a);
      }
    }
    function Vd(a, l, m) {
      {
        var _ = a.stateNode, A = l.childContextTypes;
        if (typeof _.getChildContext != "function") {
          {
            var R = Fe(a) || "Unknown";
            Zc[R] || (Zc[R] = !0, d("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", R, R));
          }
          return m;
        }
        var P = _.getChildContext();
        for (var z in P)
          if (!(z in A))
            throw new Error((Fe(a) || "Unknown") + '.getChildContext(): key "' + z + '" is not defined in childContextTypes.');
        {
          var W = Fe(a) || "Unknown";
          Bi(A, P, "child context", W);
        }
        return g({}, m, P);
      }
    }
    function Du(a) {
      {
        var l = a.stateNode, m = l && l.__reactInternalMemoizedMergedChildContext || Ur;
        return Qo = Js.current, Di(Js, m, a), Di(vi, vi.current, a), !0;
      }
    }
    function Wd(a, l, m) {
      {
        var _ = a.stateNode;
        if (!_)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (m) {
          var A = Vd(a, l, Qo);
          _.__reactInternalMemoizedMergedChildContext = A, Sn(vi, a), Sn(Js, a), Di(Js, A, a), Di(vi, m, a);
        } else
          Sn(vi, a), Di(vi, m, a);
      }
    }
    function xo(a) {
      {
        if (!vt(a) || a.tag !== U)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var l = a;
        do {
          switch (l.tag) {
            case V:
              return l.stateNode.context;
            case U: {
              var m = l.type;
              if (rs(m))
                return l.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          l = l.return;
        } while (l !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Fr = 0, $o = 1, rn = (
      /*                         */
      0
    ), zn = (
      /*                 */
      1
    ), Pn = (
      /*                    */
      2
    ), _i = (
      /*               */
      8
    ), fa = (
      /*              */
      16
    ), Tm = Math.clz32 ? Math.clz32 : bm, m_ = Math.log, g_ = Math.LN2;
    function bm(a) {
      var l = a >>> 0;
      return l === 0 ? 32 : 31 - (m_(l) / g_ | 0) | 0;
    }
    var Ul = 31, Ze = (
      /*                        */
      0
    ), yi = (
      /*                          */
      0
    ), gn = (
      /*                        */
      1
    ), el = (
      /*    */
      2
    ), Ys = (
      /*            */
      4
    ), tl = (
      /*            */
      8
    ), Wa = (
      /*                    */
      16
    ), Lu = (
      /*                */
      32
    ), Fl = (
      /*                       */
      4194240
    ), Nl = (
      /*                        */
      64
    ), Xd = (
      /*                        */
      128
    ), Jd = (
      /*                        */
      256
    ), Cm = (
      /*                        */
      512
    ), Yd = (
      /*                        */
      1024
    ), wm = (
      /*                        */
      2048
    ), Rm = (
      /*                        */
      4096
    ), Kd = (
      /*                        */
      8192
    ), qd = (
      /*                        */
      16384
    ), jd = (
      /*                       */
      32768
    ), Qd = (
      /*                       */
      65536
    ), Pu = (
      /*                       */
      131072
    ), Bm = (
      /*                       */
      262144
    ), Dm = (
      /*                       */
      524288
    ), Lm = (
      /*                       */
      1048576
    ), $c = (
      /*                       */
      2097152
    ), Iu = (
      /*                            */
      130023424
    ), Uu = (
      /*                             */
      4194304
    ), Zd = (
      /*                             */
      8388608
    ), $d = (
      /*                             */
      16777216
    ), eh = (
      /*                             */
      33554432
    ), th = (
      /*                             */
      67108864
    ), Pm = Uu, ss = (
      /*          */
      134217728
    ), Im = (
      /*                                 */
      268435455
    ), So = (
      /*               */
      268435456
    ), da = (
      /*                       */
      536870912
    ), Cr = (
      /*                   */
      1073741824
    );
    function nh(a) {
      {
        if (a & gn)
          return "Sync";
        if (a & el)
          return "InputContinuousHydration";
        if (a & Ys)
          return "InputContinuous";
        if (a & tl)
          return "DefaultHydration";
        if (a & Wa)
          return "Default";
        if (a & Lu)
          return "TransitionHydration";
        if (a & Fl)
          return "Transition";
        if (a & Iu)
          return "Retry";
        if (a & ss)
          return "SelectiveHydration";
        if (a & So)
          return "IdleHydration";
        if (a & da)
          return "Idle";
        if (a & Cr)
          return "Offscreen";
      }
    }
    var Qn = -1, nl = Nl, ki = Uu;
    function ef(a) {
      switch (il(a)) {
        case gn:
          return gn;
        case el:
          return el;
        case Ys:
          return Ys;
        case tl:
          return tl;
        case Wa:
          return Wa;
        case Lu:
          return Lu;
        case Nl:
        case Xd:
        case Jd:
        case Cm:
        case Yd:
        case wm:
        case Rm:
        case Kd:
        case qd:
        case jd:
        case Qd:
        case Pu:
        case Bm:
        case Dm:
        case Lm:
        case $c:
          return a & Fl;
        case Uu:
        case Zd:
        case $d:
        case eh:
        case th:
          return a & Iu;
        case ss:
          return ss;
        case So:
          return So;
        case da:
          return da;
        case Cr:
          return Cr;
        default:
          return d("Should have found matching lanes. This is a bug in React."), a;
      }
    }
    function ih(a, l) {
      var m = a.pendingLanes;
      if (m === Ze)
        return Ze;
      var _ = Ze, A = a.suspendedLanes, R = a.pingedLanes, P = m & Im;
      if (P !== Ze) {
        var z = P & ~A;
        if (z !== Ze)
          _ = ef(z);
        else {
          var W = P & R;
          W !== Ze && (_ = ef(W));
        }
      } else {
        var $ = m & ~A;
        $ !== Ze ? _ = ef($) : R !== Ze && (_ = ef(R));
      }
      if (_ === Ze)
        return Ze;
      if (l !== Ze && l !== _ && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (l & A) === Ze) {
        var oe = il(_), xe = il(l);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          oe >= xe || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          oe === Wa && (xe & Fl) !== Ze
        )
          return l;
      }
      (_ & Ys) !== Ze && (_ |= m & Wa);
      var Be = a.entangledLanes;
      if (Be !== Ze)
        for (var Ne = a.entanglements, $e = _ & Be; $e > 0; ) {
          var ut = rl($e), Zt = 1 << ut;
          _ |= Ne[ut], $e &= ~Zt;
        }
      return _;
    }
    function Ts(a, l) {
      for (var m = a.eventTimes, _ = Qn; l > 0; ) {
        var A = rl(l), R = 1 << A, P = m[A];
        P > _ && (_ = P), l &= ~R;
      }
      return _;
    }
    function Nr(a, l) {
      switch (a) {
        case gn:
        case el:
        case Ys:
          return l + 250;
        case tl:
        case Wa:
        case Lu:
        case Nl:
        case Xd:
        case Jd:
        case Cm:
        case Yd:
        case wm:
        case Rm:
        case Kd:
        case qd:
        case jd:
        case Qd:
        case Pu:
        case Bm:
        case Dm:
        case Lm:
        case $c:
          return l + 5e3;
        case Uu:
        case Zd:
        case $d:
        case eh:
        case th:
          return Qn;
        case ss:
        case So:
        case da:
        case Cr:
          return Qn;
        default:
          return d("Should have found matching lanes. This is a bug in React."), Qn;
      }
    }
    function v_(a, l) {
      for (var m = a.pendingLanes, _ = a.suspendedLanes, A = a.pingedLanes, R = a.expirationTimes, P = m; P > 0; ) {
        var z = rl(P), W = 1 << z, $ = R[z];
        $ === Qn ? ((W & _) === Ze || (W & A) !== Ze) && (R[z] = Nr(W, l)) : $ <= l && (a.expiredLanes |= W), P &= ~W;
      }
    }
    function __(a) {
      return ef(a.pendingLanes);
    }
    function rh(a) {
      var l = a.pendingLanes & ~Cr;
      return l !== Ze ? l : l & Cr ? Cr : Ze;
    }
    function y_(a) {
      return (a & gn) !== Ze;
    }
    function sh(a) {
      return (a & Im) !== Ze;
    }
    function ah(a) {
      return (a & Iu) === a;
    }
    function x_(a) {
      return (a & Fl) === a;
    }
    function Fu(a, l) {
      var m = el | Ys | tl | Wa;
      return (l & m) !== Ze;
    }
    function S_(a, l) {
      return (l & a.expiredLanes) !== Ze;
    }
    function Um(a) {
      return (a & Fl) !== 0;
    }
    function oh() {
      var a = nl;
      return nl <<= 1, (nl & Fl) === 0 && (nl = Nl), a;
    }
    function lh() {
      var a = ki;
      return ki <<= 1, (ki & Iu) === 0 && (ki = Uu), a;
    }
    function il(a) {
      return a & -a;
    }
    function Ol(a) {
      return il(a);
    }
    function rl(a) {
      return 31 - Tm(a);
    }
    function uh(a) {
      return rl(a);
    }
    function wr(a, l) {
      return (a & l) !== Ze;
    }
    function Hl(a, l) {
      return (a & l) === l;
    }
    function cn(a, l) {
      return a | l;
    }
    function tf(a, l) {
      return a & ~l;
    }
    function Xa(a, l) {
      return a & l;
    }
    function zC(a) {
      return a;
    }
    function PS(a, l) {
      return a !== yi && a < l ? a : l;
    }
    function Nu(a) {
      for (var l = [], m = 0; m < Ul; m++)
        l.push(a);
      return l;
    }
    function ha(a, l, m) {
      a.pendingLanes |= l, l !== da && (a.suspendedLanes = Ze, a.pingedLanes = Ze);
      var _ = a.eventTimes, A = uh(l);
      _[A] = m;
    }
    function IS(a, l) {
      a.suspendedLanes |= l, a.pingedLanes &= ~l;
      for (var m = a.expirationTimes, _ = l; _ > 0; ) {
        var A = rl(_), R = 1 << A;
        m[A] = Qn, _ &= ~R;
      }
    }
    function Mt(a, l, m) {
      a.pingedLanes |= a.suspendedLanes & l;
    }
    function ch(a, l) {
      var m = a.pendingLanes & ~l;
      a.pendingLanes = l, a.suspendedLanes = 0, a.pingedLanes = 0, a.expiredLanes &= l, a.mutableReadLanes &= l, a.entangledLanes &= l;
      for (var _ = a.entanglements, A = a.eventTimes, R = a.expirationTimes, P = m; P > 0; ) {
        var z = rl(P), W = 1 << z;
        _[z] = Ze, A[z] = Qn, R[z] = Qn, P &= ~W;
      }
    }
    function nf(a, l) {
      for (var m = a.entangledLanes |= l, _ = a.entanglements, A = m; A; ) {
        var R = rl(A), P = 1 << R;
        // Is this one of the newly entangled lanes?
        P & l | // Is this lane transitively entangled with the newly entangled lanes?
        _[R] & l && (_[R] |= l), A &= ~P;
      }
    }
    function A_(a, l) {
      var m = il(l), _;
      switch (m) {
        case Ys:
          _ = el;
          break;
        case Wa:
          _ = tl;
          break;
        case Nl:
        case Xd:
        case Jd:
        case Cm:
        case Yd:
        case wm:
        case Rm:
        case Kd:
        case qd:
        case jd:
        case Qd:
        case Pu:
        case Bm:
        case Dm:
        case Lm:
        case $c:
        case Uu:
        case Zd:
        case $d:
        case eh:
        case th:
          _ = Lu;
          break;
        case da:
          _ = So;
          break;
        default:
          _ = yi;
          break;
      }
      return (_ & (a.suspendedLanes | l)) !== yi ? yi : _;
    }
    function M_(a, l, m) {
      if (bs)
        for (var _ = a.pendingUpdatersLaneMap; m > 0; ) {
          var A = uh(m), R = 1 << A, P = _[A];
          P.add(l), m &= ~R;
        }
    }
    function sl(a, l) {
      if (bs)
        for (var m = a.pendingUpdatersLaneMap, _ = a.memoizedUpdaters; l > 0; ) {
          var A = uh(l), R = 1 << A, P = m[A];
          P.size > 0 && (P.forEach(function(z) {
            var W = z.alternate;
            (W === null || !_.has(W)) && _.add(z);
          }), P.clear()), l &= ~R;
        }
    }
    var as = gn, zl = Ys, Ou = Wa, fh = da, Hu = yi;
    function Ks() {
      return Hu;
    }
    function Vi(a) {
      Hu = a;
    }
    function E_(a, l) {
      var m = Hu;
      try {
        return Hu = a, l();
      } finally {
        Hu = m;
      }
    }
    function Fm(a, l) {
      return a !== 0 && a < l ? a : l;
    }
    function Nm(a, l) {
      return a > l ? a : l;
    }
    function Om(a, l) {
      return a !== 0 && a < l;
    }
    function dh(a) {
      var l = il(a);
      return Om(as, l) ? Om(zl, l) ? sh(l) ? Ou : fh : zl : as;
    }
    var rf = i.unstable_scheduleCallback, US = i.unstable_cancelCallback, FS = i.unstable_shouldYield, T_ = i.unstable_requestPaint, Wi = i.unstable_now, sf = i.unstable_ImmediatePriority, Hm = i.unstable_UserBlockingPriority, Ao = i.unstable_NormalPriority, af = i.unstable_IdlePriority, hh = i.unstable_yieldValue, ph = i.unstable_setDisableYieldValue, Mo = null, Li = null, Et = null, qs = !1, bs = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function b_(a) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var l = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (l.isDisabled)
        return !0;
      if (!l.supportsFiber)
        return d("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        w && (a = g({}, a, {
          getLaneLabelMap: Pi,
          injectProfilingHooks: vn
        })), Mo = l.inject(a), Li = l;
      } catch (m) {
        d("React instrumentation encountered an error: %s.", m);
      }
      return !!l.checkDCE;
    }
    function zm(a, l) {
      if (Li && typeof Li.onScheduleFiberRoot == "function")
        try {
          Li.onScheduleFiberRoot(Mo, a, l);
        } catch (m) {
          qs || (qs = !0, d("React instrumentation encountered an error: %s", m));
        }
    }
    function NS(a, l) {
      if (Li && typeof Li.onCommitFiberRoot == "function")
        try {
          var m = (a.current.flags & ot) === ot;
          if (C) {
            var _;
            switch (l) {
              case as:
                _ = sf;
                break;
              case zl:
                _ = Hm;
                break;
              case Ou:
                _ = Ao;
                break;
              case fh:
                _ = af;
                break;
              default:
                _ = Ao;
                break;
            }
            Li.onCommitFiberRoot(Mo, a, _, m);
          }
        } catch (A) {
          qs || (qs = !0, d("React instrumentation encountered an error: %s", A));
        }
    }
    function mh(a) {
      if (Li && typeof Li.onPostCommitFiberRoot == "function")
        try {
          Li.onPostCommitFiberRoot(Mo, a);
        } catch (l) {
          qs || (qs = !0, d("React instrumentation encountered an error: %s", l));
        }
    }
    function Gm(a) {
      if (Li && typeof Li.onCommitFiberUnmount == "function")
        try {
          Li.onCommitFiberUnmount(Mo, a);
        } catch (l) {
          qs || (qs = !0, d("React instrumentation encountered an error: %s", l));
        }
    }
    function An(a) {
      if (typeof hh == "function" && (ph(a), u(a)), Li && typeof Li.setStrictMode == "function")
        try {
          Li.setStrictMode(Mo, a);
        } catch (l) {
          qs || (qs = !0, d("React instrumentation encountered an error: %s", l));
        }
    }
    function vn(a) {
      Et = a;
    }
    function Pi() {
      {
        for (var a = /* @__PURE__ */ new Map(), l = 1, m = 0; m < Ul; m++) {
          var _ = nh(l);
          a.set(l, _), l *= 2;
        }
        return a;
      }
    }
    function Ii(a) {
      Et !== null && typeof Et.markCommitStarted == "function" && Et.markCommitStarted(a);
    }
    function tr() {
      Et !== null && typeof Et.markCommitStopped == "function" && Et.markCommitStopped();
    }
    function dr(a) {
      Et !== null && typeof Et.markComponentRenderStarted == "function" && Et.markComponentRenderStarted(a);
    }
    function pa() {
      Et !== null && typeof Et.markComponentRenderStopped == "function" && Et.markComponentRenderStopped();
    }
    function Xi(a) {
      Et !== null && typeof Et.markComponentPassiveEffectMountStarted == "function" && Et.markComponentPassiveEffectMountStarted(a);
    }
    function of() {
      Et !== null && typeof Et.markComponentPassiveEffectMountStopped == "function" && Et.markComponentPassiveEffectMountStopped();
    }
    function zu(a) {
      Et !== null && typeof Et.markComponentPassiveEffectUnmountStarted == "function" && Et.markComponentPassiveEffectUnmountStarted(a);
    }
    function gh() {
      Et !== null && typeof Et.markComponentPassiveEffectUnmountStopped == "function" && Et.markComponentPassiveEffectUnmountStopped();
    }
    function km(a) {
      Et !== null && typeof Et.markComponentLayoutEffectMountStarted == "function" && Et.markComponentLayoutEffectMountStarted(a);
    }
    function lf() {
      Et !== null && typeof Et.markComponentLayoutEffectMountStopped == "function" && Et.markComponentLayoutEffectMountStopped();
    }
    function Or(a) {
      Et !== null && typeof Et.markComponentLayoutEffectUnmountStarted == "function" && Et.markComponentLayoutEffectUnmountStarted(a);
    }
    function vh() {
      Et !== null && typeof Et.markComponentLayoutEffectUnmountStopped == "function" && Et.markComponentLayoutEffectUnmountStopped();
    }
    function Vm(a, l, m) {
      Et !== null && typeof Et.markComponentErrored == "function" && Et.markComponentErrored(a, l, m);
    }
    function Gu(a, l, m) {
      Et !== null && typeof Et.markComponentSuspended == "function" && Et.markComponentSuspended(a, l, m);
    }
    function _h(a) {
      Et !== null && typeof Et.markLayoutEffectsStarted == "function" && Et.markLayoutEffectsStarted(a);
    }
    function Wm() {
      Et !== null && typeof Et.markLayoutEffectsStopped == "function" && Et.markLayoutEffectsStopped();
    }
    function al(a) {
      Et !== null && typeof Et.markPassiveEffectsStarted == "function" && Et.markPassiveEffectsStarted(a);
    }
    function yh() {
      Et !== null && typeof Et.markPassiveEffectsStopped == "function" && Et.markPassiveEffectsStopped();
    }
    function Eo(a) {
      Et !== null && typeof Et.markRenderStarted == "function" && Et.markRenderStarted(a);
    }
    function xh() {
      Et !== null && typeof Et.markRenderYielded == "function" && Et.markRenderYielded();
    }
    function ku() {
      Et !== null && typeof Et.markRenderStopped == "function" && Et.markRenderStopped();
    }
    function Xm(a) {
      Et !== null && typeof Et.markRenderScheduled == "function" && Et.markRenderScheduled(a);
    }
    function Sh(a, l) {
      Et !== null && typeof Et.markForceUpdateScheduled == "function" && Et.markForceUpdateScheduled(a, l);
    }
    function Vu(a, l) {
      Et !== null && typeof Et.markStateUpdateScheduled == "function" && Et.markStateUpdateScheduled(a, l);
    }
    function Hr(a, l) {
      return a === l && (a !== 0 || 1 / a === 1 / l) || a !== a && l !== l;
    }
    var Ji = typeof Object.is == "function" ? Object.is : Hr, Ui = null, Wu = !1, Rr = !1;
    function Jm(a) {
      Ui === null ? Ui = [a] : Ui.push(a);
    }
    function Ym(a) {
      Wu = !0, Jm(a);
    }
    function Ah() {
      Wu && Ja();
    }
    function Ja() {
      if (!Rr && Ui !== null) {
        Rr = !0;
        var a = 0, l = Ks();
        try {
          var m = !0, _ = Ui;
          for (Vi(as); a < _.length; a++) {
            var A = _[a];
            do
              A = A(m);
            while (A !== null);
          }
          Ui = null, Wu = !1;
        } catch (R) {
          throw Ui !== null && (Ui = Ui.slice(a + 1)), rf(sf, Ja), R;
        } finally {
          Vi(l), Rr = !1;
        }
      }
      return null;
    }
    function To(a) {
      var l = a.current.memoizedState;
      return l.isDehydrated;
    }
    var C_ = r.ReactCurrentBatchConfig, w_ = null;
    function Km() {
      return C_.transition;
    }
    function Ya(a, l) {
      if (Ji(a, l))
        return !0;
      if (typeof a != "object" || a === null || typeof l != "object" || l === null)
        return !1;
      var m = Object.keys(a), _ = Object.keys(l);
      if (m.length !== _.length)
        return !1;
      for (var A = 0; A < m.length; A++) {
        var R = m[A];
        if (!Ru.call(l, R) || !Ji(a[R], l[R]))
          return !1;
      }
      return !0;
    }
    function R_(a) {
      switch (a._debugOwner && a._debugOwner.type, a._debugSource, a.tag) {
        case I:
          return Xs(a.type);
        case ue:
          return Xs("Lazy");
        case J:
          return Xs("Suspense");
        case ye:
          return Xs("SuspenseList");
        case N:
        case O:
        case H:
          return Gd(a.type);
        case re:
          return Gd(a.type.render);
        case U:
          return p_(a.type);
        default:
          return "";
      }
    }
    function qm(a) {
      try {
        var l = "", m = a;
        do
          l += R_(m), m = m.return;
        while (m);
        return l;
      } catch (_) {
        return `
Error generating stack: ` + _.message + `
` + _.stack;
      }
    }
    var Mh = r.ReactDebugCurrentFrame, zr = null, uf = !1;
    function OS() {
      {
        if (zr === null)
          return null;
        var a = zr._debugOwner;
        if (a !== null && typeof a < "u")
          return Fe(a);
      }
      return null;
    }
    function B_() {
      return zr === null ? "" : qm(zr);
    }
    function hr() {
      Mh.getCurrentStack = null, zr = null, uf = !1;
    }
    function oi(a) {
      Mh.getCurrentStack = B_, zr = a, uf = !1;
    }
    function Ka(a) {
      uf = a;
    }
    var pr = {
      recordUnsafeLifecycleWarnings: function(a, l) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(a, l) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var D_ = function(a) {
        for (var l = null, m = a; m !== null; )
          m.mode & _i && (l = m), m = m.return;
        return l;
      }, Fi = function(a) {
        var l = [];
        return a.forEach(function(m) {
          l.push(m);
        }), l.sort().join(", ");
      }, cf = [], Xu = [], ff = [], df = [], Ju = [], Yu = [], Gl = /* @__PURE__ */ new Set();
      pr.recordUnsafeLifecycleWarnings = function(a, l) {
        Gl.has(a.type) || (typeof l.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        l.componentWillMount.__suppressDeprecationWarning !== !0 && cf.push(a), a.mode & _i && typeof l.UNSAFE_componentWillMount == "function" && Xu.push(a), typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && ff.push(a), a.mode & _i && typeof l.UNSAFE_componentWillReceiveProps == "function" && df.push(a), typeof l.componentWillUpdate == "function" && l.componentWillUpdate.__suppressDeprecationWarning !== !0 && Ju.push(a), a.mode & _i && typeof l.UNSAFE_componentWillUpdate == "function" && Yu.push(a));
      }, pr.flushPendingUnsafeLifecycleWarnings = function() {
        var a = /* @__PURE__ */ new Set();
        cf.length > 0 && (cf.forEach(function(Be) {
          a.add(Fe(Be) || "Component"), Gl.add(Be.type);
        }), cf = []);
        var l = /* @__PURE__ */ new Set();
        Xu.length > 0 && (Xu.forEach(function(Be) {
          l.add(Fe(Be) || "Component"), Gl.add(Be.type);
        }), Xu = []);
        var m = /* @__PURE__ */ new Set();
        ff.length > 0 && (ff.forEach(function(Be) {
          m.add(Fe(Be) || "Component"), Gl.add(Be.type);
        }), ff = []);
        var _ = /* @__PURE__ */ new Set();
        df.length > 0 && (df.forEach(function(Be) {
          _.add(Fe(Be) || "Component"), Gl.add(Be.type);
        }), df = []);
        var A = /* @__PURE__ */ new Set();
        Ju.length > 0 && (Ju.forEach(function(Be) {
          A.add(Fe(Be) || "Component"), Gl.add(Be.type);
        }), Ju = []);
        var R = /* @__PURE__ */ new Set();
        if (Yu.length > 0 && (Yu.forEach(function(Be) {
          R.add(Fe(Be) || "Component"), Gl.add(Be.type);
        }), Yu = []), l.size > 0) {
          var P = Fi(l);
          d(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, P);
        }
        if (_.size > 0) {
          var z = Fi(_);
          d(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, z);
        }
        if (R.size > 0) {
          var W = Fi(R);
          d(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, W);
        }
        if (a.size > 0) {
          var $ = Fi(a);
          c(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, $);
        }
        if (m.size > 0) {
          var oe = Fi(m);
          c(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, oe);
        }
        if (A.size > 0) {
          var xe = Fi(A);
          c(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, xe);
        }
      };
      var Gr = /* @__PURE__ */ new Map(), Eh = /* @__PURE__ */ new Set();
      pr.recordLegacyContextWarning = function(a, l) {
        var m = D_(a);
        if (m === null) {
          d("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!Eh.has(a.type)) {
          var _ = Gr.get(m);
          (a.type.contextTypes != null || a.type.childContextTypes != null || l !== null && typeof l.getChildContext == "function") && (_ === void 0 && (_ = [], Gr.set(m, _)), _.push(a));
        }
      }, pr.flushLegacyContextWarning = function() {
        Gr.forEach(function(a, l) {
          if (a.length !== 0) {
            var m = a[0], _ = /* @__PURE__ */ new Set();
            a.forEach(function(R) {
              _.add(Fe(R) || "Component"), Eh.add(R.type);
            });
            var A = Fi(_);
            try {
              oi(m), d(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, A);
            } finally {
              hr();
            }
          }
        });
      }, pr.discardPendingWarnings = function() {
        cf = [], Xu = [], ff = [], df = [], Ju = [], Yu = [], Gr = /* @__PURE__ */ new Map();
      };
    }
    function L_(a) {
      {
        var l = typeof Symbol == "function" && Symbol.toStringTag, m = l && a[Symbol.toStringTag] || a.constructor.name || "Object";
        return m;
      }
    }
    function bo(a) {
      try {
        return Ku(a), !1;
      } catch {
        return !0;
      }
    }
    function Ku(a) {
      return "" + a;
    }
    function kl(a) {
      if (bo(a))
        return d("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", L_(a)), Ku(a);
    }
    function Th(a, l) {
      if (bo(a))
        return d("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", l, L_(a)), Ku(a);
    }
    function Cs(a, l) {
      if (a && a.defaultProps) {
        var m = g({}, l), _ = a.defaultProps;
        for (var A in _)
          m[A] === void 0 && (m[A] = _[A]);
        return m;
      }
      return l;
    }
    var qu = Va(null), hf;
    hf = {};
    var pf = null, Vl = null, bh = null, mf = !1;
    function ju() {
      pf = null, Vl = null, bh = null, mf = !1;
    }
    function P_() {
      mf = !0;
    }
    function I_() {
      mf = !1;
    }
    function f(a, l, m) {
      wd ? (Di(qu, l._currentValue, a), l._currentValue = m, l._currentRenderer !== void 0 && l._currentRenderer !== null && l._currentRenderer !== hf && d("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer = hf) : (Di(qu, l._currentValue2, a), l._currentValue2 = m, l._currentRenderer2 !== void 0 && l._currentRenderer2 !== null && l._currentRenderer2 !== hf && d("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), l._currentRenderer2 = hf);
    }
    function h(a, l) {
      var m = qu.current;
      Sn(qu, l), wd ? a._currentValue = m : a._currentValue2 = m;
    }
    function x(a, l, m) {
      for (var _ = a; _ !== null; ) {
        var A = _.alternate;
        if (Hl(_.childLanes, l) ? A !== null && !Hl(A.childLanes, l) && (A.childLanes = cn(A.childLanes, l)) : (_.childLanes = cn(_.childLanes, l), A !== null && (A.childLanes = cn(A.childLanes, l))), _ === m)
          break;
        _ = _.return;
      }
      _ !== m && d("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function b(a, l, m) {
      B(a, l, m);
    }
    function B(a, l, m) {
      var _ = a.child;
      for (_ !== null && (_.return = a); _ !== null; ) {
        var A = void 0, R = _.dependencies;
        if (R !== null) {
          A = _.child;
          for (var P = R.firstContext; P !== null; ) {
            if (P.context === l) {
              if (_.tag === U) {
                var z = Ol(m), W = Ce(Qn, z);
                W.tag = jt;
                var $ = _.updateQueue;
                if ($ !== null) {
                  var oe = $.shared, xe = oe.pending;
                  xe === null ? W.next = W : (W.next = xe.next, xe.next = W), oe.pending = W;
                }
              }
              _.lanes = cn(_.lanes, m);
              var Be = _.alternate;
              Be !== null && (Be.lanes = cn(Be.lanes, m)), x(_.return, m, a), R.lanes = cn(R.lanes, m);
              break;
            }
            P = P.next;
          }
        } else if (_.tag === ie)
          A = _.type === a.type ? null : _.child;
        else if (_.tag === me) {
          var Ne = _.return;
          if (Ne === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          Ne.lanes = cn(Ne.lanes, m);
          var $e = Ne.alternate;
          $e !== null && ($e.lanes = cn($e.lanes, m)), x(Ne, m, a), A = _.sibling;
        } else
          A = _.child;
        if (A !== null)
          A.return = _;
        else
          for (A = _; A !== null; ) {
            if (A === a) {
              A = null;
              break;
            }
            var ut = A.sibling;
            if (ut !== null) {
              ut.return = A.return, A = ut;
              break;
            }
            A = A.return;
          }
        _ = A;
      }
    }
    function F(a, l) {
      pf = a, Vl = null, bh = null;
      var m = a.dependencies;
      if (m !== null) {
        var _ = m.firstContext;
        _ !== null && (wr(m.lanes, l) && vy(), m.firstContext = null);
      }
    }
    function K(a) {
      mf && d("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var l = wd ? a._currentValue : a._currentValue2;
      if (bh !== a) {
        var m = {
          context: a,
          memoizedValue: l,
          next: null
        };
        if (Vl === null) {
          if (pf === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Vl = m, pf.dependencies = {
            lanes: Ze,
            firstContext: m
          };
        } else
          Vl = Vl.next = m;
      }
      return l;
    }
    var de = null;
    function Le(a) {
      de === null ? de = [a] : de.push(a);
    }
    function ft() {
      if (de !== null) {
        for (var a = 0; a < de.length; a++) {
          var l = de[a], m = l.interleaved;
          if (m !== null) {
            l.interleaved = null;
            var _ = m.next, A = l.pending;
            if (A !== null) {
              var R = A.next;
              A.next = _, m.next = R;
            }
            l.pending = m;
          }
        }
        de = null;
      }
    }
    var Nt = 0, ln = 1, jt = 2, Xn = 3, Jt = !1, nr, kr;
    nr = !1, kr = null;
    function Me(a) {
      var l = {
        baseState: a.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: Ze
        },
        effects: null
      };
      a.updateQueue = l;
    }
    function ve(a, l) {
      var m = l.updateQueue, _ = a.updateQueue;
      if (m === _) {
        var A = {
          baseState: _.baseState,
          firstBaseUpdate: _.firstBaseUpdate,
          lastBaseUpdate: _.lastBaseUpdate,
          shared: _.shared,
          effects: _.effects
        };
        l.updateQueue = A;
      }
    }
    function Ce(a, l) {
      var m = {
        eventTime: a,
        lane: l,
        tag: Nt,
        payload: null,
        callback: null,
        next: null
      };
      return m;
    }
    function _t(a, l, m) {
      var _ = a.updateQueue;
      if (_ !== null) {
        var A = _.shared;
        if (Hw(a)) {
          var R = A.interleaved;
          R === null ? (l.next = l, Le(A)) : (l.next = R.next, R.next = l), A.interleaved = l;
        } else {
          var P = A.pending;
          P === null ? l.next = l : (l.next = P.next, P.next = l), A.pending = l;
        }
        kr === A && !nr && (d("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), nr = !0);
      }
    }
    function Vt(a, l, m) {
      var _ = l.updateQueue;
      if (_ !== null) {
        var A = _.shared;
        if (Um(m)) {
          var R = A.lanes;
          R = Xa(R, a.pendingLanes);
          var P = cn(R, m);
          A.lanes = P, nf(a, P);
        }
      }
    }
    function dn(a, l) {
      var m = a.updateQueue, _ = a.alternate;
      if (_ !== null) {
        var A = _.updateQueue;
        if (m === A) {
          var R = null, P = null, z = m.firstBaseUpdate;
          if (z !== null) {
            var W = z;
            do {
              var $ = {
                eventTime: W.eventTime,
                lane: W.lane,
                tag: W.tag,
                payload: W.payload,
                callback: W.callback,
                next: null
              };
              P === null ? R = P = $ : (P.next = $, P = $), W = W.next;
            } while (W !== null);
            P === null ? R = P = l : (P.next = l, P = l);
          } else
            R = P = l;
          m = {
            baseState: A.baseState,
            firstBaseUpdate: R,
            lastBaseUpdate: P,
            shared: A.shared,
            effects: A.effects
          }, a.updateQueue = m;
          return;
        }
      }
      var oe = m.lastBaseUpdate;
      oe === null ? m.firstBaseUpdate = l : oe.next = l, m.lastBaseUpdate = l;
    }
    function fn(a, l, m, _, A, R) {
      switch (m.tag) {
        case ln: {
          var P = m.payload;
          if (typeof P == "function") {
            P_();
            var z = P.call(R, _, A);
            {
              if (a.mode & _i) {
                An(!0);
                try {
                  P.call(R, _, A);
                } finally {
                  An(!1);
                }
              }
              I_();
            }
            return z;
          }
          return P;
        }
        case Xn:
          a.flags = a.flags & ~Yt | ot;
        // Intentional fallthrough
        case Nt: {
          var W = m.payload, $;
          if (typeof W == "function") {
            P_(), $ = W.call(R, _, A);
            {
              if (a.mode & _i) {
                An(!0);
                try {
                  W.call(R, _, A);
                } finally {
                  An(!1);
                }
              }
              I_();
            }
          } else
            $ = W;
          return $ == null ? _ : g({}, _, $);
        }
        case jt:
          return Jt = !0, _;
      }
      return _;
    }
    function Bn(a, l, m, _) {
      var A = a.updateQueue;
      Jt = !1, kr = A.shared;
      var R = A.firstBaseUpdate, P = A.lastBaseUpdate, z = A.shared.pending;
      if (z !== null) {
        A.shared.pending = null;
        var W = z, $ = W.next;
        W.next = null, P === null ? R = $ : P.next = $, P = W;
        var oe = a.alternate;
        if (oe !== null) {
          var xe = oe.updateQueue, Be = xe.lastBaseUpdate;
          Be !== P && (Be === null ? xe.firstBaseUpdate = $ : Be.next = $, xe.lastBaseUpdate = W);
        }
      }
      if (R !== null) {
        var Ne = A.baseState, $e = Ze, ut = null, Zt = null, hn = null, nn = R;
        do {
          var hi = nn.lane, pi = nn.eventTime;
          if (Hl(_, hi)) {
            if (hn !== null) {
              var Ge = {
                eventTime: pi,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: yi,
                tag: nn.tag,
                payload: nn.payload,
                callback: nn.callback,
                next: null
              };
              hn = hn.next = Ge;
            }
            Ne = fn(a, A, nn, Ne, l, m);
            var Ae = nn.callback;
            if (Ae !== null && // If the update was already committed, we should not queue its
            // callback again.
            nn.lane !== yi) {
              a.flags |= Wt;
              var dt = A.effects;
              dt === null ? A.effects = [nn] : dt.push(nn);
            }
          } else {
            var Te = {
              eventTime: pi,
              lane: hi,
              tag: nn.tag,
              payload: nn.payload,
              callback: nn.callback,
              next: null
            };
            hn === null ? (Zt = hn = Te, ut = Ne) : hn = hn.next = Te, $e = cn($e, hi);
          }
          if (nn = nn.next, nn === null) {
            if (z = A.shared.pending, z === null)
              break;
            var qt = z, Ut = qt.next;
            qt.next = null, nn = Ut, A.lastBaseUpdate = qt, A.shared.pending = null;
          }
        } while (!0);
        hn === null && (ut = Ne), A.baseState = ut, A.firstBaseUpdate = Zt, A.lastBaseUpdate = hn;
        var Dn = A.shared.interleaved;
        if (Dn !== null) {
          var Jn = Dn;
          do
            $e = cn($e, Jn.lane), Jn = Jn.next;
          while (Jn !== Dn);
        } else R === null && (A.shared.lanes = Ze);
        zy($e), a.lanes = $e, a.memoizedState = Ne;
      }
      kr = null;
    }
    function ir(a, l) {
      if (typeof a != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + a));
      a.call(l);
    }
    function In() {
      Jt = !1;
    }
    function ma() {
      return Jt;
    }
    function U_(a, l, m) {
      var _ = l.effects;
      if (l.effects = null, _ !== null)
        for (var A = 0; A < _.length; A++) {
          var R = _[A], P = R.callback;
          P !== null && (R.callback = null, ir(P, m));
        }
    }
    var HS = {}, GC = new n.Component().refs, zS, GS, kS, VS, WS, kC, F_, XS, JS, YS;
    {
      zS = /* @__PURE__ */ new Set(), GS = /* @__PURE__ */ new Set(), kS = /* @__PURE__ */ new Set(), VS = /* @__PURE__ */ new Set(), XS = /* @__PURE__ */ new Set(), WS = /* @__PURE__ */ new Set(), JS = /* @__PURE__ */ new Set(), YS = /* @__PURE__ */ new Set();
      var VC = /* @__PURE__ */ new Set();
      F_ = function(a, l) {
        if (!(a === null || typeof a == "function")) {
          var m = l + "_" + a;
          VC.has(m) || (VC.add(m), d("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", l, a));
        }
      }, kC = function(a, l) {
        if (l === void 0) {
          var m = Ie(a) || "Component";
          WS.has(m) || (WS.add(m), d("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", m));
        }
      }, Object.defineProperty(HS, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(HS);
    }
    function KS(a, l, m, _) {
      var A = a.memoizedState, R = m(_, A);
      {
        if (a.mode & _i) {
          An(!0);
          try {
            R = m(_, A);
          } finally {
            An(!1);
          }
        }
        kC(l, R);
      }
      var P = R == null ? A : g({}, A, R);
      if (a.memoizedState = P, a.lanes === Ze) {
        var z = a.updateQueue;
        z.baseState = P;
      }
    }
    var qS = {
      isMounted: It,
      enqueueSetState: function(a, l, m) {
        var _ = v(a), A = Rs(), R = rc(_), P = Ce(A, R);
        P.payload = l, m != null && (F_(m, "setState"), P.callback = m), _t(_, P);
        var z = _r(_, R, A);
        z !== null && Vt(z, _, R), Vu(_, R);
      },
      enqueueReplaceState: function(a, l, m) {
        var _ = v(a), A = Rs(), R = rc(_), P = Ce(A, R);
        P.tag = ln, P.payload = l, m != null && (F_(m, "replaceState"), P.callback = m), _t(_, P);
        var z = _r(_, R, A);
        z !== null && Vt(z, _, R), Vu(_, R);
      },
      enqueueForceUpdate: function(a, l) {
        var m = v(a), _ = Rs(), A = rc(m), R = Ce(_, A);
        R.tag = jt, l != null && (F_(l, "forceUpdate"), R.callback = l), _t(m, R);
        var P = _r(m, A, _);
        P !== null && Vt(P, m, A), Sh(m, A);
      }
    };
    function WC(a, l, m, _, A, R, P) {
      var z = a.stateNode;
      if (typeof z.shouldComponentUpdate == "function") {
        var W = z.shouldComponentUpdate(_, R, P);
        {
          if (a.mode & _i) {
            An(!0);
            try {
              W = z.shouldComponentUpdate(_, R, P);
            } finally {
              An(!1);
            }
          }
          W === void 0 && d("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Ie(l) || "Component");
        }
        return W;
      }
      return l.prototype && l.prototype.isPureReactComponent ? !Ya(m, _) || !Ya(A, R) : !0;
    }
    function bU(a, l, m) {
      var _ = a.stateNode;
      {
        var A = Ie(l) || "Component", R = _.render;
        R || (l.prototype && typeof l.prototype.render == "function" ? d("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", A) : d("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", A)), _.getInitialState && !_.getInitialState.isReactClassApproved && !_.state && d("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", A), _.getDefaultProps && !_.getDefaultProps.isReactClassApproved && d("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", A), _.propTypes && d("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", A), _.contextType && d("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", A), _.contextTypes && d("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", A), l.contextType && l.contextTypes && !JS.has(l) && (JS.add(l), d("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", A)), typeof _.componentShouldUpdate == "function" && d("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", A), l.prototype && l.prototype.isPureReactComponent && typeof _.shouldComponentUpdate < "u" && d("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Ie(l) || "A pure component"), typeof _.componentDidUnmount == "function" && d("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", A), typeof _.componentDidReceiveProps == "function" && d("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", A), typeof _.componentWillRecieveProps == "function" && d("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", A), typeof _.UNSAFE_componentWillRecieveProps == "function" && d("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", A);
        var P = _.props !== m;
        _.props !== void 0 && P && d("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", A, A), _.defaultProps && d("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", A, A), typeof _.getSnapshotBeforeUpdate == "function" && typeof _.componentDidUpdate != "function" && !kS.has(l) && (kS.add(l), d("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Ie(l))), typeof _.getDerivedStateFromProps == "function" && d("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", A), typeof _.getDerivedStateFromError == "function" && d("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", A), typeof l.getSnapshotBeforeUpdate == "function" && d("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", A);
        var z = _.state;
        z && (typeof z != "object" || ht(z)) && d("%s.state: must be set to an object or null", A), typeof _.getChildContext == "function" && typeof l.childContextTypes != "object" && d("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", A);
      }
    }
    function XC(a, l) {
      l.updater = qS, a.stateNode = l, y(l, a), l._reactInternalInstance = HS;
    }
    function JC(a, l, m) {
      var _ = !1, A = Ur, R = Ur, P = l.contextType;
      if ("contextType" in l) {
        var z = (
          // Allow null for conditional declaration
          P === null || P !== void 0 && P.$$typeof === be && P._context === void 0
        );
        if (!z && !YS.has(l)) {
          YS.add(l);
          var W = "";
          P === void 0 ? W = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof P != "object" ? W = " However, it is set to a " + typeof P + "." : P.$$typeof === He ? W = " Did you accidentally pass the Context.Provider instead?" : P._context !== void 0 ? W = " Did you accidentally pass the Context.Consumer instead?" : W = " However, it is set to an object with keys {" + Object.keys(P).join(", ") + "}.", d("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Ie(l) || "Component", W);
        }
      }
      if (typeof P == "object" && P !== null)
        R = K(P);
      else {
        A = jn(a, l, !0);
        var $ = l.contextTypes;
        _ = $ != null, R = _ ? di(a, A) : Ur;
      }
      var oe = new l(m, R);
      if (a.mode & _i) {
        An(!0);
        try {
          oe = new l(m, R);
        } finally {
          An(!1);
        }
      }
      var xe = a.memoizedState = oe.state !== null && oe.state !== void 0 ? oe.state : null;
      XC(a, oe);
      {
        if (typeof l.getDerivedStateFromProps == "function" && xe === null) {
          var Be = Ie(l) || "Component";
          GS.has(Be) || (GS.add(Be), d("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", Be, oe.state === null ? "null" : "undefined", Be));
        }
        if (typeof l.getDerivedStateFromProps == "function" || typeof oe.getSnapshotBeforeUpdate == "function") {
          var Ne = null, $e = null, ut = null;
          if (typeof oe.componentWillMount == "function" && oe.componentWillMount.__suppressDeprecationWarning !== !0 ? Ne = "componentWillMount" : typeof oe.UNSAFE_componentWillMount == "function" && (Ne = "UNSAFE_componentWillMount"), typeof oe.componentWillReceiveProps == "function" && oe.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? $e = "componentWillReceiveProps" : typeof oe.UNSAFE_componentWillReceiveProps == "function" && ($e = "UNSAFE_componentWillReceiveProps"), typeof oe.componentWillUpdate == "function" && oe.componentWillUpdate.__suppressDeprecationWarning !== !0 ? ut = "componentWillUpdate" : typeof oe.UNSAFE_componentWillUpdate == "function" && (ut = "UNSAFE_componentWillUpdate"), Ne !== null || $e !== null || ut !== null) {
            var Zt = Ie(l) || "Component", hn = typeof l.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            VS.has(Zt) || (VS.add(Zt), d(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, Zt, hn, Ne !== null ? `
  ` + Ne : "", $e !== null ? `
  ` + $e : "", ut !== null ? `
  ` + ut : ""));
          }
        }
      }
      return _ && cr(a, A, R), oe;
    }
    function CU(a, l) {
      var m = l.state;
      typeof l.componentWillMount == "function" && l.componentWillMount(), typeof l.UNSAFE_componentWillMount == "function" && l.UNSAFE_componentWillMount(), m !== l.state && (d("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Fe(a) || "Component"), qS.enqueueReplaceState(l, l.state, null));
    }
    function YC(a, l, m, _) {
      var A = l.state;
      if (typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(m, _), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(m, _), l.state !== A) {
        {
          var R = Fe(a) || "Component";
          zS.has(R) || (zS.add(R), d("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", R));
        }
        qS.enqueueReplaceState(l, l.state, null);
      }
    }
    function jS(a, l, m, _) {
      bU(a, l, m);
      var A = a.stateNode;
      A.props = m, A.state = a.memoizedState, A.refs = GC, Me(a);
      var R = l.contextType;
      if (typeof R == "object" && R !== null)
        A.context = K(R);
      else {
        var P = jn(a, l, !0);
        A.context = di(a, P);
      }
      {
        if (A.state === m) {
          var z = Ie(l) || "Component";
          XS.has(z) || (XS.add(z), d("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", z));
        }
        a.mode & _i && pr.recordLegacyContextWarning(a, A), pr.recordUnsafeLifecycleWarnings(a, A);
      }
      A.state = a.memoizedState;
      var W = l.getDerivedStateFromProps;
      if (typeof W == "function" && (KS(a, l, W, m), A.state = a.memoizedState), typeof l.getDerivedStateFromProps != "function" && typeof A.getSnapshotBeforeUpdate != "function" && (typeof A.UNSAFE_componentWillMount == "function" || typeof A.componentWillMount == "function") && (CU(a, A), Bn(a, m, A, _), A.state = a.memoizedState), typeof A.componentDidMount == "function") {
        var $ = Pe;
        $ |= gt, (a.mode & fa) !== rn && ($ |= tn), a.flags |= $;
      }
    }
    function wU(a, l, m, _) {
      var A = a.stateNode, R = a.memoizedProps;
      A.props = R;
      var P = A.context, z = l.contextType, W = Ur;
      if (typeof z == "object" && z !== null)
        W = K(z);
      else {
        var $ = jn(a, l, !0);
        W = di(a, $);
      }
      var oe = l.getDerivedStateFromProps, xe = typeof oe == "function" || typeof A.getSnapshotBeforeUpdate == "function";
      !xe && (typeof A.UNSAFE_componentWillReceiveProps == "function" || typeof A.componentWillReceiveProps == "function") && (R !== m || P !== W) && YC(a, A, m, W), In();
      var Be = a.memoizedState, Ne = A.state = Be;
      if (Bn(a, m, A, _), Ne = a.memoizedState, R === m && Be === Ne && !Il() && !ma()) {
        if (typeof A.componentDidMount == "function") {
          var $e = Pe;
          $e |= gt, (a.mode & fa) !== rn && ($e |= tn), a.flags |= $e;
        }
        return !1;
      }
      typeof oe == "function" && (KS(a, l, oe, m), Ne = a.memoizedState);
      var ut = ma() || WC(a, l, R, m, Be, Ne, W);
      if (ut) {
        if (!xe && (typeof A.UNSAFE_componentWillMount == "function" || typeof A.componentWillMount == "function") && (typeof A.componentWillMount == "function" && A.componentWillMount(), typeof A.UNSAFE_componentWillMount == "function" && A.UNSAFE_componentWillMount()), typeof A.componentDidMount == "function") {
          var Zt = Pe;
          Zt |= gt, (a.mode & fa) !== rn && (Zt |= tn), a.flags |= Zt;
        }
      } else {
        if (typeof A.componentDidMount == "function") {
          var hn = Pe;
          hn |= gt, (a.mode & fa) !== rn && (hn |= tn), a.flags |= hn;
        }
        a.memoizedProps = m, a.memoizedState = Ne;
      }
      return A.props = m, A.state = Ne, A.context = W, ut;
    }
    function RU(a, l, m, _, A) {
      var R = l.stateNode;
      ve(a, l);
      var P = l.memoizedProps, z = l.type === l.elementType ? P : Cs(l.type, P);
      R.props = z;
      var W = l.pendingProps, $ = R.context, oe = m.contextType, xe = Ur;
      if (typeof oe == "object" && oe !== null)
        xe = K(oe);
      else {
        var Be = jn(l, m, !0);
        xe = di(l, Be);
      }
      var Ne = m.getDerivedStateFromProps, $e = typeof Ne == "function" || typeof R.getSnapshotBeforeUpdate == "function";
      !$e && (typeof R.UNSAFE_componentWillReceiveProps == "function" || typeof R.componentWillReceiveProps == "function") && (P !== W || $ !== xe) && YC(l, R, _, xe), In();
      var ut = l.memoizedState, Zt = R.state = ut;
      if (Bn(l, _, R, A), Zt = l.memoizedState, P === W && ut === Zt && !Il() && !ma() && !T)
        return typeof R.componentDidUpdate == "function" && (P !== a.memoizedProps || ut !== a.memoizedState) && (l.flags |= Pe), typeof R.getSnapshotBeforeUpdate == "function" && (P !== a.memoizedProps || ut !== a.memoizedState) && (l.flags |= wt), !1;
      typeof Ne == "function" && (KS(l, m, Ne, _), Zt = l.memoizedState);
      var hn = ma() || WC(l, m, z, _, ut, Zt, xe) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      T;
      return hn ? (!$e && (typeof R.UNSAFE_componentWillUpdate == "function" || typeof R.componentWillUpdate == "function") && (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(_, Zt, xe), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(_, Zt, xe)), typeof R.componentDidUpdate == "function" && (l.flags |= Pe), typeof R.getSnapshotBeforeUpdate == "function" && (l.flags |= wt)) : (typeof R.componentDidUpdate == "function" && (P !== a.memoizedProps || ut !== a.memoizedState) && (l.flags |= Pe), typeof R.getSnapshotBeforeUpdate == "function" && (P !== a.memoizedProps || ut !== a.memoizedState) && (l.flags |= wt), l.memoizedProps = _, l.memoizedState = Zt), R.props = _, R.state = Zt, R.context = xe, hn;
    }
    var Ch = [], wh = 0, N_ = null, O_ = 0, qa = [], ja = 0, gf = null, Wl = 1, Xl = "";
    function BU(a) {
      return _f(), (a.flags & ze) !== Ke;
    }
    function DU(a) {
      return _f(), O_;
    }
    function LU() {
      var a = Xl, l = Wl, m = l & ~PU(l);
      return m.toString(32) + a;
    }
    function vf(a, l) {
      _f(), Ch[wh++] = O_, Ch[wh++] = N_, N_ = a, O_ = l;
    }
    function KC(a, l, m) {
      _f(), qa[ja++] = Wl, qa[ja++] = Xl, qa[ja++] = gf, gf = a;
      var _ = Wl, A = Xl, R = H_(_) - 1, P = _ & ~(1 << R), z = m + 1, W = H_(l) + R;
      if (W > 30) {
        var $ = R - R % 5, oe = (1 << $) - 1, xe = (P & oe).toString(32), Be = P >> $, Ne = R - $, $e = H_(l) + Ne, ut = z << Ne, Zt = ut | Be, hn = xe + A;
        Wl = 1 << $e | Zt, Xl = hn;
      } else {
        var nn = z << R, hi = nn | P, pi = A;
        Wl = 1 << W | hi, Xl = pi;
      }
    }
    function QS(a) {
      _f();
      var l = a.return;
      if (l !== null) {
        var m = 1, _ = 0;
        vf(a, m), KC(a, m, _);
      }
    }
    function H_(a) {
      return 32 - Tm(a);
    }
    function PU(a) {
      return 1 << H_(a) - 1;
    }
    function ZS(a) {
      for (; a === N_; )
        N_ = Ch[--wh], Ch[wh] = null, O_ = Ch[--wh], Ch[wh] = null;
      for (; a === gf; )
        gf = qa[--ja], qa[ja] = null, Xl = qa[--ja], qa[ja] = null, Wl = qa[--ja], qa[ja] = null;
    }
    function IU() {
      return _f(), gf !== null ? {
        id: Wl,
        overflow: Xl
      } : null;
    }
    function UU(a, l) {
      _f(), qa[ja++] = Wl, qa[ja++] = Xl, qa[ja++] = gf, Wl = l.id, Xl = l.overflow, gf = a;
    }
    function _f() {
      os() || d("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Vr = null, Qa = null, Co = !1, yf = !1, Qu = null;
    function FU() {
      Co && d("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function NU() {
      yf = !0;
    }
    function OU(a) {
      if (!br)
        return !1;
      var l = a.stateNode.containerInfo;
      return Qa = Ko(l), Vr = a, Co = !0, Qu = null, yf = !1, !0;
    }
    function HU(a, l, m) {
      return br ? (Qa = _m(l), Vr = a, Co = !0, Qu = null, yf = !1, m !== null && UU(a, m), !0) : !1;
    }
    function qC(a, l) {
      switch (a.tag) {
        case V:
          f_(a.stateNode.containerInfo, l);
          break;
        case I:
          Sm(a.type, a.memoizedProps, a.stateNode, l);
          break;
        case J:
          var m = a.memoizedState;
          m.dehydrated !== null && d_(m.dehydrated, l);
          break;
      }
    }
    function jC(a, l) {
      qC(a, l);
      var m = zO();
      m.stateNode = l, m.return = a;
      var _ = a.deletions;
      _ === null ? (a.deletions = [m], a.flags |= et) : _.push(m);
    }
    function $S(a, l) {
      {
        if (yf)
          return;
        switch (a.tag) {
          case V: {
            var m = a.stateNode.containerInfo;
            switch (l.tag) {
              case I:
                var _ = l.type, A = l.pendingProps;
                Au(m, _, A);
                break;
              case Y:
                var R = l.pendingProps;
                Mu(m, R);
                break;
              case J:
                Fd(m);
                break;
            }
            break;
          }
          case I: {
            var P = a.type, z = a.memoizedProps, W = a.stateNode;
            switch (l.tag) {
              case I:
                var $ = l.type, oe = l.pendingProps;
                Ll(P, z, W, $, oe);
                break;
              case Y:
                var xe = l.pendingProps;
                go(P, z, W, xe);
                break;
              case J:
                vo(P, z, W);
                break;
            }
            break;
          }
          case J: {
            var Be = a.memoizedState, Ne = Be.dehydrated;
            if (Ne !== null) switch (l.tag) {
              case I:
                var $e = l.type, ut = l.pendingProps;
                Nd(Ne, $e, ut);
                break;
              case Y:
                var Zt = l.pendingProps;
                ks(Ne, Zt);
                break;
              case J:
                Vs(Ne);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function QC(a, l) {
      l.flags = l.flags & ~bt | We, $S(a, l);
    }
    function ZC(a, l) {
      switch (a.tag) {
        case I: {
          var m = a.type, _ = a.pendingProps, A = gm(l, m, _);
          return A !== null ? (a.stateNode = A, Vr = a, Qa = Ga(A), !0) : !1;
        }
        case Y: {
          var R = a.pendingProps, P = vm(l, R);
          return P !== null ? (a.stateNode = P, Vr = a, Qa = null, !0) : !1;
        }
        case J: {
          {
            var z = a_(l);
            if (z !== null) {
              var W = {
                dehydrated: z,
                treeContext: IU(),
                retryLane: Cr
              };
              a.memoizedState = W;
              var $ = GO(z);
              return $.return = a, a.child = $, Vr = a, Qa = null, !0;
            }
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function eA(a) {
      return (a.mode & zn) !== rn && (a.flags & ot) === Ke;
    }
    function tA(a) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function nA(a) {
      if (Co) {
        var l = Qa;
        if (!l) {
          eA(a) && ($S(Vr, a), tA()), QC(Vr, a), Co = !1, Vr = a;
          return;
        }
        var m = l;
        if (!ZC(a, l)) {
          eA(a) && ($S(Vr, a), tA()), l = Ir(m);
          var _ = Vr;
          if (!l || !ZC(a, l)) {
            QC(Vr, a), Co = !1, Vr = a;
            return;
          }
          jC(_, m);
        }
      }
    }
    function zU(a, l, m) {
      if (!br)
        throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var _ = a.stateNode, A = !yf, R = o_(_, a.type, a.memoizedProps, l, m, a, A);
      return a.updateQueue = R, R !== null;
    }
    function GU(a) {
      if (!br)
        throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var l = a.stateNode, m = a.memoizedProps, _ = !yf, A = mo(l, m, a, _);
      if (A) {
        var R = Vr;
        if (R !== null) {
          var P = (R.mode & zn) !== rn;
          switch (R.tag) {
            case V: {
              var z = R.stateNode.containerInfo;
              Ud(
                z,
                l,
                m,
                // TODO: Delete this argument when we remove the legacy root API.
                P
              );
              break;
            }
            case I: {
              var W = R.type, $ = R.memoizedProps, oe = R.stateNode;
              c_(
                W,
                $,
                oe,
                l,
                m,
                // TODO: Delete this argument when we remove the legacy root API.
                P
              );
              break;
            }
          }
        }
      }
      return A;
    }
    function kU(a) {
      if (!br)
        throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var l = a.memoizedState, m = l !== null ? l.dehydrated : null;
      if (!m)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      qo(m, a);
    }
    function VU(a) {
      if (!br)
        throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
      var l = a.memoizedState, m = l !== null ? l.dehydrated : null;
      if (!m)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return Pd(m);
    }
    function $C(a) {
      for (var l = a.return; l !== null && l.tag !== I && l.tag !== V && l.tag !== J; )
        l = l.return;
      Vr = l;
    }
    function jm(a) {
      if (!br || a !== Vr)
        return !1;
      if (!Co)
        return $C(a), Co = !0, !1;
      if (a.tag !== V && (a.tag !== I || xm(a.type) && !Gi(a.type, a.memoizedProps))) {
        var l = Qa;
        if (l)
          if (eA(a))
            e1(a), tA();
          else
            for (; l; )
              jC(a, l), l = Ir(l);
      }
      return $C(a), a.tag === J ? Qa = VU(a) : Qa = Vr ? Ir(a.stateNode) : null, !0;
    }
    function WU() {
      return Co && Qa !== null;
    }
    function e1(a) {
      for (var l = Qa; l; )
        qC(a, l), l = Ir(l);
    }
    function Rh() {
      br && (Vr = null, Qa = null, Co = !1, yf = !1);
    }
    function t1() {
      Qu !== null && (Gw(Qu), Qu = null);
    }
    function os() {
      return Co;
    }
    function iA(a) {
      Qu === null ? Qu = [a] : Qu.push(a);
    }
    var rA, sA, aA, oA, lA, n1 = function(a, l) {
    };
    rA = !1, sA = !1, aA = {}, oA = {}, lA = {}, n1 = function(a, l) {
      if (!(a === null || typeof a != "object") && !(!a._store || a._store.validated || a.key != null)) {
        if (typeof a._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        a._store.validated = !0;
        var m = Fe(l) || "Component";
        oA[m] || (oA[m] = !0, d('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function Qm(a, l, m) {
      var _ = m.ref;
      if (_ !== null && typeof _ != "function" && typeof _ != "object") {
        if ((a.mode & _i || M) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(m._owner && m._self && m._owner.stateNode !== m._self)) {
          var A = Fe(a) || "Component";
          aA[A] || (d('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', _), aA[A] = !0);
        }
        if (m._owner) {
          var R = m._owner, P;
          if (R) {
            var z = R;
            if (z.tag !== U)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            P = z.stateNode;
          }
          if (!P)
            throw new Error("Missing owner for string ref " + _ + ". This error is likely caused by a bug in React. Please file an issue.");
          var W = P;
          Th(_, "ref");
          var $ = "" + _;
          if (l !== null && l.ref !== null && typeof l.ref == "function" && l.ref._stringRef === $)
            return l.ref;
          var oe = function(xe) {
            var Be = W.refs;
            Be === GC && (Be = W.refs = {}), xe === null ? delete Be[$] : Be[$] = xe;
          };
          return oe._stringRef = $, oe;
        } else {
          if (typeof _ != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!m._owner)
            throw new Error("Element ref was specified as a string (" + _ + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return _;
    }
    function z_(a, l) {
      var m = Object.prototype.toString.call(l);
      throw new Error("Objects are not valid as a React child (found: " + (m === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : m) + "). If you meant to render a collection of children, use an array instead.");
    }
    function G_(a) {
      {
        var l = Fe(a) || "Component";
        if (lA[l])
          return;
        lA[l] = !0, d("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function i1(a) {
      var l = a._payload, m = a._init;
      return m(l);
    }
    function r1(a) {
      function l(Te, Ge) {
        if (a) {
          var Ae = Te.deletions;
          Ae === null ? (Te.deletions = [Ge], Te.flags |= et) : Ae.push(Ge);
        }
      }
      function m(Te, Ge) {
        if (!a)
          return null;
        for (var Ae = Ge; Ae !== null; )
          l(Te, Ae), Ae = Ae.sibling;
        return null;
      }
      function _(Te, Ge) {
        for (var Ae = /* @__PURE__ */ new Map(), dt = Ge; dt !== null; )
          dt.key !== null ? Ae.set(dt.key, dt) : Ae.set(dt.index, dt), dt = dt.sibling;
        return Ae;
      }
      function A(Te, Ge) {
        var Ae = bf(Te, Ge);
        return Ae.index = 0, Ae.sibling = null, Ae;
      }
      function R(Te, Ge, Ae) {
        if (Te.index = Ae, !a)
          return Te.flags |= ze, Ge;
        var dt = Te.alternate;
        if (dt !== null) {
          var qt = dt.index;
          return qt < Ge ? (Te.flags |= We, Ge) : qt;
        } else
          return Te.flags |= We, Ge;
      }
      function P(Te) {
        return a && Te.alternate === null && (Te.flags |= We), Te;
      }
      function z(Te, Ge, Ae, dt) {
        if (Ge === null || Ge.tag !== Y) {
          var qt = DM(Ae, Te.mode, dt);
          return qt.return = Te, qt;
        } else {
          var Ut = A(Ge, Ae);
          return Ut.return = Te, Ut;
        }
      }
      function W(Te, Ge, Ae, dt) {
        var qt = Ae.type;
        if (qt === ne)
          return oe(Te, Ge, Ae.props.children, dt, Ae.key);
        if (Ge !== null && (Ge.elementType === qt || // Keep this check inline so it only runs on the false path:
        nR(Ge, Ae) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof qt == "object" && qt !== null && qt.$$typeof === le && i1(qt) === Ge.type)) {
          var Ut = A(Ge, Ae.props);
          return Ut.ref = Qm(Te, Ge, Ae), Ut.return = Te, Ut._debugSource = Ae._source, Ut._debugOwner = Ae._owner, Ut;
        }
        var Dn = BM(Ae, Te.mode, dt);
        return Dn.ref = Qm(Te, Ge, Ae), Dn.return = Te, Dn;
      }
      function $(Te, Ge, Ae, dt) {
        if (Ge === null || Ge.tag !== L || Ge.stateNode.containerInfo !== Ae.containerInfo || Ge.stateNode.implementation !== Ae.implementation) {
          var qt = LM(Ae, Te.mode, dt);
          return qt.return = Te, qt;
        } else {
          var Ut = A(Ge, Ae.children || []);
          return Ut.return = Te, Ut;
        }
      }
      function oe(Te, Ge, Ae, dt, qt) {
        if (Ge === null || Ge.tag !== Q) {
          var Ut = ac(Ae, Te.mode, dt, qt);
          return Ut.return = Te, Ut;
        } else {
          var Dn = A(Ge, Ae);
          return Dn.return = Te, Dn;
        }
      }
      function xe(Te, Ge, Ae) {
        if (typeof Ge == "string" && Ge !== "" || typeof Ge == "number") {
          var dt = DM("" + Ge, Te.mode, Ae);
          return dt.return = Te, dt;
        }
        if (typeof Ge == "object" && Ge !== null) {
          switch (Ge.$$typeof) {
            case pt: {
              var qt = BM(Ge, Te.mode, Ae);
              return qt.ref = Qm(Te, null, Ge), qt.return = Te, qt;
            }
            case mt: {
              var Ut = LM(Ge, Te.mode, Ae);
              return Ut.return = Te, Ut;
            }
            case le: {
              var Dn = Ge._payload, Jn = Ge._init;
              return xe(Te, Jn(Dn), Ae);
            }
          }
          if (ht(Ge) || ee(Ge)) {
            var ii = ac(Ge, Te.mode, Ae, null);
            return ii.return = Te, ii;
          }
          z_(Te, Ge);
        }
        return typeof Ge == "function" && G_(Te), null;
      }
      function Be(Te, Ge, Ae, dt) {
        var qt = Ge !== null ? Ge.key : null;
        if (typeof Ae == "string" && Ae !== "" || typeof Ae == "number")
          return qt !== null ? null : z(Te, Ge, "" + Ae, dt);
        if (typeof Ae == "object" && Ae !== null) {
          switch (Ae.$$typeof) {
            case pt:
              return Ae.key === qt ? W(Te, Ge, Ae, dt) : null;
            case mt:
              return Ae.key === qt ? $(Te, Ge, Ae, dt) : null;
            case le: {
              var Ut = Ae._payload, Dn = Ae._init;
              return Be(Te, Ge, Dn(Ut), dt);
            }
          }
          if (ht(Ae) || ee(Ae))
            return qt !== null ? null : oe(Te, Ge, Ae, dt, null);
          z_(Te, Ae);
        }
        return typeof Ae == "function" && G_(Te), null;
      }
      function Ne(Te, Ge, Ae, dt, qt) {
        if (typeof dt == "string" && dt !== "" || typeof dt == "number") {
          var Ut = Te.get(Ae) || null;
          return z(Ge, Ut, "" + dt, qt);
        }
        if (typeof dt == "object" && dt !== null) {
          switch (dt.$$typeof) {
            case pt: {
              var Dn = Te.get(dt.key === null ? Ae : dt.key) || null;
              return W(Ge, Dn, dt, qt);
            }
            case mt: {
              var Jn = Te.get(dt.key === null ? Ae : dt.key) || null;
              return $(Ge, Jn, dt, qt);
            }
            case le: {
              var ii = dt._payload, Yn = dt._init;
              return Ne(Te, Ge, Ae, Yn(ii), qt);
            }
          }
          if (ht(dt) || ee(dt)) {
            var Mi = Te.get(Ae) || null;
            return oe(Ge, Mi, dt, qt, null);
          }
          z_(Ge, dt);
        }
        return typeof dt == "function" && G_(Ge), null;
      }
      function $e(Te, Ge, Ae) {
        {
          if (typeof Te != "object" || Te === null)
            return Ge;
          switch (Te.$$typeof) {
            case pt:
            case mt:
              n1(Te, Ae);
              var dt = Te.key;
              if (typeof dt != "string")
                break;
              if (Ge === null) {
                Ge = /* @__PURE__ */ new Set(), Ge.add(dt);
                break;
              }
              if (!Ge.has(dt)) {
                Ge.add(dt);
                break;
              }
              d("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", dt);
              break;
            case le: {
              var qt = Te._payload, Ut = Te._init;
              $e(Ut(qt), Ge, Ae);
              break;
            }
          }
        }
        return Ge;
      }
      function ut(Te, Ge, Ae, dt) {
        for (var qt = null, Ut = 0; Ut < Ae.length; Ut++) {
          var Dn = Ae[Ut];
          qt = $e(Dn, qt, Te);
        }
        for (var Jn = null, ii = null, Yn = Ge, Mi = 0, Gn = 0, En = null; Yn !== null && Gn < Ae.length; Gn++) {
          Yn.index > Gn ? (En = Yn, Yn = null) : En = Yn.sibling;
          var Ki = Be(Te, Yn, Ae[Gn], dt);
          if (Ki === null) {
            Yn === null && (Yn = En);
            break;
          }
          a && Yn && Ki.alternate === null && l(Te, Yn), Mi = R(Ki, Mi, Gn), ii === null ? Jn = Ki : ii.sibling = Ki, ii = Ki, Yn = En;
        }
        if (Gn === Ae.length) {
          if (m(Te, Yn), os()) {
            var Ei = Gn;
            vf(Te, Ei);
          }
          return Jn;
        }
        if (Yn === null) {
          for (; Gn < Ae.length; Gn++) {
            var io = xe(Te, Ae[Gn], dt);
            io !== null && (Mi = R(io, Mi, Gn), ii === null ? Jn = io : ii.sibling = io, ii = io);
          }
          if (os()) {
            var Kr = Gn;
            vf(Te, Kr);
          }
          return Jn;
        }
        for (var va = _(Te, Yn); Gn < Ae.length; Gn++) {
          var _a = Ne(va, Te, Gn, Ae[Gn], dt);
          _a !== null && (a && _a.alternate !== null && va.delete(_a.key === null ? Gn : _a.key), Mi = R(_a, Mi, Gn), ii === null ? Jn = _a : ii.sibling = _a, ii = _a);
        }
        if (a && va.forEach(function(Xh) {
          return l(Te, Xh);
        }), os()) {
          var hl = Gn;
          vf(Te, hl);
        }
        return Jn;
      }
      function Zt(Te, Ge, Ae, dt) {
        var qt = ee(Ae);
        if (typeof qt != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          Ae[Symbol.toStringTag] === "Generator" && (sA || d("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), sA = !0), Ae.entries === qt && (rA || d("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), rA = !0);
          var Ut = qt.call(Ae);
          if (Ut)
            for (var Dn = null, Jn = Ut.next(); !Jn.done; Jn = Ut.next()) {
              var ii = Jn.value;
              Dn = $e(ii, Dn, Te);
            }
        }
        var Yn = qt.call(Ae);
        if (Yn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var Mi = null, Gn = null, En = Ge, Ki = 0, Ei = 0, io = null, Kr = Yn.next(); En !== null && !Kr.done; Ei++, Kr = Yn.next()) {
          En.index > Ei ? (io = En, En = null) : io = En.sibling;
          var va = Be(Te, En, Kr.value, dt);
          if (va === null) {
            En === null && (En = io);
            break;
          }
          a && En && va.alternate === null && l(Te, En), Ki = R(va, Ki, Ei), Gn === null ? Mi = va : Gn.sibling = va, Gn = va, En = io;
        }
        if (Kr.done) {
          if (m(Te, En), os()) {
            var _a = Ei;
            vf(Te, _a);
          }
          return Mi;
        }
        if (En === null) {
          for (; !Kr.done; Ei++, Kr = Yn.next()) {
            var hl = xe(Te, Kr.value, dt);
            hl !== null && (Ki = R(hl, Ki, Ei), Gn === null ? Mi = hl : Gn.sibling = hl, Gn = hl);
          }
          if (os()) {
            var Xh = Ei;
            vf(Te, Xh);
          }
          return Mi;
        }
        for (var Jh = _(Te, En); !Kr.done; Ei++, Kr = Yn.next()) {
          var ya = Ne(Jh, Te, Ei, Kr.value, dt);
          ya !== null && (a && ya.alternate !== null && Jh.delete(ya.key === null ? Ei : ya.key), Ki = R(ya, Ki, Ei), Gn === null ? Mi = ya : Gn.sibling = ya, Gn = ya);
        }
        if (a && Jh.forEach(function(NM) {
          return l(Te, NM);
        }), os()) {
          var Cf = Ei;
          vf(Te, Cf);
        }
        return Mi;
      }
      function hn(Te, Ge, Ae, dt) {
        if (Ge !== null && Ge.tag === Y) {
          m(Te, Ge.sibling);
          var qt = A(Ge, Ae);
          return qt.return = Te, qt;
        }
        m(Te, Ge);
        var Ut = DM(Ae, Te.mode, dt);
        return Ut.return = Te, Ut;
      }
      function nn(Te, Ge, Ae, dt) {
        for (var qt = Ae.key, Ut = Ge; Ut !== null; ) {
          if (Ut.key === qt) {
            var Dn = Ae.type;
            if (Dn === ne) {
              if (Ut.tag === Q) {
                m(Te, Ut.sibling);
                var Jn = A(Ut, Ae.props.children);
                return Jn.return = Te, Jn._debugSource = Ae._source, Jn._debugOwner = Ae._owner, Jn;
              }
            } else if (Ut.elementType === Dn || // Keep this check inline so it only runs on the false path:
            nR(Ut, Ae) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof Dn == "object" && Dn !== null && Dn.$$typeof === le && i1(Dn) === Ut.type) {
              m(Te, Ut.sibling);
              var ii = A(Ut, Ae.props);
              return ii.ref = Qm(Te, Ut, Ae), ii.return = Te, ii._debugSource = Ae._source, ii._debugOwner = Ae._owner, ii;
            }
            m(Te, Ut);
            break;
          } else
            l(Te, Ut);
          Ut = Ut.sibling;
        }
        if (Ae.type === ne) {
          var Yn = ac(Ae.props.children, Te.mode, dt, Ae.key);
          return Yn.return = Te, Yn;
        } else {
          var Mi = BM(Ae, Te.mode, dt);
          return Mi.ref = Qm(Te, Ge, Ae), Mi.return = Te, Mi;
        }
      }
      function hi(Te, Ge, Ae, dt) {
        for (var qt = Ae.key, Ut = Ge; Ut !== null; ) {
          if (Ut.key === qt)
            if (Ut.tag === L && Ut.stateNode.containerInfo === Ae.containerInfo && Ut.stateNode.implementation === Ae.implementation) {
              m(Te, Ut.sibling);
              var Dn = A(Ut, Ae.children || []);
              return Dn.return = Te, Dn;
            } else {
              m(Te, Ut);
              break;
            }
          else
            l(Te, Ut);
          Ut = Ut.sibling;
        }
        var Jn = LM(Ae, Te.mode, dt);
        return Jn.return = Te, Jn;
      }
      function pi(Te, Ge, Ae, dt) {
        var qt = typeof Ae == "object" && Ae !== null && Ae.type === ne && Ae.key === null;
        if (qt && (Ae = Ae.props.children), typeof Ae == "object" && Ae !== null) {
          switch (Ae.$$typeof) {
            case pt:
              return P(nn(Te, Ge, Ae, dt));
            case mt:
              return P(hi(Te, Ge, Ae, dt));
            case le: {
              var Ut = Ae._payload, Dn = Ae._init;
              return pi(Te, Ge, Dn(Ut), dt);
            }
          }
          if (ht(Ae))
            return ut(Te, Ge, Ae, dt);
          if (ee(Ae))
            return Zt(Te, Ge, Ae, dt);
          z_(Te, Ae);
        }
        return typeof Ae == "string" && Ae !== "" || typeof Ae == "number" ? P(hn(Te, Ge, "" + Ae, dt)) : (typeof Ae == "function" && G_(Te), m(Te, Ge));
      }
      return pi;
    }
    var Bh = r1(!0), s1 = r1(!1);
    function XU(a, l) {
      if (a !== null && l.child !== a.child)
        throw new Error("Resuming work not yet implemented.");
      if (l.child !== null) {
        var m = l.child, _ = bf(m, m.pendingProps);
        for (l.child = _, _.return = l; m.sibling !== null; )
          m = m.sibling, _ = _.sibling = bf(m, m.pendingProps), _.return = l;
        _.sibling = null;
      }
    }
    function JU(a, l) {
      for (var m = a.child; m !== null; )
        UO(m, l), m = m.sibling;
    }
    var Zm = {}, Zu = Va(Zm), $m = Va(Zm), k_ = Va(Zm);
    function V_(a) {
      if (a === Zm)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return a;
    }
    function uA() {
      var a = V_(k_.current);
      return a;
    }
    function cA(a, l) {
      Di(k_, l, a), Di($m, a, a), Di(Zu, Zm, a);
      var m = mn(l);
      Sn(Zu, a), Di(Zu, m, a);
    }
    function Dh(a) {
      Sn(Zu, a), Sn($m, a), Sn(k_, a);
    }
    function eg() {
      var a = V_(Zu.current);
      return a;
    }
    function a1(a) {
      var l = V_(k_.current), m = V_(Zu.current), _ = mi(m, a.type, l);
      m !== _ && (Di($m, a, a), Di(Zu, _, a));
    }
    function fA(a) {
      $m.current === a && (Sn(Zu, a), Sn($m, a));
    }
    var YU = 0, o1 = 1, l1 = 1, tg = 2, wo = Va(YU);
    function dA(a, l) {
      return (a & l) !== 0;
    }
    function Lh(a) {
      return a & o1;
    }
    function hA(a, l) {
      return a & o1 | l;
    }
    function KU(a, l) {
      return a | l;
    }
    function $u(a, l) {
      Di(wo, l, a);
    }
    function Ph(a) {
      Sn(wo, a);
    }
    function qU(a, l) {
      var m = a.memoizedState;
      return m !== null ? m.dehydrated !== null : (a.memoizedProps, !0);
    }
    function W_(a) {
      for (var l = a; l !== null; ) {
        if (l.tag === J) {
          var m = l.memoizedState;
          if (m !== null) {
            var _ = m.dehydrated;
            if (_ === null || Ld(_) || Kc(_))
              return l;
          }
        } else if (l.tag === ye && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        l.memoizedProps.revealOrder !== void 0) {
          var A = (l.flags & ot) !== Ke;
          if (A)
            return l;
        } else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === a)
          return null;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === a)
            return null;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
      return null;
    }
    var ol = (
      /*   */
      0
    ), xi = (
      /* */
      1
    ), ec = (
      /*  */
      2
    ), Yi = (
      /*    */
      4
    ), Wr = (
      /*   */
      8
    ), pA = [];
    function mA() {
      for (var a = 0; a < pA.length; a++) {
        var l = pA[a];
        wd ? l._workInProgressVersionPrimary = null : l._workInProgressVersionSecondary = null;
      }
      pA.length = 0;
    }
    function jU(a, l) {
      var m = l._getVersion, _ = m(l._source);
      a.mutableSourceEagerHydrationData == null ? a.mutableSourceEagerHydrationData = [l, _] : a.mutableSourceEagerHydrationData.push(l, _);
    }
    var Pt = r.ReactCurrentDispatcher, js = r.ReactCurrentBatchConfig, gA, Ih;
    gA = /* @__PURE__ */ new Set();
    var Uh = Ze, ei = null, ls = null, mr = null, X_ = !1, ng = !1, ig = 0, QU = 0, ZU = 25, ke = null, Za = null, tc = -1, vA = !1;
    function Wn() {
      {
        var a = ke;
        Za === null ? Za = [a] : Za.push(a);
      }
    }
    function yt() {
      {
        var a = ke;
        Za !== null && (tc++, Za[tc] !== a && $U(a));
      }
    }
    function Fh(a) {
      a != null && !ht(a) && d("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", ke, typeof a);
    }
    function $U(a) {
      {
        var l = Fe(ei);
        if (!gA.has(l) && (gA.add(l), Za !== null)) {
          for (var m = "", _ = 30, A = 0; A <= tc; A++) {
            for (var R = Za[A], P = A === tc ? a : R, z = A + 1 + ". " + R; z.length < _; )
              z += " ";
            z += P + `
`, m += z;
          }
          d(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, l, m);
        }
      }
    }
    function us() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function _A(a, l) {
      if (vA)
        return !1;
      if (l === null)
        return d("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", ke), !1;
      a.length !== l.length && d(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, ke, "[" + l.join(", ") + "]", "[" + a.join(", ") + "]");
      for (var m = 0; m < l.length && m < a.length; m++)
        if (!Ji(a[m], l[m]))
          return !1;
      return !0;
    }
    function Nh(a, l, m, _, A, R) {
      Uh = R, ei = l, Za = a !== null ? a._debugHookTypes : null, tc = -1, vA = a !== null && a.type !== l.type, l.memoizedState = null, l.updateQueue = null, l.lanes = Ze, a !== null && a.memoizedState !== null ? Pt.current = B1 : Za !== null ? Pt.current = R1 : Pt.current = w1;
      var P = m(_, A);
      if (ng) {
        var z = 0;
        do {
          if (ng = !1, ig = 0, z >= ZU)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          z += 1, vA = !1, ls = null, mr = null, l.updateQueue = null, tc = -1, Pt.current = D1, P = m(_, A);
        } while (ng);
      }
      Pt.current = ry, l._debugHookTypes = Za;
      var W = ls !== null && ls.next !== null;
      if (Uh = Ze, ei = null, ls = null, mr = null, ke = null, Za = null, tc = -1, a !== null && (a.flags & je) !== (l.flags & je) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (a.mode & zn) !== rn && d("Internal React error: Expected static flag was missing. Please notify the React team."), X_ = !1, W)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return P;
    }
    function Oh() {
      var a = ig !== 0;
      return ig = 0, a;
    }
    function u1(a, l, m) {
      l.updateQueue = a.updateQueue, (l.mode & fa) !== rn ? l.flags &= -50333701 : l.flags &= -2053, a.lanes = tf(a.lanes, m);
    }
    function c1() {
      if (Pt.current = ry, X_) {
        for (var a = ei.memoizedState; a !== null; ) {
          var l = a.queue;
          l !== null && (l.pending = null), a = a.next;
        }
        X_ = !1;
      }
      Uh = Ze, ei = null, ls = null, mr = null, Za = null, tc = -1, ke = null, A1 = !1, ng = !1, ig = 0;
    }
    function Jl() {
      var a = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return mr === null ? ei.memoizedState = mr = a : mr = mr.next = a, mr;
    }
    function ll() {
      var a;
      if (ls === null) {
        var l = ei.alternate;
        l !== null ? a = l.memoizedState : a = null;
      } else
        a = ls.next;
      var m;
      if (mr === null ? m = ei.memoizedState : m = mr.next, m !== null)
        mr = m, m = mr.next, ls = a;
      else {
        if (a === null)
          throw new Error("Rendered more hooks than during the previous render.");
        ls = a;
        var _ = {
          memoizedState: ls.memoizedState,
          baseState: ls.baseState,
          baseQueue: ls.baseQueue,
          queue: ls.queue,
          next: null
        };
        mr === null ? ei.memoizedState = mr = _ : mr = mr.next = _;
      }
      return mr;
    }
    function f1() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function yA(a, l) {
      return typeof l == "function" ? l(a) : l;
    }
    function xA(a, l, m) {
      var _ = Jl(), A;
      m !== void 0 ? A = m(l) : A = l, _.memoizedState = _.baseState = A;
      var R = {
        pending: null,
        interleaved: null,
        lanes: Ze,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: A
      };
      _.queue = R;
      var P = R.dispatch = iF.bind(null, ei, R);
      return [_.memoizedState, P];
    }
    function SA(a, l, m) {
      var _ = ll(), A = _.queue;
      if (A === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      A.lastRenderedReducer = a;
      var R = ls, P = R.baseQueue, z = A.pending;
      if (z !== null) {
        if (P !== null) {
          var W = P.next, $ = z.next;
          P.next = $, z.next = W;
        }
        R.baseQueue !== P && d("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), R.baseQueue = P = z, A.pending = null;
      }
      if (P !== null) {
        var oe = P.next, xe = R.baseState, Be = null, Ne = null, $e = null, ut = oe;
        do {
          var Zt = ut.lane;
          if (Hl(Uh, Zt)) {
            if ($e !== null) {
              var nn = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: yi,
                action: ut.action,
                hasEagerState: ut.hasEagerState,
                eagerState: ut.eagerState,
                next: null
              };
              $e = $e.next = nn;
            }
            if (ut.hasEagerState)
              xe = ut.eagerState;
            else {
              var hi = ut.action;
              xe = a(xe, hi);
            }
          } else {
            var hn = {
              lane: Zt,
              action: ut.action,
              hasEagerState: ut.hasEagerState,
              eagerState: ut.eagerState,
              next: null
            };
            $e === null ? (Ne = $e = hn, Be = xe) : $e = $e.next = hn, ei.lanes = cn(ei.lanes, Zt), zy(Zt);
          }
          ut = ut.next;
        } while (ut !== null && ut !== oe);
        $e === null ? Be = xe : $e.next = Ne, Ji(xe, _.memoizedState) || vy(), _.memoizedState = xe, _.baseState = Be, _.baseQueue = $e, A.lastRenderedState = xe;
      }
      var pi = A.interleaved;
      if (pi !== null) {
        var Te = pi;
        do {
          var Ge = Te.lane;
          ei.lanes = cn(ei.lanes, Ge), zy(Ge), Te = Te.next;
        } while (Te !== pi);
      } else P === null && (A.lanes = Ze);
      var Ae = A.dispatch;
      return [_.memoizedState, Ae];
    }
    function AA(a, l, m) {
      var _ = ll(), A = _.queue;
      if (A === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      A.lastRenderedReducer = a;
      var R = A.dispatch, P = A.pending, z = _.memoizedState;
      if (P !== null) {
        A.pending = null;
        var W = P.next, $ = W;
        do {
          var oe = $.action;
          z = a(z, oe), $ = $.next;
        } while ($ !== W);
        Ji(z, _.memoizedState) || vy(), _.memoizedState = z, _.baseQueue === null && (_.baseState = z), A.lastRenderedState = z;
      }
      return [z, R];
    }
    function C6(a, l, m) {
    }
    function w6(a, l, m) {
    }
    function MA(a, l, m) {
      var _ = ei, A = Jl(), R, P = os();
      if (P) {
        if (m === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        R = m(), Ih || R !== m() && (d("The result of getServerSnapshot should be cached to avoid an infinite loop"), Ih = !0);
      } else {
        if (R = l(), !Ih) {
          var z = l();
          Ji(R, z) || (d("The result of getSnapshot should be cached to avoid an infinite loop"), Ih = !0);
        }
        var W = Fy();
        if (W === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Fu(W, Uh) || d1(_, l, R);
      }
      A.memoizedState = R;
      var $ = {
        value: R,
        getSnapshot: l
      };
      return A.queue = $, og(p1.bind(null, _, $, a), [a]), _.flags |= St, sg(xi | Wr, h1.bind(null, _, $, R, l), void 0, null), R;
    }
    function J_(a, l, m) {
      var _ = ei, A = ll(), R = l();
      if (!Ih) {
        var P = l();
        Ji(R, P) || (d("The result of getSnapshot should be cached to avoid an infinite loop"), Ih = !0);
      }
      var z = A.memoizedState, W = !Ji(z, R);
      W && (A.memoizedState = R, vy());
      var $ = A.queue;
      if (xf(p1.bind(null, _, $, a), [a]), $.getSnapshot !== l || W || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      mr !== null && mr.memoizedState.tag & xi) {
        _.flags |= St, sg(xi | Wr, h1.bind(null, _, $, R, l), void 0, null);
        var oe = Fy();
        if (oe === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        Fu(oe, Uh) || d1(_, l, R);
      }
      return R;
    }
    function d1(a, l, m) {
      a.flags |= kt;
      var _ = {
        getSnapshot: l,
        value: m
      }, A = ei.updateQueue;
      if (A === null)
        A = f1(), ei.updateQueue = A, A.stores = [_];
      else {
        var R = A.stores;
        R === null ? A.stores = [_] : R.push(_);
      }
    }
    function h1(a, l, m, _) {
      l.value = m, l.getSnapshot = _, m1(l) && g1(a);
    }
    function p1(a, l, m) {
      var _ = function() {
        m1(l) && g1(a);
      };
      return m(_);
    }
    function m1(a) {
      var l = a.getSnapshot, m = a.value;
      try {
        var _ = l();
        return !Ji(m, _);
      } catch {
        return !0;
      }
    }
    function g1(a) {
      _r(a, gn, Qn);
    }
    function rg(a) {
      var l = Jl();
      typeof a == "function" && (a = a()), l.memoizedState = l.baseState = a;
      var m = {
        pending: null,
        interleaved: null,
        lanes: Ze,
        dispatch: null,
        lastRenderedReducer: yA,
        lastRenderedState: a
      };
      l.queue = m;
      var _ = m.dispatch = rF.bind(null, ei, m);
      return [l.memoizedState, _];
    }
    function Y_(a) {
      return SA(yA);
    }
    function K_(a) {
      return AA(yA);
    }
    function sg(a, l, m, _) {
      var A = {
        tag: a,
        create: l,
        destroy: m,
        deps: _,
        // Circular
        next: null
      }, R = ei.updateQueue;
      if (R === null)
        R = f1(), ei.updateQueue = R, R.lastEffect = A.next = A;
      else {
        var P = R.lastEffect;
        if (P === null)
          R.lastEffect = A.next = A;
        else {
          var z = P.next;
          P.next = A, A.next = z, R.lastEffect = A;
        }
      }
      return A;
    }
    function EA(a) {
      var l = Jl();
      {
        var m = {
          current: a
        };
        return l.memoizedState = m, m;
      }
    }
    function q_(a) {
      var l = ll();
      return l.memoizedState;
    }
    function ag(a, l, m, _) {
      var A = Jl(), R = _ === void 0 ? null : _;
      ei.flags |= a, A.memoizedState = sg(xi | l, m, void 0, R);
    }
    function j_(a, l, m, _) {
      var A = ll(), R = _ === void 0 ? null : _, P = void 0;
      if (ls !== null) {
        var z = ls.memoizedState;
        if (P = z.destroy, R !== null) {
          var W = z.deps;
          if (_A(R, W)) {
            A.memoizedState = sg(l, m, P, R);
            return;
          }
        }
      }
      ei.flags |= a, A.memoizedState = sg(xi | l, m, P, R);
    }
    function og(a, l) {
      return (ei.mode & fa) !== rn ? ag(k | St | Ht, Wr, a, l) : ag(St | Ht, Wr, a, l);
    }
    function xf(a, l) {
      return j_(St, Wr, a, l);
    }
    function TA(a, l) {
      return ag(Pe, ec, a, l);
    }
    function Q_(a, l) {
      return j_(Pe, ec, a, l);
    }
    function bA(a, l) {
      var m = Pe;
      return m |= gt, (ei.mode & fa) !== rn && (m |= tn), ag(m, Yi, a, l);
    }
    function Z_(a, l) {
      return j_(Pe, Yi, a, l);
    }
    function v1(a, l) {
      if (typeof l == "function") {
        var m = l, _ = a();
        return m(_), function() {
          m(null);
        };
      } else if (l != null) {
        var A = l;
        A.hasOwnProperty("current") || d("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(A).join(", ") + "}");
        var R = a();
        return A.current = R, function() {
          A.current = null;
        };
      }
    }
    function CA(a, l, m) {
      typeof l != "function" && d("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", l !== null ? typeof l : "null");
      var _ = m != null ? m.concat([a]) : null, A = Pe;
      return A |= gt, (ei.mode & fa) !== rn && (A |= tn), ag(A, Yi, v1.bind(null, l, a), _);
    }
    function $_(a, l, m) {
      typeof l != "function" && d("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", l !== null ? typeof l : "null");
      var _ = m != null ? m.concat([a]) : null;
      return j_(Pe, Yi, v1.bind(null, l, a), _);
    }
    function eF(a, l) {
    }
    var ey = eF;
    function wA(a, l) {
      var m = Jl(), _ = l === void 0 ? null : l;
      return m.memoizedState = [a, _], a;
    }
    function ty(a, l) {
      var m = ll(), _ = l === void 0 ? null : l, A = m.memoizedState;
      if (A !== null && _ !== null) {
        var R = A[1];
        if (_A(_, R))
          return A[0];
      }
      return m.memoizedState = [a, _], a;
    }
    function RA(a, l) {
      var m = Jl(), _ = l === void 0 ? null : l, A = a();
      return m.memoizedState = [A, _], A;
    }
    function ny(a, l) {
      var m = ll(), _ = l === void 0 ? null : l, A = m.memoizedState;
      if (A !== null && _ !== null) {
        var R = A[1];
        if (_A(_, R))
          return A[0];
      }
      var P = a();
      return m.memoizedState = [P, _], P;
    }
    function BA(a) {
      var l = rg(a), m = l[0], _ = l[1];
      return og(function() {
        var A = js.transition;
        js.transition = {};
        try {
          _(a);
        } finally {
          js.transition = A;
        }
      }, [a]), m;
    }
    function _1(a) {
      var l = Y_(), m = l[0], _ = l[1];
      return xf(function() {
        var A = js.transition;
        js.transition = {};
        try {
          _(a);
        } finally {
          js.transition = A;
        }
      }, [a]), m;
    }
    function y1(a) {
      var l = K_(), m = l[0], _ = l[1];
      return xf(function() {
        var A = js.transition;
        js.transition = {};
        try {
          _(a);
        } finally {
          js.transition = A;
        }
      }, [a]), m;
    }
    function tF(a, l, m) {
      var _ = Ks();
      Vi(Fm(_, zl)), a(!0);
      var A = js.transition;
      js.transition = {};
      var R = js.transition;
      js.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        a(!1), l();
      } finally {
        if (Vi(_), js.transition = A, A === null && R._updatedFibers) {
          var P = R._updatedFibers.size;
          P > 10 && c("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), R._updatedFibers.clear();
        }
      }
    }
    function DA() {
      var a = rg(!1), l = a[0], m = a[1], _ = tF.bind(null, m), A = Jl();
      return A.memoizedState = _, [l, _];
    }
    function x1() {
      var a = Y_(), l = a[0], m = ll(), _ = m.memoizedState;
      return [l, _];
    }
    function S1() {
      var a = K_(), l = a[0], m = ll(), _ = m.memoizedState;
      return [l, _];
    }
    var A1 = !1;
    function nF() {
      return A1;
    }
    function LA() {
      var a = Jl(), l = Fy(), m = l.identifierPrefix, _;
      if (os()) {
        var A = LU();
        _ = ":" + m + "R" + A;
        var R = ig++;
        R > 0 && (_ += "H" + R.toString(32)), _ += ":";
      } else {
        var P = QU++;
        _ = ":" + m + "r" + P.toString(32) + ":";
      }
      return a.memoizedState = _, _;
    }
    function iy() {
      var a = ll(), l = a.memoizedState;
      return l;
    }
    function iF(a, l, m) {
      typeof arguments[3] == "function" && d("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var _ = rc(a), A = {
        lane: _,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (M1(a))
        E1(l, A);
      else {
        T1(a, l, A);
        var R = Rs(), P = _r(a, _, R);
        P !== null && b1(P, l, _);
      }
      C1(a, _);
    }
    function rF(a, l, m) {
      typeof arguments[3] == "function" && d("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var _ = rc(a), A = {
        lane: _,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (M1(a))
        E1(l, A);
      else {
        T1(a, l, A);
        var R = a.alternate;
        if (a.lanes === Ze && (R === null || R.lanes === Ze)) {
          var P = l.lastRenderedReducer;
          if (P !== null) {
            var z;
            z = Pt.current, Pt.current = Ro;
            try {
              var W = l.lastRenderedState, $ = P(W, m);
              if (A.hasEagerState = !0, A.eagerState = $, Ji($, W))
                return;
            } catch {
            } finally {
              Pt.current = z;
            }
          }
        }
        var oe = Rs(), xe = _r(a, _, oe);
        xe !== null && b1(xe, l, _);
      }
      C1(a, _);
    }
    function M1(a) {
      var l = a.alternate;
      return a === ei || l !== null && l === ei;
    }
    function E1(a, l) {
      ng = X_ = !0;
      var m = a.pending;
      m === null ? l.next = l : (l.next = m.next, m.next = l), a.pending = l;
    }
    function T1(a, l, m, _) {
      if (Hw(a)) {
        var A = l.interleaved;
        A === null ? (m.next = m, Le(l)) : (m.next = A.next, A.next = m), l.interleaved = m;
      } else {
        var R = l.pending;
        R === null ? m.next = m : (m.next = R.next, R.next = m), l.pending = m;
      }
    }
    function b1(a, l, m) {
      if (Um(m)) {
        var _ = l.lanes;
        _ = Xa(_, a.pendingLanes);
        var A = cn(_, m);
        l.lanes = A, nf(a, A);
      }
    }
    function C1(a, l, m) {
      Vu(a, l);
    }
    var ry = {
      readContext: K,
      useCallback: us,
      useContext: us,
      useEffect: us,
      useImperativeHandle: us,
      useInsertionEffect: us,
      useLayoutEffect: us,
      useMemo: us,
      useReducer: us,
      useRef: us,
      useState: us,
      useDebugValue: us,
      useDeferredValue: us,
      useTransition: us,
      useMutableSource: us,
      useSyncExternalStore: us,
      useId: us,
      unstable_isNewReconciler: S
    }, w1 = null, R1 = null, B1 = null, D1 = null, ul = null, Ro = null, sy = null;
    {
      var PA = function() {
        d("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, on = function() {
        d("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      w1 = {
        readContext: function(a) {
          return K(a);
        },
        useCallback: function(a, l) {
          return ke = "useCallback", Wn(), Fh(l), wA(a, l);
        },
        useContext: function(a) {
          return ke = "useContext", Wn(), K(a);
        },
        useEffect: function(a, l) {
          return ke = "useEffect", Wn(), Fh(l), og(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return ke = "useImperativeHandle", Wn(), Fh(m), CA(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return ke = "useInsertionEffect", Wn(), Fh(l), TA(a, l);
        },
        useLayoutEffect: function(a, l) {
          return ke = "useLayoutEffect", Wn(), Fh(l), bA(a, l);
        },
        useMemo: function(a, l) {
          ke = "useMemo", Wn(), Fh(l);
          var m = Pt.current;
          Pt.current = ul;
          try {
            return RA(a, l);
          } finally {
            Pt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          ke = "useReducer", Wn();
          var _ = Pt.current;
          Pt.current = ul;
          try {
            return xA(a, l, m);
          } finally {
            Pt.current = _;
          }
        },
        useRef: function(a) {
          return ke = "useRef", Wn(), EA(a);
        },
        useState: function(a) {
          ke = "useState", Wn();
          var l = Pt.current;
          Pt.current = ul;
          try {
            return rg(a);
          } finally {
            Pt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return ke = "useDebugValue", Wn(), void 0;
        },
        useDeferredValue: function(a) {
          return ke = "useDeferredValue", Wn(), BA(a);
        },
        useTransition: function() {
          return ke = "useTransition", Wn(), DA();
        },
        useMutableSource: function(a, l, m) {
          return ke = "useMutableSource", Wn(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return ke = "useSyncExternalStore", Wn(), MA(a, l, m);
        },
        useId: function() {
          return ke = "useId", Wn(), LA();
        },
        unstable_isNewReconciler: S
      }, R1 = {
        readContext: function(a) {
          return K(a);
        },
        useCallback: function(a, l) {
          return ke = "useCallback", yt(), wA(a, l);
        },
        useContext: function(a) {
          return ke = "useContext", yt(), K(a);
        },
        useEffect: function(a, l) {
          return ke = "useEffect", yt(), og(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return ke = "useImperativeHandle", yt(), CA(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return ke = "useInsertionEffect", yt(), TA(a, l);
        },
        useLayoutEffect: function(a, l) {
          return ke = "useLayoutEffect", yt(), bA(a, l);
        },
        useMemo: function(a, l) {
          ke = "useMemo", yt();
          var m = Pt.current;
          Pt.current = ul;
          try {
            return RA(a, l);
          } finally {
            Pt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          ke = "useReducer", yt();
          var _ = Pt.current;
          Pt.current = ul;
          try {
            return xA(a, l, m);
          } finally {
            Pt.current = _;
          }
        },
        useRef: function(a) {
          return ke = "useRef", yt(), EA(a);
        },
        useState: function(a) {
          ke = "useState", yt();
          var l = Pt.current;
          Pt.current = ul;
          try {
            return rg(a);
          } finally {
            Pt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return ke = "useDebugValue", yt(), void 0;
        },
        useDeferredValue: function(a) {
          return ke = "useDeferredValue", yt(), BA(a);
        },
        useTransition: function() {
          return ke = "useTransition", yt(), DA();
        },
        useMutableSource: function(a, l, m) {
          return ke = "useMutableSource", yt(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return ke = "useSyncExternalStore", yt(), MA(a, l, m);
        },
        useId: function() {
          return ke = "useId", yt(), LA();
        },
        unstable_isNewReconciler: S
      }, B1 = {
        readContext: function(a) {
          return K(a);
        },
        useCallback: function(a, l) {
          return ke = "useCallback", yt(), ty(a, l);
        },
        useContext: function(a) {
          return ke = "useContext", yt(), K(a);
        },
        useEffect: function(a, l) {
          return ke = "useEffect", yt(), xf(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return ke = "useImperativeHandle", yt(), $_(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return ke = "useInsertionEffect", yt(), Q_(a, l);
        },
        useLayoutEffect: function(a, l) {
          return ke = "useLayoutEffect", yt(), Z_(a, l);
        },
        useMemo: function(a, l) {
          ke = "useMemo", yt();
          var m = Pt.current;
          Pt.current = Ro;
          try {
            return ny(a, l);
          } finally {
            Pt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          ke = "useReducer", yt();
          var _ = Pt.current;
          Pt.current = Ro;
          try {
            return SA(a, l, m);
          } finally {
            Pt.current = _;
          }
        },
        useRef: function(a) {
          return ke = "useRef", yt(), q_();
        },
        useState: function(a) {
          ke = "useState", yt();
          var l = Pt.current;
          Pt.current = Ro;
          try {
            return Y_(a);
          } finally {
            Pt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return ke = "useDebugValue", yt(), ey();
        },
        useDeferredValue: function(a) {
          return ke = "useDeferredValue", yt(), _1(a);
        },
        useTransition: function() {
          return ke = "useTransition", yt(), x1();
        },
        useMutableSource: function(a, l, m) {
          return ke = "useMutableSource", yt(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return ke = "useSyncExternalStore", yt(), J_(a, l);
        },
        useId: function() {
          return ke = "useId", yt(), iy();
        },
        unstable_isNewReconciler: S
      }, D1 = {
        readContext: function(a) {
          return K(a);
        },
        useCallback: function(a, l) {
          return ke = "useCallback", yt(), ty(a, l);
        },
        useContext: function(a) {
          return ke = "useContext", yt(), K(a);
        },
        useEffect: function(a, l) {
          return ke = "useEffect", yt(), xf(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return ke = "useImperativeHandle", yt(), $_(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return ke = "useInsertionEffect", yt(), Q_(a, l);
        },
        useLayoutEffect: function(a, l) {
          return ke = "useLayoutEffect", yt(), Z_(a, l);
        },
        useMemo: function(a, l) {
          ke = "useMemo", yt();
          var m = Pt.current;
          Pt.current = sy;
          try {
            return ny(a, l);
          } finally {
            Pt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          ke = "useReducer", yt();
          var _ = Pt.current;
          Pt.current = sy;
          try {
            return AA(a, l, m);
          } finally {
            Pt.current = _;
          }
        },
        useRef: function(a) {
          return ke = "useRef", yt(), q_();
        },
        useState: function(a) {
          ke = "useState", yt();
          var l = Pt.current;
          Pt.current = sy;
          try {
            return K_(a);
          } finally {
            Pt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return ke = "useDebugValue", yt(), ey();
        },
        useDeferredValue: function(a) {
          return ke = "useDeferredValue", yt(), y1(a);
        },
        useTransition: function() {
          return ke = "useTransition", yt(), S1();
        },
        useMutableSource: function(a, l, m) {
          return ke = "useMutableSource", yt(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return ke = "useSyncExternalStore", yt(), J_(a, l);
        },
        useId: function() {
          return ke = "useId", yt(), iy();
        },
        unstable_isNewReconciler: S
      }, ul = {
        readContext: function(a) {
          return PA(), K(a);
        },
        useCallback: function(a, l) {
          return ke = "useCallback", on(), Wn(), wA(a, l);
        },
        useContext: function(a) {
          return ke = "useContext", on(), Wn(), K(a);
        },
        useEffect: function(a, l) {
          return ke = "useEffect", on(), Wn(), og(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return ke = "useImperativeHandle", on(), Wn(), CA(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return ke = "useInsertionEffect", on(), Wn(), TA(a, l);
        },
        useLayoutEffect: function(a, l) {
          return ke = "useLayoutEffect", on(), Wn(), bA(a, l);
        },
        useMemo: function(a, l) {
          ke = "useMemo", on(), Wn();
          var m = Pt.current;
          Pt.current = ul;
          try {
            return RA(a, l);
          } finally {
            Pt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          ke = "useReducer", on(), Wn();
          var _ = Pt.current;
          Pt.current = ul;
          try {
            return xA(a, l, m);
          } finally {
            Pt.current = _;
          }
        },
        useRef: function(a) {
          return ke = "useRef", on(), Wn(), EA(a);
        },
        useState: function(a) {
          ke = "useState", on(), Wn();
          var l = Pt.current;
          Pt.current = ul;
          try {
            return rg(a);
          } finally {
            Pt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return ke = "useDebugValue", on(), Wn(), void 0;
        },
        useDeferredValue: function(a) {
          return ke = "useDeferredValue", on(), Wn(), BA(a);
        },
        useTransition: function() {
          return ke = "useTransition", on(), Wn(), DA();
        },
        useMutableSource: function(a, l, m) {
          return ke = "useMutableSource", on(), Wn(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return ke = "useSyncExternalStore", on(), Wn(), MA(a, l, m);
        },
        useId: function() {
          return ke = "useId", on(), Wn(), LA();
        },
        unstable_isNewReconciler: S
      }, Ro = {
        readContext: function(a) {
          return PA(), K(a);
        },
        useCallback: function(a, l) {
          return ke = "useCallback", on(), yt(), ty(a, l);
        },
        useContext: function(a) {
          return ke = "useContext", on(), yt(), K(a);
        },
        useEffect: function(a, l) {
          return ke = "useEffect", on(), yt(), xf(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return ke = "useImperativeHandle", on(), yt(), $_(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return ke = "useInsertionEffect", on(), yt(), Q_(a, l);
        },
        useLayoutEffect: function(a, l) {
          return ke = "useLayoutEffect", on(), yt(), Z_(a, l);
        },
        useMemo: function(a, l) {
          ke = "useMemo", on(), yt();
          var m = Pt.current;
          Pt.current = Ro;
          try {
            return ny(a, l);
          } finally {
            Pt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          ke = "useReducer", on(), yt();
          var _ = Pt.current;
          Pt.current = Ro;
          try {
            return SA(a, l, m);
          } finally {
            Pt.current = _;
          }
        },
        useRef: function(a) {
          return ke = "useRef", on(), yt(), q_();
        },
        useState: function(a) {
          ke = "useState", on(), yt();
          var l = Pt.current;
          Pt.current = Ro;
          try {
            return Y_(a);
          } finally {
            Pt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return ke = "useDebugValue", on(), yt(), ey();
        },
        useDeferredValue: function(a) {
          return ke = "useDeferredValue", on(), yt(), _1(a);
        },
        useTransition: function() {
          return ke = "useTransition", on(), yt(), x1();
        },
        useMutableSource: function(a, l, m) {
          return ke = "useMutableSource", on(), yt(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return ke = "useSyncExternalStore", on(), yt(), J_(a, l);
        },
        useId: function() {
          return ke = "useId", on(), yt(), iy();
        },
        unstable_isNewReconciler: S
      }, sy = {
        readContext: function(a) {
          return PA(), K(a);
        },
        useCallback: function(a, l) {
          return ke = "useCallback", on(), yt(), ty(a, l);
        },
        useContext: function(a) {
          return ke = "useContext", on(), yt(), K(a);
        },
        useEffect: function(a, l) {
          return ke = "useEffect", on(), yt(), xf(a, l);
        },
        useImperativeHandle: function(a, l, m) {
          return ke = "useImperativeHandle", on(), yt(), $_(a, l, m);
        },
        useInsertionEffect: function(a, l) {
          return ke = "useInsertionEffect", on(), yt(), Q_(a, l);
        },
        useLayoutEffect: function(a, l) {
          return ke = "useLayoutEffect", on(), yt(), Z_(a, l);
        },
        useMemo: function(a, l) {
          ke = "useMemo", on(), yt();
          var m = Pt.current;
          Pt.current = Ro;
          try {
            return ny(a, l);
          } finally {
            Pt.current = m;
          }
        },
        useReducer: function(a, l, m) {
          ke = "useReducer", on(), yt();
          var _ = Pt.current;
          Pt.current = Ro;
          try {
            return AA(a, l, m);
          } finally {
            Pt.current = _;
          }
        },
        useRef: function(a) {
          return ke = "useRef", on(), yt(), q_();
        },
        useState: function(a) {
          ke = "useState", on(), yt();
          var l = Pt.current;
          Pt.current = Ro;
          try {
            return K_(a);
          } finally {
            Pt.current = l;
          }
        },
        useDebugValue: function(a, l) {
          return ke = "useDebugValue", on(), yt(), ey();
        },
        useDeferredValue: function(a) {
          return ke = "useDeferredValue", on(), yt(), y1(a);
        },
        useTransition: function() {
          return ke = "useTransition", on(), yt(), S1();
        },
        useMutableSource: function(a, l, m) {
          return ke = "useMutableSource", on(), yt(), void 0;
        },
        useSyncExternalStore: function(a, l, m) {
          return ke = "useSyncExternalStore", on(), yt(), J_(a, l);
        },
        useId: function() {
          return ke = "useId", on(), yt(), iy();
        },
        unstable_isNewReconciler: S
      };
    }
    var nc = i.unstable_now, L1 = 0, ay = -1, lg = -1, oy = -1, IA = !1, ly = !1;
    function P1() {
      return IA;
    }
    function sF() {
      ly = !0;
    }
    function aF() {
      IA = !1, ly = !1;
    }
    function oF() {
      IA = ly, ly = !1;
    }
    function I1() {
      return L1;
    }
    function U1() {
      L1 = nc();
    }
    function UA(a) {
      lg = nc(), a.actualStartTime < 0 && (a.actualStartTime = nc());
    }
    function F1(a) {
      lg = -1;
    }
    function uy(a, l) {
      if (lg >= 0) {
        var m = nc() - lg;
        a.actualDuration += m, l && (a.selfBaseDuration = m), lg = -1;
      }
    }
    function $a(a) {
      if (ay >= 0) {
        var l = nc() - ay;
        ay = -1;
        for (var m = a.return; m !== null; ) {
          switch (m.tag) {
            case V:
              var _ = m.stateNode;
              _.effectDuration += l;
              return;
            case pe:
              var A = m.stateNode;
              A.effectDuration += l;
              return;
          }
          m = m.return;
        }
      }
    }
    function FA(a) {
      if (oy >= 0) {
        var l = nc() - oy;
        oy = -1;
        for (var m = a.return; m !== null; ) {
          switch (m.tag) {
            case V:
              var _ = m.stateNode;
              _ !== null && (_.passiveEffectDuration += l);
              return;
            case pe:
              var A = m.stateNode;
              A !== null && (A.passiveEffectDuration += l);
              return;
          }
          m = m.return;
        }
      }
    }
    function eo() {
      ay = nc();
    }
    function NA() {
      oy = nc();
    }
    function OA(a) {
      for (var l = a.child; l; )
        a.actualDuration += l.actualDuration, l = l.sibling;
    }
    function cy(a, l) {
      return {
        value: a,
        source: l,
        stack: qm(l)
      };
    }
    function lF(a, l) {
      return !0;
    }
    function HA(a, l) {
      try {
        var m = lF(a, l);
        if (m === !1)
          return;
        var _ = l.value, A = l.source, R = l.stack, P = R !== null ? R : "";
        if (_ != null && _._suppressLogging) {
          if (a.tag === U)
            return;
          console.error(_);
        }
        var z = A ? Fe(A) : null, W = z ? "The above error occurred in the <" + z + "> component:" : "The above error occurred in one of your React components:", $;
        if (a.tag === V)
          $ = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var oe = Fe(a) || "Anonymous";
          $ = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + oe + ".");
        }
        var xe = W + `
` + P + `

` + ("" + $);
        console.error(xe);
      } catch (Be) {
        setTimeout(function() {
          throw Be;
        });
      }
    }
    var uF = typeof WeakMap == "function" ? WeakMap : Map;
    function N1(a, l, m) {
      var _ = Ce(Qn, m);
      _.tag = Xn, _.payload = {
        element: null
      };
      var A = l.value;
      return _.callback = function() {
        mO(A), HA(a, l);
      }, _;
    }
    function zA(a, l, m) {
      var _ = Ce(Qn, m);
      _.tag = Xn;
      var A = a.type.getDerivedStateFromError;
      if (typeof A == "function") {
        var R = l.value;
        _.payload = function() {
          return A(R);
        }, _.callback = function() {
          iR(a), HA(a, l);
        };
      }
      var P = a.stateNode;
      return P !== null && typeof P.componentDidCatch == "function" && (_.callback = function() {
        iR(a), HA(a, l), typeof A != "function" && hO(this);
        var W = l.value, $ = l.stack;
        this.componentDidCatch(W, {
          componentStack: $ !== null ? $ : ""
        }), typeof A != "function" && (wr(a.lanes, gn) || d("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Fe(a) || "Unknown"));
      }), _;
    }
    function O1(a, l, m) {
      var _ = a.pingCache, A;
      if (_ === null ? (_ = a.pingCache = new uF(), A = /* @__PURE__ */ new Set(), _.set(l, A)) : (A = _.get(l), A === void 0 && (A = /* @__PURE__ */ new Set(), _.set(l, A))), !A.has(m)) {
        A.add(m);
        var R = gO.bind(null, a, l, m);
        bs && Eg(a, m), l.then(R, R);
      }
    }
    function cF(a, l, m, _) {
      var A = a.updateQueue;
      if (A === null) {
        var R = /* @__PURE__ */ new Set();
        R.add(m), a.updateQueue = R;
      } else
        A.add(m);
    }
    function fF(a, l) {
      var m = a.tag;
      if ((a.mode & zn) === rn && (m === N || m === re || m === H)) {
        var _ = a.alternate;
        _ ? (a.updateQueue = _.updateQueue, a.memoizedState = _.memoizedState, a.lanes = _.lanes) : (a.updateQueue = null, a.memoizedState = null);
      }
    }
    function H1(a) {
      var l = a;
      do {
        if (l.tag === J && qU(l))
          return l;
        l = l.return;
      } while (l !== null);
      return null;
    }
    function z1(a, l, m, _, A) {
      if ((a.mode & zn) === rn) {
        if (a === l)
          a.flags |= Yt;
        else {
          if (a.flags |= ot, m.flags |= te, m.flags &= -52805, m.tag === U) {
            var R = m.alternate;
            if (R === null)
              m.tag = Se;
            else {
              var P = Ce(Qn, gn);
              P.tag = jt, _t(m, P);
            }
          }
          m.lanes = cn(m.lanes, gn);
        }
        return a;
      }
      return a.flags |= Yt, a.lanes = A, a;
    }
    function dF(a, l, m, _, A) {
      if (m.flags |= Vn, bs && Eg(a, A), _ !== null && typeof _ == "object" && typeof _.then == "function") {
        var R = _;
        fF(m);
        var P = H1(l);
        if (P !== null) {
          P.flags &= ~an, z1(P, l, m, a, A), P.mode & zn && O1(a, R, A), cF(P, a, R);
          return;
        } else {
          if (!y_(A)) {
            O1(a, R, A), yM();
            return;
          }
          var z = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          _ = z;
        }
      } else if (os() && m.mode & zn) {
        NU();
        var W = H1(l);
        if (W !== null) {
          (W.flags & Yt) === Ke && (W.flags |= an), z1(W, l, m, a, A), iA(_);
          return;
        }
      }
      sO(_), _ = cy(_, m);
      var $ = l;
      do {
        switch ($.tag) {
          case V: {
            var oe = _;
            $.flags |= Yt;
            var xe = Ol(A);
            $.lanes = cn($.lanes, xe);
            var Be = N1($, oe, xe);
            dn($, Be);
            return;
          }
          case U:
            var Ne = _, $e = $.type, ut = $.stateNode;
            if (($.flags & ot) === Ke && (typeof $e.getDerivedStateFromError == "function" || ut !== null && typeof ut.componentDidCatch == "function" && !Kw(ut))) {
              $.flags |= Yt;
              var Zt = Ol(A);
              $.lanes = cn($.lanes, Zt);
              var hn = zA($, Ne, Zt);
              dn($, hn);
              return;
            }
            break;
        }
        $ = $.return;
      } while ($ !== null);
    }
    function hF() {
      return null;
    }
    function cl(a) {
      a.flags |= Pe;
    }
    function G1(a) {
      a.flags |= un, a.flags |= tt;
    }
    function k1(a, l) {
      var m = a !== null && a.child === l.child;
      if (m)
        return !0;
      if ((l.flags & et) !== Ke)
        return !1;
      for (var _ = l.child; _ !== null; ) {
        if ((_.flags & _e) !== Ke || (_.subtreeFlags & _e) !== Ke)
          return !1;
        _ = _.sibling;
      }
      return !0;
    }
    var ug, cg, fy, dy;
    if (ts)
      ug = function(a, l, m, _) {
        for (var A = l.child; A !== null; ) {
          if (A.tag === I || A.tag === Y)
            fi(a, A.stateNode);
          else if (A.tag !== L) {
            if (A.child !== null) {
              A.child.return = A, A = A.child;
              continue;
            }
          }
          if (A === l)
            return;
          for (; A.sibling === null; ) {
            if (A.return === null || A.return === l)
              return;
            A = A.return;
          }
          A.sibling.return = A.return, A = A.sibling;
        }
      }, cg = function(a, l) {
      }, fy = function(a, l, m, _, A) {
        var R = a.memoizedProps;
        if (R !== _) {
          var P = l.stateNode, z = eg(), W = Rl(P, m, R, _, A, z);
          l.updateQueue = W, W && cl(l);
        }
      }, dy = function(a, l, m, _) {
        m !== _ && cl(l);
      };
    else if (Jo) {
      ug = function(a, l, m, _) {
        for (var A = l.child; A !== null; ) {
          if (A.tag === I) {
            var R = A.stateNode;
            if (m && _) {
              var P = A.memoizedProps, z = A.type;
              R = Yc(R, z, P, A);
            }
            fi(a, R);
          } else if (A.tag === Y) {
            var W = A.stateNode;
            if (m && _) {
              var $ = A.memoizedProps;
              W = Dl(W, $, A);
            }
            fi(a, W);
          } else if (A.tag !== L) {
            if (A.tag === Je && A.memoizedState !== null) {
              var oe = A.child;
              oe !== null && (oe.return = A), ug(a, A, !0, !0);
            } else if (A.child !== null) {
              A.child.return = A, A = A.child;
              continue;
            }
          }
          if (A = A, A === l)
            return;
          for (; A.sibling === null; ) {
            if (A.return === null || A.return === l)
              return;
            A = A.return;
          }
          A.sibling.return = A.return, A = A.sibling;
        }
      };
      var V1 = function(a, l, m, _) {
        for (var A = l.child; A !== null; ) {
          if (A.tag === I) {
            var R = A.stateNode;
            if (m && _) {
              var P = A.memoizedProps, z = A.type;
              R = Yc(R, z, P, A);
            }
            s_(a, R);
          } else if (A.tag === Y) {
            var W = A.stateNode;
            if (m && _) {
              var $ = A.memoizedProps;
              W = Dl(W, $, A);
            }
            s_(a, W);
          } else if (A.tag !== L) {
            if (A.tag === Je && A.memoizedState !== null) {
              var oe = A.child;
              oe !== null && (oe.return = A), V1(a, A, !0, !0);
            } else if (A.child !== null) {
              A.child.return = A, A = A.child;
              continue;
            }
          }
          if (A = A, A === l)
            return;
          for (; A.sibling === null; ) {
            if (A.return === null || A.return === l)
              return;
            A = A.return;
          }
          A.sibling.return = A.return, A = A.sibling;
        }
      };
      cg = function(a, l) {
        var m = l.stateNode, _ = k1(a, l);
        if (!_) {
          var A = m.containerInfo, R = Xc(A);
          V1(R, l, !1, !1), m.pendingChildren = R, cl(l), ca(A, R);
        }
      }, fy = function(a, l, m, _, A) {
        var R = a.stateNode, P = a.memoizedProps, z = k1(a, l);
        if (z && P === _) {
          l.stateNode = R;
          return;
        }
        var W = l.stateNode, $ = eg(), oe = null;
        if (P !== _ && (oe = Rl(W, m, P, _, A, $)), z && oe === null) {
          l.stateNode = R;
          return;
        }
        var xe = LS(R, oe, m, P, _, l, z, W);
        ua(xe, m, _, A, $) && cl(l), l.stateNode = xe, z ? cl(l) : ug(xe, l, !1, !1);
      }, dy = function(a, l, m, _) {
        if (m !== _) {
          var A = uA(), R = eg();
          l.stateNode = Bl(_, A, R, l), cl(l);
        } else
          l.stateNode = a.stateNode;
      };
    } else
      cg = function(a, l) {
      }, fy = function(a, l, m, _, A) {
      }, dy = function(a, l, m, _) {
      };
    function fg(a, l) {
      if (!os())
        switch (a.tailMode) {
          case "hidden": {
            for (var m = a.tail, _ = null; m !== null; )
              m.alternate !== null && (_ = m), m = m.sibling;
            _ === null ? a.tail = null : _.sibling = null;
            break;
          }
          case "collapsed": {
            for (var A = a.tail, R = null; A !== null; )
              A.alternate !== null && (R = A), A = A.sibling;
            R === null ? !l && a.tail !== null ? a.tail.sibling = null : a.tail = null : R.sibling = null;
            break;
          }
        }
    }
    function Xr(a) {
      var l = a.alternate !== null && a.alternate.child === a.child, m = Ze, _ = Ke;
      if (l) {
        if ((a.mode & Pn) !== rn) {
          for (var W = a.selfBaseDuration, $ = a.child; $ !== null; )
            m = cn(m, cn($.lanes, $.childLanes)), _ |= $.subtreeFlags & je, _ |= $.flags & je, W += $.treeBaseDuration, $ = $.sibling;
          a.treeBaseDuration = W;
        } else
          for (var oe = a.child; oe !== null; )
            m = cn(m, cn(oe.lanes, oe.childLanes)), _ |= oe.subtreeFlags & je, _ |= oe.flags & je, oe.return = a, oe = oe.sibling;
        a.subtreeFlags |= _;
      } else {
        if ((a.mode & Pn) !== rn) {
          for (var A = a.actualDuration, R = a.selfBaseDuration, P = a.child; P !== null; )
            m = cn(m, cn(P.lanes, P.childLanes)), _ |= P.subtreeFlags, _ |= P.flags, A += P.actualDuration, R += P.treeBaseDuration, P = P.sibling;
          a.actualDuration = A, a.treeBaseDuration = R;
        } else
          for (var z = a.child; z !== null; )
            m = cn(m, cn(z.lanes, z.childLanes)), _ |= z.subtreeFlags, _ |= z.flags, z.return = a, z = z.sibling;
        a.subtreeFlags |= _;
      }
      return a.childLanes = m, l;
    }
    function W1(a, l, m) {
      var _ = l.pendingProps;
      switch (ZS(l), l.tag) {
        case O:
        case ue:
        case H:
        case N:
        case re:
        case Q:
        case fe:
        case pe:
        case j:
        case Z:
          return Xr(l), null;
        case U: {
          var A = l.type;
          return rs(A) && Zo(l), Xr(l), null;
        }
        case V: {
          var R = l.stateNode;
          if (Dh(l), Em(l), mA(), R.pendingContext && (R.context = R.pendingContext, R.pendingContext = null), a === null || a.child === null) {
            var P = jm(l);
            if (P)
              cl(l);
            else if (a !== null) {
              var z = a.memoizedState;
              // Check if this is a client root
              (!z.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (l.flags & an) !== Ke) && (l.flags |= wt, t1());
            }
          }
          return cg(a, l), Xr(l), null;
        }
        case I: {
          fA(l);
          var W = uA(), $ = l.type;
          if (a !== null && l.stateNode != null)
            fy(a, l, $, _, W), a.ref !== l.ref && G1(l);
          else {
            if (!_) {
              if (l.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return Xr(l), null;
            }
            var oe = eg(), xe = jm(l);
            if (xe)
              zU(l, W, oe) && cl(l);
            else {
              var Be = $i($, _, W, oe, l);
              ug(Be, l, !1, !1), l.stateNode = Be, ua(Be, $, _, W, oe) && cl(l);
            }
            l.ref !== null && G1(l);
          }
          return Xr(l), null;
        }
        case Y: {
          var Ne = _;
          if (a && l.stateNode != null) {
            var $e = a.memoizedProps;
            dy(a, l, $e, Ne);
          } else {
            if (typeof Ne != "string" && l.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var ut = uA(), Zt = eg(), hn = jm(l);
            hn ? GU(l) && cl(l) : l.stateNode = Bl(Ne, ut, Zt, l);
          }
          return Xr(l), null;
        }
        case J: {
          Ph(l);
          var nn = l.memoizedState;
          {
            if (WU() && (l.mode & zn) !== rn && (l.flags & ot) === Ke)
              return e1(l), Rh(), l.flags |= an | Vn | Yt, l;
            if (nn !== null && nn.dehydrated !== null) {
              var hi = jm(l);
              if (a === null) {
                if (!hi)
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                if (kU(l), Xr(l), (l.mode & Pn) !== rn) {
                  var pi = nn !== null;
                  if (pi) {
                    var Te = l.child;
                    Te !== null && (l.treeBaseDuration -= Te.treeBaseDuration);
                  }
                }
                return null;
              } else {
                if (Rh(), (l.flags & ot) === Ke && (l.memoizedState = null), l.flags |= Pe, Xr(l), (l.mode & Pn) !== rn) {
                  var Ge = nn !== null;
                  if (Ge) {
                    var Ae = l.child;
                    Ae !== null && (l.treeBaseDuration -= Ae.treeBaseDuration);
                  }
                }
                return null;
              }
            }
            t1();
          }
          if ((l.flags & ot) !== Ke)
            return l.lanes = m, (l.mode & Pn) !== rn && OA(l), l;
          var dt = nn !== null, qt = !1;
          if (a === null)
            jm(l);
          else {
            var Ut = a.memoizedState;
            qt = Ut !== null;
          }
          if (dt && !qt) {
            var Dn = l.child;
            if (Dn.flags |= Ot, (l.mode & zn) !== rn) {
              var Jn = a === null && (l.memoizedProps.unstable_avoidThisFallback !== !0 || !0);
              Jn || dA(wo.current, l1) ? rO() : yM();
            }
          }
          var ii = l.updateQueue;
          if (ii !== null && (l.flags |= Pe), Xr(l), (l.mode & Pn) !== rn && dt) {
            var Yn = l.child;
            Yn !== null && (l.treeBaseDuration -= Yn.treeBaseDuration);
          }
          return null;
        }
        case L:
          return Dh(l), cg(a, l), a === null && MS(l.stateNode.containerInfo), Xr(l), null;
        case ie:
          var Mi = l.type._context;
          return h(Mi, l), Xr(l), null;
        case Se: {
          var Gn = l.type;
          return rs(Gn) && Zo(l), Xr(l), null;
        }
        case ye: {
          Ph(l);
          var En = l.memoizedState;
          if (En === null)
            return Xr(l), null;
          var Ki = (l.flags & ot) !== Ke, Ei = En.rendering;
          if (Ei === null)
            if (Ki)
              fg(En, !1);
            else {
              var io = aO() && (a === null || (a.flags & ot) === Ke);
              if (!io)
                for (var Kr = l.child; Kr !== null; ) {
                  var va = W_(Kr);
                  if (va !== null) {
                    Ki = !0, l.flags |= ot, fg(En, !1);
                    var _a = va.updateQueue;
                    return _a !== null && (l.updateQueue = _a, l.flags |= Pe), l.subtreeFlags = Ke, JU(l, m), $u(l, hA(wo.current, tg)), l.child;
                  }
                  Kr = Kr.sibling;
                }
              En.tail !== null && Wi() > Ow() && (l.flags |= ot, Ki = !0, fg(En, !1), l.lanes = Pm);
            }
          else {
            if (!Ki) {
              var hl = W_(Ei);
              if (hl !== null) {
                l.flags |= ot, Ki = !0;
                var Xh = hl.updateQueue;
                if (Xh !== null && (l.updateQueue = Xh, l.flags |= Pe), fg(En, !0), En.tail === null && En.tailMode === "hidden" && !Ei.alternate && !os())
                  return Xr(l), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              Wi() * 2 - En.renderingStartTime > Ow() && m !== Cr && (l.flags |= ot, Ki = !0, fg(En, !1), l.lanes = Pm);
            }
            if (En.isBackwards)
              Ei.sibling = l.child, l.child = Ei;
            else {
              var Jh = En.last;
              Jh !== null ? Jh.sibling = Ei : l.child = Ei, En.last = Ei;
            }
          }
          if (En.tail !== null) {
            var ya = En.tail;
            En.rendering = ya, En.tail = ya.sibling, En.renderingStartTime = Wi(), ya.sibling = null;
            var Cf = wo.current;
            return Ki ? Cf = hA(Cf, tg) : Cf = Lh(Cf), $u(l, Cf), ya;
          }
          return Xr(l), null;
        }
        case Xe:
          break;
        case Je:
        case Ye: {
          _M(l);
          var NM = l.memoizedState, BR = NM !== null;
          if (a !== null) {
            var r3 = a.memoizedState, s3 = r3 !== null;
            s3 !== BR && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !E && (l.flags |= Ot);
          }
          return !BR || (l.mode & zn) === rn ? Xr(l) : wr(fl, Cr) && (Xr(l), ts && l.subtreeFlags & (We | Pe) && (l.flags |= Ot)), null;
        }
        case At:
          return null;
        case Ct:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + l.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    var dg = r.ReactCurrentOwner, Bo = !1, GA, hg, kA, VA, WA, Sf, XA, hy;
    GA = {}, hg = {}, kA = {}, VA = {}, WA = {}, Sf = !1, XA = {}, hy = {};
    function ws(a, l, m, _) {
      a === null ? l.child = s1(l, null, m, _) : l.child = Bh(l, a.child, m, _);
    }
    function pF(a, l, m, _) {
      l.child = Bh(l, a.child, null, _), l.child = Bh(l, null, m, _);
    }
    function X1(a, l, m, _, A) {
      if (l.type !== l.elementType) {
        var R = m.propTypes;
        R && Bi(
          R,
          _,
          // Resolved props
          "prop",
          Ie(m)
        );
      }
      var P = m.render, z = l.ref, W, $;
      F(l, A), dr(l);
      {
        if (dg.current = l, Ka(!0), W = Nh(a, l, P, _, z, A), $ = Oh(), l.mode & _i) {
          An(!0);
          try {
            W = Nh(a, l, P, _, z, A), $ = Oh();
          } finally {
            An(!1);
          }
        }
        Ka(!1);
      }
      return pa(), a !== null && !Bo ? (u1(a, l, A), Yl(a, l, A)) : (os() && $ && QS(l), l.flags |= Dt, ws(a, l, W, A), l.child);
    }
    function J1(a, l, m, _, A) {
      if (a === null) {
        var R = m.type;
        if (PO(R) && m.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        m.defaultProps === void 0) {
          var P = R;
          return P = Wh(R), l.tag = H, l.type = P, KA(l, R), Y1(a, l, P, _, A);
        }
        {
          var z = R.propTypes;
          z && Bi(
            z,
            _,
            // Resolved props
            "prop",
            Ie(R)
          );
        }
        var W = RM(m.type, null, _, l, l.mode, A);
        return W.ref = l.ref, W.return = l, l.child = W, W;
      }
      {
        var $ = m.type, oe = $.propTypes;
        oe && Bi(
          oe,
          _,
          // Resolved props
          "prop",
          Ie($)
        );
      }
      var xe = a.child, Be = ZA(a, A);
      if (!Be) {
        var Ne = xe.memoizedProps, $e = m.compare;
        if ($e = $e !== null ? $e : Ya, $e(Ne, _) && a.ref === l.ref)
          return Yl(a, l, A);
      }
      l.flags |= Dt;
      var ut = bf(xe, _);
      return ut.ref = l.ref, ut.return = l, l.child = ut, ut;
    }
    function Y1(a, l, m, _, A) {
      if (l.type !== l.elementType) {
        var R = l.elementType;
        if (R.$$typeof === le) {
          var P = R, z = P._payload, W = P._init;
          try {
            R = W(z);
          } catch {
            R = null;
          }
          var $ = R && R.propTypes;
          $ && Bi(
            $,
            _,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Ie(R)
          );
        }
      }
      if (a !== null) {
        var oe = a.memoizedProps;
        if (Ya(oe, _) && a.ref === l.ref && // Prevent bailout if the implementation changed due to hot reload.
        l.type === a.type)
          if (Bo = !1, ZA(a, A))
            (a.flags & te) !== Ke && (Bo = !0);
          else return l.lanes = a.lanes, Yl(a, l, A);
      }
      return JA(a, l, m, _, A);
    }
    function K1(a, l, m) {
      var _ = l.pendingProps, A = _.children, R = a !== null ? a.memoizedState : null;
      if (_.mode === "hidden" || E)
        if ((l.mode & zn) === rn) {
          var P = {
            baseLanes: Ze,
            cachePool: null
          };
          l.memoizedState = P, Hy(l, m);
        } else if (wr(m, Cr)) {
          var xe = {
            baseLanes: Ze,
            cachePool: null
          };
          l.memoizedState = xe;
          var Be = R !== null ? R.baseLanes : m;
          Hy(l, Be);
        } else {
          var z = null, W;
          if (R !== null) {
            var $ = R.baseLanes;
            W = cn($, m);
          } else
            W = m;
          l.lanes = l.childLanes = Cr;
          var oe = {
            baseLanes: W,
            cachePool: z
          };
          return l.memoizedState = oe, l.updateQueue = null, Hy(l, W), null;
        }
      else {
        var Ne;
        R !== null ? (Ne = cn(R.baseLanes, m), l.memoizedState = null) : Ne = m, Hy(l, Ne);
      }
      return ws(a, l, A, m), l.child;
    }
    function mF(a, l, m) {
      var _ = l.pendingProps;
      return ws(a, l, _, m), l.child;
    }
    function gF(a, l, m) {
      var _ = l.pendingProps.children;
      return ws(a, l, _, m), l.child;
    }
    function vF(a, l, m) {
      {
        l.flags |= Pe;
        {
          var _ = l.stateNode;
          _.effectDuration = 0, _.passiveEffectDuration = 0;
        }
      }
      var A = l.pendingProps, R = A.children;
      return ws(a, l, R, m), l.child;
    }
    function q1(a, l) {
      var m = l.ref;
      (a === null && m !== null || a !== null && a.ref !== m) && (l.flags |= un, l.flags |= tt);
    }
    function JA(a, l, m, _, A) {
      if (l.type !== l.elementType) {
        var R = m.propTypes;
        R && Bi(
          R,
          _,
          // Resolved props
          "prop",
          Ie(m)
        );
      }
      var P;
      {
        var z = jn(l, m, !0);
        P = di(l, z);
      }
      var W, $;
      F(l, A), dr(l);
      {
        if (dg.current = l, Ka(!0), W = Nh(a, l, m, _, P, A), $ = Oh(), l.mode & _i) {
          An(!0);
          try {
            W = Nh(a, l, m, _, P, A), $ = Oh();
          } finally {
            An(!1);
          }
        }
        Ka(!1);
      }
      return pa(), a !== null && !Bo ? (u1(a, l, A), Yl(a, l, A)) : (os() && $ && QS(l), l.flags |= Dt, ws(a, l, W, A), l.child);
    }
    function j1(a, l, m, _, A) {
      {
        switch (dR(l)) {
          case !1: {
            var R = l.stateNode, P = l.type, z = new P(l.memoizedProps, R.context), W = z.state;
            R.updater.enqueueSetState(R, W, null);
            break;
          }
          case !0: {
            l.flags |= ot, l.flags |= Yt;
            var $ = new Error("Simulated error coming from DevTools"), oe = Ol(A);
            l.lanes = cn(l.lanes, oe);
            var xe = zA(l, cy($, l), oe);
            dn(l, xe);
            break;
          }
        }
        if (l.type !== l.elementType) {
          var Be = m.propTypes;
          Be && Bi(
            Be,
            _,
            // Resolved props
            "prop",
            Ie(m)
          );
        }
      }
      var Ne;
      rs(m) ? (Ne = !0, Du(l)) : Ne = !1, F(l, A);
      var $e = l.stateNode, ut;
      $e === null ? (a !== null && (a.alternate = null, l.alternate = null, l.flags |= We), JC(l, m, _), jS(l, m, _, A), ut = !0) : a === null ? ut = wU(l, m, _, A) : ut = RU(a, l, m, _, A);
      var Zt = YA(a, l, m, ut, Ne, A);
      {
        var hn = l.stateNode;
        ut && hn.props !== _ && (Sf || d("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Fe(l) || "a component"), Sf = !0);
      }
      return Zt;
    }
    function YA(a, l, m, _, A, R) {
      q1(a, l);
      var P = (l.flags & ot) !== Ke;
      if (!_ && !P)
        return A && Wd(l, m, !1), Yl(a, l, R);
      var z = l.stateNode;
      dg.current = l;
      var W;
      if (P && typeof m.getDerivedStateFromError != "function")
        W = null, F1();
      else {
        dr(l);
        {
          if (Ka(!0), W = z.render(), l.mode & _i) {
            An(!0);
            try {
              z.render();
            } finally {
              An(!1);
            }
          }
          Ka(!1);
        }
        pa();
      }
      return l.flags |= Dt, a !== null && P ? pF(a, l, W, R) : ws(a, l, W, R), l.memoizedState = z.state, A && Wd(l, m, !0), l.child;
    }
    function Q1(a) {
      var l = a.stateNode;
      l.pendingContext ? fr(a, l.pendingContext, l.pendingContext !== l.context) : l.context && fr(a, l.context, !1), cA(a, l.containerInfo);
    }
    function _F(a, l, m) {
      if (Q1(l), a === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var _ = l.pendingProps, A = l.memoizedState, R = A.element;
      ve(a, l), Bn(l, _, null, m);
      var P = l.memoizedState;
      l.stateNode;
      var z = P.element;
      if (br && A.isDehydrated) {
        var W = {
          element: z,
          isDehydrated: !1,
          cache: P.cache,
          transitions: P.transitions
        }, $ = l.updateQueue;
        if ($.baseState = W, l.memoizedState = W, l.flags & an) {
          var oe = new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");
          return Z1(a, l, z, m, oe);
        } else if (z !== R) {
          var xe = new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");
          return Z1(a, l, z, m, xe);
        } else {
          OU(l);
          var Be = s1(l, null, z, m);
          l.child = Be;
          for (var Ne = Be; Ne; )
            Ne.flags = Ne.flags & ~We | bt, Ne = Ne.sibling;
        }
      } else {
        if (Rh(), z === R)
          return Yl(a, l, m);
        ws(a, l, z, m);
      }
      return l.child;
    }
    function Z1(a, l, m, _, A) {
      return Rh(), iA(A), l.flags |= an, ws(a, l, m, _), l.child;
    }
    function yF(a, l, m) {
      a1(l), a === null && nA(l);
      var _ = l.type, A = l.pendingProps, R = a !== null ? a.memoizedProps : null, P = A.children, z = Gi(_, A);
      return z ? P = null : R !== null && Gi(_, R) && (l.flags |= at), q1(a, l), ws(a, l, P, m), l.child;
    }
    function xF(a, l) {
      return a === null && nA(l), null;
    }
    function SF(a, l, m, _) {
      a !== null && (a.alternate = null, l.alternate = null, l.flags |= We);
      var A = l.pendingProps, R = m, P = R._payload, z = R._init, W = z(P);
      l.type = W;
      var $ = l.tag = IO(W), oe = Cs(W, A), xe;
      switch ($) {
        case N:
          return KA(l, W), l.type = W = Wh(W), xe = JA(null, l, W, oe, _), xe;
        case U:
          return l.type = W = MM(W), xe = j1(null, l, W, oe, _), xe;
        case re:
          return l.type = W = EM(W), xe = X1(null, l, W, oe, _), xe;
        case Z: {
          if (l.type !== l.elementType) {
            var Be = W.propTypes;
            Be && Bi(
              Be,
              oe,
              // Resolved for outer only
              "prop",
              Ie(W)
            );
          }
          return xe = J1(
            null,
            l,
            W,
            Cs(W.type, oe),
            // The inner type can have defaults too
            _
          ), xe;
        }
      }
      var Ne = "";
      throw W !== null && typeof W == "object" && W.$$typeof === le && (Ne = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + W + ". " + ("Lazy element type must resolve to a class or function." + Ne));
    }
    function AF(a, l, m, _, A) {
      a !== null && (a.alternate = null, l.alternate = null, l.flags |= We), l.tag = U;
      var R;
      return rs(m) ? (R = !0, Du(l)) : R = !1, F(l, A), JC(l, m, _), jS(l, m, _, A), YA(null, l, m, !0, R, A);
    }
    function MF(a, l, m, _) {
      a !== null && (a.alternate = null, l.alternate = null, l.flags |= We);
      var A = l.pendingProps, R;
      {
        var P = jn(l, m, !1);
        R = di(l, P);
      }
      F(l, _);
      var z, W;
      dr(l);
      {
        if (m.prototype && typeof m.prototype.render == "function") {
          var $ = Ie(m) || "Unknown";
          GA[$] || (d("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", $, $), GA[$] = !0);
        }
        l.mode & _i && pr.recordLegacyContextWarning(l, null), Ka(!0), dg.current = l, z = Nh(null, l, m, A, R, _), W = Oh(), Ka(!1);
      }
      if (pa(), l.flags |= Dt, typeof z == "object" && z !== null && typeof z.render == "function" && z.$$typeof === void 0) {
        var oe = Ie(m) || "Unknown";
        hg[oe] || (d("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", oe, oe, oe), hg[oe] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof z == "object" && z !== null && typeof z.render == "function" && z.$$typeof === void 0
      ) {
        {
          var xe = Ie(m) || "Unknown";
          hg[xe] || (d("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", xe, xe, xe), hg[xe] = !0);
        }
        l.tag = U, l.memoizedState = null, l.updateQueue = null;
        var Be = !1;
        return rs(m) ? (Be = !0, Du(l)) : Be = !1, l.memoizedState = z.state !== null && z.state !== void 0 ? z.state : null, Me(l), XC(l, z), jS(l, m, A, _), YA(null, l, m, !0, Be, _);
      } else {
        if (l.tag = N, l.mode & _i) {
          An(!0);
          try {
            z = Nh(null, l, m, A, R, _), W = Oh();
          } finally {
            An(!1);
          }
        }
        return os() && W && QS(l), ws(null, l, z, _), KA(l, m), l.child;
      }
    }
    function KA(a, l) {
      {
        if (l && l.childContextTypes && d("%s(...): childContextTypes cannot be defined on a function component.", l.displayName || l.name || "Component"), a.ref !== null) {
          var m = "", _ = OS();
          _ && (m += `

Check the render method of \`` + _ + "`.");
          var A = _ || "", R = a._debugSource;
          R && (A = R.fileName + ":" + R.lineNumber), WA[A] || (WA[A] = !0, d("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", m));
        }
        if (typeof l.getDerivedStateFromProps == "function") {
          var P = Ie(l) || "Unknown";
          VA[P] || (d("%s: Function components do not support getDerivedStateFromProps.", P), VA[P] = !0);
        }
        if (typeof l.contextType == "object" && l.contextType !== null) {
          var z = Ie(l) || "Unknown";
          kA[z] || (d("%s: Function components do not support contextType.", z), kA[z] = !0);
        }
      }
    }
    var py = {
      dehydrated: null,
      treeContext: null,
      retryLane: yi
    };
    function my(a) {
      return {
        baseLanes: a,
        cachePool: hF()
      };
    }
    function $1(a, l) {
      var m = null;
      return {
        baseLanes: cn(a.baseLanes, l),
        cachePool: m
      };
    }
    function EF(a, l, m, _) {
      if (l !== null) {
        var A = l.memoizedState;
        if (A === null)
          return !1;
      }
      return dA(a, tg);
    }
    function ew(a, l) {
      return tf(a.childLanes, l);
    }
    function tw(a, l, m) {
      var _ = l.pendingProps;
      pR(l) && (l.flags |= ot);
      var A = wo.current, R = !1, P = (l.flags & ot) !== Ke;
      if (P || EF(A, a) ? (R = !0, l.flags &= ~ot) : (a === null || a.memoizedState !== null) && (A = KU(A, l1)), A = Lh(A), $u(l, A), a === null) {
        nA(l);
        {
          var z = l.memoizedState;
          if (z !== null) {
            var W = z.dehydrated;
            if (W !== null)
              return CF(l, W);
          }
        }
        var $ = _.children, oe = _.fallback;
        if (R) {
          var xe = TF(l, $, oe, m), Be = l.child;
          return Be.memoizedState = my(m), l.memoizedState = py, xe;
        } else
          return qA(l, $);
      } else {
        var Ne = a.memoizedState;
        if (Ne !== null) {
          {
            var $e = Ne.dehydrated;
            if ($e !== null)
              if (P) {
                if (l.flags & an)
                  return l.flags &= ~an, gy(a, l, m, new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                if (l.memoizedState !== null)
                  return l.child = a.child, l.flags |= ot, null;
                var ut = _.children, Zt = _.fallback, hn = bF(a, l, ut, Zt, m), nn = l.child;
                return nn.memoizedState = my(m), l.memoizedState = py, hn;
              } else return wF(a, l, $e, Ne, m);
          }
          if (R) {
            var hi = _.fallback, pi = _.children, Te = rw(a, l, pi, hi, m), Ge = l.child, Ae = a.child.memoizedState;
            return Ge.memoizedState = Ae === null ? my(m) : $1(Ae, m), Ge.childLanes = ew(a, m), l.memoizedState = py, Te;
          } else {
            var dt = _.children, qt = iw(a, l, dt, m);
            return l.memoizedState = null, qt;
          }
        } else if (R) {
          var Ut = _.fallback, Dn = _.children, Jn = rw(a, l, Dn, Ut, m), ii = l.child, Yn = a.child.memoizedState;
          return ii.memoizedState = Yn === null ? my(m) : $1(Yn, m), ii.childLanes = ew(a, m), l.memoizedState = py, Jn;
        } else {
          var Mi = _.children, Gn = iw(a, l, Mi, m);
          return l.memoizedState = null, Gn;
        }
      }
    }
    function qA(a, l, m) {
      var _ = a.mode, A = {
        mode: "visible",
        children: l
      }, R = jA(A, _);
      return R.return = a, a.child = R, R;
    }
    function TF(a, l, m, _) {
      var A = a.mode, R = a.child, P = {
        mode: "hidden",
        children: l
      }, z, W;
      return (A & zn) === rn && R !== null ? (z = R, z.childLanes = Ze, z.pendingProps = P, a.mode & Pn && (z.actualDuration = 0, z.actualStartTime = -1, z.selfBaseDuration = 0, z.treeBaseDuration = 0), W = ac(m, A, _, null)) : (z = jA(P, A), W = ac(m, A, _, null)), z.return = a, W.return = a, z.sibling = W, a.child = z, W;
    }
    function jA(a, l, m) {
      return sR(a, l, Ze, null);
    }
    function nw(a, l) {
      return bf(a, l);
    }
    function iw(a, l, m, _) {
      var A = a.child, R = A.sibling, P = nw(A, {
        mode: "visible",
        children: m
      });
      if ((l.mode & zn) === rn && (P.lanes = _), P.return = l, P.sibling = null, R !== null) {
        var z = l.deletions;
        z === null ? (l.deletions = [R], l.flags |= et) : z.push(R);
      }
      return l.child = P, P;
    }
    function rw(a, l, m, _, A) {
      var R = l.mode, P = a.child, z = P.sibling, W = {
        mode: "hidden",
        children: m
      }, $;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (R & zn) === rn && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        l.child !== P
      ) {
        var oe = l.child;
        $ = oe, $.childLanes = Ze, $.pendingProps = W, l.mode & Pn && ($.actualDuration = 0, $.actualStartTime = -1, $.selfBaseDuration = P.selfBaseDuration, $.treeBaseDuration = P.treeBaseDuration), l.deletions = null;
      } else
        $ = nw(P, W), $.subtreeFlags = P.subtreeFlags & je;
      var xe;
      return z !== null ? xe = bf(z, _) : (xe = ac(_, R, A, null), xe.flags |= We), xe.return = l, $.return = l, $.sibling = xe, l.child = $, xe;
    }
    function gy(a, l, m, _) {
      _ !== null && iA(_), Bh(l, a.child, null, m);
      var A = l.pendingProps, R = A.children, P = qA(l, R);
      return P.flags |= We, l.memoizedState = null, P;
    }
    function bF(a, l, m, _, A) {
      var R = l.mode, P = {
        mode: "visible",
        children: m
      }, z = jA(P, R), W = ac(_, R, A, null);
      return W.flags |= We, z.return = l, W.return = l, z.sibling = W, l.child = z, (l.mode & zn) !== rn && Bh(l, a.child, null, A), W;
    }
    function CF(a, l, m) {
      return (a.mode & zn) === rn ? (d("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), a.lanes = gn) : Kc(l) ? a.lanes = tl : a.lanes = Cr, null;
    }
    function wF(a, l, m, _, A) {
      if (FU(), (l.mode & zn) === rn)
        return gy(
          a,
          l,
          A,
          // TODO: When we delete legacy mode, we should make this error argument
          // required — every concurrent mode path that causes hydration to
          // de-opt to client rendering should have an error message.
          null
        );
      if (Kc(m))
        return gy(
          a,
          l,
          A,
          // TODO: The server should serialize the error message so we can log it
          // here on the client. Or, in production, a hash/id that corresponds to
          // the error.
          new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.")
        );
      var R = wr(A, a.childLanes);
      if (Bo || R) {
        var P = Fy();
        if (P !== null) {
          var z = A_(P, A);
          if (z !== yi && z !== _.retryLane) {
            _.retryLane = z;
            var W = Qn;
            _r(a, z, W);
          }
        }
        return yM(), gy(a, l, A, new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
      } else if (Ld(m)) {
        l.flags |= ot, l.child = a.child;
        var $ = vO.bind(null, a);
        return Su(m, $), null;
      } else {
        HU(l, m, _.treeContext);
        var oe = l.pendingProps, xe = oe.children, Be = qA(l, xe);
        return Be.flags |= bt, Be;
      }
    }
    function sw(a, l, m) {
      a.lanes = cn(a.lanes, l);
      var _ = a.alternate;
      _ !== null && (_.lanes = cn(_.lanes, l)), x(a.return, l, m);
    }
    function RF(a, l, m) {
      for (var _ = l; _ !== null; ) {
        if (_.tag === J) {
          var A = _.memoizedState;
          A !== null && sw(_, m, a);
        } else if (_.tag === ye)
          sw(_, m, a);
        else if (_.child !== null) {
          _.child.return = _, _ = _.child;
          continue;
        }
        if (_ === a)
          return;
        for (; _.sibling === null; ) {
          if (_.return === null || _.return === a)
            return;
          _ = _.return;
        }
        _.sibling.return = _.return, _ = _.sibling;
      }
    }
    function BF(a) {
      for (var l = a, m = null; l !== null; ) {
        var _ = l.alternate;
        _ !== null && W_(_) === null && (m = l), l = l.sibling;
      }
      return m;
    }
    function DF(a) {
      if (a !== void 0 && a !== "forwards" && a !== "backwards" && a !== "together" && !XA[a])
        if (XA[a] = !0, typeof a == "string")
          switch (a.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              d('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', a, a.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              d('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', a, a.toLowerCase());
              break;
            }
            default:
              d('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', a);
              break;
          }
        else
          d('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', a);
    }
    function LF(a, l) {
      a !== void 0 && !hy[a] && (a !== "collapsed" && a !== "hidden" ? (hy[a] = !0, d('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', a)) : l !== "forwards" && l !== "backwards" && (hy[a] = !0, d('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', a)));
    }
    function aw(a, l) {
      {
        var m = ht(a), _ = !m && typeof ee(a) == "function";
        if (m || _) {
          var A = m ? "array" : "iterable";
          return d("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", A, l, A), !1;
        }
      }
      return !0;
    }
    function PF(a, l) {
      if ((l === "forwards" || l === "backwards") && a !== void 0 && a !== null && a !== !1)
        if (ht(a)) {
          for (var m = 0; m < a.length; m++)
            if (!aw(a[m], m))
              return;
        } else {
          var _ = ee(a);
          if (typeof _ == "function") {
            var A = _.call(a);
            if (A)
              for (var R = A.next(), P = 0; !R.done; R = A.next()) {
                if (!aw(R.value, P))
                  return;
                P++;
              }
          } else
            d('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', l);
        }
    }
    function QA(a, l, m, _, A) {
      var R = a.memoizedState;
      R === null ? a.memoizedState = {
        isBackwards: l,
        rendering: null,
        renderingStartTime: 0,
        last: _,
        tail: m,
        tailMode: A
      } : (R.isBackwards = l, R.rendering = null, R.renderingStartTime = 0, R.last = _, R.tail = m, R.tailMode = A);
    }
    function ow(a, l, m) {
      var _ = l.pendingProps, A = _.revealOrder, R = _.tail, P = _.children;
      DF(A), LF(R, A), PF(P, A), ws(a, l, P, m);
      var z = wo.current, W = dA(z, tg);
      if (W)
        z = hA(z, tg), l.flags |= ot;
      else {
        var $ = a !== null && (a.flags & ot) !== Ke;
        $ && RF(l, l.child, m), z = Lh(z);
      }
      if ($u(l, z), (l.mode & zn) === rn)
        l.memoizedState = null;
      else
        switch (A) {
          case "forwards": {
            var oe = BF(l.child), xe;
            oe === null ? (xe = l.child, l.child = null) : (xe = oe.sibling, oe.sibling = null), QA(
              l,
              !1,
              // isBackwards
              xe,
              oe,
              R
            );
            break;
          }
          case "backwards": {
            var Be = null, Ne = l.child;
            for (l.child = null; Ne !== null; ) {
              var $e = Ne.alternate;
              if ($e !== null && W_($e) === null) {
                l.child = Ne;
                break;
              }
              var ut = Ne.sibling;
              Ne.sibling = Be, Be = Ne, Ne = ut;
            }
            QA(
              l,
              !0,
              // isBackwards
              Be,
              null,
              // last
              R
            );
            break;
          }
          case "together": {
            QA(
              l,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            l.memoizedState = null;
        }
      return l.child;
    }
    function IF(a, l, m) {
      cA(l, l.stateNode.containerInfo);
      var _ = l.pendingProps;
      return a === null ? l.child = Bh(l, null, _, m) : ws(a, l, _, m), l.child;
    }
    var lw = !1;
    function UF(a, l, m) {
      var _ = l.type, A = _._context, R = l.pendingProps, P = l.memoizedProps, z = R.value;
      {
        "value" in R || lw || (lw = !0, d("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var W = l.type.propTypes;
        W && Bi(W, R, "prop", "Context.Provider");
      }
      if (f(l, A, z), P !== null) {
        var $ = P.value;
        if (Ji($, z)) {
          if (P.children === R.children && !Il())
            return Yl(a, l, m);
        } else
          b(l, A, m);
      }
      var oe = R.children;
      return ws(a, l, oe, m), l.child;
    }
    var uw = !1;
    function FF(a, l, m) {
      var _ = l.type;
      _._context === void 0 ? _ !== _.Consumer && (uw || (uw = !0, d("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : _ = _._context;
      var A = l.pendingProps, R = A.children;
      typeof R != "function" && d("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), F(l, m);
      var P = K(_);
      dr(l);
      var z;
      return dg.current = l, Ka(!0), z = R(P), Ka(!1), pa(), l.flags |= Dt, ws(a, l, z, m), l.child;
    }
    function vy() {
      Bo = !0;
    }
    function Yl(a, l, m) {
      return a !== null && (l.dependencies = a.dependencies), F1(), zy(l.lanes), wr(m, l.childLanes) ? (XU(a, l), l.child) : null;
    }
    function NF(a, l, m) {
      {
        var _ = l.return;
        if (_ === null)
          throw new Error("Cannot swap the root fiber.");
        if (a.alternate = null, l.alternate = null, m.index = l.index, m.sibling = l.sibling, m.return = l.return, m.ref = l.ref, l === _.child)
          _.child = m;
        else {
          var A = _.child;
          if (A === null)
            throw new Error("Expected parent to have a child.");
          for (; A.sibling !== l; )
            if (A = A.sibling, A === null)
              throw new Error("Expected to find the previous sibling.");
          A.sibling = m;
        }
        var R = _.deletions;
        return R === null ? (_.deletions = [a], _.flags |= et) : R.push(a), m.flags |= We, m;
      }
    }
    function ZA(a, l) {
      var m = a.lanes;
      return !!wr(m, l);
    }
    function OF(a, l, m) {
      switch (l.tag) {
        case V:
          Q1(l), l.stateNode, Rh();
          break;
        case I:
          a1(l);
          break;
        case U: {
          var _ = l.type;
          rs(_) && Du(l);
          break;
        }
        case L:
          cA(l, l.stateNode.containerInfo);
          break;
        case ie: {
          var A = l.memoizedProps.value, R = l.type._context;
          f(l, R, A);
          break;
        }
        case pe:
          {
            var P = wr(m, l.childLanes);
            P && (l.flags |= Pe);
            {
              var z = l.stateNode;
              z.effectDuration = 0, z.passiveEffectDuration = 0;
            }
          }
          break;
        case J: {
          var W = l.memoizedState;
          if (W !== null) {
            if (W.dehydrated !== null)
              return $u(l, Lh(wo.current)), l.flags |= ot, null;
            var $ = l.child, oe = $.childLanes;
            if (wr(m, oe))
              return tw(a, l, m);
            $u(l, Lh(wo.current));
            var xe = Yl(a, l, m);
            return xe !== null ? xe.sibling : null;
          } else
            $u(l, Lh(wo.current));
          break;
        }
        case ye: {
          var Be = (a.flags & ot) !== Ke, Ne = wr(m, l.childLanes);
          if (Be) {
            if (Ne)
              return ow(a, l, m);
            l.flags |= ot;
          }
          var $e = l.memoizedState;
          if ($e !== null && ($e.rendering = null, $e.tail = null, $e.lastEffect = null), $u(l, wo.current), Ne)
            break;
          return null;
        }
        case Je:
        case Ye:
          return l.lanes = Ze, K1(a, l, m);
      }
      return Yl(a, l, m);
    }
    function cw(a, l, m) {
      if (l._debugNeedsRemount && a !== null)
        return NF(a, l, RM(l.type, l.key, l.pendingProps, l._debugOwner || null, l.mode, l.lanes));
      if (a !== null) {
        var _ = a.memoizedProps, A = l.pendingProps;
        if (_ !== A || Il() || // Force a re-render if the implementation changed due to hot reload:
        l.type !== a.type)
          Bo = !0;
        else {
          var R = ZA(a, m);
          if (!R && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (l.flags & ot) === Ke)
            return Bo = !1, OF(a, l, m);
          (a.flags & te) !== Ke ? Bo = !0 : Bo = !1;
        }
      } else if (Bo = !1, os() && BU(l)) {
        var P = l.index, z = DU();
        KC(l, z, P);
      }
      switch (l.lanes = Ze, l.tag) {
        case O:
          return MF(a, l, l.type, m);
        case ue: {
          var W = l.elementType;
          return SF(a, l, W, m);
        }
        case N: {
          var $ = l.type, oe = l.pendingProps, xe = l.elementType === $ ? oe : Cs($, oe);
          return JA(a, l, $, xe, m);
        }
        case U: {
          var Be = l.type, Ne = l.pendingProps, $e = l.elementType === Be ? Ne : Cs(Be, Ne);
          return j1(a, l, Be, $e, m);
        }
        case V:
          return _F(a, l, m);
        case I:
          return yF(a, l, m);
        case Y:
          return xF(a, l);
        case J:
          return tw(a, l, m);
        case L:
          return IF(a, l, m);
        case re: {
          var ut = l.type, Zt = l.pendingProps, hn = l.elementType === ut ? Zt : Cs(ut, Zt);
          return X1(a, l, ut, hn, m);
        }
        case Q:
          return mF(a, l, m);
        case fe:
          return gF(a, l, m);
        case pe:
          return vF(a, l, m);
        case ie:
          return UF(a, l, m);
        case j:
          return FF(a, l, m);
        case Z: {
          var nn = l.type, hi = l.pendingProps, pi = Cs(nn, hi);
          if (l.type !== l.elementType) {
            var Te = nn.propTypes;
            Te && Bi(
              Te,
              pi,
              // Resolved for outer only
              "prop",
              Ie(nn)
            );
          }
          return pi = Cs(nn.type, pi), J1(a, l, nn, pi, m);
        }
        case H:
          return Y1(a, l, l.type, l.pendingProps, m);
        case Se: {
          var Ge = l.type, Ae = l.pendingProps, dt = l.elementType === Ge ? Ae : Cs(Ge, Ae);
          return AF(a, l, Ge, dt, m);
        }
        case ye:
          return ow(a, l, m);
        case Xe:
          break;
        case Je:
          return K1(a, l, m);
      }
      throw new Error("Unknown unit of work tag (" + l.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function HF(a, l, m) {
      switch (ZS(l), l.tag) {
        case U: {
          var _ = l.type;
          rs(_) && Zo(l);
          var A = l.flags;
          return A & Yt ? (l.flags = A & ~Yt | ot, (l.mode & Pn) !== rn && OA(l), l) : null;
        }
        case V: {
          Dh(l), Em(l), mA();
          var R = l.flags;
          return (R & Yt) !== Ke && (R & ot) === Ke ? (l.flags = R & ~Yt | ot, l) : null;
        }
        case I:
          return fA(l), null;
        case J: {
          Ph(l);
          {
            var P = l.memoizedState;
            if (P !== null && P.dehydrated !== null) {
              if (l.alternate === null)
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
              Rh();
            }
          }
          var z = l.flags;
          return z & Yt ? (l.flags = z & ~Yt | ot, (l.mode & Pn) !== rn && OA(l), l) : null;
        }
        case ye:
          return Ph(l), null;
        case L:
          return Dh(l), null;
        case ie:
          var W = l.type._context;
          return h(W, l), null;
        case Je:
        case Ye:
          return _M(l), null;
        case At:
          return null;
        default:
          return null;
      }
    }
    function fw(a, l, m) {
      switch (ZS(l), l.tag) {
        case U: {
          var _ = l.type.childContextTypes;
          _ != null && Zo(l);
          break;
        }
        case V: {
          Dh(l), Em(l), mA();
          break;
        }
        case I: {
          fA(l);
          break;
        }
        case L:
          Dh(l);
          break;
        case J:
          Ph(l);
          break;
        case ye:
          Ph(l);
          break;
        case ie:
          var A = l.type._context;
          h(A, l);
          break;
        case Je:
        case Ye:
          _M(l);
          break;
      }
    }
    function dw(a, l, m, _, A, R, P, z, W) {
      var $ = Array.prototype.slice.call(arguments, 3);
      try {
        l.apply(m, $);
      } catch (oe) {
        this.onError(oe);
      }
    }
    var hw = dw;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var $A = document.createElement("react");
      hw = function(l, m, _, A, R, P, z, W, $) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var oe = document.createEvent("Event"), xe = !1, Be = !0, Ne = window.event, $e = Object.getOwnPropertyDescriptor(window, "event");
        function ut() {
          $A.removeEventListener(Ge, hn, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = Ne);
        }
        var Zt = Array.prototype.slice.call(arguments, 3);
        function hn() {
          xe = !0, ut(), m.apply(_, Zt), Be = !1;
        }
        var nn, hi = !1, pi = !1;
        function Te(Ae) {
          if (nn = Ae.error, hi = !0, nn === null && Ae.colno === 0 && Ae.lineno === 0 && (pi = !0), Ae.defaultPrevented && nn != null && typeof nn == "object")
            try {
              nn._suppressLogging = !0;
            } catch {
            }
        }
        var Ge = "react-" + (l || "invokeguardedcallback");
        if (window.addEventListener("error", Te), $A.addEventListener(Ge, hn, !1), oe.initEvent(Ge, !1, !1), $A.dispatchEvent(oe), $e && Object.defineProperty(window, "event", $e), xe && Be && (hi ? pi && (nn = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : nn = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(nn)), window.removeEventListener("error", Te), !xe)
          return ut(), dw.apply(this, arguments);
      };
    }
    var zF = hw, pg = !1, _y = null, GF = {
      onError: function(a) {
        pg = !0, _y = a;
      }
    };
    function pw(a, l, m, _, A, R, P, z, W) {
      pg = !1, _y = null, zF.apply(GF, arguments);
    }
    function kF() {
      return pg;
    }
    function mw() {
      if (pg) {
        var a = _y;
        return pg = !1, _y = null, a;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    var gw = null;
    gw = /* @__PURE__ */ new Set();
    var yy = !1, ic = !1, VF = typeof WeakSet == "function" ? WeakSet : Set, Bt = null, Hh = null, zh = null;
    function Jr(a) {
      pw(null, function() {
        throw a;
      }), mw();
    }
    var WF = function(a, l) {
      if (l.props = a.memoizedProps, l.state = a.memoizedState, a.mode & Pn)
        try {
          eo(), l.componentWillUnmount();
        } finally {
          $a(a);
        }
      else
        l.componentWillUnmount();
    };
    function vw(a, l) {
      try {
        Kl(Yi, a);
      } catch (m) {
        Jr(m), Yr(a, l, m);
      }
    }
    function eM(a, l, m) {
      try {
        WF(a, m);
      } catch (_) {
        Jr(_), Yr(a, l, _);
      }
    }
    function XF(a, l, m) {
      try {
        m.componentDidMount();
      } catch (_) {
        Jr(_), Yr(a, l, _);
      }
    }
    function _w(a, l) {
      try {
        xw(a);
      } catch (m) {
        Jr(m), Yr(a, l, m);
      }
    }
    function xy(a, l) {
      var m = a.ref;
      if (m !== null)
        if (typeof m == "function") {
          var _;
          try {
            if (C && D && a.mode & Pn)
              try {
                eo(), _ = m(null);
              } finally {
                $a(a);
              }
            else
              _ = m(null);
          } catch (A) {
            Jr(A), Yr(a, l, A);
          }
          typeof _ == "function" && d("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Fe(a));
        } else
          m.current = null;
    }
    function Sy(a, l, m) {
      try {
        m();
      } catch (_) {
        Jr(_), Yr(a, l, _);
      }
    }
    var yw = !1;
    function JF(a, l) {
      Fa(a.containerInfo), Bt = l, YF();
      var m = yw;
      return yw = !1, m;
    }
    function YF() {
      for (; Bt !== null; ) {
        var a = Bt, l = a.child;
        (a.subtreeFlags & se) !== Ke && l !== null ? (to(l, a), Bt = l) : KF();
      }
    }
    function KF() {
      for (; Bt !== null; ) {
        var a = Bt;
        oi(a);
        try {
          qF(a);
        } catch (m) {
          Jr(m), Yr(a, a.return, m);
        }
        hr();
        var l = a.sibling;
        if (l !== null) {
          to(l, a.return), Bt = l;
          return;
        }
        Bt = a.return;
      }
    }
    function qF(a) {
      var l = a.alternate, m = a.flags;
      if ((m & wt) !== Ke) {
        switch (oi(a), a.tag) {
          case N:
          case re:
          case H:
            break;
          case U: {
            if (l !== null) {
              var _ = l.memoizedProps, A = l.memoizedState, R = a.stateNode;
              a.type === a.elementType && !Sf && (R.props !== a.memoizedProps && d("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Fe(a) || "instance"), R.state !== a.memoizedState && d("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Fe(a) || "instance"));
              var P = R.getSnapshotBeforeUpdate(a.elementType === a.type ? _ : Cs(a.type, _), A);
              {
                var z = gw;
                P === void 0 && !z.has(a.type) && (z.add(a.type), d("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Fe(a)));
              }
              R.__reactInternalSnapshotBeforeUpdate = P;
            }
            break;
          }
          case V: {
            if (ts) {
              var W = a.stateNode;
              za(W.containerInfo);
            }
            break;
          }
          case I:
          case Y:
          case L:
          case Se:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        hr();
      }
    }
    function Qs(a, l, m) {
      var _ = l.updateQueue, A = _ !== null ? _.lastEffect : null;
      if (A !== null) {
        var R = A.next, P = R;
        do {
          if ((P.tag & a) === a) {
            var z = P.destroy;
            P.destroy = void 0, z !== void 0 && ((a & Wr) !== ol ? zu(l) : (a & Yi) !== ol && Or(l), Sy(l, m, z), (a & Wr) !== ol ? gh() : (a & Yi) !== ol && vh());
          }
          P = P.next;
        } while (P !== R);
      }
    }
    function Kl(a, l) {
      var m = l.updateQueue, _ = m !== null ? m.lastEffect : null;
      if (_ !== null) {
        var A = _.next, R = A;
        do {
          if ((R.tag & a) === a) {
            (a & Wr) !== ol ? Xi(l) : (a & Yi) !== ol && km(l);
            var P = R.create;
            R.destroy = P(), (a & Wr) !== ol ? of() : (a & Yi) !== ol && lf();
            {
              var z = R.destroy;
              if (z !== void 0 && typeof z != "function") {
                var W = void 0;
                (R.tag & Yi) !== Ke ? W = "useLayoutEffect" : (R.tag & ec) !== Ke ? W = "useInsertionEffect" : W = "useEffect";
                var $ = void 0;
                z === null ? $ = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof z.then == "function" ? $ = `

It looks like you wrote ` + W + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + W + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : $ = " You returned: " + z, d("%s must not return anything besides a function, which is used for clean-up.%s", W, $);
              }
            }
          }
          R = R.next;
        } while (R !== A);
      }
    }
    function jF(a, l) {
      if ((l.flags & Pe) !== Ke)
        switch (l.tag) {
          case pe: {
            var m = l.stateNode.passiveEffectDuration, _ = l.memoizedProps, A = _.id, R = _.onPostCommit, P = I1(), z = l.alternate === null ? "mount" : "update";
            P1() && (z = "nested-update"), typeof R == "function" && R(A, z, m, P);
            var W = l.return;
            e: for (; W !== null; ) {
              switch (W.tag) {
                case V:
                  var $ = W.stateNode;
                  $.passiveEffectDuration += m;
                  break e;
                case pe:
                  var oe = W.stateNode;
                  oe.passiveEffectDuration += m;
                  break e;
              }
              W = W.return;
            }
            break;
          }
        }
    }
    function QF(a, l, m, _) {
      if ((m.flags & ge) !== Ke)
        switch (m.tag) {
          case N:
          case re:
          case H: {
            if (!ic)
              if (m.mode & Pn)
                try {
                  eo(), Kl(Yi | xi, m);
                } finally {
                  $a(m);
                }
              else
                Kl(Yi | xi, m);
            break;
          }
          case U: {
            var A = m.stateNode;
            if (m.flags & Pe && !ic)
              if (l === null)
                if (m.type === m.elementType && !Sf && (A.props !== m.memoizedProps && d("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Fe(m) || "instance"), A.state !== m.memoizedState && d("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Fe(m) || "instance")), m.mode & Pn)
                  try {
                    eo(), A.componentDidMount();
                  } finally {
                    $a(m);
                  }
                else
                  A.componentDidMount();
              else {
                var R = m.elementType === m.type ? l.memoizedProps : Cs(m.type, l.memoizedProps), P = l.memoizedState;
                if (m.type === m.elementType && !Sf && (A.props !== m.memoizedProps && d("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Fe(m) || "instance"), A.state !== m.memoizedState && d("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Fe(m) || "instance")), m.mode & Pn)
                  try {
                    eo(), A.componentDidUpdate(R, P, A.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    $a(m);
                  }
                else
                  A.componentDidUpdate(R, P, A.__reactInternalSnapshotBeforeUpdate);
              }
            var z = m.updateQueue;
            z !== null && (m.type === m.elementType && !Sf && (A.props !== m.memoizedProps && d("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Fe(m) || "instance"), A.state !== m.memoizedState && d("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Fe(m) || "instance")), U_(m, z, A));
            break;
          }
          case V: {
            var W = m.updateQueue;
            if (W !== null) {
              var $ = null;
              if (m.child !== null)
                switch (m.child.tag) {
                  case I:
                    $ = $r(m.child.stateNode);
                    break;
                  case U:
                    $ = m.child.stateNode;
                    break;
                }
              U_(m, W, $);
            }
            break;
          }
          case I: {
            var oe = m.stateNode;
            if (l === null && m.flags & Pe) {
              var xe = m.type, Be = m.memoizedProps;
              wS(oe, xe, Be, m);
            }
            break;
          }
          case Y:
            break;
          case L:
            break;
          case pe: {
            {
              var Ne = m.memoizedProps, $e = Ne.onCommit, ut = Ne.onRender, Zt = m.stateNode.effectDuration, hn = I1(), nn = l === null ? "mount" : "update";
              P1() && (nn = "nested-update"), typeof ut == "function" && ut(m.memoizedProps.id, nn, m.actualDuration, m.treeBaseDuration, m.actualStartTime, hn);
              {
                typeof $e == "function" && $e(m.memoizedProps.id, nn, Zt, hn), fO(m);
                var hi = m.return;
                e: for (; hi !== null; ) {
                  switch (hi.tag) {
                    case V:
                      var pi = hi.stateNode;
                      pi.effectDuration += Zt;
                      break e;
                    case pe:
                      var Te = hi.stateNode;
                      Te.effectDuration += Zt;
                      break e;
                  }
                  hi = hi.return;
                }
              }
            }
            break;
          }
          case J: {
            aN(a, m);
            break;
          }
          case ye:
          case Se:
          case Xe:
          case Je:
          case Ye:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      ic || m.flags & un && xw(m);
    }
    function ZF(a) {
      switch (a.tag) {
        case N:
        case re:
        case H: {
          if (a.mode & Pn)
            try {
              eo(), vw(a, a.return);
            } finally {
              $a(a);
            }
          else
            vw(a, a.return);
          break;
        }
        case U: {
          var l = a.stateNode;
          typeof l.componentDidMount == "function" && XF(a, a.return, l), _w(a, a.return);
          break;
        }
        case I: {
          _w(a, a.return);
          break;
        }
      }
    }
    function $F(a, l) {
      var m = null;
      if (ts)
        for (var _ = a; ; ) {
          if (_.tag === I) {
            if (m === null) {
              m = _;
              var A = _.stateNode;
              l ? Dd(A) : r_(_.stateNode, _.memoizedProps);
            }
          } else if (_.tag === Y) {
            if (m === null) {
              var R = _.stateNode;
              l ? mm(R) : DS(R, _.memoizedProps);
            }
          } else if (!((_.tag === Je || _.tag === Ye) && _.memoizedState !== null && _ !== a)) {
            if (_.child !== null) {
              _.child.return = _, _ = _.child;
              continue;
            }
          }
          if (_ === a)
            return;
          for (; _.sibling === null; ) {
            if (_.return === null || _.return === a)
              return;
            m === _ && (m = null), _ = _.return;
          }
          m === _ && (m = null), _.sibling.return = _.return, _ = _.sibling;
        }
    }
    function xw(a) {
      var l = a.ref;
      if (l !== null) {
        var m = a.stateNode, _;
        switch (a.tag) {
          case I:
            _ = $r(m);
            break;
          default:
            _ = m;
        }
        if (typeof l == "function") {
          var A;
          if (a.mode & Pn)
            try {
              eo(), A = l(_);
            } finally {
              $a(a);
            }
          else
            A = l(_);
          typeof A == "function" && d("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Fe(a));
        } else
          l.hasOwnProperty("current") || d("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Fe(a)), l.current = _;
      }
    }
    function eN(a) {
      var l = a.ref;
      if (l !== null)
        if (typeof l == "function")
          if (a.mode & Pn)
            try {
              eo(), l(null);
            } finally {
              $a(a);
            }
          else
            l(null);
        else
          l.current = null;
    }
    function Sw(a, l, m) {
      switch (Gm(l), l.tag) {
        case N:
        case re:
        case Z:
        case H: {
          var _ = l.updateQueue;
          if (_ !== null) {
            var A = _.lastEffect;
            if (A !== null) {
              var R = A.next, P = R;
              do {
                var z = P, W = z.destroy, $ = z.tag;
                W !== void 0 && (($ & ec) !== ol ? Sy(l, m, W) : ($ & Yi) !== ol && (Or(l), l.mode & Pn ? (eo(), Sy(l, m, W), $a(l)) : Sy(l, m, W), vh())), P = P.next;
              } while (P !== R);
            }
          }
          return;
        }
        case U: {
          xy(l, m);
          var oe = l.stateNode;
          typeof oe.componentWillUnmount == "function" && eM(l, m, oe);
          return;
        }
        case I: {
          xy(l, m);
          return;
        }
        case L: {
          ts ? Cw(a, l, m) : Jo && nN(l);
          return;
        }
        case me:
          return;
        case Xe:
          return;
      }
    }
    function Aw(a, l, m) {
      for (var _ = l; ; ) {
        if (Sw(a, _, m), _.child !== null && // If we use mutation we drill down into portals using commitUnmount above.
        // If we don't use mutation we drill down into portals here instead.
        (!ts || _.tag !== L)) {
          _.child.return = _, _ = _.child;
          continue;
        }
        if (_ === l)
          return;
        for (; _.sibling === null; ) {
          if (_.return === null || _.return === l)
            return;
          _ = _.return;
        }
        _.sibling.return = _.return, _ = _.sibling;
      }
    }
    function tN(a) {
      var l = a.alternate;
      l !== null && (l.return = null), a.return = null;
    }
    function Mw(a) {
      var l = a.alternate;
      l !== null && (a.alternate = null, Mw(l));
      {
        if (a.child = null, a.deletions = null, a.sibling = null, a.tag === I) {
          var m = a.stateNode;
          m !== null && fm(m);
        }
        a.stateNode = null, a._debugOwner = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
      }
    }
    function nN(a) {
      if (Jo) {
        var l = a.stateNode, m = l.containerInfo, _ = Xc(m);
        Jc(m, _);
      }
    }
    function iN(a) {
      if (Jo) {
        switch (a.tag) {
          case U:
          case I:
          case Y:
            return;
          case V:
          case L: {
            var l = a.stateNode, m = l.containerInfo, _ = l.pendingChildren;
            Jc(m, _);
            return;
          }
        }
        throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function rN(a) {
      for (var l = a.return; l !== null; ) {
        if (Ew(l))
          return l;
        l = l.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function Ew(a) {
      return a.tag === I || a.tag === V || a.tag === L;
    }
    function Tw(a) {
      var l = a;
      e: for (; ; ) {
        for (; l.sibling === null; ) {
          if (l.return === null || Ew(l.return))
            return null;
          l = l.return;
        }
        for (l.sibling.return = l.return, l = l.sibling; l.tag !== I && l.tag !== Y && l.tag !== me; ) {
          if (l.flags & We || l.child === null || l.tag === L)
            continue e;
          l.child.return = l, l = l.child;
        }
        if (!(l.flags & We))
          return l.stateNode;
      }
    }
    function bw(a) {
      if (ts) {
        var l = rN(a);
        switch (l.tag) {
          case I: {
            var m = l.stateNode;
            l.flags & at && (Ha(m), l.flags &= ~at);
            var _ = Tw(a);
            nM(a, _, m);
            break;
          }
          case V:
          case L: {
            var A = l.stateNode.containerInfo, R = Tw(a);
            tM(a, R, A);
            break;
          }
          // eslint-disable-next-line-no-fallthrough
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
        }
      }
    }
    function tM(a, l, m) {
      var _ = a.tag, A = _ === I || _ === Y;
      if (A) {
        var R = a.stateNode;
        l ? RS(m, R, l) : CS(m, R);
      } else if (_ !== L) {
        var P = a.child;
        if (P !== null) {
          tM(P, l, m);
          for (var z = P.sibling; z !== null; )
            tM(z, l, m), z = z.sibling;
        }
      }
    }
    function nM(a, l, m) {
      var _ = a.tag, A = _ === I || _ === Y;
      if (A) {
        var R = a.stateNode;
        l ? Na(m, R, l) : hm(m, R);
      } else if (_ !== L) {
        var P = a.child;
        if (P !== null) {
          nM(P, l, m);
          for (var z = P.sibling; z !== null; )
            nM(z, l, m), z = z.sibling;
        }
      }
    }
    function Cw(a, l, m) {
      for (var _ = l, A = !1, R, P; ; ) {
        if (!A) {
          var z = _.return;
          e: for (; ; ) {
            if (z === null)
              throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
            var W = z.stateNode;
            switch (z.tag) {
              case I:
                R = W, P = !1;
                break e;
              case V:
                R = W.containerInfo, P = !0;
                break e;
              case L:
                R = W.containerInfo, P = !0;
                break e;
            }
            z = z.return;
          }
          A = !0;
        }
        if (_.tag === I || _.tag === Y)
          Aw(a, _, m), P ? Oa(R, _.stateNode) : BS(R, _.stateNode);
        else if (_.tag === me)
          P ? u_(R, _.stateNode) : l_(R, _.stateNode);
        else if (_.tag === L) {
          if (_.child !== null) {
            R = _.stateNode.containerInfo, P = !0, _.child.return = _, _ = _.child;
            continue;
          }
        } else if (Sw(a, _, m), _.child !== null) {
          _.child.return = _, _ = _.child;
          continue;
        }
        if (_ === l)
          return;
        for (; _.sibling === null; ) {
          if (_.return === null || _.return === l)
            return;
          _ = _.return, _.tag === L && (A = !1);
        }
        _.sibling.return = _.return, _ = _.sibling;
      }
    }
    function sN(a, l, m) {
      ts ? Cw(a, l, m) : Aw(a, l, m), tN(l);
    }
    function iM(a, l) {
      if (!ts) {
        switch (l.tag) {
          case N:
          case re:
          case Z:
          case H: {
            if (Qs(ec | xi, l, l.return), Kl(ec | xi, l), l.mode & Pn)
              try {
                eo(), Qs(Yi | xi, l, l.return);
              } finally {
                $a(l);
              }
            else
              Qs(Yi | xi, l, l.return);
            return;
          }
          case pe:
            return;
          case J: {
            ww(l), Ay(l);
            return;
          }
          case ye: {
            Ay(l);
            return;
          }
          case V: {
            if (br && a !== null) {
              var m = a.memoizedState;
              if (m.isDehydrated) {
                var _ = l.stateNode;
                ym(_.containerInfo);
              }
            }
            break;
          }
          case Je:
          case Ye:
            return;
        }
        iN(l);
        return;
      }
      switch (l.tag) {
        case N:
        case re:
        case Z:
        case H: {
          if (Qs(ec | xi, l, l.return), Kl(ec | xi, l), l.mode & Pn)
            try {
              eo(), Qs(Yi | xi, l, l.return);
            } finally {
              $a(l);
            }
          else
            Qs(Yi | xi, l, l.return);
          return;
        }
        case U:
          return;
        case I: {
          var A = l.stateNode;
          if (A != null) {
            var R = l.memoizedProps, P = a !== null ? a.memoizedProps : R, z = l.type, W = l.updateQueue;
            l.updateQueue = null, W !== null && Bd(A, W, z, P, R, l);
          }
          return;
        }
        case Y: {
          if (l.stateNode === null)
            throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          var $ = l.stateNode, oe = l.memoizedProps, xe = a !== null ? a.memoizedProps : oe;
          pm($, xe, oe);
          return;
        }
        case V: {
          if (br && a !== null) {
            var Be = a.memoizedState;
            if (Be.isDehydrated) {
              var Ne = l.stateNode;
              ym(Ne.containerInfo);
            }
          }
          return;
        }
        case pe:
          return;
        case J: {
          ww(l), Ay(l);
          return;
        }
        case ye: {
          Ay(l);
          return;
        }
        case Se:
          return;
      }
      throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
    }
    function ww(a) {
      a.memoizedState;
    }
    function aN(a, l) {
      if (br) {
        var m = l.memoizedState;
        if (m === null) {
          var _ = l.alternate;
          if (_ !== null) {
            var A = _.memoizedState;
            if (A !== null) {
              var R = A.dehydrated;
              R !== null && Id(R);
            }
          }
        }
      }
    }
    function Ay(a) {
      var l = a.updateQueue;
      if (l !== null) {
        a.updateQueue = null;
        var m = a.stateNode;
        m === null && (m = a.stateNode = new VF()), l.forEach(function(_) {
          var A = _O.bind(null, a, _);
          if (!m.has(_)) {
            if (m.add(_), bs)
              if (Hh !== null && zh !== null)
                Eg(zh, Hh);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            _.then(A, A);
          }
        });
      }
    }
    function oN(a) {
      ts && Ha(a.stateNode);
    }
    function lN(a, l, m) {
      Hh = m, zh = a, Bt = l, uN(a, m), Hh = null, zh = null;
    }
    function uN(a, l) {
      for (; Bt !== null; ) {
        var m = Bt, _ = m.deletions;
        if (_ !== null)
          for (var A = 0; A < _.length; A++) {
            var R = _[A];
            try {
              sN(a, R, m);
            } catch (z) {
              Jr(z), Yr(R, m, z);
            }
          }
        var P = m.child;
        (m.subtreeFlags & _e) !== Ke && P !== null ? (to(P, m), Bt = P) : cN(a, l);
      }
    }
    function cN(a, l) {
      for (; Bt !== null; ) {
        var m = Bt;
        oi(m);
        try {
          fN(m, a, l);
        } catch (A) {
          Jr(A), Yr(m, m.return, A);
        }
        hr();
        var _ = m.sibling;
        if (_ !== null) {
          to(_, m.return), Bt = _;
          return;
        }
        Bt = m.return;
      }
    }
    function fN(a, l, m) {
      var _ = a.flags;
      if (_ & at && oN(a), _ & un) {
        var A = a.alternate;
        A !== null && eN(A);
      }
      if (_ & Ot)
        switch (a.tag) {
          case J: {
            var R = a.memoizedState, P = R !== null;
            if (P) {
              var z = a.alternate, W = z !== null && z.memoizedState !== null;
              W || iO();
            }
            break;
          }
          case Je: {
            var $ = a.memoizedState, oe = $ !== null, xe = a.alternate, Be = xe !== null && xe.memoizedState !== null, Ne = a;
            ts && $F(Ne, oe);
            {
              if (oe && !Be && (Ne.mode & zn) !== rn) {
                Bt = Ne;
                for (var $e = Ne.child; $e !== null; )
                  Bt = $e, hN($e), $e = $e.sibling;
              }
              break;
            }
          }
        }
      var ut = _ & (We | Pe | bt);
      switch (ut) {
        case We: {
          bw(a), a.flags &= ~We;
          break;
        }
        case ae: {
          bw(a), a.flags &= ~We;
          var Zt = a.alternate;
          iM(Zt, a);
          break;
        }
        case bt: {
          a.flags &= ~bt;
          break;
        }
        case lt: {
          a.flags &= ~bt;
          var hn = a.alternate;
          iM(hn, a);
          break;
        }
        case Pe: {
          var nn = a.alternate;
          iM(nn, a);
          break;
        }
      }
    }
    function dN(a, l, m) {
      Hh = m, zh = l, Bt = a, Rw(a, l, m), Hh = null, zh = null;
    }
    function Rw(a, l, m) {
      for (var _ = (a.mode & zn) !== rn; Bt !== null; ) {
        var A = Bt, R = A.child;
        if (A.tag === Je && _) {
          var P = A.memoizedState !== null, z = P || yy;
          if (z) {
            rM(a, l, m);
            continue;
          } else {
            var W = A.alternate, $ = W !== null && W.memoizedState !== null, oe = $ || ic, xe = yy, Be = ic;
            yy = z, ic = oe, ic && !Be && (Bt = A, pN(A));
            for (var Ne = R; Ne !== null; )
              Bt = Ne, Rw(
                Ne,
                // New root; bubble back up to here and stop.
                l,
                m
              ), Ne = Ne.sibling;
            Bt = A, yy = xe, ic = Be, rM(a, l, m);
            continue;
          }
        }
        (A.subtreeFlags & ge) !== Ke && R !== null ? (to(R, A), Bt = R) : rM(a, l, m);
      }
    }
    function rM(a, l, m) {
      for (; Bt !== null; ) {
        var _ = Bt;
        if ((_.flags & ge) !== Ke) {
          var A = _.alternate;
          oi(_);
          try {
            QF(l, A, _, m);
          } catch (P) {
            Jr(P), Yr(_, _.return, P);
          }
          hr();
        }
        if (_ === a) {
          Bt = null;
          return;
        }
        var R = _.sibling;
        if (R !== null) {
          to(R, _.return), Bt = R;
          return;
        }
        Bt = _.return;
      }
    }
    function hN(a) {
      for (; Bt !== null; ) {
        var l = Bt, m = l.child;
        switch (l.tag) {
          case N:
          case re:
          case Z:
          case H: {
            if (l.mode & Pn)
              try {
                eo(), Qs(Yi, l, l.return);
              } finally {
                $a(l);
              }
            else
              Qs(Yi, l, l.return);
            break;
          }
          case U: {
            xy(l, l.return);
            var _ = l.stateNode;
            typeof _.componentWillUnmount == "function" && eM(l, l.return, _);
            break;
          }
          case I: {
            xy(l, l.return);
            break;
          }
          case Je: {
            var A = l.memoizedState !== null;
            if (A) {
              Bw(a);
              continue;
            }
            break;
          }
        }
        m !== null ? (m.return = l, Bt = m) : Bw(a);
      }
    }
    function Bw(a) {
      for (; Bt !== null; ) {
        var l = Bt;
        if (l === a) {
          Bt = null;
          return;
        }
        var m = l.sibling;
        if (m !== null) {
          m.return = l.return, Bt = m;
          return;
        }
        Bt = l.return;
      }
    }
    function pN(a) {
      for (; Bt !== null; ) {
        var l = Bt, m = l.child;
        if (l.tag === Je) {
          var _ = l.memoizedState !== null;
          if (_) {
            Dw(a);
            continue;
          }
        }
        m !== null ? (m.return = l, Bt = m) : Dw(a);
      }
    }
    function Dw(a) {
      for (; Bt !== null; ) {
        var l = Bt;
        oi(l);
        try {
          ZF(l);
        } catch (_) {
          Jr(_), Yr(l, l.return, _);
        }
        if (hr(), l === a) {
          Bt = null;
          return;
        }
        var m = l.sibling;
        if (m !== null) {
          m.return = l.return, Bt = m;
          return;
        }
        Bt = l.return;
      }
    }
    function mN(a, l) {
      Bt = l, gN(l, a);
    }
    function gN(a, l) {
      for (; Bt !== null; ) {
        var m = Bt, _ = m.child;
        (m.subtreeFlags & he) !== Ke && _ !== null ? (to(_, m), Bt = _) : vN(a, l);
      }
    }
    function vN(a, l) {
      for (; Bt !== null; ) {
        var m = Bt;
        if ((m.flags & St) !== Ke) {
          oi(m);
          try {
            _N(l, m);
          } catch (A) {
            Jr(A), Yr(m, m.return, A);
          }
          hr();
        }
        if (m === a) {
          Bt = null;
          return;
        }
        var _ = m.sibling;
        if (_ !== null) {
          to(_, m.return), Bt = _;
          return;
        }
        Bt = m.return;
      }
    }
    function _N(a, l) {
      switch (l.tag) {
        case N:
        case re:
        case H: {
          if (l.mode & Pn) {
            NA();
            try {
              Kl(Wr | xi, l);
            } finally {
              FA(l);
            }
          } else
            Kl(Wr | xi, l);
          break;
        }
      }
    }
    function yN(a) {
      Bt = a, xN();
    }
    function xN() {
      for (; Bt !== null; ) {
        var a = Bt, l = a.child;
        if ((Bt.flags & et) !== Ke) {
          var m = a.deletions;
          if (m !== null) {
            for (var _ = 0; _ < m.length; _++) {
              var A = m[_];
              Bt = A, MN(A, a);
            }
            {
              var R = a.alternate;
              if (R !== null) {
                var P = R.child;
                if (P !== null) {
                  R.child = null;
                  do {
                    var z = P.sibling;
                    P.sibling = null, P = z;
                  } while (P !== null);
                }
              }
            }
            Bt = a;
          }
        }
        (a.subtreeFlags & he) !== Ke && l !== null ? (to(l, a), Bt = l) : SN();
      }
    }
    function SN() {
      for (; Bt !== null; ) {
        var a = Bt;
        (a.flags & St) !== Ke && (oi(a), AN(a), hr());
        var l = a.sibling;
        if (l !== null) {
          to(l, a.return), Bt = l;
          return;
        }
        Bt = a.return;
      }
    }
    function AN(a) {
      switch (a.tag) {
        case N:
        case re:
        case H: {
          a.mode & Pn ? (NA(), Qs(Wr | xi, a, a.return), FA(a)) : Qs(Wr | xi, a, a.return);
          break;
        }
      }
    }
    function MN(a, l) {
      for (; Bt !== null; ) {
        var m = Bt;
        oi(m), TN(m, l), hr();
        var _ = m.child;
        _ !== null ? (to(_, m), Bt = _) : EN(a);
      }
    }
    function EN(a) {
      for (; Bt !== null; ) {
        var l = Bt, m = l.sibling, _ = l.return;
        if (Mw(l), l === a) {
          Bt = null;
          return;
        }
        if (m !== null) {
          to(m, _), Bt = m;
          return;
        }
        Bt = _;
      }
    }
    function TN(a, l) {
      switch (a.tag) {
        case N:
        case re:
        case H: {
          a.mode & Pn ? (NA(), Qs(Wr, a, l), FA(a)) : Qs(Wr, a, l);
          break;
        }
      }
    }
    var Lw = !1;
    function to(a, l) {
      !Lw && a.return !== l && (Lw = !0, d("Internal React error: Return pointer is inconsistent with parent.")), a.return = l;
    }
    function bN(a) {
      switch (a.tag) {
        case N:
        case re:
        case H: {
          try {
            Kl(Yi | xi, a);
          } catch (m) {
            Jr(m), Yr(a, a.return, m);
          }
          break;
        }
        case U: {
          var l = a.stateNode;
          try {
            l.componentDidMount();
          } catch (m) {
            Jr(m), Yr(a, a.return, m);
          }
          break;
        }
      }
    }
    function CN(a) {
      switch (a.tag) {
        case N:
        case re:
        case H: {
          try {
            Kl(Wr | xi, a);
          } catch (l) {
            Jr(l), Yr(a, a.return, l);
          }
          break;
        }
      }
    }
    function wN(a) {
      switch (a.tag) {
        case N:
        case re:
        case H: {
          try {
            Qs(Yi | xi, a, a.return);
          } catch (m) {
            Jr(m), Yr(a, a.return, m);
          }
          break;
        }
        case U: {
          var l = a.stateNode;
          typeof l.componentWillUnmount == "function" && eM(a, a.return, l);
          break;
        }
      }
    }
    function RN(a) {
      switch (a.tag) {
        case N:
        case re:
        case H:
          try {
            Qs(Wr | xi, a, a.return);
          } catch (l) {
            Jr(l), Yr(a, a.return, l);
          }
      }
    }
    var My = 0, Ey = 1, Ty = 2, by = 3, Cy = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var mg = Symbol.for;
      My = mg("selector.component"), Ey = mg("selector.has_pseudo_class"), Ty = mg("selector.role"), by = mg("selector.test_id"), Cy = mg("selector.text");
    }
    function BN(a) {
      return {
        $$typeof: My,
        value: a
      };
    }
    function DN(a) {
      return {
        $$typeof: Ey,
        value: a
      };
    }
    function LN(a) {
      return {
        $$typeof: Ty,
        value: a
      };
    }
    function PN(a) {
      return {
        $$typeof: Cy,
        value: a
      };
    }
    function IN(a) {
      return {
        $$typeof: by,
        value: a
      };
    }
    function sM(a) {
      var l = AS(a);
      if (l != null) {
        if (typeof l.memoizedProps["data-testname"] != "string")
          throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");
        return l;
      } else {
        var m = Fn(a);
        if (m === null)
          throw new Error("Could not find React container within specified host subtree.");
        return m.stateNode.current;
      }
    }
    function aM(a, l) {
      switch (l.$$typeof) {
        case My:
          if (a.type === l.value)
            return !0;
          break;
        case Ey:
          return UN(a, l.value);
        case Ty:
          if (a.tag === I) {
            var m = a.stateNode;
            if (TS(m, l.value))
              return !0;
          }
          break;
        case Cy:
          if (a.tag === I || a.tag === Y) {
            var _ = dm(a);
            if (_ !== null && _.indexOf(l.value) >= 0)
              return !0;
          }
          break;
        case by:
          if (a.tag === I) {
            var A = a.memoizedProps["data-testname"];
            if (typeof A == "string" && A.toLowerCase() === l.value.toLowerCase())
              return !0;
          }
          break;
        default:
          throw new Error("Invalid selector type specified.");
      }
      return !1;
    }
    function oM(a) {
      switch (a.$$typeof) {
        case My:
          var l = Ie(a.value) || "Unknown";
          return "<" + l + ">";
        case Ey:
          return ":has(" + (oM(a) || "") + ")";
        case Ty:
          return '[role="' + a.value + '"]';
        case Cy:
          return '"' + a.value + '"';
        case by:
          return '[data-testname="' + a.value + '"]';
        default:
          throw new Error("Invalid selector type specified.");
      }
    }
    function Pw(a, l) {
      for (var m = [], _ = [a, 0], A = 0; A < _.length; ) {
        var R = _[A++], P = _[A++], z = l[P];
        if (!(R.tag === I && xu(R))) {
          for (; z != null && aM(R, z); )
            P++, z = l[P];
          if (P === l.length)
            m.push(R);
          else
            for (var W = R.child; W !== null; )
              _.push(W, P), W = W.sibling;
        }
      }
      return m;
    }
    function UN(a, l) {
      for (var m = [a, 0], _ = 0; _ < m.length; ) {
        var A = m[_++], R = m[_++], P = l[R];
        if (!(A.tag === I && xu(A))) {
          for (; P != null && aM(A, P); )
            R++, P = l[R];
          if (R === l.length)
            return !0;
          for (var z = A.child; z !== null; )
            m.push(z, R), z = z.sibling;
        }
      }
      return !1;
    }
    function wy(a, l) {
      if (!Yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var m = sM(a), _ = Pw(m, l), A = [], R = Array.from(_), P = 0; P < R.length; ) {
        var z = R[P++];
        if (z.tag === I) {
          if (xu(z))
            continue;
          A.push(z.stateNode);
        } else
          for (var W = z.child; W !== null; )
            R.push(W), W = W.sibling;
      }
      return A;
    }
    function FN(a, l) {
      if (!Yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var m = sM(a), _ = 0, A = [], R = [m, 0], P = 0; P < R.length; ) {
        var z = R[P++], W = R[P++], $ = l[W];
        if (!(z.tag === I && xu(z)) && (aM(z, $) && (A.push(oM($)), W++, W > _ && (_ = W)), W < l.length))
          for (var oe = z.child; oe !== null; )
            R.push(oe, W), oe = oe.sibling;
      }
      if (_ < l.length) {
        for (var xe = [], Be = _; Be < l.length; Be++)
          xe.push(oM(l[Be]));
        return `findAllNodes was able to match part of the selector:
` + ("  " + A.join(" > ") + `

`) + `No matching component was found for:
` + ("  " + xe.join(" > "));
      }
      return null;
    }
    function NN(a, l) {
      if (!Yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var m = wy(a, l), _ = [], A = 0; A < m.length; A++)
        _.push(i_(m[A]));
      for (var R = _.length - 1; R > 0; R--)
        for (var P = _[R], z = P.x, W = z + P.width, $ = P.y, oe = $ + P.height, xe = R - 1; xe >= 0; xe--)
          if (R !== xe) {
            var Be = _[xe], Ne = Be.x, $e = Ne + Be.width, ut = Be.y, Zt = ut + Be.height;
            if (z >= Ne && $ >= ut && W <= $e && oe <= Zt) {
              _.splice(R, 1);
              break;
            } else if (z === Ne && P.width === Be.width && !(Zt < $) && !(ut > oe)) {
              ut > $ && (Be.height += ut - $, Be.y = $), Zt < oe && (Be.height = oe - ut), _.splice(R, 1);
              break;
            } else if ($ === ut && P.height === Be.height && !($e < z) && !(Ne > W)) {
              Ne > z && (Be.width += Ne - z, Be.x = z), $e < W && (Be.width = W - Ne), _.splice(R, 1);
              break;
            }
          }
      return _;
    }
    function ON(a, l) {
      if (!Yo)
        throw new Error("Test selector API is not supported by this renderer.");
      for (var m = sM(a), _ = Pw(m, l), A = Array.from(_), R = 0; R < A.length; ) {
        var P = A[R++];
        if (!xu(P)) {
          if (P.tag === I) {
            var z = P.stateNode;
            if (bS(z))
              return !0;
          }
          for (var W = P.child; W !== null; )
            A.push(W), W = W.sibling;
        }
      }
      return !1;
    }
    var Ry = [];
    function HN() {
      Yo && Ry.forEach(function(a) {
        return a();
      });
    }
    function zN(a, l, m, _) {
      if (!Yo)
        throw new Error("Test selector API is not supported by this renderer.");
      var A = wy(a, l), R = er(A, m, _), P = R.disconnect, z = R.observe, W = R.unobserve, $ = function() {
        var oe = wy(a, l);
        A.forEach(function(xe) {
          oe.indexOf(xe) < 0 && W(xe);
        }), oe.forEach(function(xe) {
          A.indexOf(xe) < 0 && z(xe);
        });
      };
      return Ry.push($), {
        disconnect: function() {
          var oe = Ry.indexOf($);
          oe >= 0 && Ry.splice(oe, 1), P();
        }
      };
    }
    var GN = r.ReactCurrentActQueue;
    function kN(a) {
      {
        var l = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), m = typeof jest < "u";
        return Rd && m && l !== !1;
      }
    }
    function Iw() {
      {
        var a = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !a && GN.current !== null && d("The current testing environment is not configured to support act(...)"), a;
      }
    }
    var VN = Math.ceil, lM = r.ReactCurrentDispatcher, uM = r.ReactCurrentOwner, Si = r.ReactCurrentBatchConfig, Do = r.ReactCurrentActQueue, rr = (
      /*             */
      0
    ), cM = (
      /*               */
      1
    ), cs = (
      /*                */
      2
    ), Lo = (
      /*                */
      4
    ), ql = 0, gg = 1, Af = 2, By = 3, vg = 4, Uw = 5, fM = 6, _n = rr, fs = null, Ai = null, gr = Ze, fl = Ze, dM = Va(Ze), vr = ql, _g = null, Dy = Ze, yg = Ze, Ly = Ze, xg = null, Zs = null, hM = 0, Fw = 500, Nw = 1 / 0, WN = 500;
    function Gh() {
      Nw = Wi() + WN;
    }
    function Ow() {
      return Nw;
    }
    var Py = !1, pM = null, kh = null, Mf = !1, jl = null, Sg = Ze, mM = [], XN = 50, Ag = 0, gM = null, JN = 50, Iy = 0, Mg = Qn, Uy = Ze;
    function Fy() {
      return fs;
    }
    function Rs() {
      return (_n & (cs | Lo)) !== rr ? Wi() : (Mg !== Qn || (Mg = Wi()), Mg);
    }
    function rc(a) {
      var l = a.mode;
      if ((l & zn) === rn)
        return gn;
      if ((_n & cs) !== rr && gr !== Ze)
        return Ol(gr);
      var m = Km() !== w_;
      if (m) {
        if (Si.transition !== null) {
          var _ = Si.transition;
          _._updatedFibers || (_._updatedFibers = /* @__PURE__ */ new Set()), _._updatedFibers.add(a);
        }
        return Uy === yi && (Uy = oh()), Uy;
      }
      var A = Ks();
      if (A !== yi)
        return A;
      var R = cm();
      return R;
    }
    function YN(a) {
      var l = a.mode;
      return (l & zn) === rn ? gn : lh();
    }
    function _r(a, l, m) {
      xO();
      var _ = Ny(a, l);
      return _ === null ? null : (ha(_, l, m), (_n & cs) !== Ze && _ === fs ? MO(a) : (bs && M_(_, a, l), EO(a), _ === fs && ((_n & cs) === rr && (yg = cn(yg, l)), vr === vg && sc(_, gr)), $s(_, m), l === gn && _n === rr && (a.mode & zn) === rn && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !Do.isBatchingLegacy && (Gh(), Ah())), _);
    }
    function KN(a, l, m) {
      var _ = a.current;
      _.lanes = l, ha(a, l, m), $s(a, m);
    }
    function Ny(a, l) {
      a.lanes = cn(a.lanes, l);
      var m = a.alternate;
      m !== null && (m.lanes = cn(m.lanes, l)), m === null && (a.flags & (We | bt)) !== Ke && Zw(a);
      for (var _ = a, A = a.return; A !== null; )
        A.childLanes = cn(A.childLanes, l), m = A.alternate, m !== null ? m.childLanes = cn(m.childLanes, l) : (A.flags & (We | bt)) !== Ke && Zw(a), _ = A, A = A.return;
      if (_.tag === V) {
        var R = _.stateNode;
        return R;
      } else
        return null;
    }
    function Hw(a, l) {
      return (
        // TODO: Optimize slightly by comparing to root that fiber belongs to.
        // Requires some refactoring. Not a big deal though since it's rare for
        // concurrent apps to have more than a single root.
        fs !== null && (a.mode & zn) !== rn && // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),
        // then don't treat this as an interleaved update. This pattern is
        // accompanied by a warning but we haven't fully deprecated it yet. We can
        // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.
        (_n & cs) === rr
      );
    }
    function $s(a, l) {
      var m = a.callbackNode;
      v_(a, l);
      var _ = ih(a, a === fs ? gr : Ze);
      if (_ === Ze) {
        m !== null && eR(m), a.callbackNode = null, a.callbackPriority = yi;
        return;
      }
      var A = il(_), R = a.callbackPriority;
      if (R === A && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(Do.current !== null && m !== AM)) {
        m == null && R !== gn && d("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      m != null && eR(m);
      var P;
      if (A === gn)
        a.tag === Fr ? (Do.isBatchingLegacy !== null && (Do.didScheduleLegacyUpdate = !0), Ym(kw.bind(null, a))) : Jm(kw.bind(null, a)), Wc ? Do.current !== null ? Do.current.push(Ja) : ES(function() {
          _n === rr && Ja();
        }) : Wy(sf, Ja), P = null;
      else {
        var z;
        switch (dh(_)) {
          case as:
            z = sf;
            break;
          case zl:
            z = Hm;
            break;
          case Ou:
            z = Ao;
            break;
          case fh:
            z = af;
            break;
          default:
            z = Ao;
            break;
        }
        P = Wy(z, zw.bind(null, a));
      }
      a.callbackPriority = A, a.callbackNode = P;
    }
    function zw(a, l) {
      if (aF(), Mg = Qn, Uy = Ze, (_n & (cs | Lo)) !== rr)
        throw new Error("Should not already be working.");
      var m = a.callbackNode, _ = dl();
      if (_ && a.callbackNode !== m)
        return null;
      var A = ih(a, a === fs ? gr : Ze);
      if (A === Ze)
        return null;
      var R = !Fu(a, A) && !S_(a, A) && !l, P = R ? lO(a, A) : Gy(a, A);
      if (P !== ql) {
        if (P === Af) {
          var z = rh(a);
          z !== Ze && (A = z, P = vM(a, z));
        }
        if (P === gg) {
          var W = _g;
          throw Ef(a, Ze), sc(a, A), $s(a, Wi()), W;
        }
        if (P === fM)
          sc(a, A);
        else {
          var $ = !Fu(a, A), oe = a.current.alternate;
          if ($ && !jN(oe)) {
            if (P = Gy(a, A), P === Af) {
              var xe = rh(a);
              xe !== Ze && (A = xe, P = vM(a, xe));
            }
            if (P === gg) {
              var Be = _g;
              throw Ef(a, Ze), sc(a, A), $s(a, Wi()), Be;
            }
          }
          a.finishedWork = oe, a.finishedLanes = A, qN(a, P, A);
        }
      }
      return $s(a, Wi()), a.callbackNode === m ? zw.bind(null, a) : null;
    }
    function vM(a, l) {
      var m = xg;
      if (To(a)) {
        var _ = Ef(a, l);
        _.flags |= an, Pl(a.containerInfo);
      }
      var A = Gy(a, l);
      if (A !== Af) {
        var R = Zs;
        Zs = m, R !== null && Gw(R);
      }
      return A;
    }
    function Gw(a) {
      Zs === null ? Zs = a : Zs.push.apply(Zs, a);
    }
    function qN(a, l, m) {
      switch (l) {
        case ql:
        case gg:
          throw new Error("Root did not complete. This is a bug in React.");
        // Flow knows about invariant, so it complains if I add a break
        // statement, but eslint doesn't know about invariant, so it complains
        // if I do. eslint-disable-next-line no-fallthrough
        case Af: {
          Tf(a, Zs);
          break;
        }
        case By: {
          if (sc(a, m), ah(m) && // do not delay if we're inside an act() scope
          !tR()) {
            var _ = hM + Fw - Wi();
            if (_ > 10) {
              var A = ih(a, Ze);
              if (A !== Ze)
                break;
              var R = a.suspendedLanes;
              if (!Hl(R, m)) {
                Rs(), Mt(a, R);
                break;
              }
              a.timeoutHandle = es(Tf.bind(null, a, Zs), _);
              break;
            }
          }
          Tf(a, Zs);
          break;
        }
        case vg: {
          if (sc(a, m), x_(m))
            break;
          if (!tR()) {
            var P = Ts(a, m), z = P, W = Wi() - z, $ = yO(W) - W;
            if ($ > 10) {
              a.timeoutHandle = es(Tf.bind(null, a, Zs), $);
              break;
            }
          }
          Tf(a, Zs);
          break;
        }
        case Uw: {
          Tf(a, Zs);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function jN(a) {
      for (var l = a; ; ) {
        if (l.flags & kt) {
          var m = l.updateQueue;
          if (m !== null) {
            var _ = m.stores;
            if (_ !== null)
              for (var A = 0; A < _.length; A++) {
                var R = _[A], P = R.getSnapshot, z = R.value;
                try {
                  if (!Ji(P(), z))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var W = l.child;
        if (l.subtreeFlags & kt && W !== null) {
          W.return = l, l = W;
          continue;
        }
        if (l === a)
          return !0;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === a)
            return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
      return !0;
    }
    function sc(a, l) {
      l = tf(l, Ly), l = tf(l, yg), IS(a, l);
    }
    function kw(a) {
      if (oF(), (_n & (cs | Lo)) !== rr)
        throw new Error("Should not already be working.");
      dl();
      var l = ih(a, Ze);
      if (!wr(l, gn))
        return $s(a, Wi()), null;
      var m = Gy(a, l);
      if (a.tag !== Fr && m === Af) {
        var _ = rh(a);
        _ !== Ze && (l = _, m = vM(a, _));
      }
      if (m === gg) {
        var A = _g;
        throw Ef(a, Ze), sc(a, l), $s(a, Wi()), A;
      }
      if (m === fM)
        throw new Error("Root did not complete. This is a bug in React.");
      var R = a.current.alternate;
      return a.finishedWork = R, a.finishedLanes = l, Tf(a, Zs), $s(a, Wi()), null;
    }
    function QN(a, l) {
      l !== Ze && (nf(a, cn(l, gn)), $s(a, Wi()), (_n & (cs | Lo)) === rr && (Gh(), Ja()));
    }
    function ZN(a) {
      var l = Ks(), m = Si.transition;
      try {
        return Si.transition = null, Vi(Ou), a();
      } finally {
        Vi(l), Si.transition = m;
      }
    }
    function $N(a, l) {
      var m = _n;
      _n |= cM;
      try {
        return a(l);
      } finally {
        _n = m, _n === rr && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !Do.isBatchingLegacy && (Gh(), Ah());
      }
    }
    function eO(a, l, m, _, A) {
      var R = Ks(), P = Si.transition;
      try {
        return Si.transition = null, Vi(as), a(l, m, _, A);
      } finally {
        Vi(R), Si.transition = P, _n === rr && Gh();
      }
    }
    function Oy(a) {
      jl !== null && jl.tag === Fr && (_n & (cs | Lo)) === rr && dl();
      var l = _n;
      _n |= cM;
      var m = Si.transition, _ = Ks();
      try {
        return Si.transition = null, Vi(as), a ? a() : void 0;
      } finally {
        Vi(_), Si.transition = m, _n = l, (_n & (cs | Lo)) === rr && Ja();
      }
    }
    function tO() {
      return (_n & (cs | Lo)) !== rr;
    }
    function nO(a) {
      var l = _n;
      _n |= cM;
      var m = Si.transition, _ = Ks();
      try {
        Si.transition = null, Vi(as), a();
      } finally {
        Vi(_), Si.transition = m, _n = l, _n === rr && (Gh(), Ja());
      }
    }
    function Hy(a, l) {
      Di(dM, fl, a), fl = cn(fl, l);
    }
    function _M(a) {
      fl = dM.current, Sn(dM, a);
    }
    function Ef(a, l) {
      a.finishedWork = null, a.finishedLanes = Ze;
      var m = a.timeoutHandle;
      if (m !== um && (a.timeoutHandle = um, Cd(m)), Ai !== null)
        for (var _ = Ai.return; _ !== null; ) {
          var A = _.alternate;
          fw(A, _), _ = _.return;
        }
      fs = a;
      var R = bf(a.current, null);
      return Ai = R, gr = fl = l, vr = ql, _g = null, Dy = Ze, yg = Ze, Ly = Ze, xg = null, Zs = null, ft(), pr.discardPendingWarnings(), R;
    }
    function Vw(a, l) {
      do {
        var m = Ai;
        try {
          if (ju(), c1(), hr(), uM.current = null, m === null || m.return === null) {
            vr = gg, _g = l, Ai = null;
            return;
          }
          if (C && m.mode & Pn && uy(m, !0), w)
            if (pa(), l !== null && typeof l == "object" && typeof l.then == "function") {
              var _ = l;
              Gu(m, _, gr);
            } else
              Vm(m, l, gr);
          dF(a, m.return, m, l, gr), Yw(m);
        } catch (A) {
          l = A, Ai === m && m !== null ? (m = m.return, Ai = m) : m = Ai;
          continue;
        }
        return;
      } while (!0);
    }
    function Ww() {
      var a = lM.current;
      return lM.current = ry, a === null ? ry : a;
    }
    function Xw(a) {
      lM.current = a;
    }
    function iO() {
      hM = Wi();
    }
    function zy(a) {
      Dy = cn(a, Dy);
    }
    function rO() {
      vr === ql && (vr = By);
    }
    function yM() {
      (vr === ql || vr === By || vr === Af) && (vr = vg), fs !== null && (sh(Dy) || sh(yg)) && sc(fs, gr);
    }
    function sO(a) {
      vr !== vg && (vr = Af), xg === null ? xg = [a] : xg.push(a);
    }
    function aO() {
      return vr === ql;
    }
    function Gy(a, l) {
      var m = _n;
      _n |= cs;
      var _ = Ww();
      if (fs !== a || gr !== l) {
        if (bs) {
          var A = a.memoizedUpdaters;
          A.size > 0 && (Eg(a, gr), A.clear()), sl(a, l);
        }
        Ef(a, l);
      }
      Eo(l);
      do
        try {
          oO();
          break;
        } catch (R) {
          Vw(a, R);
        }
      while (!0);
      if (ju(), _n = m, Xw(_), Ai !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return ku(), fs = null, gr = Ze, vr;
    }
    function oO() {
      for (; Ai !== null; )
        Jw(Ai);
    }
    function lO(a, l) {
      var m = _n;
      _n |= cs;
      var _ = Ww();
      if (fs !== a || gr !== l) {
        if (bs) {
          var A = a.memoizedUpdaters;
          A.size > 0 && (Eg(a, gr), A.clear()), sl(a, l);
        }
        Gh(), Ef(a, l);
      }
      Eo(l);
      do
        try {
          uO();
          break;
        } catch (R) {
          Vw(a, R);
        }
      while (!0);
      return ju(), Xw(_), _n = m, Ai !== null ? (xh(), ql) : (ku(), fs = null, gr = Ze, vr);
    }
    function uO() {
      for (; Ai !== null && !FS(); )
        Jw(Ai);
    }
    function Jw(a) {
      var l = a.alternate;
      oi(a);
      var m;
      (a.mode & Pn) !== rn ? (UA(a), m = xM(l, a, fl), uy(a, !0)) : m = xM(l, a, fl), hr(), a.memoizedProps = a.pendingProps, m === null ? Yw(a) : Ai = m, uM.current = null;
    }
    function Yw(a) {
      var l = a;
      do {
        var m = l.alternate, _ = l.return;
        if ((l.flags & Vn) === Ke) {
          oi(l);
          var A = void 0;
          if ((l.mode & Pn) === rn ? A = W1(m, l, fl) : (UA(l), A = W1(m, l, fl), uy(l, !1)), hr(), A !== null) {
            Ai = A;
            return;
          }
        } else {
          var R = HF(m, l);
          if (R !== null) {
            R.flags &= en, Ai = R;
            return;
          }
          if ((l.mode & Pn) !== rn) {
            uy(l, !1);
            for (var P = l.actualDuration, z = l.child; z !== null; )
              P += z.actualDuration, z = z.sibling;
            l.actualDuration = P;
          }
          if (_ !== null)
            _.flags |= Vn, _.subtreeFlags = Ke, _.deletions = null;
          else {
            vr = fM, Ai = null;
            return;
          }
        }
        var W = l.sibling;
        if (W !== null) {
          Ai = W;
          return;
        }
        l = _, Ai = l;
      } while (l !== null);
      vr === ql && (vr = Uw);
    }
    function Tf(a, l) {
      var m = Ks(), _ = Si.transition;
      try {
        Si.transition = null, Vi(as), cO(a, l, m);
      } finally {
        Si.transition = _, Vi(m);
      }
      return null;
    }
    function cO(a, l, m) {
      do
        dl();
      while (jl !== null);
      if (SO(), (_n & (cs | Lo)) !== rr)
        throw new Error("Should not already be working.");
      var _ = a.finishedWork, A = a.finishedLanes;
      if (Ii(A), _ === null)
        return tr(), null;
      if (A === Ze && d("root.finishedLanes should not be empty during a commit. This is a bug in React."), a.finishedWork = null, a.finishedLanes = Ze, _ === a.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      a.callbackNode = null, a.callbackPriority = yi;
      var R = cn(_.lanes, _.childLanes);
      ch(a, R), a === fs && (fs = null, Ai = null, gr = Ze), ((_.subtreeFlags & he) !== Ke || (_.flags & he) !== Ke) && (Mf || (Mf = !0, Wy(Ao, function() {
        return dl(), null;
      })));
      var P = (_.subtreeFlags & (se | _e | ge | he)) !== Ke, z = (_.flags & (se | _e | ge | he)) !== Ke;
      if (P || z) {
        var W = Si.transition;
        Si.transition = null;
        var $ = Ks();
        Vi(as);
        var oe = _n;
        _n |= Lo, uM.current = null, JF(a, _), U1(), lN(a, _, A), Gs(a.containerInfo), a.current = _, _h(A), dN(_, a, A), Wm(), T_(), _n = oe, Vi($), Si.transition = W;
      } else
        a.current = _, U1();
      var xe = Mf;
      if (Mf && (Mf = !1, jl = a, Sg = A), R = a.pendingLanes, R === Ze && (kh = null), xe || Qw(a.current, !1), NS(_.stateNode, m), bs && a.memoizedUpdaters.clear(), HN(), $s(a, Wi()), l !== null)
        for (var Be = a.onRecoverableError, Ne = 0; Ne < l.length; Ne++) {
          var $e = l[Ne];
          Be($e);
        }
      if (Py) {
        Py = !1;
        var ut = pM;
        throw pM = null, ut;
      }
      return wr(Sg, gn) && a.tag !== Fr && dl(), R = a.pendingLanes, wr(R, gn) ? (sF(), a === gM ? Ag++ : (Ag = 0, gM = a)) : Ag = 0, Ja(), tr(), null;
    }
    function dl() {
      if (jl !== null) {
        var a = dh(Sg), l = Nm(Ou, a), m = Si.transition, _ = Ks();
        try {
          return Si.transition = null, Vi(l), dO();
        } finally {
          Vi(_), Si.transition = m;
        }
      }
      return !1;
    }
    function fO(a) {
      mM.push(a), Mf || (Mf = !0, Wy(Ao, function() {
        return dl(), null;
      }));
    }
    function dO() {
      if (jl === null)
        return !1;
      var a = jl, l = Sg;
      if (jl = null, Sg = Ze, (_n & (cs | Lo)) !== rr)
        throw new Error("Cannot flush passive effects while already rendering.");
      al(l);
      var m = _n;
      _n |= Lo, yN(a.current), mN(a, a.current);
      {
        var _ = mM;
        mM = [];
        for (var A = 0; A < _.length; A++) {
          var R = _[A];
          jF(a, R);
        }
      }
      yh(), Qw(a.current, !0), _n = m, Ja(), Iy = jl === null ? 0 : Iy + 1, mh(a);
      {
        var P = a.current.stateNode;
        P.effectDuration = 0, P.passiveEffectDuration = 0;
      }
      return !0;
    }
    function Kw(a) {
      return kh !== null && kh.has(a);
    }
    function hO(a) {
      kh === null ? kh = /* @__PURE__ */ new Set([a]) : kh.add(a);
    }
    function pO(a) {
      Py || (Py = !0, pM = a);
    }
    var mO = pO;
    function qw(a, l, m) {
      var _ = cy(m, l), A = N1(a, _, gn);
      _t(a, A);
      var R = Rs(), P = Ny(a, gn);
      P !== null && (ha(P, gn, R), $s(P, R));
    }
    function Yr(a, l, m) {
      if (a.tag === V) {
        qw(a, a, m);
        return;
      }
      var _ = null;
      for (_ = l; _ !== null; ) {
        if (_.tag === V) {
          qw(_, a, m);
          return;
        } else if (_.tag === U) {
          var A = _.type, R = _.stateNode;
          if (typeof A.getDerivedStateFromError == "function" || typeof R.componentDidCatch == "function" && !Kw(R)) {
            var P = cy(m, a), z = zA(_, P, gn);
            _t(_, z);
            var W = Rs(), $ = Ny(_, gn);
            $ !== null && (ha($, gn, W), $s($, W));
            return;
          }
        }
        _ = _.return;
      }
      d(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, m);
    }
    function gO(a, l, m) {
      var _ = a.pingCache;
      _ !== null && _.delete(l);
      var A = Rs();
      Mt(a, m), TO(a), fs === a && Hl(gr, m) && (vr === vg || vr === By && ah(gr) && Wi() - hM < Fw ? Ef(a, Ze) : Ly = cn(Ly, m)), $s(a, A);
    }
    function jw(a, l) {
      l === yi && (l = YN(a));
      var m = Rs(), _ = Ny(a, l);
      _ !== null && (ha(_, l, m), $s(_, m));
    }
    function vO(a) {
      var l = a.memoizedState, m = yi;
      l !== null && (m = l.retryLane), jw(a, m);
    }
    function _O(a, l) {
      var m = yi, _;
      switch (a.tag) {
        case J:
          _ = a.stateNode;
          var A = a.memoizedState;
          A !== null && (m = A.retryLane);
          break;
        case ye:
          _ = a.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      _ !== null && _.delete(l), jw(a, m);
    }
    function yO(a) {
      return a < 120 ? 120 : a < 480 ? 480 : a < 1080 ? 1080 : a < 1920 ? 1920 : a < 3e3 ? 3e3 : a < 4320 ? 4320 : VN(a / 1960) * 1960;
    }
    function xO() {
      if (Ag > XN)
        throw Ag = 0, gM = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Iy > JN && (Iy = 0, d("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function SO() {
      pr.flushLegacyContextWarning(), pr.flushPendingUnsafeLifecycleWarnings();
    }
    function Qw(a, l) {
      oi(a), ky(a, tn, wN), l && ky(a, k, RN), ky(a, tn, bN), l && ky(a, k, CN), hr();
    }
    function ky(a, l, m) {
      for (var _ = a, A = null; _ !== null; ) {
        var R = _.subtreeFlags & l;
        _ !== A && _.child !== null && R !== Ke ? _ = _.child : ((_.flags & l) !== Ke && m(_), _.sibling !== null ? _ = _.sibling : _ = A = _.return);
      }
    }
    var Vy = null;
    function Zw(a) {
      {
        if ((_n & cs) !== rr || !(a.mode & zn))
          return;
        var l = a.tag;
        if (l !== O && l !== V && l !== U && l !== N && l !== re && l !== Z && l !== H)
          return;
        var m = Fe(a) || "ReactComponent";
        if (Vy !== null) {
          if (Vy.has(m))
            return;
          Vy.add(m);
        } else
          Vy = /* @__PURE__ */ new Set([m]);
        var _ = zr;
        try {
          oi(a), d("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          _ ? oi(a) : hr();
        }
      }
    }
    var xM;
    {
      var AO = null;
      xM = function(a, l, m) {
        var _ = aR(AO, l);
        try {
          return cw(a, l, m);
        } catch (R) {
          if (R !== null && typeof R == "object" && typeof R.then == "function")
            throw R;
          if (ju(), c1(), fw(a, l), aR(l, _), l.mode & Pn && UA(l), pw(null, cw, null, a, l, m), kF()) {
            var A = mw();
            typeof A == "object" && A !== null && A._suppressLogging && typeof R == "object" && R !== null && !R._suppressLogging && (R._suppressLogging = !0);
          }
          throw R;
        }
      };
    }
    var $w = !1, SM;
    SM = /* @__PURE__ */ new Set();
    function MO(a) {
      if (uf && !nF())
        switch (a.tag) {
          case N:
          case re:
          case H: {
            var l = Ai && Fe(Ai) || "Unknown", m = l;
            if (!SM.has(m)) {
              SM.add(m);
              var _ = Fe(a) || "Unknown";
              d("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", _, l, l);
            }
            break;
          }
          case U: {
            $w || (d("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), $w = !0);
            break;
          }
        }
    }
    function Eg(a, l) {
      if (bs) {
        var m = a.memoizedUpdaters;
        m.forEach(function(_) {
          M_(a, _, l);
        });
      }
    }
    var AM = {};
    function Wy(a, l) {
      {
        var m = Do.current;
        return m !== null ? (m.push(l), AM) : rf(a, l);
      }
    }
    function eR(a) {
      if (a !== AM)
        return US(a);
    }
    function tR() {
      return Do.current !== null;
    }
    function EO(a) {
      {
        if (a.mode & zn) {
          if (!Iw())
            return;
        } else if (!kN() || _n !== rr || a.tag !== N && a.tag !== re && a.tag !== H)
          return;
        if (Do.current === null) {
          var l = zr;
          try {
            oi(a), d(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Fe(a));
          } finally {
            l ? oi(a) : hr();
          }
        }
      }
    }
    function TO(a) {
      a.tag !== Fr && Iw() && Do.current === null && d(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    var no = null, Vh = null, bO = function(a) {
      no = a;
    };
    function Wh(a) {
      {
        if (no === null)
          return a;
        var l = no(a);
        return l === void 0 ? a : l.current;
      }
    }
    function MM(a) {
      return Wh(a);
    }
    function EM(a) {
      {
        if (no === null)
          return a;
        var l = no(a);
        if (l === void 0) {
          if (a != null && typeof a.render == "function") {
            var m = Wh(a.render);
            if (a.render !== m) {
              var _ = {
                $$typeof: ce,
                render: m
              };
              return a.displayName !== void 0 && (_.displayName = a.displayName), _;
            }
          }
          return a;
        }
        return l.current;
      }
    }
    function nR(a, l) {
      {
        if (no === null)
          return !1;
        var m = a.elementType, _ = l.type, A = !1, R = typeof _ == "object" && _ !== null ? _.$$typeof : null;
        switch (a.tag) {
          case U: {
            typeof _ == "function" && (A = !0);
            break;
          }
          case N: {
            (typeof _ == "function" || R === le) && (A = !0);
            break;
          }
          case re: {
            (R === ce || R === le) && (A = !0);
            break;
          }
          case Z:
          case H: {
            (R === G || R === le) && (A = !0);
            break;
          }
          default:
            return !1;
        }
        if (A) {
          var P = no(m);
          if (P !== void 0 && P === no(_))
            return !0;
        }
        return !1;
      }
    }
    function iR(a) {
      {
        if (no === null || typeof WeakSet != "function")
          return;
        Vh === null && (Vh = /* @__PURE__ */ new WeakSet()), Vh.add(a);
      }
    }
    var CO = function(a, l) {
      {
        if (no === null)
          return;
        var m = l.staleFamilies, _ = l.updatedFamilies;
        dl(), Oy(function() {
          TM(a.current, _, m);
        });
      }
    }, wO = function(a, l) {
      {
        if (a.context !== Ur)
          return;
        dl(), Oy(function() {
          uR(l, a, null, null);
        });
      }
    };
    function TM(a, l, m) {
      {
        var _ = a.alternate, A = a.child, R = a.sibling, P = a.tag, z = a.type, W = null;
        switch (P) {
          case N:
          case H:
          case U:
            W = z;
            break;
          case re:
            W = z.render;
            break;
        }
        if (no === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var $ = !1, oe = !1;
        if (W !== null) {
          var xe = no(W);
          xe !== void 0 && (m.has(xe) ? oe = !0 : l.has(xe) && (P === U ? oe = !0 : $ = !0));
        }
        Vh !== null && (Vh.has(a) || _ !== null && Vh.has(_)) && (oe = !0), oe && (a._debugNeedsRemount = !0), (oe || $) && _r(a, gn, Qn), A !== null && !oe && TM(A, l, m), R !== null && TM(R, l, m);
      }
    }
    var RO = function(a, l) {
      {
        var m = /* @__PURE__ */ new Set(), _ = new Set(l.map(function(A) {
          return A.current;
        }));
        return bM(a.current, _, m), m;
      }
    };
    function bM(a, l, m) {
      {
        var _ = a.child, A = a.sibling, R = a.tag, P = a.type, z = null;
        switch (R) {
          case N:
          case H:
          case U:
            z = P;
            break;
          case re:
            z = P.render;
            break;
        }
        var W = !1;
        z !== null && l.has(z) && (W = !0), W ? BO(a, m) : _ !== null && bM(_, l, m), A !== null && bM(A, l, m);
      }
    }
    function BO(a, l) {
      {
        var m = DO(a, l);
        if (m)
          return;
        for (var _ = a; ; ) {
          switch (_.tag) {
            case I:
              l.add(_.stateNode);
              return;
            case L:
              l.add(_.stateNode.containerInfo);
              return;
            case V:
              l.add(_.stateNode.containerInfo);
              return;
          }
          if (_.return === null)
            throw new Error("Expected to reach root first.");
          _ = _.return;
        }
      }
    }
    function DO(a, l) {
      for (var m = a, _ = !1; ; ) {
        if (m.tag === I)
          _ = !0, l.add(m.stateNode);
        else if (m.child !== null) {
          m.child.return = m, m = m.child;
          continue;
        }
        if (m === a)
          return _;
        for (; m.sibling === null; ) {
          if (m.return === null || m.return === a)
            return _;
          m = m.return;
        }
        m.sibling.return = m.return, m = m.sibling;
      }
      return !1;
    }
    var CM;
    {
      CM = !1;
      try {
        var rR = Object.preventExtensions({});
      } catch {
        CM = !0;
      }
    }
    function LO(a, l, m, _) {
      this.tag = a, this.key = m, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = l, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = _, this.flags = Ke, this.subtreeFlags = Ke, this.deletions = null, this.lanes = Ze, this.childLanes = Ze, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !CM && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var ga = function(a, l, m, _) {
      return new LO(a, l, m, _);
    };
    function wM(a) {
      var l = a.prototype;
      return !!(l && l.isReactComponent);
    }
    function PO(a) {
      return typeof a == "function" && !wM(a) && a.defaultProps === void 0;
    }
    function IO(a) {
      if (typeof a == "function")
        return wM(a) ? U : N;
      if (a != null) {
        var l = a.$$typeof;
        if (l === ce)
          return re;
        if (l === G)
          return Z;
      }
      return O;
    }
    function bf(a, l) {
      var m = a.alternate;
      m === null ? (m = ga(a.tag, l, a.key, a.mode), m.elementType = a.elementType, m.type = a.type, m.stateNode = a.stateNode, m._debugSource = a._debugSource, m._debugOwner = a._debugOwner, m._debugHookTypes = a._debugHookTypes, m.alternate = a, a.alternate = m) : (m.pendingProps = l, m.type = a.type, m.flags = Ke, m.subtreeFlags = Ke, m.deletions = null, m.actualDuration = 0, m.actualStartTime = -1), m.flags = a.flags & je, m.childLanes = a.childLanes, m.lanes = a.lanes, m.child = a.child, m.memoizedProps = a.memoizedProps, m.memoizedState = a.memoizedState, m.updateQueue = a.updateQueue;
      var _ = a.dependencies;
      switch (m.dependencies = _ === null ? null : {
        lanes: _.lanes,
        firstContext: _.firstContext
      }, m.sibling = a.sibling, m.index = a.index, m.ref = a.ref, m.selfBaseDuration = a.selfBaseDuration, m.treeBaseDuration = a.treeBaseDuration, m._debugNeedsRemount = a._debugNeedsRemount, m.tag) {
        case O:
        case N:
        case H:
          m.type = Wh(a.type);
          break;
        case U:
          m.type = MM(a.type);
          break;
        case re:
          m.type = EM(a.type);
          break;
      }
      return m;
    }
    function UO(a, l) {
      a.flags &= je | We;
      var m = a.alternate;
      if (m === null)
        a.childLanes = Ze, a.lanes = l, a.child = null, a.subtreeFlags = Ke, a.memoizedProps = null, a.memoizedState = null, a.updateQueue = null, a.dependencies = null, a.stateNode = null, a.selfBaseDuration = 0, a.treeBaseDuration = 0;
      else {
        a.childLanes = m.childLanes, a.lanes = m.lanes, a.child = m.child, a.subtreeFlags = Ke, a.deletions = null, a.memoizedProps = m.memoizedProps, a.memoizedState = m.memoizedState, a.updateQueue = m.updateQueue, a.type = m.type;
        var _ = m.dependencies;
        a.dependencies = _ === null ? null : {
          lanes: _.lanes,
          firstContext: _.firstContext
        }, a.selfBaseDuration = m.selfBaseDuration, a.treeBaseDuration = m.treeBaseDuration;
      }
      return a;
    }
    function FO(a, l, m) {
      var _;
      return a === $o ? (_ = zn, l === !0 && (_ |= _i, _ |= fa)) : _ = rn, bs && (_ |= Pn), ga(V, null, null, _);
    }
    function RM(a, l, m, _, A, R) {
      var P = O, z = a;
      if (typeof a == "function")
        wM(a) ? (P = U, z = MM(z)) : z = Wh(z);
      else if (typeof a == "string")
        P = I;
      else
        e: switch (a) {
          case ne:
            return ac(m.children, A, R, l);
          case we:
            P = fe, A |= _i, (A & zn) !== rn && (A |= fa);
            break;
          case Ee:
            return NO(m, A, R, l);
          case nt:
            return OO(m, A, R, l);
          case X:
            return HO(m, A, R, l);
          case Oe:
            return sR(m, A, R, l);
          case ct:
          // eslint-disable-next-line no-fallthrough
          case Ue:
          // eslint-disable-next-line no-fallthrough
          case st:
          // eslint-disable-next-line no-fallthrough
          case it:
          // eslint-disable-next-line no-fallthrough
          case Ve:
          // eslint-disable-next-line no-fallthrough
          default: {
            if (typeof a == "object" && a !== null)
              switch (a.$$typeof) {
                case He:
                  P = ie;
                  break e;
                case be:
                  P = j;
                  break e;
                case ce:
                  P = re, z = EM(z);
                  break e;
                case G:
                  P = Z;
                  break e;
                case le:
                  P = ue, z = null;
                  break e;
              }
            var W = "";
            {
              (a === void 0 || typeof a == "object" && a !== null && Object.keys(a).length === 0) && (W += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var $ = _ ? Fe(_) : null;
              $ && (W += `

Check the render method of \`` + $ + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (a == null ? a : typeof a) + "." + W));
          }
        }
      var oe = ga(P, m, l, A);
      return oe.elementType = a, oe.type = z, oe.lanes = R, oe._debugOwner = _, oe;
    }
    function BM(a, l, m) {
      var _ = null;
      _ = a._owner;
      var A = a.type, R = a.key, P = a.props, z = RM(A, R, P, _, l, m);
      return z._debugSource = a._source, z._debugOwner = a._owner, z;
    }
    function ac(a, l, m, _) {
      var A = ga(Q, a, _, l);
      return A.lanes = m, A;
    }
    function NO(a, l, m, _) {
      typeof a.id != "string" && d('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof a.id);
      var A = ga(pe, a, _, l | Pn);
      return A.elementType = Ee, A.lanes = m, A.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, A;
    }
    function OO(a, l, m, _) {
      var A = ga(J, a, _, l);
      return A.elementType = nt, A.lanes = m, A;
    }
    function HO(a, l, m, _) {
      var A = ga(ye, a, _, l);
      return A.elementType = X, A.lanes = m, A;
    }
    function sR(a, l, m, _) {
      var A = ga(Je, a, _, l);
      A.elementType = Oe, A.lanes = m;
      var R = {};
      return A.stateNode = R, A;
    }
    function DM(a, l, m) {
      var _ = ga(Y, a, null, l);
      return _.lanes = m, _;
    }
    function zO() {
      var a = ga(I, null, null, rn);
      return a.elementType = "DELETED", a;
    }
    function GO(a) {
      var l = ga(me, null, null, rn);
      return l.stateNode = a, l;
    }
    function LM(a, l, m) {
      var _ = a.children !== null ? a.children : [], A = ga(L, _, a.key, l);
      return A.lanes = m, A.stateNode = {
        containerInfo: a.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: a.implementation
      }, A;
    }
    function aR(a, l) {
      return a === null && (a = ga(O, null, null, rn)), a.tag = l.tag, a.key = l.key, a.elementType = l.elementType, a.type = l.type, a.stateNode = l.stateNode, a.return = l.return, a.child = l.child, a.sibling = l.sibling, a.index = l.index, a.ref = l.ref, a.pendingProps = l.pendingProps, a.memoizedProps = l.memoizedProps, a.updateQueue = l.updateQueue, a.memoizedState = l.memoizedState, a.dependencies = l.dependencies, a.mode = l.mode, a.flags = l.flags, a.subtreeFlags = l.subtreeFlags, a.deletions = l.deletions, a.lanes = l.lanes, a.childLanes = l.childLanes, a.alternate = l.alternate, a.actualDuration = l.actualDuration, a.actualStartTime = l.actualStartTime, a.selfBaseDuration = l.selfBaseDuration, a.treeBaseDuration = l.treeBaseDuration, a._debugSource = l._debugSource, a._debugOwner = l._debugOwner, a._debugNeedsRemount = l._debugNeedsRemount, a._debugHookTypes = l._debugHookTypes, a;
    }
    function kO(a, l, m, _, A) {
      this.tag = l, this.containerInfo = a, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = um, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = yi, this.eventTimes = Nu(Ze), this.expirationTimes = Nu(Qn), this.pendingLanes = Ze, this.suspendedLanes = Ze, this.pingedLanes = Ze, this.expiredLanes = Ze, this.mutableReadLanes = Ze, this.finishedLanes = Ze, this.entangledLanes = Ze, this.entanglements = Nu(Ze), this.identifierPrefix = _, this.onRecoverableError = A, br && (this.mutableSourceEagerHydrationData = null), this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var R = this.pendingUpdatersLaneMap = [], P = 0; P < Ul; P++)
          R.push(/* @__PURE__ */ new Set());
      }
      switch (l) {
        case $o:
          this._debugRootType = m ? "hydrateRoot()" : "createRoot()";
          break;
        case Fr:
          this._debugRootType = m ? "hydrate()" : "render()";
          break;
      }
    }
    function oR(a, l, m, _, A, R, P, z, W, $) {
      var oe = new kO(a, l, m, z, W), xe = FO(l, R);
      oe.current = xe, xe.stateNode = oe;
      {
        var Be = {
          element: _,
          isDehydrated: m,
          cache: null,
          // not enabled yet
          transitions: null
        };
        xe.memoizedState = Be;
      }
      return Me(xe), oe;
    }
    var VO = "18.0.0-fc46dba67-20220329";
    function WO(a, l, m) {
      var _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return kl(_), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: mt,
        key: _ == null ? null : "" + _,
        children: a,
        containerInfo: l,
        implementation: m
      };
    }
    var PM, IM;
    PM = !1, IM = {};
    function lR(a) {
      if (!a)
        return Ur;
      var l = v(a), m = xo(l);
      if (l.tag === U) {
        var _ = l.type;
        if (rs(_))
          return Vd(l, _, m);
      }
      return m;
    }
    function XO(a) {
      var l = v(a);
      if (l === void 0) {
        if (typeof a.render == "function")
          throw new Error("Unable to find node on an unmounted component.");
        var m = Object.keys(a).join(",");
        throw new Error("Argument appears to not be a ReactComponent. Keys: " + m);
      }
      var _ = Kn(l);
      return _ === null ? null : _.stateNode;
    }
    function JO(a, l) {
      {
        var m = v(a);
        if (m === void 0) {
          if (typeof a.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var _ = Object.keys(a).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + _);
        }
        var A = Kn(m);
        if (A === null)
          return null;
        if (A.mode & _i) {
          var R = Fe(m) || "Component";
          if (!IM[R]) {
            IM[R] = !0;
            var P = zr;
            try {
              oi(A), m.mode & _i ? d("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", l, l, R) : d("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", l, l, R);
            } finally {
              P ? oi(P) : hr();
            }
          }
        }
        return A.stateNode;
      }
    }
    function YO(a, l, m, _, A, R, P, z) {
      var W = !1, $ = null;
      return oR(a, l, W, $, m, _, A, R, P);
    }
    function KO(a, l, m, _, A, R, P, z, W, $) {
      var oe = !0, xe = oR(m, _, oe, a, A, R, P, z, W);
      xe.context = lR(null);
      var Be = xe.current, Ne = Rs(), $e = rc(Be), ut = Ce(Ne, $e);
      return ut.callback = l ?? null, _t(Be, ut), KN(xe, $e, Ne), xe;
    }
    function uR(a, l, m, _) {
      zm(l, a);
      var A = l.current, R = Rs(), P = rc(A);
      Xm(P);
      var z = lR(m);
      l.context === null ? l.context = z : l.pendingContext = z, uf && zr !== null && !PM && (PM = !0, d(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Fe(zr) || "Unknown"));
      var W = Ce(R, P);
      W.payload = {
        element: a
      }, _ = _ === void 0 ? null : _, _ !== null && (typeof _ != "function" && d("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", _), W.callback = _), _t(A, W);
      var $ = _r(A, P, R);
      return $ !== null && Vt($, A, P), P;
    }
    function qO(a) {
      var l = a.current;
      if (!l.child)
        return null;
      switch (l.child.tag) {
        case I:
          return $r(l.child.stateNode);
        default:
          return l.child.stateNode;
      }
    }
    function jO(a) {
      switch (a.tag) {
        case V:
          var l = a.stateNode;
          if (To(l)) {
            var m = __(l);
            QN(l, m);
          }
          break;
        case J:
          var _ = Rs();
          Oy(function() {
            return _r(a, gn, _);
          });
          var A = gn;
          UM(a, A);
          break;
      }
    }
    function cR(a, l) {
      var m = a.memoizedState;
      m !== null && m.dehydrated !== null && (m.retryLane = PS(m.retryLane, l));
    }
    function UM(a, l) {
      cR(a, l);
      var m = a.alternate;
      m && cR(m, l);
    }
    function QO(a) {
      if (a.tag === J) {
        var l = Rs(), m = ss;
        _r(a, m, l), UM(a, m);
      }
    }
    function ZO(a) {
      if (a.tag === J) {
        var l = Rs(), m = rc(a);
        _r(a, m, l), UM(a, m);
      }
    }
    function $O(a) {
      var l = bn(a);
      return l === null ? null : l.stateNode;
    }
    var fR = function(a) {
      return null;
    };
    function dR(a) {
      return fR(a);
    }
    var hR = function(a) {
      return !1;
    };
    function pR(a) {
      return hR(a);
    }
    var mR = null, gR = null, vR = null, _R = null, yR = null, xR = null, SR = null, AR = null, MR = null;
    {
      var ER = function(a, l, m) {
        var _ = l[m], A = ht(a) ? a.slice() : g({}, a);
        return m + 1 === l.length ? (ht(A) ? A.splice(_, 1) : delete A[_], A) : (A[_] = ER(a[_], l, m + 1), A);
      }, TR = function(a, l) {
        return ER(a, l, 0);
      }, bR = function(a, l, m, _) {
        var A = l[_], R = ht(a) ? a.slice() : g({}, a);
        if (_ + 1 === l.length) {
          var P = m[_];
          R[P] = R[A], ht(R) ? R.splice(A, 1) : delete R[A];
        } else
          R[A] = bR(
            // $FlowFixMe number or string is fine here
            a[A],
            l,
            m,
            _ + 1
          );
        return R;
      }, CR = function(a, l, m) {
        if (l.length !== m.length) {
          c("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var _ = 0; _ < m.length - 1; _++)
            if (l[_] !== m[_]) {
              c("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return bR(a, l, m, 0);
      }, wR = function(a, l, m, _) {
        if (m >= l.length)
          return _;
        var A = l[m], R = ht(a) ? a.slice() : g({}, a);
        return R[A] = wR(a[A], l, m + 1, _), R;
      }, RR = function(a, l, m) {
        return wR(a, l, 0, m);
      }, FM = function(a, l) {
        for (var m = a.memoizedState; m !== null && l > 0; )
          m = m.next, l--;
        return m;
      };
      mR = function(a, l, m, _) {
        var A = FM(a, l);
        if (A !== null) {
          var R = RR(A.memoizedState, m, _);
          A.memoizedState = R, A.baseState = R, a.memoizedProps = g({}, a.memoizedProps), _r(a, gn, Qn);
        }
      }, gR = function(a, l, m) {
        var _ = FM(a, l);
        if (_ !== null) {
          var A = TR(_.memoizedState, m);
          _.memoizedState = A, _.baseState = A, a.memoizedProps = g({}, a.memoizedProps), _r(a, gn, Qn);
        }
      }, vR = function(a, l, m, _) {
        var A = FM(a, l);
        if (A !== null) {
          var R = CR(A.memoizedState, m, _);
          A.memoizedState = R, A.baseState = R, a.memoizedProps = g({}, a.memoizedProps), _r(a, gn, Qn);
        }
      }, _R = function(a, l, m) {
        a.pendingProps = RR(a.memoizedProps, l, m), a.alternate && (a.alternate.pendingProps = a.pendingProps), _r(a, gn, Qn);
      }, yR = function(a, l) {
        a.pendingProps = TR(a.memoizedProps, l), a.alternate && (a.alternate.pendingProps = a.pendingProps), _r(a, gn, Qn);
      }, xR = function(a, l, m) {
        a.pendingProps = CR(a.memoizedProps, l, m), a.alternate && (a.alternate.pendingProps = a.pendingProps), _r(a, gn, Qn);
      }, SR = function(a) {
        _r(a, gn, Qn);
      }, AR = function(a) {
        fR = a;
      }, MR = function(a) {
        hR = a;
      };
    }
    function e3(a) {
      var l = Kn(a);
      return l === null ? null : l.stateNode;
    }
    function t3(a) {
      return null;
    }
    function n3() {
      return zr;
    }
    function i3(a) {
      var l = a.findFiberByHostInstance, m = r.ReactCurrentDispatcher;
      return b_({
        bundleType: a.bundleType,
        version: a.version,
        rendererPackageName: a.rendererPackageName,
        rendererConfig: a.rendererConfig,
        overrideHookState: mR,
        overrideHookStateDeletePath: gR,
        overrideHookStateRenamePath: vR,
        overrideProps: _R,
        overridePropsDeletePath: yR,
        overridePropsRenamePath: xR,
        setErrorHandler: AR,
        setSuspenseHandler: MR,
        scheduleUpdate: SR,
        currentDispatcherRef: m,
        findHostInstanceByFiber: e3,
        findFiberByHostInstance: l || t3,
        // React Refresh
        findHostInstancesForRefresh: RO,
        scheduleRefresh: CO,
        scheduleRoot: wO,
        setRefreshHandler: bO,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: n3,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: VO
      });
    }
    return t.attemptContinuousHydration = QO, t.attemptHydrationAtCurrentPriority = ZO, t.attemptSynchronousHydration = jO, t.batchedUpdates = $N, t.createComponentSelector = BN, t.createContainer = YO, t.createHasPseudoClassSelector = DN, t.createHydrationContainer = KO, t.createPortal = WO, t.createRoleSelector = LN, t.createTestNameSelector = IN, t.createTextSelector = PN, t.deferredUpdates = ZN, t.discreteUpdates = eO, t.findAllNodes = wy, t.findBoundingRects = NN, t.findHostInstance = XO, t.findHostInstanceWithNoPortals = $O, t.findHostInstanceWithWarning = JO, t.flushControlled = nO, t.flushPassiveEffects = dl, t.flushSync = Oy, t.focusWithin = ON, t.getCurrentUpdatePriority = Ks, t.getFindAllNodesFailureDescription = FN, t.getPublicRootInstance = qO, t.injectIntoDevTools = i3, t.isAlreadyRendering = tO, t.observeVisibleRects = zN, t.registerMutableSourceForHydration = jU, t.runWithPriority = E_, t.shouldError = dR, t.shouldSuspend = pR, t.updateContainer = uR, t;
  })), EE.exports;
}
var _D;
function g5() {
  return _D || (_D = 1, process.env.NODE_ENV === "production" ? H0.exports = p5() : H0.exports = m5()), H0.exports;
}
var v5 = g5();
const _5 = /* @__PURE__ */ u3(v5);
var G0 = { exports: {} }, TE = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yD;
function y5() {
  return yD || (yD = 1, function(s) {
    function e(J, Z) {
      var H = J.length;
      J.push(Z);
      e: for (; 0 < H; ) {
        var ue = H - 1 >>> 1, Se = J[ue];
        if (0 < i(Se, Z)) J[ue] = Z, J[H] = Se, H = ue;
        else break e;
      }
    }
    function t(J) {
      return J.length === 0 ? null : J[0];
    }
    function n(J) {
      if (J.length === 0) return null;
      var Z = J[0], H = J.pop();
      if (H !== Z) {
        J[0] = H;
        e: for (var ue = 0, Se = J.length, me = Se >>> 1; ue < me; ) {
          var ye = 2 * (ue + 1) - 1, Xe = J[ye], Je = ye + 1, Ye = J[Je];
          if (0 > i(Xe, H)) Je < Se && 0 > i(Ye, Xe) ? (J[ue] = Ye, J[Je] = H, ue = Je) : (J[ue] = Xe, J[ye] = H, ue = ye);
          else if (Je < Se && 0 > i(Ye, H)) J[ue] = Ye, J[Je] = H, ue = Je;
          else break e;
        }
      }
      return Z;
    }
    function i(J, Z) {
      var H = J.sortIndex - Z.sortIndex;
      return H !== 0 ? H : J.id - Z.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var r = performance;
      s.unstable_now = function() {
        return r.now();
      };
    } else {
      var o = Date, u = o.now();
      s.unstable_now = function() {
        return o.now() - u;
      };
    }
    var c = [], d = [], p = 1, g = null, v = 3, y = !1, S = !1, T = !1, E = typeof setTimeout == "function" ? setTimeout : null, M = typeof clearTimeout == "function" ? clearTimeout : null, w = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function C(J) {
      for (var Z = t(d); Z !== null; ) {
        if (Z.callback === null) n(d);
        else if (Z.startTime <= J) n(d), Z.sortIndex = Z.expirationTime, e(c, Z);
        else break;
        Z = t(d);
      }
    }
    function D(J) {
      if (T = !1, C(J), !S) if (t(c) !== null) S = !0, re(N);
      else {
        var Z = t(d);
        Z !== null && pe(D, Z.startTime - J);
      }
    }
    function N(J, Z) {
      S = !1, T && (T = !1, M(V), V = -1), y = !0;
      var H = v;
      try {
        for (C(Z), g = t(c); g !== null && (!(g.expirationTime > Z) || J && !Y()); ) {
          var ue = g.callback;
          if (typeof ue == "function") {
            g.callback = null, v = g.priorityLevel;
            var Se = ue(g.expirationTime <= Z);
            Z = s.unstable_now(), typeof Se == "function" ? g.callback = Se : g === t(c) && n(c), C(Z);
          } else n(c);
          g = t(c);
        }
        if (g !== null) var me = !0;
        else {
          var ye = t(d);
          ye !== null && pe(D, ye.startTime - Z), me = !1;
        }
        return me;
      } finally {
        g = null, v = H, y = !1;
      }
    }
    var U = !1, O = null, V = -1, L = 5, I = -1;
    function Y() {
      return !(s.unstable_now() - I < L);
    }
    function Q() {
      if (O !== null) {
        var J = s.unstable_now();
        I = J;
        var Z = !0;
        try {
          Z = O(!0, J);
        } finally {
          Z ? fe() : (U = !1, O = null);
        }
      } else U = !1;
    }
    var fe;
    if (typeof w == "function") fe = function() {
      w(Q);
    };
    else if (typeof MessageChannel < "u") {
      var j = new MessageChannel(), ie = j.port2;
      j.port1.onmessage = Q, fe = function() {
        ie.postMessage(null);
      };
    } else fe = function() {
      E(Q, 0);
    };
    function re(J) {
      O = J, U || (U = !0, fe());
    }
    function pe(J, Z) {
      V = E(function() {
        J(s.unstable_now());
      }, Z);
    }
    s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(J) {
      J.callback = null;
    }, s.unstable_continueExecution = function() {
      S || y || (S = !0, re(N));
    }, s.unstable_forceFrameRate = function(J) {
      0 > J || 125 < J ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : L = 0 < J ? Math.floor(1e3 / J) : 5;
    }, s.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, s.unstable_getFirstCallbackNode = function() {
      return t(c);
    }, s.unstable_next = function(J) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var Z = 3;
          break;
        default:
          Z = v;
      }
      var H = v;
      v = Z;
      try {
        return J();
      } finally {
        v = H;
      }
    }, s.unstable_pauseExecution = function() {
    }, s.unstable_requestPaint = function() {
    }, s.unstable_runWithPriority = function(J, Z) {
      switch (J) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          J = 3;
      }
      var H = v;
      v = J;
      try {
        return Z();
      } finally {
        v = H;
      }
    }, s.unstable_scheduleCallback = function(J, Z, H) {
      var ue = s.unstable_now();
      switch (typeof H == "object" && H !== null ? (H = H.delay, H = typeof H == "number" && 0 < H ? ue + H : ue) : H = ue, J) {
        case 1:
          var Se = -1;
          break;
        case 2:
          Se = 250;
          break;
        case 5:
          Se = 1073741823;
          break;
        case 4:
          Se = 1e4;
          break;
        default:
          Se = 5e3;
      }
      return Se = H + Se, J = { id: p++, callback: Z, priorityLevel: J, startTime: H, expirationTime: Se, sortIndex: -1 }, H > ue ? (J.sortIndex = H, e(d, J), t(c) === null && J === t(d) && (T ? (M(V), V = -1) : T = !0, pe(D, H - ue))) : (J.sortIndex = Se, e(c, J), S || y || (S = !0, re(N))), J;
    }, s.unstable_shouldYield = Y, s.unstable_wrapCallback = function(J) {
      var Z = v;
      return function() {
        var H = v;
        v = Z;
        try {
          return J.apply(this, arguments);
        } finally {
          v = H;
        }
      };
    };
  }(TE)), TE;
}
var bE = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xD;
function x5() {
  return xD || (xD = 1, function(s) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var e = !1, t = 5;
      function n(ee, Re) {
        var De = ee.length;
        ee.push(Re), o(ee, Re, De);
      }
      function i(ee) {
        return ee.length === 0 ? null : ee[0];
      }
      function r(ee) {
        if (ee.length === 0)
          return null;
        var Re = ee[0], De = ee.pop();
        return De !== Re && (ee[0] = De, u(ee, De, 0)), Re;
      }
      function o(ee, Re, De) {
        for (var Ie = De; Ie > 0; ) {
          var Qe = Ie - 1 >>> 1, rt = ee[Qe];
          if (c(rt, Re) > 0)
            ee[Qe] = Re, ee[Ie] = rt, Ie = Qe;
          else
            return;
        }
      }
      function u(ee, Re, De) {
        for (var Ie = De, Qe = ee.length, rt = Qe >>> 1; Ie < rt; ) {
          var Fe = (Ie + 1) * 2 - 1, Ke = ee[Fe], Dt = Fe + 1, We = ee[Dt];
          if (c(Ke, Re) < 0)
            Dt < Qe && c(We, Ke) < 0 ? (ee[Ie] = We, ee[Dt] = Re, Ie = Dt) : (ee[Ie] = Ke, ee[Fe] = Re, Ie = Fe);
          else if (Dt < Qe && c(We, Re) < 0)
            ee[Ie] = We, ee[Dt] = Re, Ie = Dt;
          else
            return;
        }
      }
      function c(ee, Re) {
        var De = ee.sortIndex - Re.sortIndex;
        return De !== 0 ? De : ee.id - Re.id;
      }
      var d = 1, p = 2, g = 3, v = 4, y = 5;
      function S(ee, Re) {
      }
      var T = typeof performance == "object" && typeof performance.now == "function";
      if (T) {
        var E = performance;
        s.unstable_now = function() {
          return E.now();
        };
      } else {
        var M = Date, w = M.now();
        s.unstable_now = function() {
          return M.now() - w;
        };
      }
      var C = 1073741823, D = -1, N = 250, U = 5e3, O = 1e4, V = C, L = [], I = [], Y = 1, Q = null, fe = g, j = !1, ie = !1, re = !1, pe = typeof setTimeout == "function" ? setTimeout : null, J = typeof clearTimeout == "function" ? clearTimeout : null, Z = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function H(ee) {
        for (var Re = i(I); Re !== null; ) {
          if (Re.callback === null)
            r(I);
          else if (Re.startTime <= ee)
            r(I), Re.sortIndex = Re.expirationTime, n(L, Re);
          else
            return;
          Re = i(I);
        }
      }
      function ue(ee) {
        if (re = !1, H(ee), !ie)
          if (i(L) !== null)
            ie = !0, ct(Se);
          else {
            var Re = i(I);
            Re !== null && st(ue, Re.startTime - ee);
          }
      }
      function Se(ee, Re) {
        ie = !1, re && (re = !1, it()), j = !0;
        var De = fe;
        try {
          var Ie;
          if (!e) return me(ee, Re);
        } finally {
          Q = null, fe = De, j = !1;
        }
      }
      function me(ee, Re) {
        var De = Re;
        for (H(De), Q = i(L); Q !== null && !(Q.expirationTime > De && (!ee || nt())); ) {
          var Ie = Q.callback;
          if (typeof Ie == "function") {
            Q.callback = null, fe = Q.priorityLevel;
            var Qe = Q.expirationTime <= De, rt = Ie(Qe);
            De = s.unstable_now(), typeof rt == "function" ? Q.callback = rt : Q === i(L) && r(L), H(De);
          } else
            r(L);
          Q = i(L);
        }
        if (Q !== null)
          return !0;
        var Fe = i(I);
        return Fe !== null && st(ue, Fe.startTime - De), !1;
      }
      function ye(ee, Re) {
        switch (ee) {
          case d:
          case p:
          case g:
          case v:
          case y:
            break;
          default:
            ee = g;
        }
        var De = fe;
        fe = ee;
        try {
          return Re();
        } finally {
          fe = De;
        }
      }
      function Xe(ee) {
        var Re;
        switch (fe) {
          case d:
          case p:
          case g:
            Re = g;
            break;
          default:
            Re = fe;
            break;
        }
        var De = fe;
        fe = Re;
        try {
          return ee();
        } finally {
          fe = De;
        }
      }
      function Je(ee) {
        var Re = fe;
        return function() {
          var De = fe;
          fe = Re;
          try {
            return ee.apply(this, arguments);
          } finally {
            fe = De;
          }
        };
      }
      function Ye(ee, Re, De) {
        var Ie = s.unstable_now(), Qe;
        if (typeof De == "object" && De !== null) {
          var rt = De.delay;
          typeof rt == "number" && rt > 0 ? Qe = Ie + rt : Qe = Ie;
        } else
          Qe = Ie;
        var Fe;
        switch (ee) {
          case d:
            Fe = D;
            break;
          case p:
            Fe = N;
            break;
          case y:
            Fe = V;
            break;
          case v:
            Fe = O;
            break;
          case g:
          default:
            Fe = U;
            break;
        }
        var Ke = Qe + Fe, Dt = {
          id: Y++,
          callback: Re,
          priorityLevel: ee,
          startTime: Qe,
          expirationTime: Ke,
          sortIndex: -1
        };
        return Qe > Ie ? (Dt.sortIndex = Qe, n(I, Dt), i(L) === null && Dt === i(I) && (re ? it() : re = !0, st(ue, Qe - Ie))) : (Dt.sortIndex = Ke, n(L, Dt), !ie && !j && (ie = !0, ct(Se))), Dt;
      }
      function At() {
      }
      function Ct() {
        !ie && !j && (ie = !0, ct(Se));
      }
      function pt() {
        return i(L);
      }
      function mt(ee) {
        ee.callback = null;
      }
      function ne() {
        return fe;
      }
      var we = !1, Ee = null, He = -1, be = t, ce = -1;
      function nt() {
        var ee = s.unstable_now() - ce;
        return !(ee < be);
      }
      function X() {
      }
      function G(ee) {
        if (ee < 0 || ee > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ee > 0 ? be = Math.floor(1e3 / ee) : be = t;
      }
      var le = function() {
        if (Ee !== null) {
          var ee = s.unstable_now();
          ce = ee;
          var Re = !0, De = !0;
          try {
            De = Ee(Re, ee);
          } finally {
            De ? Ue() : (we = !1, Ee = null);
          }
        } else
          we = !1;
      }, Ue;
      if (typeof Z == "function")
        Ue = function() {
          Z(le);
        };
      else if (typeof MessageChannel < "u") {
        var Ve = new MessageChannel(), Oe = Ve.port2;
        Ve.port1.onmessage = le, Ue = function() {
          Oe.postMessage(null);
        };
      } else
        Ue = function() {
          pe(le, 0);
        };
      function ct(ee) {
        Ee = ee, we || (we = !0, Ue());
      }
      function st(ee, Re) {
        He = pe(function() {
          ee(s.unstable_now());
        }, Re);
      }
      function it() {
        J(He), He = -1;
      }
      var Lt = X, zt = null;
      s.unstable_IdlePriority = y, s.unstable_ImmediatePriority = d, s.unstable_LowPriority = v, s.unstable_NormalPriority = g, s.unstable_Profiling = zt, s.unstable_UserBlockingPriority = p, s.unstable_cancelCallback = mt, s.unstable_continueExecution = Ct, s.unstable_forceFrameRate = G, s.unstable_getCurrentPriorityLevel = ne, s.unstable_getFirstCallbackNode = pt, s.unstable_next = Xe, s.unstable_pauseExecution = At, s.unstable_requestPaint = Lt, s.unstable_runWithPriority = ye, s.unstable_scheduleCallback = Ye, s.unstable_shouldYield = nt, s.unstable_wrapCallback = Je, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(bE)), bE;
}
var SD;
function S5() {
  return SD || (SD = 1, process.env.NODE_ENV === "production" ? G0.exports = y5() : G0.exports = x5()), G0.exports;
}
var AD = S5();
const fC = {}, A5 = (s) => void Object.assign(fC, s);
function M5(s, e) {
  function t(p, {
    args: g = [],
    attach: v,
    ...y
  }, S) {
    let T = `${p[0].toUpperCase()}${p.slice(1)}`, E;
    if (p === "primitive") {
      if (y.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
      const M = y.object;
      E = yp(M, {
        type: p,
        root: S,
        attach: v,
        primitive: !0
      });
    } else {
      const M = fC[T];
      if (!M)
        throw new Error(`R3F: ${T} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(g)) throw new Error("R3F: The args prop must be an array!");
      E = yp(new M(...g), {
        type: p,
        root: S,
        attach: v,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: g
        }
      });
    }
    return E.__r3f.attach === void 0 && (E.isBufferGeometry ? E.__r3f.attach = "geometry" : E.isMaterial && (E.__r3f.attach = "material")), T !== "inject" && RE(E, y), E;
  }
  function n(p, g) {
    let v = !1;
    if (g) {
      var y, S;
      (y = g.__r3f) != null && y.attach ? wE(p, g, g.__r3f.attach) : g.isObject3D && p.isObject3D && (p.add(g), v = !0), v || (S = p.__r3f) == null || S.objects.push(g), g.__r3f || yp(g, {}), g.__r3f.parent = p, WT(g), xp(g);
    }
  }
  function i(p, g, v) {
    let y = !1;
    if (g) {
      var S, T;
      if ((S = g.__r3f) != null && S.attach)
        wE(p, g, g.__r3f.attach);
      else if (g.isObject3D && p.isObject3D) {
        g.parent = p, g.dispatchEvent({
          type: "added"
        }), p.dispatchEvent({
          type: "childadded",
          child: g
        });
        const E = p.children.filter((w) => w !== g), M = E.indexOf(v);
        p.children = [...E.slice(0, M), g, ...E.slice(M)], y = !0;
      }
      y || (T = p.__r3f) == null || T.objects.push(g), g.__r3f || yp(g, {}), g.__r3f.parent = p, WT(g), xp(g);
    }
  }
  function r(p, g, v = !1) {
    p && [...p].forEach((y) => o(g, y, v));
  }
  function o(p, g, v) {
    if (g) {
      var y, S, T;
      if (g.__r3f && (g.__r3f.parent = null), (y = p.__r3f) != null && y.objects && (p.__r3f.objects = p.__r3f.objects.filter((D) => D !== g)), (S = g.__r3f) != null && S.attach)
        CD(p, g, g.__r3f.attach);
      else if (g.isObject3D && p.isObject3D) {
        var E;
        p.remove(g), (E = g.__r3f) != null && E.root && L5(dx(g), g);
      }
      const w = (T = g.__r3f) == null ? void 0 : T.primitive, C = !w && (v === void 0 ? g.dispose !== null : v);
      if (!w) {
        var M;
        r((M = g.__r3f) == null ? void 0 : M.objects, g, C), r(g.children, g, C);
      }
      if (delete g.__r3f, C && g.dispose && g.type !== "Scene") {
        const D = () => {
          try {
            g.dispose();
          } catch {
          }
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u" ? AD.unstable_scheduleCallback(AD.unstable_IdlePriority, D) : D();
      }
      xp(p);
    }
  }
  function u(p, g, v, y) {
    var S;
    const T = (S = p.__r3f) == null ? void 0 : S.parent;
    if (!T) return;
    const E = t(g, v, p.__r3f.root);
    if (p.children) {
      for (const M of p.children)
        M.__r3f && n(E, M);
      p.children = p.children.filter((M) => !M.__r3f);
    }
    p.__r3f.objects.forEach((M) => n(E, M)), p.__r3f.objects = [], p.__r3f.autoRemovedBeforeAppend || o(T, p), E.parent && (E.__r3f.autoRemovedBeforeAppend = !0), n(T, E), E.raycast && E.__r3f.eventCount && dx(E).getState().internal.interaction.push(E), [y, y.alternate].forEach((M) => {
      M !== null && (M.stateNode = E, M.ref && (typeof M.ref == "function" ? M.ref(E) : M.ref.current = E));
    });
  }
  const c = () => {
  };
  return {
    reconciler: _5({
      createInstance: t,
      removeChild: o,
      appendChild: n,
      appendInitialChild: n,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (p, g) => {
        if (!g) return;
        const v = p.getState().scene;
        v.__r3f && (v.__r3f.root = p, n(v, g));
      },
      removeChildFromContainer: (p, g) => {
        g && o(p.getState().scene, g);
      },
      insertInContainerBefore: (p, g, v) => {
        if (!g || !v) return;
        const y = p.getState().scene;
        y.__r3f && i(y, g, v);
      },
      getRootHostContext: () => null,
      getChildHostContext: (p) => p,
      finalizeInitialChildren(p) {
        var g;
        return !!((g = p?.__r3f) != null ? g : {}).handlers;
      },
      prepareUpdate(p, g, v, y) {
        var S;
        if (((S = p?.__r3f) != null ? S : {}).primitive && y.object && y.object !== p)
          return [!0];
        {
          const {
            args: E = [],
            children: M,
            ...w
          } = y, {
            args: C = [],
            children: D,
            ...N
          } = v;
          if (!Array.isArray(E)) throw new Error("R3F: the args prop must be an array!");
          if (E.some((O, V) => O !== C[V])) return [!0];
          const U = k2(p, w, N, !0);
          return U.changes.length ? [!1, U] : null;
        }
      },
      commitUpdate(p, [g, v], y, S, T, E) {
        g ? u(p, y, T, E) : RE(p, v);
      },
      commitMount(p, g, v, y) {
        var S;
        const T = (S = p.__r3f) != null ? S : {};
        p.raycast && T.handlers && T.eventCount && dx(p).getState().internal.interaction.push(p);
      },
      getPublicInstance: (p) => p,
      prepareForCommit: () => null,
      preparePortalMount: (p) => yp(p.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(p) {
        var g;
        const {
          attach: v,
          parent: y
        } = (g = p.__r3f) != null ? g : {};
        v && y && CD(y, p, v), p.isObject3D && (p.visible = !1), xp(p);
      },
      unhideInstance(p, g) {
        var v;
        const {
          attach: y,
          parent: S
        } = (v = p.__r3f) != null ? v : {};
        y && S && wE(S, p, y), (p.isObject3D && g.visible == null || g.visible) && (p.visible = !0), xp(p);
      },
      createTextInstance: c,
      hideTextInstance: c,
      unhideTextInstance: c,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-expect-error
      getCurrentEventPriority: () => e ? e() : Cp.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && ci.fun(performance.now) ? performance.now : ci.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: ci.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: ci.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: RE
  };
}
var MD, ED;
const CE = (s) => "colorSpace" in s || "outputColorSpace" in s, F2 = () => {
  var s;
  return (s = fC.ColorManagement) != null ? s : null;
}, N2 = (s) => s && s.isOrthographicCamera, E5 = (s) => s && s.hasOwnProperty("current"), e_ = typeof window < "u" && ((MD = window.document) != null && MD.createElement || ((ED = window.navigator) == null ? void 0 : ED.product) === "ReactNative") ? kn.useLayoutEffect : kn.useEffect;
function O2(s) {
  const e = kn.useRef(s);
  return e_(() => void (e.current = s), [s]), e;
}
function T5({
  set: s
}) {
  return e_(() => (s(new Promise(() => null)), () => s(!1)), [s]), null;
}
class H2 extends kn.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
H2.getDerivedStateFromError = () => ({
  error: !0
});
const z2 = "__default", TD = /* @__PURE__ */ new Map(), b5 = (s) => s && !!s.memoized && !!s.changes;
function G2(s) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(s) ? Math.min(Math.max(s[0], t), s[1]) : s;
}
const Og = (s) => {
  var e;
  return (e = s.__r3f) == null ? void 0 : e.root.getState();
};
function dx(s) {
  let e = s.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const ci = {
  obj: (s) => s === Object(s) && !ci.arr(s) && typeof s != "function",
  fun: (s) => typeof s == "function",
  str: (s) => typeof s == "string",
  num: (s) => typeof s == "number",
  boo: (s) => typeof s == "boolean",
  und: (s) => s === void 0,
  arr: (s) => Array.isArray(s),
  equ(s, e, {
    arrays: t = "shallow",
    objects: n = "reference",
    strict: i = !0
  } = {}) {
    if (typeof s != typeof e || !!s != !!e) return !1;
    if (ci.str(s) || ci.num(s) || ci.boo(s)) return s === e;
    const r = ci.obj(s);
    if (r && n === "reference") return s === e;
    const o = ci.arr(s);
    if (o && t === "reference") return s === e;
    if ((o || r) && s === e) return !0;
    let u;
    for (u in s) if (!(u in e)) return !1;
    if (r && t === "shallow" && n === "shallow") {
      for (u in i ? e : s) if (!ci.equ(s[u], e[u], {
        strict: i,
        objects: "reference"
      })) return !1;
    } else
      for (u in i ? e : s) if (s[u] !== e[u]) return !1;
    if (ci.und(u)) {
      if (o && s.length === 0 && e.length === 0 || r && Object.keys(s).length === 0 && Object.keys(e).length === 0) return !0;
      if (s !== e) return !1;
    }
    return !0;
  }
};
function C5(s) {
  const e = {
    nodes: {},
    materials: {}
  };
  return s && s.traverse((t) => {
    t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material);
  }), e;
}
function w5(s) {
  s.dispose && s.type !== "Scene" && s.dispose();
  for (const e in s)
    e.dispose == null || e.dispose(), delete s[e];
}
function yp(s, e) {
  const t = s;
  return t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }, s;
}
function VT(s, e) {
  let t = s;
  if (e.includes("-")) {
    const n = e.split("-"), i = n.pop();
    return t = n.reduce((r, o) => r[o], s), {
      target: t,
      key: i
    };
  } else return {
    target: t,
    key: e
  };
}
const bD = /-\d+$/;
function wE(s, e, t) {
  if (ci.str(t)) {
    if (bD.test(t)) {
      const r = t.replace(bD, ""), {
        target: o,
        key: u
      } = VT(s, r);
      Array.isArray(o[u]) || (o[u] = []);
    }
    const {
      target: n,
      key: i
    } = VT(s, t);
    e.__r3f.previousAttach = n[i], n[i] = e;
  } else e.__r3f.previousAttach = t(s, e);
}
function CD(s, e, t) {
  var n, i;
  if (ci.str(t)) {
    const {
      target: r,
      key: o
    } = VT(s, t), u = e.__r3f.previousAttach;
    u === void 0 ? delete r[o] : r[o] = u;
  } else (n = e.__r3f) == null || n.previousAttach == null || n.previousAttach(s, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function k2(s, {
  children: e,
  key: t,
  ref: n,
  ...i
}, {
  children: r,
  key: o,
  ref: u,
  ...c
} = {}, d = !1) {
  const p = s.__r3f, g = Object.entries(i), v = [];
  if (d) {
    const S = Object.keys(c);
    for (let T = 0; T < S.length; T++)
      i.hasOwnProperty(S[T]) || g.unshift([S[T], z2 + "remove"]);
  }
  g.forEach(([S, T]) => {
    var E;
    if ((E = s.__r3f) != null && E.primitive && S === "object" || ci.equ(T, c[S])) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(S)) return v.push([S, T, !0, []]);
    let M = [];
    S.includes("-") && (M = S.split("-")), v.push([S, T, !1, M]);
    for (const w in i) {
      const C = i[w];
      w.startsWith(`${S}-`) && v.push([w, C, !1, w.split("-")]);
    }
  });
  const y = {
    ...i
  };
  return p != null && p.memoizedProps && p != null && p.memoizedProps.args && (y.args = p.memoizedProps.args), p != null && p.memoizedProps && p != null && p.memoizedProps.attach && (y.attach = p.memoizedProps.attach), {
    memoized: y,
    changes: v
  };
}
const R5 = typeof process < "u" && process.env.NODE_ENV !== "production";
function RE(s, e) {
  var t;
  const n = s.__r3f, i = n?.root, r = i == null || i.getState == null ? void 0 : i.getState(), {
    memoized: o,
    changes: u
  } = b5(e) ? e : k2(s, e), c = n?.eventCount;
  s.__r3f && (s.__r3f.memoizedProps = o);
  for (let v = 0; v < u.length; v++) {
    let [y, S, T, E] = u[v];
    if (CE(s)) {
      const D = "srgb", N = "srgb-linear";
      y === "encoding" ? (y = "colorSpace", S = S === 3001 ? D : N) : y === "outputEncoding" && (y = "outputColorSpace", S = S === 3001 ? D : N);
    }
    let M = s, w = M[y];
    if (E.length && (w = E.reduce((C, D) => C[D], s), !(w && w.set))) {
      const [C, ...D] = E.reverse();
      M = D.reverse().reduce((N, U) => N[U], s), y = C;
    }
    if (S === z2 + "remove")
      if (M.constructor) {
        let C = TD.get(M.constructor);
        C || (C = new M.constructor(), TD.set(M.constructor, C)), S = C[y];
      } else
        S = 0;
    if (T && n)
      S ? n.handlers[y] = S : delete n.handlers[y], n.eventCount = Object.keys(n.handlers).length;
    else if (w && w.set && (w.copy || w instanceof id)) {
      if (Array.isArray(S))
        w.fromArray ? w.fromArray(S) : w.set(...S);
      else if (w.copy && S && S.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.
      // Loosen to unminified names, ignoring descendents.
      // https://github.com/pmndrs/react-three-fiber/issues/2856
      // TODO: fix upstream and remove in v9
      (R5 ? w.constructor.name === S.constructor.name : w.constructor === S.constructor))
        w.copy(S);
      else if (S !== void 0) {
        var d;
        const C = (d = w) == null ? void 0 : d.isColor;
        !C && w.setScalar ? w.setScalar(S) : w instanceof id && S instanceof id ? w.mask = S.mask : w.set(S), !F2() && r && !r.linear && C && w.convertSRGBToLinear();
      }
    } else {
      var p;
      if (M[y] = S, (p = M[y]) != null && p.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
      M[y].format === Ns && M[y].type === Sl && r) {
        const C = M[y];
        CE(C) && CE(r.gl) ? C.colorSpace = r.gl.outputColorSpace : C.encoding = r.gl.outputEncoding;
      }
    }
    xp(s);
  }
  if (n && n.parent && s.raycast && c !== n.eventCount) {
    const v = dx(s).getState().internal, y = v.interaction.indexOf(s);
    y > -1 && v.interaction.splice(y, 1), n.eventCount && v.interaction.push(s);
  }
  return !(u.length === 1 && u[0][0] === "onUpdate") && u.length && (t = s.__r3f) != null && t.parent && WT(s), s;
}
function xp(s) {
  var e, t;
  const n = (e = s.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  n && n.internal.frames === 0 && n.invalidate();
}
function WT(s) {
  s.onUpdate == null || s.onUpdate(s);
}
function B5(s, e) {
  s.manual || (N2(s) ? (s.left = e.width / -2, s.right = e.width / 2, s.top = e.height / 2, s.bottom = e.height / -2) : s.aspect = e.width / e.height, s.updateProjectionMatrix(), s.updateMatrixWorld());
}
function k0(s) {
  return (s.eventObject || s.object).uuid + "/" + s.index + s.instanceId;
}
function D5() {
  var s;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e) return Cp.DefaultEventPriority;
  switch ((s = e.event) == null ? void 0 : s.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Cp.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Cp.ContinuousEventPriority;
    default:
      return Cp.DefaultEventPriority;
  }
}
function V2(s, e, t, n) {
  const i = t.get(e);
  i && (t.delete(e), t.size === 0 && (s.delete(n), i.target.releasePointerCapture(n)));
}
function L5(s, e) {
  const {
    internal: t
  } = s.getState();
  t.interaction = t.interaction.filter((n) => n !== e), t.initialHits = t.initialHits.filter((n) => n !== e), t.hovered.forEach((n, i) => {
    (n.eventObject === e || n.object === e) && t.hovered.delete(i);
  }), t.capturedMap.forEach((n, i) => {
    V2(t.capturedMap, e, n, i);
  });
}
function P5(s) {
  function e(c) {
    const {
      internal: d
    } = s.getState(), p = c.offsetX - d.initialClick[0], g = c.offsetY - d.initialClick[1];
    return Math.round(Math.sqrt(p * p + g * g));
  }
  function t(c) {
    return c.filter((d) => ["Move", "Over", "Enter", "Out", "Leave"].some((p) => {
      var g;
      return (g = d.__r3f) == null ? void 0 : g.handlers["onPointer" + p];
    }));
  }
  function n(c, d) {
    const p = s.getState(), g = /* @__PURE__ */ new Set(), v = [], y = d ? d(p.internal.interaction) : p.internal.interaction;
    for (let M = 0; M < y.length; M++) {
      const w = Og(y[M]);
      w && (w.raycaster.camera = void 0);
    }
    p.previousRoot || p.events.compute == null || p.events.compute(c, p);
    function S(M) {
      const w = Og(M);
      if (!w || !w.events.enabled || w.raycaster.camera === null) return [];
      if (w.raycaster.camera === void 0) {
        var C;
        w.events.compute == null || w.events.compute(c, w, (C = w.previousRoot) == null ? void 0 : C.getState()), w.raycaster.camera === void 0 && (w.raycaster.camera = null);
      }
      return w.raycaster.camera ? w.raycaster.intersectObject(M, !0) : [];
    }
    let T = y.flatMap(S).sort((M, w) => {
      const C = Og(M.object), D = Og(w.object);
      return !C || !D ? M.distance - w.distance : D.events.priority - C.events.priority || M.distance - w.distance;
    }).filter((M) => {
      const w = k0(M);
      return g.has(w) ? !1 : (g.add(w), !0);
    });
    p.events.filter && (T = p.events.filter(T, p));
    for (const M of T) {
      let w = M.object;
      for (; w; ) {
        var E;
        (E = w.__r3f) != null && E.eventCount && v.push({
          ...M,
          eventObject: w
        }), w = w.parent;
      }
    }
    if ("pointerId" in c && p.internal.capturedMap.has(c.pointerId))
      for (let M of p.internal.capturedMap.get(c.pointerId).values())
        g.has(k0(M.intersection)) || v.push(M.intersection);
    return v;
  }
  function i(c, d, p, g) {
    const v = s.getState();
    if (c.length) {
      const y = {
        stopped: !1
      };
      for (const S of c) {
        const T = Og(S.object) || v, {
          raycaster: E,
          pointer: M,
          camera: w,
          internal: C
        } = T, D = new q(M.x, M.y, 0).unproject(w), N = (I) => {
          var Y, Q;
          return (Y = (Q = C.capturedMap.get(I)) == null ? void 0 : Q.has(S.eventObject)) != null ? Y : !1;
        }, U = (I) => {
          const Y = {
            intersection: S,
            target: d.target
          };
          C.capturedMap.has(I) ? C.capturedMap.get(I).set(S.eventObject, Y) : C.capturedMap.set(I, /* @__PURE__ */ new Map([[S.eventObject, Y]])), d.target.setPointerCapture(I);
        }, O = (I) => {
          const Y = C.capturedMap.get(I);
          Y && V2(C.capturedMap, S.eventObject, Y, I);
        };
        let V = {};
        for (let I in d) {
          let Y = d[I];
          typeof Y != "function" && (V[I] = Y);
        }
        let L = {
          ...S,
          ...V,
          pointer: M,
          intersections: c,
          stopped: y.stopped,
          delta: p,
          unprojectedPoint: D,
          ray: E.ray,
          camera: w,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const I = "pointerId" in d && C.capturedMap.get(d.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!I || // ... or if the hit object is capturing the pointer
              I.has(S.eventObject)) && (L.stopped = y.stopped = !0, C.hovered.size && Array.from(C.hovered.values()).find((Y) => Y.eventObject === S.eventObject))
            ) {
              const Y = c.slice(0, c.indexOf(S));
              r([...Y, S]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: N,
            setPointerCapture: U,
            releasePointerCapture: O
          },
          currentTarget: {
            hasPointerCapture: N,
            setPointerCapture: U,
            releasePointerCapture: O
          },
          nativeEvent: d
        };
        if (g(L), y.stopped === !0) break;
      }
    }
    return c;
  }
  function r(c) {
    const {
      internal: d
    } = s.getState();
    for (const p of d.hovered.values())
      if (!c.length || !c.find((g) => g.object === p.object && g.index === p.index && g.instanceId === p.instanceId)) {
        const v = p.eventObject.__r3f, y = v?.handlers;
        if (d.hovered.delete(k0(p)), v != null && v.eventCount) {
          const S = {
            ...p,
            intersections: c
          };
          y.onPointerOut == null || y.onPointerOut(S), y.onPointerLeave == null || y.onPointerLeave(S);
        }
      }
  }
  function o(c, d) {
    for (let p = 0; p < d.length; p++) {
      const g = d[p].__r3f;
      g == null || g.handlers.onPointerMissed == null || g.handlers.onPointerMissed(c);
    }
  }
  function u(c) {
    switch (c) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => r([]);
      case "onLostPointerCapture":
        return (d) => {
          const {
            internal: p
          } = s.getState();
          "pointerId" in d && p.capturedMap.has(d.pointerId) && requestAnimationFrame(() => {
            p.capturedMap.has(d.pointerId) && (p.capturedMap.delete(d.pointerId), r([]));
          });
        };
    }
    return function(p) {
      const {
        onPointerMissed: g,
        internal: v
      } = s.getState();
      v.lastEvent.current = p;
      const y = c === "onPointerMove", S = c === "onClick" || c === "onContextMenu" || c === "onDoubleClick", E = n(p, y ? t : void 0), M = S ? e(p) : 0;
      c === "onPointerDown" && (v.initialClick = [p.offsetX, p.offsetY], v.initialHits = E.map((C) => C.eventObject)), S && !E.length && M <= 2 && (o(p, v.interaction), g && g(p)), y && r(E);
      function w(C) {
        const D = C.eventObject, N = D.__r3f, U = N?.handlers;
        if (N != null && N.eventCount)
          if (y) {
            if (U.onPointerOver || U.onPointerEnter || U.onPointerOut || U.onPointerLeave) {
              const O = k0(C), V = v.hovered.get(O);
              V ? V.stopped && C.stopPropagation() : (v.hovered.set(O, C), U.onPointerOver == null || U.onPointerOver(C), U.onPointerEnter == null || U.onPointerEnter(C));
            }
            U.onPointerMove == null || U.onPointerMove(C);
          } else {
            const O = U[c];
            O ? (!S || v.initialHits.includes(D)) && (o(p, v.interaction.filter((V) => !v.initialHits.includes(V))), O(C)) : S && v.initialHits.includes(D) && o(p, v.interaction.filter((V) => !v.initialHits.includes(V)));
          }
      }
      i(E, p, M, w);
    };
  }
  return {
    handlePointer: u
  };
}
const W2 = (s) => !!(s != null && s.render), X2 = /* @__PURE__ */ kn.createContext(null), I5 = (s, e) => {
  const t = o5((u, c) => {
    const d = new q(), p = new q(), g = new q();
    function v(M = c().camera, w = p, C = c().size) {
      const {
        width: D,
        height: N,
        top: U,
        left: O
      } = C, V = D / N;
      w.isVector3 ? g.copy(w) : g.set(...w);
      const L = M.getWorldPosition(d).distanceTo(g);
      if (N2(M))
        return {
          width: D / M.zoom,
          height: N / M.zoom,
          top: U,
          left: O,
          factor: 1,
          distance: L,
          aspect: V
        };
      {
        const I = M.fov * Math.PI / 180, Y = 2 * Math.tan(I / 2) * L, Q = Y * (D / N);
        return {
          width: Q,
          height: Y,
          top: U,
          left: O,
          factor: D / Q,
          distance: L,
          aspect: V
        };
      }
    }
    let y;
    const S = (M) => u((w) => ({
      performance: {
        ...w.performance,
        current: M
      }
    })), T = new qe();
    return {
      set: u,
      get: c,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (M = 1) => s(c(), M),
      advance: (M, w) => e(M, w, c()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new oC(),
      pointer: T,
      mouse: T,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const M = c();
          y && clearTimeout(y), M.performance.current !== M.performance.min && S(M.performance.min), y = setTimeout(() => S(c().performance.max), M.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: v
      },
      setEvents: (M) => u((w) => ({
        ...w,
        events: {
          ...w.events,
          ...M
        }
      })),
      setSize: (M, w, C, D, N) => {
        const U = c().camera, O = {
          width: M,
          height: w,
          top: D || 0,
          left: N || 0,
          updateStyle: C
        };
        u((V) => ({
          size: O,
          viewport: {
            ...V.viewport,
            ...v(U, p, O)
          }
        }));
      },
      setDpr: (M) => u((w) => {
        const C = G2(M);
        return {
          viewport: {
            ...w.viewport,
            dpr: C,
            initialDpr: w.viewport.initialDpr || C
          }
        };
      }),
      setFrameloop: (M = "always") => {
        const w = c().clock;
        w.stop(), w.elapsedTime = 0, M !== "never" && (w.start(), w.elapsedTime = 0), u(() => ({
          frameloop: M
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ kn.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (M, w, C) => {
          const D = c().internal;
          return D.priority = D.priority + (w > 0 ? 1 : 0), D.subscribers.push({
            ref: M,
            priority: w,
            store: C
          }), D.subscribers = D.subscribers.sort((N, U) => N.priority - U.priority), () => {
            const N = c().internal;
            N != null && N.subscribers && (N.priority = N.priority - (w > 0 ? 1 : 0), N.subscribers = N.subscribers.filter((U) => U.ref !== M));
          };
        }
      }
    };
  }), n = t.getState();
  let i = n.size, r = n.viewport.dpr, o = n.camera;
  return t.subscribe(() => {
    const {
      camera: u,
      size: c,
      viewport: d,
      gl: p,
      set: g
    } = t.getState();
    if (c.width !== i.width || c.height !== i.height || d.dpr !== r) {
      var v;
      i = c, r = d.dpr, B5(u, c), p.setPixelRatio(d.dpr);
      const y = (v = c.updateStyle) != null ? v : typeof HTMLCanvasElement < "u" && p.domElement instanceof HTMLCanvasElement;
      p.setSize(c.width, c.height, y);
    }
    u !== o && (o = u, g((y) => ({
      viewport: {
        ...y.viewport,
        ...y.viewport.getCurrentViewport(u)
      }
    })));
  }), t.subscribe((u) => s(u)), t;
};
let V0, U5 = /* @__PURE__ */ new Set(), F5 = /* @__PURE__ */ new Set(), N5 = /* @__PURE__ */ new Set();
function BE(s, e) {
  if (s.size)
    for (const {
      callback: t
    } of s.values())
      t(e);
}
function Hg(s, e) {
  switch (s) {
    case "before":
      return BE(U5, e);
    case "after":
      return BE(F5, e);
    case "tail":
      return BE(N5, e);
  }
}
let DE, LE;
function PE(s, e, t) {
  let n = e.clock.getDelta();
  for (e.frameloop === "never" && typeof s == "number" && (n = s - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = s), DE = e.internal.subscribers, V0 = 0; V0 < DE.length; V0++)
    LE = DE[V0], LE.ref.current(LE.store.getState(), n, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function O5(s) {
  let e = !1, t = !1, n, i, r;
  function o(d) {
    i = requestAnimationFrame(o), e = !0, n = 0, Hg("before", d), t = !0;
    for (const g of s.values()) {
      var p;
      r = g.store.getState(), r.internal.active && (r.frameloop === "always" || r.internal.frames > 0) && !((p = r.gl.xr) != null && p.isPresenting) && (n += PE(d, r));
    }
    if (t = !1, Hg("after", d), n === 0)
      return Hg("tail", d), e = !1, cancelAnimationFrame(i);
  }
  function u(d, p = 1) {
    var g;
    if (!d) return s.forEach((v) => u(v.store.getState(), p));
    (g = d.gl.xr) != null && g.isPresenting || !d.internal.active || d.frameloop === "never" || (p > 1 ? d.internal.frames = Math.min(60, d.internal.frames + p) : t ? d.internal.frames = 2 : d.internal.frames = 1, e || (e = !0, requestAnimationFrame(o)));
  }
  function c(d, p = !0, g, v) {
    if (p && Hg("before", d), g) PE(d, g, v);
    else for (const y of s.values()) PE(d, y.store.getState());
    p && Hg("after", d);
  }
  return {
    loop: o,
    invalidate: u,
    advance: c
  };
}
function J2() {
  const s = kn.useContext(X2);
  if (!s) throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return s;
}
function H5(s = (t) => t, e) {
  return J2()(s, e);
}
function z5(s, e = 0) {
  const t = J2(), n = t.getState().internal.subscribe, i = O2(s);
  return e_(() => n(i, e, t), [e, n, t]), null;
}
const wD = /* @__PURE__ */ new WeakMap();
function Y2(s, e) {
  return function(t, ...n) {
    let i = wD.get(t);
    return i || (i = new t(), wD.set(t, i)), s && s(i), Promise.all(n.map((r) => new Promise((o, u) => i.load(r, (c) => {
      c.scene && Object.assign(c, C5(c.scene)), o(c);
    }, e, (c) => u(new Error(`Could not load ${r}: ${c?.message}`))))));
  };
}
function t_(s, e, t, n) {
  const i = Array.isArray(e) ? e : [e], r = u5(Y2(t, n), [s, ...i], {
    equal: ci.equ
  });
  return Array.isArray(e) ? r : r[0];
}
t_.preload = function(s, e, t) {
  const n = Array.isArray(e) ? e : [e];
  return c5(Y2(t), [s, ...n]);
};
t_.clear = function(s, e) {
  const t = Array.isArray(e) ? e : [e];
  return f5([s, ...t]);
};
const Kp = /* @__PURE__ */ new Map(), {
  invalidate: RD,
  advance: BD
} = O5(Kp), {
  reconciler: Rx,
  applyProps: pp
} = M5(Kp, D5), mp = {
  objects: "shallow",
  strict: !1
}, G5 = (s, e) => {
  const t = typeof s == "function" ? s(e) : s;
  return W2(t) ? t : new Hb({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...s
  });
};
function k5(s, e) {
  const t = typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement;
  if (e) {
    const {
      width: n,
      height: i,
      top: r,
      left: o,
      updateStyle: u = t
    } = e;
    return {
      width: n,
      height: i,
      top: r,
      left: o,
      updateStyle: u
    };
  } else if (typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement && s.parentElement) {
    const {
      width: n,
      height: i,
      top: r,
      left: o
    } = s.parentElement.getBoundingClientRect();
    return {
      width: n,
      height: i,
      top: r,
      left: o,
      updateStyle: t
    };
  } else if (typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas)
    return {
      width: s.width,
      height: s.height,
      top: 0,
      left: 0,
      updateStyle: t
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function V5(s) {
  const e = Kp.get(s), t = e?.fiber, n = e?.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), r = n || I5(RD, BD), o = t || Rx.createContainer(r, Cp.ConcurrentRoot, null, !1, null, "", i, null);
  e || Kp.set(s, {
    fiber: o,
    store: r
  });
  let u, c = !1, d;
  return {
    configure(p = {}) {
      let {
        gl: g,
        size: v,
        scene: y,
        events: S,
        onCreated: T,
        shadows: E = !1,
        linear: M = !1,
        flat: w = !1,
        legacy: C = !1,
        orthographic: D = !1,
        frameloop: N = "always",
        dpr: U = [1, 2],
        performance: O,
        raycaster: V,
        camera: L,
        onPointerMissed: I
      } = p, Y = r.getState(), Q = Y.gl;
      Y.gl || Y.set({
        gl: Q = G5(g, s)
      });
      let fe = Y.raycaster;
      fe || Y.set({
        raycaster: fe = new D2()
      });
      const {
        params: j,
        ...ie
      } = V || {};
      if (ci.equ(ie, fe, mp) || pp(fe, {
        ...ie
      }), ci.equ(j, fe.params, mp) || pp(fe, {
        params: {
          ...fe.params,
          ...j
        }
      }), !Y.camera || Y.camera === d && !ci.equ(d, L, mp)) {
        d = L;
        const H = L instanceof Wv, ue = H ? L : D ? new sm(0, 0, 0, 0, 0.1, 1e3) : new Ar(75, 0, 0.1, 1e3);
        H || (ue.position.z = 5, L && (pp(ue, L), ("aspect" in L || "left" in L || "right" in L || "bottom" in L || "top" in L) && (ue.manual = !0, ue.updateProjectionMatrix())), !Y.camera && !(L != null && L.rotation) && ue.lookAt(0, 0, 0)), Y.set({
          camera: ue
        }), fe.camera = ue;
      }
      if (!Y.scene) {
        let H;
        y != null && y.isScene ? H = y : (H = new zb(), y && pp(H, y)), Y.set({
          scene: yp(H)
        });
      }
      if (!Y.xr) {
        var re;
        const H = (me, ye) => {
          const Xe = r.getState();
          Xe.frameloop !== "never" && BD(me, !0, Xe, ye);
        }, ue = () => {
          const me = r.getState();
          me.gl.xr.enabled = me.gl.xr.isPresenting, me.gl.xr.setAnimationLoop(me.gl.xr.isPresenting ? H : null), me.gl.xr.isPresenting || RD(me);
        }, Se = {
          connect() {
            const me = r.getState().gl;
            me.xr.addEventListener("sessionstart", ue), me.xr.addEventListener("sessionend", ue);
          },
          disconnect() {
            const me = r.getState().gl;
            me.xr.removeEventListener("sessionstart", ue), me.xr.removeEventListener("sessionend", ue);
          }
        };
        typeof ((re = Q.xr) == null ? void 0 : re.addEventListener) == "function" && Se.connect(), Y.set({
          xr: Se
        });
      }
      if (Q.shadowMap) {
        const H = Q.shadowMap.enabled, ue = Q.shadowMap.type;
        if (Q.shadowMap.enabled = !!E, ci.boo(E))
          Q.shadowMap.type = Zg;
        else if (ci.str(E)) {
          var pe;
          const Se = {
            basic: wL,
            percentage: Wx,
            soft: Zg,
            variance: No
          };
          Q.shadowMap.type = (pe = Se[E]) != null ? pe : Zg;
        } else ci.obj(E) && Object.assign(Q.shadowMap, E);
        (H !== Q.shadowMap.enabled || ue !== Q.shadowMap.type) && (Q.shadowMap.needsUpdate = !0);
      }
      const J = F2();
      J && ("enabled" in J ? J.enabled = !C : "legacyMode" in J && (J.legacyMode = C)), c || pp(Q, {
        outputEncoding: M ? 3e3 : 3001,
        toneMapping: w ? xl : _b
      }), Y.legacy !== C && Y.set(() => ({
        legacy: C
      })), Y.linear !== M && Y.set(() => ({
        linear: M
      })), Y.flat !== w && Y.set(() => ({
        flat: w
      })), g && !ci.fun(g) && !W2(g) && !ci.equ(g, Q, mp) && pp(Q, g), S && !Y.events.handlers && Y.set({
        events: S(r)
      });
      const Z = k5(s, v);
      return ci.equ(Z, Y.size, mp) || Y.setSize(Z.width, Z.height, Z.updateStyle, Z.top, Z.left), U && Y.viewport.dpr !== G2(U) && Y.setDpr(U), Y.frameloop !== N && Y.setFrameloop(N), Y.onPointerMissed || Y.set({
        onPointerMissed: I
      }), O && !ci.equ(O, Y.performance, mp) && Y.set((H) => ({
        performance: {
          ...H.performance,
          ...O
        }
      })), u = T, c = !0, this;
    },
    render(p) {
      return c || this.configure(), Rx.updateContainer(/* @__PURE__ */ Qi.jsx(W5, {
        store: r,
        children: p,
        onCreated: u,
        rootElement: s
      }), o, null, () => {
      }), r;
    },
    unmount() {
      K2(s);
    }
  };
}
function W5({
  store: s,
  children: e,
  onCreated: t,
  rootElement: n
}) {
  return e_(() => {
    const i = s.getState();
    i.set((r) => ({
      internal: {
        ...r.internal,
        active: !0
      }
    })), t && t(i), s.getState().events.connected || i.events.connect == null || i.events.connect(n);
  }, []), /* @__PURE__ */ Qi.jsx(X2.Provider, {
    value: s,
    children: e
  });
}
function K2(s, e) {
  const t = Kp.get(s), n = t?.fiber;
  if (n) {
    const i = t?.store.getState();
    i && (i.internal.active = !1), Rx.updateContainer(null, n, null, () => {
      i && setTimeout(() => {
        try {
          var r, o, u, c;
          i.events.disconnect == null || i.events.disconnect(), (r = i.gl) == null || (o = r.renderLists) == null || o.dispose == null || o.dispose(), (u = i.gl) == null || u.forceContextLoss == null || u.forceContextLoss(), (c = i.gl) != null && c.xr && i.xr.disconnect(), w5(i), Kp.delete(s);
        } catch {
        }
      }, 500);
    });
  }
}
Rx.injectIntoDevTools({
  bundleType: process.env.NODE_ENV === "production" ? 0 : 1,
  rendererPackageName: "@react-three/fiber",
  version: kn.version
});
const IE = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function X5(s) {
  const {
    handlePointer: e
  } = P5(s);
  return {
    priority: 1,
    enabled: !0,
    compute(t, n, i) {
      n.pointer.set(t.offsetX / n.size.width * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1), n.raycaster.setFromCamera(n.pointer, n.camera);
    },
    connected: void 0,
    handlers: Object.keys(IE).reduce((t, n) => ({
      ...t,
      [n]: e(n)
    }), {}),
    update: () => {
      var t;
      const {
        events: n,
        internal: i
      } = s.getState();
      (t = i.lastEvent) != null && t.current && n.handlers && n.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var n;
      const {
        set: i,
        events: r
      } = s.getState();
      r.disconnect == null || r.disconnect(), i((o) => ({
        events: {
          ...o.events,
          connected: t
        }
      })), Object.entries((n = r.handlers) != null ? n : []).forEach(([o, u]) => {
        const [c, d] = IE[o];
        t.addEventListener(c, u, {
          passive: d
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: n
      } = s.getState();
      if (n.connected) {
        var i;
        Object.entries((i = n.handlers) != null ? i : []).forEach(([r, o]) => {
          if (n && n.connected instanceof HTMLElement) {
            const [u] = IE[r];
            n.connected.removeEventListener(u, o);
          }
        }), t((r) => ({
          events: {
            ...r.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
function DD(s, e) {
  let t;
  return (...n) => {
    window.clearTimeout(t), t = window.setTimeout(() => s(...n), e);
  };
}
function J5({ debounce: s, scroll: e, polyfill: t, offsetSize: n } = { debounce: 0, scroll: !1, offsetSize: !1 }) {
  const i = t || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!i) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [r, o] = Ax({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), u = gl({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: r, orientationHandler: null }), c = s ? typeof s == "number" ? s : s.scroll : null, d = s ? typeof s == "number" ? s : s.resize : null, p = gl(!1);
  Tc(() => (p.current = !0, () => void (p.current = !1)));
  const [g, v, y] = l3(() => {
    const M = () => {
      if (!u.current.element) return;
      const { left: w, top: C, width: D, height: N, bottom: U, right: O, x: V, y: L } = u.current.element.getBoundingClientRect(), I = { left: w, top: C, width: D, height: N, bottom: U, right: O, x: V, y: L };
      u.current.element instanceof HTMLElement && n && (I.height = u.current.element.offsetHeight, I.width = u.current.element.offsetWidth), Object.freeze(I), p.current && !j5(u.current.lastBounds, I) && o(u.current.lastBounds = I);
    };
    return [M, d ? DD(M, d) : M, c ? DD(M, c) : M];
  }, [o, n, c, d]);
  function S() {
    u.current.scrollContainers && (u.current.scrollContainers.forEach((M) => M.removeEventListener("scroll", y, !0)), u.current.scrollContainers = null), u.current.resizeObserver && (u.current.resizeObserver.disconnect(), u.current.resizeObserver = null), u.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", u.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", u.current.orientationHandler));
  }
  function T() {
    u.current.element && (u.current.resizeObserver = new i(y), u.current.resizeObserver.observe(u.current.element), e && u.current.scrollContainers && u.current.scrollContainers.forEach((M) => M.addEventListener("scroll", y, { capture: !0, passive: !0 })), u.current.orientationHandler = () => {
      y();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", u.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", u.current.orientationHandler));
  }
  const E = (M) => {
    !M || M === u.current.element || (S(), u.current.element = M, u.current.scrollContainers = q2(M), T());
  };
  return K5(y, !!e), Y5(v), Tc(() => {
    S(), T();
  }, [e, y, v]), Tc(() => S, []), [E, r, g];
}
function Y5(s) {
  Tc(() => {
    const e = s;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [s]);
}
function K5(s, e) {
  Tc(() => {
    if (e) {
      const t = s;
      return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [s, e]);
}
function q2(s) {
  const e = [];
  if (!s || s === document.body) return e;
  const { overflow: t, overflowX: n, overflowY: i } = window.getComputedStyle(s);
  return [t, n, i].some((r) => r === "auto" || r === "scroll") && e.push(s), [...e, ...q2(s.parentElement)];
}
const q5 = ["x", "y", "top", "bottom", "left", "right", "width", "height"], j5 = (s, e) => q5.every((t) => s[t] === e[t]);
var Q5 = Object.defineProperty, Z5 = Object.defineProperties, $5 = Object.getOwnPropertyDescriptors, LD = Object.getOwnPropertySymbols, e8 = Object.prototype.hasOwnProperty, t8 = Object.prototype.propertyIsEnumerable, PD = (s, e, t) => e in s ? Q5(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, ID = (s, e) => {
  for (var t in e || (e = {}))
    e8.call(e, t) && PD(s, t, e[t]);
  if (LD)
    for (var t of LD(e))
      t8.call(e, t) && PD(s, t, e[t]);
  return s;
}, n8 = (s, e) => Z5(s, $5(e)), UD, FD;
typeof window < "u" && ((UD = window.document) != null && UD.createElement || ((FD = window.navigator) == null ? void 0 : FD.product) === "ReactNative") ? kn.useLayoutEffect : kn.useEffect;
function j2(s, e, t) {
  if (!s)
    return;
  if (t(s) === !0)
    return s;
  let n = s.child;
  for (; n; ) {
    const i = j2(n, e, t);
    if (i)
      return i;
    n = n.sibling;
  }
}
function Q2(s) {
  try {
    return Object.defineProperties(s, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return s;
  }
}
const ND = console.error;
console.error = function() {
  const s = [...arguments].join("");
  if (s?.startsWith("Warning:") && s.includes("useContext")) {
    console.error = ND;
    return;
  }
  return ND.apply(this, arguments);
};
const dC = Q2(kn.createContext(null));
class Z2 extends kn.Component {
  render() {
    return /* @__PURE__ */ kn.createElement(dC.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
function i8() {
  const s = kn.useContext(dC);
  if (s === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = kn.useId();
  return kn.useMemo(() => {
    for (const n of [s, s?.alternate]) {
      if (!n)
        continue;
      const i = j2(n, !1, (r) => {
        let o = r.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e)
            return !0;
          o = o.next;
        }
      });
      if (i)
        return i;
    }
  }, [s, e]);
}
function r8() {
  const s = i8(), [e] = kn.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = s;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const i = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      i && i !== dC && !e.has(i) && e.set(i, kn.useContext(Q2(i)));
    }
    t = t.return;
  }
  return e;
}
function s8() {
  const s = r8();
  return kn.useMemo(
    () => Array.from(s.keys()).reduce(
      (e, t) => (n) => /* @__PURE__ */ kn.createElement(e, null, /* @__PURE__ */ kn.createElement(t.Provider, n8(ID({}, n), {
        value: s.get(t)
      }))),
      (e) => /* @__PURE__ */ kn.createElement(Z2, ID({}, e))
    ),
    [s]
  );
}
const a8 = /* @__PURE__ */ kn.forwardRef(function({
  children: e,
  fallback: t,
  resize: n,
  style: i,
  gl: r,
  events: o = X5,
  eventSource: u,
  eventPrefix: c,
  shadows: d,
  linear: p,
  flat: g,
  legacy: v,
  orthographic: y,
  frameloop: S,
  dpr: T,
  performance: E,
  raycaster: M,
  camera: w,
  scene: C,
  onPointerMissed: D,
  onCreated: N,
  ...U
}, O) {
  kn.useMemo(() => A5(t5), []);
  const V = s8(), [L, I] = J5({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...n
  }), Y = kn.useRef(null), Q = kn.useRef(null);
  kn.useImperativeHandle(O, () => Y.current);
  const fe = O2(D), [j, ie] = kn.useState(!1), [re, pe] = kn.useState(!1);
  if (j) throw j;
  if (re) throw re;
  const J = kn.useRef(null);
  e_(() => {
    const H = Y.current;
    I.width > 0 && I.height > 0 && H && (J.current || (J.current = V5(H)), J.current.configure({
      gl: r,
      events: o,
      shadows: d,
      linear: p,
      flat: g,
      legacy: v,
      orthographic: y,
      frameloop: S,
      dpr: T,
      performance: E,
      raycaster: M,
      camera: w,
      scene: C,
      size: I,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...ue) => fe.current == null ? void 0 : fe.current(...ue),
      onCreated: (ue) => {
        ue.events.connect == null || ue.events.connect(u ? E5(u) ? u.current : u : Q.current), c && ue.setEvents({
          compute: (Se, me) => {
            const ye = Se[c + "X"], Xe = Se[c + "Y"];
            me.pointer.set(ye / me.size.width * 2 - 1, -(Xe / me.size.height) * 2 + 1), me.raycaster.setFromCamera(me.pointer, me.camera);
          }
        }), N?.(ue);
      }
    }), J.current.render(/* @__PURE__ */ Qi.jsx(V, {
      children: /* @__PURE__ */ Qi.jsx(H2, {
        set: pe,
        children: /* @__PURE__ */ Qi.jsx(kn.Suspense, {
          fallback: /* @__PURE__ */ Qi.jsx(T5, {
            set: ie
          }),
          children: e ?? null
        })
      })
    })));
  }), kn.useEffect(() => {
    const H = Y.current;
    if (H) return () => K2(H);
  }, []);
  const Z = u ? "none" : "auto";
  return /* @__PURE__ */ Qi.jsx("div", {
    ref: Q,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: Z,
      ...i
    },
    ...U,
    children: /* @__PURE__ */ Qi.jsx("div", {
      ref: L,
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ Qi.jsx("canvas", {
        ref: Y,
        style: {
          display: "block"
        },
        children: t
      })
    })
  });
}), o8 = /* @__PURE__ */ kn.forwardRef(function(e, t) {
  return /* @__PURE__ */ Qi.jsx(Z2, {
    children: /* @__PURE__ */ Qi.jsx(a8, {
      ...e,
      ref: t
    })
  });
}), l8 = parseInt(Gv.replace(/\D+/g, ""));
function OD(s, e) {
  if (e === vP)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), s;
  if (e === Tx || e === Cb) {
    let t = s.getIndex();
    if (t === null) {
      const o = [], u = s.getAttribute("position");
      if (u !== void 0) {
        for (let c = 0; c < u.count; c++)
          o.push(c);
        s.setIndex(o), t = s.getIndex();
      } else
        return console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ), s;
    }
    const n = t.count - 2, i = [];
    if (t)
      if (e === Tx)
        for (let o = 1; o <= n; o++)
          i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
      else
        for (let o = 0; o < n; o++)
          o % 2 === 0 ? (i.push(t.getX(o)), i.push(t.getX(o + 1)), i.push(t.getX(o + 2))) : (i.push(t.getX(o + 2)), i.push(t.getX(o + 1)), i.push(t.getX(o)));
    i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r = s.clone();
    return r.setIndex(i), r.clearGroups(), r;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), s;
}
function Bx(s) {
  if (typeof TextDecoder < "u")
    return new TextDecoder().decode(s);
  let e = "";
  for (let t = 0, n = s.length; t < n; t++)
    e += String.fromCharCode(s[t]);
  try {
    return decodeURIComponent(escape(e));
  } catch {
    return e;
  }
}
const Zf = "srgb", hu = "srgb-linear", HD = 3001, u8 = 3e3;
class hC extends Ms {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new p8(t);
    }), this.register(function(t) {
      return new m8(t);
    }), this.register(function(t) {
      return new E8(t);
    }), this.register(function(t) {
      return new T8(t);
    }), this.register(function(t) {
      return new b8(t);
    }), this.register(function(t) {
      return new v8(t);
    }), this.register(function(t) {
      return new _8(t);
    }), this.register(function(t) {
      return new y8(t);
    }), this.register(function(t) {
      return new x8(t);
    }), this.register(function(t) {
      return new h8(t);
    }), this.register(function(t) {
      return new S8(t);
    }), this.register(function(t) {
      return new g8(t);
    }), this.register(function(t) {
      return new M8(t);
    }), this.register(function(t) {
      return new A8(t);
    }), this.register(function(t) {
      return new f8(t);
    }), this.register(function(t) {
      return new C8(t);
    }), this.register(function(t) {
      return new w8(t);
    });
  }
  load(e, t, n, i) {
    const r = this;
    let o;
    if (this.resourcePath !== "")
      o = this.resourcePath;
    else if (this.path !== "") {
      const d = Rc.extractUrlBase(e);
      o = Rc.resolveURL(d, this.path);
    } else
      o = Rc.extractUrlBase(e);
    this.manager.itemStart(e);
    const u = function(d) {
      i ? i(d) : console.error(d), r.manager.itemError(e), r.manager.itemEnd(e);
    }, c = new Pa(this.manager);
    c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(this.withCredentials), c.load(
      e,
      function(d) {
        try {
          r.parse(
            d,
            o,
            function(p) {
              t(p), r.manager.itemEnd(e);
            },
            u
          );
        } catch (p) {
          u(p);
        }
      },
      n,
      u
    );
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, i) {
    let r;
    const o = {}, u = {};
    if (typeof e == "string")
      r = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (Bx(new Uint8Array(e.slice(0, 4))) === $2) {
        try {
          o[Ln.KHR_BINARY_GLTF] = new R8(e);
        } catch (p) {
          i && i(p);
          return;
        }
        r = JSON.parse(o[Ln.KHR_BINARY_GLTF].content);
      } else
        r = JSON.parse(Bx(new Uint8Array(e)));
    else
      r = e;
    if (r.asset === void 0 || r.asset.version[0] < 2) {
      i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const c = new k8(r, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let d = 0; d < this.pluginCallbacks.length; d++) {
      const p = this.pluginCallbacks[d](c);
      p.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), u[p.name] = p, o[p.name] = !0;
    }
    if (r.extensionsUsed)
      for (let d = 0; d < r.extensionsUsed.length; ++d) {
        const p = r.extensionsUsed[d], g = r.extensionsRequired || [];
        switch (p) {
          case Ln.KHR_MATERIALS_UNLIT:
            o[p] = new d8();
            break;
          case Ln.KHR_DRACO_MESH_COMPRESSION:
            o[p] = new B8(r, this.dracoLoader);
            break;
          case Ln.KHR_TEXTURE_TRANSFORM:
            o[p] = new D8();
            break;
          case Ln.KHR_MESH_QUANTIZATION:
            o[p] = new L8();
            break;
          default:
            g.indexOf(p) >= 0 && u[p] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + p + '".');
        }
      }
    c.setExtensions(o), c.setPlugins(u), c.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(i, r) {
      n.parse(e, t, i, r);
    });
  }
}
function c8() {
  let s = {};
  return {
    get: function(e) {
      return s[e];
    },
    add: function(e, t) {
      s[e] = t;
    },
    remove: function(e) {
      delete s[e];
    },
    removeAll: function() {
      s = {};
    }
  };
}
const Ln = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class f8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let i = t.cache.get(n);
    if (i)
      return i;
    const r = t.json, c = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
    let d;
    const p = new Tt(16777215);
    c.color !== void 0 && p.setRGB(c.color[0], c.color[1], c.color[2], hu);
    const g = c.range !== void 0 ? c.range : 0;
    switch (c.type) {
      case "directional":
        d = new sC(p), d.target.position.set(0, 0, -1), d.add(d.target);
        break;
      case "point":
        d = new rC(p), d.distance = g;
        break;
      case "spot":
        d = new iC(p), d.distance = g, c.spot = c.spot || {}, c.spot.innerConeAngle = c.spot.innerConeAngle !== void 0 ? c.spot.innerConeAngle : 0, c.spot.outerConeAngle = c.spot.outerConeAngle !== void 0 ? c.spot.outerConeAngle : Math.PI / 4, d.angle = c.spot.outerConeAngle, d.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle, d.target.position.set(0, 0, -1), d.add(d.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type);
    }
    return d.position.set(0, 0, 0), d.decay = 2, iu(d, c), c.intensity !== void 0 && (d.intensity = c.intensity), d.name = t.createUniqueName(c.name || "light_" + e), i = Promise.resolve(d), t.cache.add(n, i), i;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, r = n.json.nodes[e], u = (r.extensions && r.extensions[this.name] || {}).light;
    return u === void 0 ? null : this._loadLight(u).then(function(c) {
      return n._getNodeRef(t.cache, u, c);
    });
  }
}
class d8 {
  constructor() {
    this.name = Ln.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Ra;
  }
  extendParams(e, t, n) {
    const i = [];
    e.color = new Tt(1, 1, 1), e.opacity = 1;
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const o = r.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], hu), e.opacity = o[3];
      }
      r.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", r.baseColorTexture, Zf));
    }
    return Promise.all(i);
  }
}
class h8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class p8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : po;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const u = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new qe(u, u);
    }
    return Promise.all(r);
  }
}
class m8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : po;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name];
    return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
  }
}
class g8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : po;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && r.push(
      n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)
    ), Promise.all(r);
  }
}
class v8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : po;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [];
    t.sheenColor = new Tt(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = i.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const u = o.sheenColorFactor;
      t.sheenColor.setRGB(u[0], u[1], u[2], hu);
    }
    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Zf)), o.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(r);
  }
}
class _8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : po;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(r);
  }
}
class y8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : po;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const u = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Tt().setRGB(
      u[0],
      u[1],
      u[2],
      hu
    ), Promise.all(r);
  }
}
class x8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : po;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name];
    return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
  }
}
class S8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : po;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const u = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Tt().setRGB(u[0], u[1], u[2], hu), o.specularColorTexture !== void 0 && r.push(
      n.assignTexture(t, "specularColorMap", o.specularColorTexture, Zf)
    ), Promise.all(r);
  }
}
class A8 {
  constructor(e) {
    this.parser = e, this.name = Ln.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : po;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && r.push(n.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(r);
  }
}
class M8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : po;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(r);
  }
}
class E8 {
  constructor(e) {
    this.parser = e, this.name = Ln.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name])
      return null;
    const r = i.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, r.source, o);
  }
}
class T8 {
  constructor(e) {
    this.parser = e, this.name = Ln.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const o = r.extensions[t], u = i.images[o.source];
    let c = n.textureLoader;
    if (u.uri) {
      const d = n.options.manager.getHandler(u.uri);
      d !== null && (c = d);
    }
    return this.detectSupport().then(function(d) {
      if (d)
        return n.loadTextureImage(e, o.source, c);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class b8 {
  constructor(e) {
    this.parser = e, this.name = Ln.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const o = r.extensions[t], u = i.images[o.source];
    let c = n.textureLoader;
    if (u.uri) {
      const d = n.options.manager.getHandler(u.uri);
      d !== null && (c = d);
    }
    return this.detectSupport().then(function(d) {
      if (d)
        return n.loadTextureImage(e, o.source, c);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class C8 {
  constructor(e) {
    this.name = Ln.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name], r = this.parser.getDependency("buffer", i.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return r.then(function(u) {
        const c = i.byteOffset || 0, d = i.byteLength || 0, p = i.count, g = i.byteStride, v = new Uint8Array(u, c, d);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(p, g, v, i.mode, i.filter).then(function(y) {
          return y.buffer;
        }) : o.ready.then(function() {
          const y = new ArrayBuffer(p * g);
          return o.decodeGltfBuffer(
            new Uint8Array(y),
            p,
            g,
            v,
            i.mode,
            i.filter
          ), y;
        });
      });
    } else
      return null;
  }
}
class w8 {
  constructor(e) {
    this.name = Ln.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const d of i.primitives)
      if (d.mode !== ao.TRIANGLES && d.mode !== ao.TRIANGLE_STRIP && d.mode !== ao.TRIANGLE_FAN && d.mode !== void 0)
        return null;
    const o = n.extensions[this.name].attributes, u = [], c = {};
    for (const d in o)
      u.push(
        this.parser.getDependency("accessor", o[d]).then((p) => (c[d] = p, c[d]))
      );
    return u.length < 1 ? null : (u.push(this.parser.createNodeMesh(e)), Promise.all(u).then((d) => {
      const p = d.pop(), g = p.isGroup ? p.children : [p], v = d[0].count, y = [];
      for (const S of g) {
        const T = new sn(), E = new q(), M = new ys(), w = new q(1, 1, 1), C = new Vb(S.geometry, S.material, v);
        for (let D = 0; D < v; D++)
          c.TRANSLATION && E.fromBufferAttribute(c.TRANSLATION, D), c.ROTATION && M.fromBufferAttribute(c.ROTATION, D), c.SCALE && w.fromBufferAttribute(c.SCALE, D), C.setMatrixAt(D, T.compose(E, M, w));
        for (const D in c)
          if (D === "_COLOR_0") {
            const N = c[D];
            C.instanceColor = new md(N.array, N.itemSize, N.normalized);
          } else D !== "TRANSLATION" && D !== "ROTATION" && D !== "SCALE" && S.geometry.setAttribute(D, c[D]);
        On.prototype.copy.call(C, S), this.parser.assignFinalMaterial(C), y.push(C);
      }
      return p.isGroup ? (p.clear(), p.add(...y), p) : y[0];
    }));
  }
}
const $2 = "glTF", zg = 12, zD = { JSON: 1313821514, BIN: 5130562 };
class R8 {
  constructor(e) {
    this.name = Ln.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, zg);
    if (this.header = {
      magic: Bx(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== $2)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - zg, i = new DataView(e, zg);
    let r = 0;
    for (; r < n; ) {
      const o = i.getUint32(r, !0);
      r += 4;
      const u = i.getUint32(r, !0);
      if (r += 4, u === zD.JSON) {
        const c = new Uint8Array(e, zg + r, o);
        this.content = Bx(c);
      } else if (u === zD.BIN) {
        const c = zg + r;
        this.body = e.slice(c, c + o);
      }
      r += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class B8 {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ln.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, i = this.dracoLoader, r = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, u = {}, c = {}, d = {};
    for (const p in o) {
      const g = XT[p] || p.toLowerCase();
      u[g] = o[p];
    }
    for (const p in e.attributes) {
      const g = XT[p] || p.toLowerCase();
      if (o[p] !== void 0) {
        const v = n.accessors[e.attributes[p]], y = Pp[v.componentType];
        d[g] = y.name, c[g] = v.normalized === !0;
      }
    }
    return t.getDependency("bufferView", r).then(function(p) {
      return new Promise(function(g, v) {
        i.decodeDracoFile(
          p,
          function(y) {
            for (const S in y.attributes) {
              const T = y.attributes[S], E = c[S];
              E !== void 0 && (T.normalized = E);
            }
            g(y);
          },
          u,
          d,
          hu,
          v
        );
      });
    });
  }
}
class D8 {
  constructor() {
    this.name = Ln.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class L8 {
  constructor() {
    this.name = Ln.KHR_MESH_QUANTIZATION;
  }
}
class eI extends lm {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i * 3 + i;
    for (let o = 0; o !== i; o++)
      t[o] = n[r + o];
    return t;
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, o = this.sampleValues, u = this.valueSize, c = u * 2, d = u * 3, p = i - t, g = (n - t) / p, v = g * g, y = v * g, S = e * d, T = S - d, E = -2 * y + 3 * v, M = y - v, w = 1 - E, C = M - v + g;
    for (let D = 0; D !== u; D++) {
      const N = o[T + D + u], U = o[T + D + c] * p, O = o[S + D + u], V = o[S + D] * p;
      r[D] = w * N + C * U + E * O + M * V;
    }
    return r;
  }
}
const P8 = /* @__PURE__ */ new ys();
class I8 extends eI {
  interpolate_(e, t, n, i) {
    const r = super.interpolate_(e, t, n, i);
    return P8.fromArray(r).normalize().toArray(r), r;
  }
}
const ao = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, Pp = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, GD = {
  9728: Oi,
  9729: bi,
  9984: yv,
  9985: Jx,
  9986: Dp,
  9987: Tl
}, kD = {
  33071: qr,
  33648: Gp,
  10497: Ic
}, UE = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, XT = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  // uv => uv1, 4 uv channels
  // https://github.com/mrdoob/three.js/pull/25943
  // https://github.com/mrdoob/three.js/pull/25788
  ...l8 >= 152 ? {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3"
  } : {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2"
  },
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, gc = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, U8 = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: pd,
  STEP: Vp
}, FE = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function F8(s) {
  return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new $v({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: El
  })), s.DefaultMaterial;
}
function Of(s, e, t) {
  for (const n in t.extensions)
    s[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function iu(s, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(s.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function N8(s, e, t) {
  let n = !1, i = !1, r = !1;
  for (let d = 0, p = e.length; d < p; d++) {
    const g = e[d];
    if (g.POSITION !== void 0 && (n = !0), g.NORMAL !== void 0 && (i = !0), g.COLOR_0 !== void 0 && (r = !0), n && i && r)
      break;
  }
  if (!n && !i && !r)
    return Promise.resolve(s);
  const o = [], u = [], c = [];
  for (let d = 0, p = e.length; d < p; d++) {
    const g = e[d];
    if (n) {
      const v = g.POSITION !== void 0 ? t.getDependency("accessor", g.POSITION) : s.attributes.position;
      o.push(v);
    }
    if (i) {
      const v = g.NORMAL !== void 0 ? t.getDependency("accessor", g.NORMAL) : s.attributes.normal;
      u.push(v);
    }
    if (r) {
      const v = g.COLOR_0 !== void 0 ? t.getDependency("accessor", g.COLOR_0) : s.attributes.color;
      c.push(v);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(u),
    Promise.all(c)
  ]).then(function(d) {
    const p = d[0], g = d[1], v = d[2];
    return n && (s.morphAttributes.position = p), i && (s.morphAttributes.normal = g), r && (s.morphAttributes.color = v), s.morphTargetsRelative = !0, s;
  });
}
function O8(s, e) {
  if (s.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      s.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (s.morphTargetInfluences.length === t.length) {
      s.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        s.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function H8(s) {
  let e;
  const t = s.extensions && s.extensions[Ln.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + NE(t.attributes) : e = s.indices + ":" + NE(s.attributes) + ":" + s.mode, s.targets !== void 0)
    for (let n = 0, i = s.targets.length; n < i; n++)
      e += ":" + NE(s.targets[n]);
  return e;
}
function NE(s) {
  let e = "";
  const t = Object.keys(s).sort();
  for (let n = 0, i = t.length; n < i; n++)
    e += t[n] + ":" + s[t[n]] + ";";
  return e;
}
function JT(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function z8(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const G8 = /* @__PURE__ */ new sn();
class k8 {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new c8(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, i = !1, r = -1;
    typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || i && r < 98 ? this.textureLoader = new y2(this.options.manager) : this.textureLoader = new C2(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new Pa(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, i = this.json, r = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(
      this._invokeAll(function(o) {
        return o.beforeRoot && o.beforeRoot();
      })
    ).then(function() {
      return Promise.all([
        n.getDependencies("scene"),
        n.getDependencies("animation"),
        n.getDependencies("camera")
      ]);
    }).then(function(o) {
      const u = {
        scene: o[0][i.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: i.asset,
        parser: n,
        userData: {}
      };
      return Of(r, u, i), iu(u, i), Promise.all(
        n._invokeAll(function(c) {
          return c.afterRoot && c.afterRoot(u);
        })
      ).then(function() {
        for (const c of u.scenes)
          c.updateMatrixWorld();
        e(u);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i].joints;
      for (let u = 0, c = o.length; u < c; u++)
        e[o[u]].isBone = !0;
    }
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1)
      return n;
    const i = n.clone(), r = (o, u) => {
      const c = this.associations.get(o);
      c != null && this.associations.set(u, c);
      for (const [d, p] of o.children.entries())
        r(p, u.children[d]);
    };
    return r(n, i), i.name += "_instance_" + e.uses[t]++, i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i)
        return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      r && n.push(r);
    }
    return n;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function(r) {
            return r.loadNode && r.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function(r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function(r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function(r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function(r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function(r) {
            return r.loadAnimation && r.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (i = this._invokeOne(function(r) {
            return r != this && r.getDependency && r.getDependency(e, t);
          }), !i)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(
        i.map(function(r, o) {
          return n.getDependency(e, o);
        })
      ), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ln.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function(r, o) {
      n.load(Rc.resolveURL(t.uri, i.path), r, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const i = t.byteLength || 0, r = t.byteOffset || 0;
      return n.slice(r, r + i);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, n = this.json, i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const o = UE[i.type], u = Pp[i.componentType], c = i.normalized === !0, d = new u(i.count * o);
      return Promise.resolve(new Hn(d, o, c));
    }
    const r = [];
    return i.bufferView !== void 0 ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), i.sparse !== void 0 && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then(function(o) {
      const u = o[0], c = UE[i.type], d = Pp[i.componentType], p = d.BYTES_PER_ELEMENT, g = p * c, v = i.byteOffset || 0, y = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0, S = i.normalized === !0;
      let T, E;
      if (y && y !== g) {
        const M = Math.floor(v / y), w = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + M + ":" + i.count;
        let C = t.cache.get(w);
        C || (T = new d(u, M * y, i.count * y / p), C = new Kv(T, y / p), t.cache.add(w, C)), E = new Uc(
          C,
          c,
          v % y / p,
          S
        );
      } else
        u === null ? T = new d(i.count * c) : T = new d(u, v, i.count * c), E = new Hn(T, c, S);
      if (i.sparse !== void 0) {
        const M = UE.SCALAR, w = Pp[i.sparse.indices.componentType], C = i.sparse.indices.byteOffset || 0, D = i.sparse.values.byteOffset || 0, N = new w(
          o[1],
          C,
          i.sparse.count * M
        ), U = new d(o[2], D, i.sparse.count * c);
        u !== null && (E = new Hn(
          E.array.slice(),
          E.itemSize,
          E.normalized
        ));
        for (let O = 0, V = N.length; O < V; O++) {
          const L = N[O];
          if (E.setX(L, U[O * c]), c >= 2 && E.setY(L, U[O * c + 1]), c >= 3 && E.setZ(L, U[O * c + 2]), c >= 4 && E.setW(L, U[O * c + 3]), c >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return E;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, n = this.options, r = t.textures[e].source, o = t.images[r];
    let u = this.textureLoader;
    if (o.uri) {
      const c = n.manager.getHandler(o.uri);
      c !== null && (u = c);
    }
    return this.loadTextureImage(e, r, u);
  }
  loadTextureImage(e, t, n) {
    const i = this, r = this.json, o = r.textures[e], u = r.images[t], c = (u.uri || u.bufferView) + ":" + o.sampler;
    if (this.textureCache[c])
      return this.textureCache[c];
    const d = this.loadImageSource(t, n).then(function(p) {
      p.flipY = !1, p.name = o.name || u.name || "", p.name === "" && typeof u.uri == "string" && u.uri.startsWith("data:image/") === !1 && (p.name = u.uri);
      const v = (r.samplers || {})[o.sampler] || {};
      return p.magFilter = GD[v.magFilter] || bi, p.minFilter = GD[v.minFilter] || Tl, p.wrapS = kD[v.wrapS] || Ic, p.wrapT = kD[v.wrapT] || Ic, i.associations.set(p, { textures: e }), p;
    }).catch(function() {
      return null;
    });
    return this.textureCache[c] = d, d;
  }
  loadImageSource(e, t) {
    const n = this, i = this.json, r = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((g) => g.clone());
    const o = i.images[e], u = self.URL || self.webkitURL;
    let c = o.uri || "", d = !1;
    if (o.bufferView !== void 0)
      c = n.getDependency("bufferView", o.bufferView).then(function(g) {
        d = !0;
        const v = new Blob([g], { type: o.mimeType });
        return c = u.createObjectURL(v), c;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const p = Promise.resolve(c).then(function(g) {
      return new Promise(function(v, y) {
        let S = v;
        t.isImageBitmapLoader === !0 && (S = function(T) {
          const E = new Ri(T);
          E.needsUpdate = !0, v(E);
        }), t.load(Rc.resolveURL(g, r.path), S, void 0, y);
      });
    }).then(function(g) {
      return d === !0 && u.revokeObjectURL(c), iu(g, o), g.userData.mimeType = o.mimeType || z8(o.uri), g;
    }).catch(function(g) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", c), g;
    });
    return this.sourceCache[e] = p, p;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, n, i) {
    const r = this;
    return this.getDependency("texture", n.index).then(function(o) {
      if (!o)
        return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(), o.channel = n.texCoord), r.extensions[Ln.KHR_TEXTURE_TRANSFORM]) {
        const u = n.extensions !== void 0 ? n.extensions[Ln.KHR_TEXTURE_TRANSFORM] : void 0;
        if (u) {
          const c = r.associations.get(o);
          o = r.extensions[Ln.KHR_TEXTURE_TRANSFORM].extendTexture(o, u), r.associations.set(o, c);
        }
      }
      return i !== void 0 && (typeof i == "number" && (i = i === HD ? Zf : hu), "colorSpace" in o ? o.colorSpace = i : o.encoding = i === Zf ? HD : u8), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const u = "PointsMaterial:" + n.uuid;
      let c = this.cache.get(u);
      c || (c = new tS(), Mr.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, c.sizeAttenuation = !1, this.cache.add(u, c)), n = c;
    } else if (e.isLine) {
      const u = "LineBasicMaterial:" + n.uuid;
      let c = this.cache.get(u);
      c || (c = new As(), Mr.prototype.copy.call(c, n), c.color.copy(n.color), c.map = n.map, this.cache.add(u, c)), n = c;
    }
    if (i || r || o) {
      let u = "ClonedMaterial:" + n.uuid + ":";
      i && (u += "derivative-tangents:"), r && (u += "vertex-colors:"), o && (u += "flat-shading:");
      let c = this.cache.get(u);
      c || (c = n.clone(), r && (c.vertexColors = !0), o && (c.flatShading = !0), i && (c.normalScale && (c.normalScale.y *= -1), c.clearcoatNormalScale && (c.clearcoatNormalScale.y *= -1)), this.cache.add(u, c), this.associations.set(c, this.associations.get(n))), n = c;
    }
    e.material = n;
  }
  getMaterialType() {
    return $v;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, n = this.json, i = this.extensions, r = n.materials[e];
    let o;
    const u = {}, c = r.extensions || {}, d = [];
    if (c[Ln.KHR_MATERIALS_UNLIT]) {
      const g = i[Ln.KHR_MATERIALS_UNLIT];
      o = g.getMaterialType(), d.push(g.extendParams(u, r, t));
    } else {
      const g = r.pbrMetallicRoughness || {};
      if (u.color = new Tt(1, 1, 1), u.opacity = 1, Array.isArray(g.baseColorFactor)) {
        const v = g.baseColorFactor;
        u.color.setRGB(v[0], v[1], v[2], hu), u.opacity = v[3];
      }
      g.baseColorTexture !== void 0 && d.push(t.assignTexture(u, "map", g.baseColorTexture, Zf)), u.metalness = g.metallicFactor !== void 0 ? g.metallicFactor : 1, u.roughness = g.roughnessFactor !== void 0 ? g.roughnessFactor : 1, g.metallicRoughnessTexture !== void 0 && (d.push(t.assignTexture(u, "metalnessMap", g.metallicRoughnessTexture)), d.push(t.assignTexture(u, "roughnessMap", g.metallicRoughnessTexture))), o = this._invokeOne(function(v) {
        return v.getMaterialType && v.getMaterialType(e);
      }), d.push(
        Promise.all(
          this._invokeAll(function(v) {
            return v.extendMaterialParams && v.extendMaterialParams(e, u);
          })
        )
      );
    }
    r.doubleSided === !0 && (u.side = Ho);
    const p = r.alphaMode || FE.OPAQUE;
    if (p === FE.BLEND ? (u.transparent = !0, u.depthWrite = !1) : (u.transparent = !1, p === FE.MASK && (u.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && o !== Ra && (d.push(t.assignTexture(u, "normalMap", r.normalTexture)), u.normalScale = new qe(1, 1), r.normalTexture.scale !== void 0)) {
      const g = r.normalTexture.scale;
      u.normalScale.set(g, g);
    }
    if (r.occlusionTexture !== void 0 && o !== Ra && (d.push(t.assignTexture(u, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (u.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && o !== Ra) {
      const g = r.emissiveFactor;
      u.emissive = new Tt().setRGB(
        g[0],
        g[1],
        g[2],
        hu
      );
    }
    return r.emissiveTexture !== void 0 && o !== Ra && d.push(t.assignTexture(u, "emissiveMap", r.emissiveTexture, Zf)), Promise.all(d).then(function() {
      const g = new o(u);
      return r.name && (g.name = r.name), iu(g, r), t.associations.set(g, { materials: e }), r.extensions && Of(i, g, r), g;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Nn.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, n = this.extensions, i = this.primitiveCache;
    function r(u) {
      return n[Ln.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(u, t).then(function(c) {
        return VD(c, u, t);
      });
    }
    const o = [];
    for (let u = 0, c = e.length; u < c; u++) {
      const d = e[u], p = H8(d), g = i[p];
      if (g)
        o.push(g.promise);
      else {
        let v;
        d.extensions && d.extensions[Ln.KHR_DRACO_MESH_COMPRESSION] ? v = r(d) : v = VD(new pn(), d, t), i[p] = { primitive: d, promise: v }, o.push(v);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, n = this.json, i = this.extensions, r = n.meshes[e], o = r.primitives, u = [];
    for (let c = 0, d = o.length; c < d; c++) {
      const p = o[c].material === void 0 ? F8(this.cache) : this.getDependency("material", o[c].material);
      u.push(p);
    }
    return u.push(t.loadGeometries(o)), Promise.all(u).then(function(c) {
      const d = c.slice(0, c.length - 1), p = c[c.length - 1], g = [];
      for (let y = 0, S = p.length; y < S; y++) {
        const T = p[y], E = o[y];
        let M;
        const w = d[y];
        if (E.mode === ao.TRIANGLES || E.mode === ao.TRIANGLE_STRIP || E.mode === ao.TRIANGLE_FAN || E.mode === void 0)
          M = r.isSkinnedMesh === !0 ? new kb(T, w) : new ur(T, w), M.isSkinnedMesh === !0 && M.normalizeSkinWeights(), E.mode === ao.TRIANGLE_STRIP ? M.geometry = OD(M.geometry, Cb) : E.mode === ao.TRIANGLE_FAN && (M.geometry = OD(M.geometry, Tx));
        else if (E.mode === ao.LINES)
          M = new Vo(T, w);
        else if (E.mode === ao.LINE_STRIP)
          M = new gu(T, w);
        else if (E.mode === ao.LINE_LOOP)
          M = new Wb(T, w);
        else if (E.mode === ao.POINTS)
          M = new Xb(T, w);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + E.mode);
        Object.keys(M.geometry.morphAttributes).length > 0 && O8(M, r), M.name = t.createUniqueName(r.name || "mesh_" + e), iu(M, r), E.extensions && Of(i, M, E), t.assignFinalMaterial(M), g.push(M);
      }
      for (let y = 0, S = g.length; y < S; y++)
        t.associations.set(g[y], {
          meshes: e,
          primitives: y
        });
      if (g.length === 1)
        return r.extensions && Of(i, g[0], r), g[0];
      const v = new uu();
      r.extensions && Of(i, v, r), t.associations.set(v, { meshes: e });
      for (let y = 0, S = g.length; y < S; y++)
        v.add(g[y]);
      return v;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return n.type === "perspective" ? t = new Ar(
      ev.radToDeg(i.yfov),
      i.aspectRatio || 1,
      i.znear || 1,
      i.zfar || 2e6
    ) : n.type === "orthographic" && (t = new sm(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), iu(t, n), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let i = 0, r = t.joints.length; i < r; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
      const r = i.pop(), o = i, u = [], c = [];
      for (let d = 0, p = o.length; d < p; d++) {
        const g = o[d];
        if (g) {
          u.push(g);
          const v = new sn();
          r !== null && v.fromArray(r.array, d * 16), c.push(v);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[d]);
      }
      return new qv(u, c);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, n = this, i = t.animations[e], r = i.name ? i.name : "animation_" + e, o = [], u = [], c = [], d = [], p = [];
    for (let g = 0, v = i.channels.length; g < v; g++) {
      const y = i.channels[g], S = i.samplers[y.sampler], T = y.target, E = T.node, M = i.parameters !== void 0 ? i.parameters[S.input] : S.input, w = i.parameters !== void 0 ? i.parameters[S.output] : S.output;
      T.node !== void 0 && (o.push(this.getDependency("node", E)), u.push(this.getDependency("accessor", M)), c.push(this.getDependency("accessor", w)), d.push(S), p.push(T));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(u),
      Promise.all(c),
      Promise.all(d),
      Promise.all(p)
    ]).then(function(g) {
      const v = g[0], y = g[1], S = g[2], T = g[3], E = g[4], M = [];
      for (let w = 0, C = v.length; w < C; w++) {
        const D = v[w], N = y[w], U = S[w], O = T[w], V = E[w];
        if (D === void 0)
          continue;
        D.updateMatrix && D.updateMatrix();
        const L = n._createAnimationTracks(D, N, U, O, V);
        if (L)
          for (let I = 0; I < L.length; I++)
            M.push(L[I]);
      }
      return new Yp(r, void 0, M);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, i = t.nodes[e];
    return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(r) {
      const o = n._getNodeRef(n.meshCache, i.mesh, r);
      return i.weights !== void 0 && o.traverse(function(u) {
        if (u.isMesh)
          for (let c = 0, d = i.weights.length; c < d; c++)
            u.morphTargetInfluences[c] = i.weights[c];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, n = this, i = t.nodes[e], r = n._loadNodeShallow(e), o = [], u = i.children || [];
    for (let d = 0, p = u.length; d < p; d++)
      o.push(n.getDependency("node", u[d]));
    const c = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
    return Promise.all([r, Promise.all(o), c]).then(function(d) {
      const p = d[0], g = d[1], v = d[2];
      v !== null && p.traverse(function(y) {
        y.isSkinnedMesh && y.bind(v, G8);
      });
      for (let y = 0, S = g.length; y < S; y++)
        p.add(g[y]);
      return p;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, i = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const r = t.nodes[e], o = r.name ? i.createUniqueName(r.name) : "", u = [], c = i._invokeOne(function(d) {
      return d.createNodeMesh && d.createNodeMesh(e);
    });
    return c && u.push(c), r.camera !== void 0 && u.push(
      i.getDependency("camera", r.camera).then(function(d) {
        return i._getNodeRef(i.cameraCache, r.camera, d);
      })
    ), i._invokeAll(function(d) {
      return d.createNodeAttachment && d.createNodeAttachment(e);
    }).forEach(function(d) {
      u.push(d);
    }), this.nodeCache[e] = Promise.all(u).then(function(d) {
      let p;
      if (r.isBone === !0 ? p = new eS() : d.length > 1 ? p = new uu() : d.length === 1 ? p = d[0] : p = new On(), p !== d[0])
        for (let g = 0, v = d.length; g < v; g++)
          p.add(d[g]);
      if (r.name && (p.userData.name = r.name, p.name = o), iu(p, r), r.extensions && Of(n, p, r), r.matrix !== void 0) {
        const g = new sn();
        g.fromArray(r.matrix), p.applyMatrix4(g);
      } else
        r.translation !== void 0 && p.position.fromArray(r.translation), r.rotation !== void 0 && p.quaternion.fromArray(r.rotation), r.scale !== void 0 && p.scale.fromArray(r.scale);
      return i.associations.has(p) || i.associations.set(p, {}), i.associations.get(p).nodes = e, p;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], i = this, r = new uu();
    n.name && (r.name = i.createUniqueName(n.name)), iu(r, n), n.extensions && Of(t, r, n);
    const o = n.nodes || [], u = [];
    for (let c = 0, d = o.length; c < d; c++)
      u.push(i.getDependency("node", o[c]));
    return Promise.all(u).then(function(c) {
      for (let p = 0, g = c.length; p < g; p++)
        r.add(c[p]);
      const d = (p) => {
        const g = /* @__PURE__ */ new Map();
        for (const [v, y] of i.associations)
          (v instanceof Mr || v instanceof Ri) && g.set(v, y);
        return p.traverse((v) => {
          const y = i.associations.get(v);
          y != null && g.set(v, y);
        }), g;
      };
      return i.associations = d(r), r;
    });
  }
  _createAnimationTracks(e, t, n, i, r) {
    const o = [], u = e.name ? e.name : e.uuid, c = [];
    gc[r.path] === gc.weights ? e.traverse(function(v) {
      v.morphTargetInfluences && c.push(v.name ? v.name : v.uuid);
    }) : c.push(u);
    let d;
    switch (gc[r.path]) {
      case gc.weights:
        d = vd;
        break;
      case gc.rotation:
        d = Fc;
        break;
      case gc.position:
      case gc.scale:
        d = _d;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            d = vd;
            break;
          case 2:
          case 3:
          default:
            d = _d;
            break;
        }
        break;
    }
    const p = i.interpolation !== void 0 ? U8[i.interpolation] : pd, g = this._getArrayFromAccessor(n);
    for (let v = 0, y = c.length; v < y; v++) {
      const S = new d(
        c[v] + "." + gc[r.path],
        t.array,
        g,
        p
      );
      i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(S), o.push(S);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = JT(t.constructor), i = new Float32Array(t.length);
      for (let r = 0, o = t.length; r < o; r++)
        i[r] = t[r] * n;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(n) {
      const i = this instanceof Fc ? I8 : eI;
      return new i(this.times, this.values, this.getValueSize() / 3, n);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function V8(s, e, t) {
  const n = e.attributes, i = new xs();
  if (n.POSITION !== void 0) {
    const u = t.json.accessors[n.POSITION], c = u.min, d = u.max;
    if (c !== void 0 && d !== void 0) {
      if (i.set(new q(c[0], c[1], c[2]), new q(d[0], d[1], d[2])), u.normalized) {
        const p = JT(Pp[u.componentType]);
        i.min.multiplyScalar(p), i.max.multiplyScalar(p);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const r = e.targets;
  if (r !== void 0) {
    const u = new q(), c = new q();
    for (let d = 0, p = r.length; d < p; d++) {
      const g = r[d];
      if (g.POSITION !== void 0) {
        const v = t.json.accessors[g.POSITION], y = v.min, S = v.max;
        if (y !== void 0 && S !== void 0) {
          if (c.setX(Math.max(Math.abs(y[0]), Math.abs(S[0]))), c.setY(Math.max(Math.abs(y[1]), Math.abs(S[1]))), c.setZ(Math.max(Math.abs(y[2]), Math.abs(S[2]))), v.normalized) {
            const T = JT(Pp[v.componentType]);
            c.multiplyScalar(T);
          }
          u.max(c);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    i.expandByVector(u);
  }
  s.boundingBox = i;
  const o = new Qr();
  i.getCenter(o.center), o.radius = i.min.distanceTo(i.max) / 2, s.boundingSphere = o;
}
function VD(s, e, t) {
  const n = e.attributes, i = [];
  function r(o, u) {
    return t.getDependency("accessor", o).then(function(c) {
      s.setAttribute(u, c);
    });
  }
  for (const o in n) {
    const u = XT[o] || o.toLowerCase();
    u in s.attributes || i.push(r(n[o], u));
  }
  if (e.indices !== void 0 && !s.index) {
    const o = t.getDependency("accessor", e.indices).then(function(u) {
      s.setIndex(u);
    });
    i.push(o);
  }
  return iu(s, e), V8(s, e, t), Promise.all(i).then(function() {
    return e.targets !== void 0 ? N8(s, e.targets, t) : s;
  });
}
const OE = /* @__PURE__ */ new WeakMap();
class W8 extends Ms {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, n, i) {
    const r = new Pa(this.manager);
    r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(
      e,
      (o) => {
        const u = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: !1
        };
        this.decodeGeometry(o, u).then(t).catch(i);
      },
      n,
      i
    );
  }
  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
  decodeDracoFile(e, t, n, i) {
    const r = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n
    };
    this.decodeGeometry(e, r).then(t);
  }
  decodeGeometry(e, t) {
    for (const c in t.attributeTypes) {
      const d = t.attributeTypes[c];
      d.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[c] = d.name);
    }
    const n = JSON.stringify(t);
    if (OE.has(e)) {
      const c = OE.get(e);
      if (c.key === n)
        return c.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let i;
    const r = this.workerNextTaskID++, o = e.byteLength, u = this._getWorker(r, o).then((c) => (i = c, new Promise((d, p) => {
      i._callbacks[r] = { resolve: d, reject: p }, i.postMessage({ type: "decode", id: r, taskConfig: t, buffer: e }, [e]);
    }))).then((c) => this._createGeometry(c.geometry));
    return u.catch(() => !0).then(() => {
      i && r && this._releaseTask(i, r);
    }), OE.set(e, {
      key: n,
      promise: u
    }), u;
  }
  _createGeometry(e) {
    const t = new pn();
    e.index && t.setIndex(new Hn(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const i = e.attributes[n], r = i.name, o = i.array, u = i.itemSize;
      t.setAttribute(r, new Hn(o, u));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const n = new Pa(this.manager);
    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((i, r) => {
      n.load(e, i, void 0, r);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
      const i = n[0];
      e || (this.decoderConfig.wasmBinary = n[1]);
      const r = X8.toString(), o = [
        "/* draco decoder */",
        i,
        "",
        "/* worker */",
        r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({ type: "init", decoderConfig: this.decoderConfig }), i.onmessage = function(r) {
          const o = r.data;
          switch (o.type) {
            case "decode":
              i._callbacks[o.id].resolve(o);
              break;
            case "error":
              i._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(i);
      } else
        this.workerPool.sort(function(i, r) {
          return i._taskLoad > r._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return n._taskCosts[e] = t, n._taskLoad += t, n;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
}
function X8() {
  let s, e;
  onmessage = function(o) {
    const u = o.data;
    switch (u.type) {
      case "init":
        s = u.decoderConfig, e = new Promise(function(p) {
          s.onModuleLoaded = function(g) {
            p({ draco: g });
          }, DracoDecoderModule(s);
        });
        break;
      case "decode":
        const c = u.buffer, d = u.taskConfig;
        e.then((p) => {
          const g = p.draco, v = new g.Decoder(), y = new g.DecoderBuffer();
          y.Init(new Int8Array(c), c.byteLength);
          try {
            const S = t(g, v, y, d), T = S.attributes.map((E) => E.array.buffer);
            S.index && T.push(S.index.array.buffer), self.postMessage({ type: "decode", id: u.id, geometry: S }, T);
          } catch (S) {
            console.error(S), self.postMessage({ type: "error", id: u.id, error: S.message });
          } finally {
            g.destroy(y), g.destroy(v);
          }
        });
        break;
    }
  };
  function t(o, u, c, d) {
    const p = d.attributeIDs, g = d.attributeTypes;
    let v, y;
    const S = u.GetEncodedGeometryType(c);
    if (S === o.TRIANGULAR_MESH)
      v = new o.Mesh(), y = u.DecodeBufferToMesh(c, v);
    else if (S === o.POINT_CLOUD)
      v = new o.PointCloud(), y = u.DecodeBufferToPointCloud(c, v);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!y.ok() || v.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + y.error_msg());
    const T = { index: null, attributes: [] };
    for (const E in p) {
      const M = self[g[E]];
      let w, C;
      if (d.useUniqueIDs)
        C = p[E], w = u.GetAttributeByUniqueId(v, C);
      else {
        if (C = u.GetAttributeId(v, o[p[E]]), C === -1)
          continue;
        w = u.GetAttribute(v, C);
      }
      T.attributes.push(i(o, u, v, E, M, w));
    }
    return S === o.TRIANGULAR_MESH && (T.index = n(o, u, v)), o.destroy(v), T;
  }
  function n(o, u, c) {
    const p = c.num_faces() * 3, g = p * 4, v = o._malloc(g);
    u.GetTrianglesUInt32Array(c, g, v);
    const y = new Uint32Array(o.HEAPF32.buffer, v, p).slice();
    return o._free(v), { array: y, itemSize: 1 };
  }
  function i(o, u, c, d, p, g) {
    const v = g.num_components(), S = c.num_points() * v, T = S * p.BYTES_PER_ELEMENT, E = r(o, p), M = o._malloc(T);
    u.GetAttributeDataArrayForAllPoints(c, g, E, T, M);
    const w = new p(o.HEAPF32.buffer, M, S).slice();
    return o._free(M), {
      name: d,
      array: w,
      itemSize: v
    };
  }
  function r(o, u) {
    switch (u) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
let W0;
const HE = () => {
  if (W0)
    return W0;
  const s = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", t = new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    4,
    1,
    96,
    0,
    0,
    3,
    3,
    2,
    0,
    0,
    5,
    3,
    1,
    0,
    1,
    12,
    1,
    0,
    10,
    22,
    2,
    12,
    0,
    65,
    0,
    65,
    0,
    65,
    0,
    252,
    10,
    0,
    0,
    11,
    7,
    0,
    65,
    0,
    253,
    15,
    26,
    11
  ]), n = new Uint8Array([
    32,
    0,
    65,
    253,
    3,
    1,
    2,
    34,
    4,
    106,
    6,
    5,
    11,
    8,
    7,
    20,
    13,
    33,
    12,
    16,
    128,
    9,
    116,
    64,
    19,
    113,
    127,
    15,
    10,
    21,
    22,
    14,
    255,
    66,
    24,
    54,
    136,
    107,
    18,
    23,
    192,
    26,
    114,
    118,
    132,
    17,
    77,
    101,
    130,
    144,
    27,
    87,
    131,
    44,
    45,
    74,
    156,
    154,
    70,
    167
  ]);
  if (typeof WebAssembly != "object")
    return {
      supported: !1
    };
  let i = s;
  WebAssembly.validate(t) && (i = e);
  let r;
  const o = WebAssembly.instantiate(u(i), {}).then((g) => {
    r = g.instance, r.exports.__wasm_call_ctors();
  });
  function u(g) {
    const v = new Uint8Array(g.length);
    for (let S = 0; S < g.length; ++S) {
      const T = g.charCodeAt(S);
      v[S] = T > 96 ? T - 71 : T > 64 ? T - 65 : T > 47 ? T + 4 : T > 46 ? 63 : 62;
    }
    let y = 0;
    for (let S = 0; S < g.length; ++S)
      v[y++] = v[S] < 60 ? n[v[S]] : (v[S] - 60) * 64 + v[++S];
    return v.buffer.slice(0, y);
  }
  function c(g, v, y, S, T, E) {
    const M = r.exports.sbrk, w = y + 3 & -4, C = M(w * S), D = M(T.length), N = new Uint8Array(r.exports.memory.buffer);
    N.set(T, D);
    const U = g(C, y, S, D, T.length);
    if (U === 0 && E && E(C, w, S), v.set(N.subarray(C, C + y * S)), M(C - M(0)), U !== 0)
      throw new Error(`Malformed buffer data: ${U}`);
  }
  const d = {
    // legacy index-based enums for glTF
    0: "",
    1: "meshopt_decodeFilterOct",
    2: "meshopt_decodeFilterQuat",
    3: "meshopt_decodeFilterExp",
    // string-based enums for glTF
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, p = {
    // legacy index-based enums for glTF
    0: "meshopt_decodeVertexBuffer",
    1: "meshopt_decodeIndexBuffer",
    2: "meshopt_decodeIndexSequence",
    // string-based enums for glTF
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  return W0 = {
    ready: o,
    supported: !0,
    decodeVertexBuffer(g, v, y, S, T) {
      c(
        r.exports.meshopt_decodeVertexBuffer,
        g,
        v,
        y,
        S,
        r.exports[d[T]]
      );
    },
    decodeIndexBuffer(g, v, y, S) {
      c(r.exports.meshopt_decodeIndexBuffer, g, v, y, S);
    },
    decodeIndexSequence(g, v, y, S) {
      c(r.exports.meshopt_decodeIndexSequence, g, v, y, S);
    },
    decodeGltfBuffer(g, v, y, S, T, E) {
      c(
        r.exports[p[T]],
        g,
        v,
        y,
        S,
        r.exports[d[E]]
      );
    }
  }, W0;
};
let X0 = null, tI = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";
function nI(s = !0, e = !0, t) {
  return (n) => {
    t && t(n), s && (X0 || (X0 = new W8()), X0.setDecoderPath(typeof s == "string" ? s : tI), n.setDRACOLoader(X0)), e && n.setMeshoptDecoder(typeof HE == "function" ? HE() : HE);
  };
}
const Dv = (s, e, t, n) => t_(hC, s, nI(e, t, n));
Dv.preload = (s, e, t, n) => t_.preload(hC, s, nI(e, t, n));
Dv.clear = (s) => t_.clear(hC, s);
Dv.setDecoderPath = (s) => {
  tI = s;
};
function ru(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function iI(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, s.__proto__ = e;
}
/*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var La = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, qp = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, pC, Zr, gi, uo = 1e8, si = 1 / uo, YT = Math.PI * 2, J8 = YT / 4, Y8 = 0, rI = Math.sqrt, K8 = Math.cos, q8 = Math.sin, Pr = function(e) {
  return typeof e == "string";
}, zi = function(e) {
  return typeof e == "function";
}, vu = function(e) {
  return typeof e == "number";
}, mC = function(e) {
  return typeof e > "u";
}, wl = function(e) {
  return typeof e == "object";
}, ra = function(e) {
  return e !== !1;
}, gC = function() {
  return typeof window < "u";
}, J0 = function(e) {
  return zi(e) || Pr(e);
}, sI = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, Ss = Array.isArray, KT = /(?:-?\.?\d|\.)+/gi, aI = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, wp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, zE = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, oI = /[+-]=-?[.\d]+/, lI = /[^,'"\[\]\s]+/gi, j8 = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Ti, pl, qT, vC, Ia = {}, Dx = {}, uI, cI = function(e) {
  return (Dx = jp(e, Ia)) && la;
}, _C = function(e, t) {
  return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, Lv = function(e, t) {
  return !t && console.warn(e);
}, fI = function(e, t) {
  return e && (Ia[e] = t) && Dx && (Dx[e] = t) || Ia;
}, Pv = function() {
  return 0;
}, Q8 = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, hx = {
  suppressEvents: !0,
  kill: !1
}, Z8 = {
  suppressEvents: !0
}, yC = {}, Bc = [], jT = {}, dI, Ea = {}, GE = {}, WD = 30, px = [], xC = "", SC = function(e) {
  var t = e[0], n, i;
  if (wl(t) || zi(t) || (e = [e]), !(n = (t._gsap || {}).harness)) {
    for (i = px.length; i-- && !px[i].targetTest(t); )
      ;
    n = px[i];
  }
  for (i = e.length; i--; )
    e[i] && (e[i]._gsap || (e[i]._gsap = new FI(e[i], n))) || e.splice(i, 1);
  return e;
}, ad = function(e) {
  return e._gsap || SC(co(e))[0]._gsap;
}, hI = function(e, t, n) {
  return (n = e[t]) && zi(n) ? e[t]() : mC(n) && e.getAttribute && e.getAttribute(t) || n;
}, sa = function(e, t) {
  return (e = e.split(",")).forEach(t) || e;
}, ji = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, lr = function(e) {
  return Math.round(e * 1e7) / 1e7 || 0;
}, Ip = function(e, t) {
  var n = t.charAt(0), i = parseFloat(t.substr(2));
  return e = parseFloat(e), n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i;
}, $8 = function(e, t) {
  for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; )
    ;
  return i < n;
}, Lx = function() {
  var e = Bc.length, t = Bc.slice(0), n, i;
  for (jT = {}, Bc.length = 0, n = 0; n < e; n++)
    i = t[n], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
}, AC = function(e) {
  return !!(e._initted || e._startAt || e.add);
}, pI = function(e, t, n, i) {
  Bc.length && !Zr && Lx(), e.render(t, n, !!(Zr && t < 0 && AC(e))), Bc.length && !Zr && Lx();
}, mI = function(e) {
  var t = parseFloat(e);
  return (t || t === 0) && (e + "").match(lI).length < 2 ? t : Pr(e) ? e.trim() : e;
}, gI = function(e) {
  return e;
}, Ua = function(e, t) {
  for (var n in t)
    n in e || (e[n] = t[n]);
  return e;
}, eW = function(e) {
  return function(t, n) {
    for (var i in n)
      i in t || i === "duration" && e || i === "ease" || (t[i] = n[i]);
  };
}, jp = function(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}, XD = function s(e, t) {
  for (var n in t)
    n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = wl(t[n]) ? s(e[n] || (e[n] = {}), t[n]) : t[n]);
  return e;
}, Px = function(e, t) {
  var n = {}, i;
  for (i in e)
    i in t || (n[i] = e[i]);
  return n;
}, rv = function(e) {
  var t = e.parent || Ti, n = e.keyframes ? eW(Ss(e.keyframes)) : Ua;
  if (ra(e.inherit))
    for (; t; )
      n(e, t.vars.defaults), t = t.parent || t._dp;
  return e;
}, tW = function(e, t) {
  for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; )
    ;
  return n < 0;
}, vI = function(e, t, n, i, r) {
  var o = e[i], u;
  if (r)
    for (u = t[r]; o && o[r] > u; )
      o = o._prev;
  return o ? (t._next = o._next, o._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = o, t.parent = t._dp = e, t;
}, _S = function(e, t, n, i) {
  n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
  var r = t._prev, o = t._next;
  r ? r._next = o : e[n] === t && (e[n] = o), o ? o._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null;
}, Nc = function(e, t) {
  e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0;
}, od = function(e, t) {
  if (e && (!t || t._end > e._dur || t._start < 0))
    for (var n = e; n; )
      n._dirty = 1, n = n.parent;
  return e;
}, nW = function(e) {
  for (var t = e.parent; t && t.parent; )
    t._dirty = 1, t.totalDuration(), t = t.parent;
  return e;
}, QT = function(e, t, n, i) {
  return e._startAt && (Zr ? e._startAt.revert(hx) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i));
}, iW = function s(e) {
  return !e || e._ts && s(e.parent);
}, JD = function(e) {
  return e._repeat ? Qp(e._tTime, e = e.duration() + e._rDelay) * e : 0;
}, Qp = function(e, t) {
  var n = Math.floor(e = lr(e / t));
  return e && n === e ? n - 1 : n;
}, Ix = function(e, t) {
  return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, yS = function(e) {
  return e._end = lr(e._start + (e._tDur / Math.abs(e._ts || e._rts || si) || 0));
}, xS = function(e, t) {
  var n = e._dp;
  return n && n.smoothChildTiming && e._ts && (e._start = lr(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), yS(e), n._dirty || od(n, e)), e;
}, _I = function(e, t) {
  var n;
  if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Ix(e.rawTime(), t), (!t._dur || n_(0, t.totalDuration(), n) - t._tTime > si) && t.render(n, !0)), od(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
    if (e._dur < e.duration())
      for (n = e; n._dp; )
        n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
    e._zTime = -si;
  }
}, vl = function(e, t, n, i) {
  return t.parent && Nc(t), t._start = lr((vu(n) ? n : n || e !== Ti ? so(e, n, t) : e._time) + t._delay), t._end = lr(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), vI(e, t, "_first", "_last", e._sort ? "_start" : 0), ZT(t) || (e._recent = t), i || _I(e, t), e._ts < 0 && xS(e, e._tTime), e;
}, yI = function(e, t) {
  return (Ia.ScrollTrigger || _C("scrollTrigger", t)) && Ia.ScrollTrigger.create(t, e);
}, xI = function(e, t, n, i, r) {
  if (EC(e, t, r), !e._initted)
    return 1;
  if (!n && e._pt && !Zr && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && dI !== Ca.frame)
    return Bc.push(e), e._lazy = [r, i], 1;
}, rW = function s(e) {
  var t = e.parent;
  return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || s(t));
}, ZT = function(e) {
  var t = e.data;
  return t === "isFromStart" || t === "isStart";
}, sW = function(e, t, n, i) {
  var r = e.ratio, o = t < 0 || !t && (!e._start && rW(e) && !(!e._initted && ZT(e)) || (e._ts < 0 || e._dp._ts < 0) && !ZT(e)) ? 0 : 1, u = e._rDelay, c = 0, d, p, g;
  if (u && e._repeat && (c = n_(0, e._tDur, t), p = Qp(c, u), e._yoyo && p & 1 && (o = 1 - o), p !== Qp(e._tTime, u) && (r = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== r || Zr || i || e._zTime === si || !t && e._zTime) {
    if (!e._initted && xI(e, t, i, n, c))
      return;
    for (g = e._zTime, e._zTime = t || (n ? si : 0), n || (n = t && !g), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = c, d = e._pt; d; )
      d.r(o, d.d), d = d._next;
    t < 0 && QT(e, t, n, !0), e._onUpdate && !n && Ba(e, "onUpdate"), c && e._repeat && !n && e.parent && Ba(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === o && (o && Nc(e, 1), !n && !Zr && (Ba(e, o ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()));
  } else e._zTime || (e._zTime = t);
}, aW = function(e, t, n) {
  var i;
  if (n > t)
    for (i = e._first; i && i._start <= n; ) {
      if (i.data === "isPause" && i._start > t)
        return i;
      i = i._next;
    }
  else
    for (i = e._last; i && i._start >= n; ) {
      if (i.data === "isPause" && i._start < t)
        return i;
      i = i._prev;
    }
}, Zp = function(e, t, n, i) {
  var r = e._repeat, o = lr(t) || 0, u = e._tTime / e._tDur;
  return u && !i && (e._time *= o / e._dur), e._dur = o, e._tDur = r ? r < 0 ? 1e10 : lr(o * (r + 1) + e._rDelay * r) : o, u > 0 && !i && xS(e, e._tTime = e._tDur * u), e.parent && yS(e), n || od(e.parent, e), e;
}, YD = function(e) {
  return e instanceof Os ? od(e) : Zp(e, e._dur);
}, oW = {
  _start: 0,
  endTime: Pv,
  totalDuration: Pv
}, so = function s(e, t, n) {
  var i = e.labels, r = e._recent || oW, o = e.duration() >= uo ? r.endTime(!1) : e._dur, u, c, d;
  return Pr(t) && (isNaN(t) || t in i) ? (c = t.charAt(0), d = t.substr(-1) === "%", u = t.indexOf("="), c === "<" || c === ">" ? (u >= 0 && (t = t.replace(/=/, "")), (c === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (d ? (u < 0 ? r : n).totalDuration() / 100 : 1)) : u < 0 ? (t in i || (i[t] = o), i[t]) : (c = parseFloat(t.charAt(u - 1) + t.substr(u + 1)), d && n && (c = c / 100 * (Ss(n) ? n[0] : n).totalDuration()), u > 1 ? s(e, t.substr(0, u - 1), n) + c : o + c)) : t == null ? o : +t;
}, sv = function(e, t, n) {
  var i = vu(t[1]), r = (i ? 2 : 1) + (e < 2 ? 0 : 1), o = t[r], u, c;
  if (i && (o.duration = t[1]), o.parent = n, e) {
    for (u = o, c = n; c && !("immediateRender" in u); )
      u = c.vars.defaults || {}, c = ra(c.vars.inherit) && c.parent;
    o.immediateRender = ra(u.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[r - 1];
  }
  return new or(t[0], o, t[r + 1]);
}, Vc = function(e, t) {
  return e || e === 0 ? t(e) : t;
}, n_ = function(e, t, n) {
  return n < e ? e : n > t ? t : n;
}, vs = function(e, t) {
  return !Pr(e) || !(t = j8.exec(e)) ? "" : t[1];
}, lW = function(e, t, n) {
  return Vc(n, function(i) {
    return n_(e, t, i);
  });
}, $T = [].slice, SI = function(e, t) {
  return e && wl(e) && "length" in e && (!t && !e.length || e.length - 1 in e && wl(e[0])) && !e.nodeType && e !== pl;
}, uW = function(e, t, n) {
  return n === void 0 && (n = []), e.forEach(function(i) {
    var r;
    return Pr(i) && !t || SI(i, 1) ? (r = n).push.apply(r, co(i)) : n.push(i);
  }) || n;
}, co = function(e, t, n) {
  return gi && !t && gi.selector ? gi.selector(e) : Pr(e) && !n && (qT || !$p()) ? $T.call((t || vC).querySelectorAll(e), 0) : Ss(e) ? uW(e, n) : SI(e) ? $T.call(e, 0) : e ? [e] : [];
}, eb = function(e) {
  return e = co(e)[0] || Lv("Invalid scope") || {}, function(t) {
    var n = e.current || e.nativeElement || e;
    return co(t, n.querySelectorAll ? n : n === e ? Lv("Invalid scope") || vC.createElement("div") : e);
  };
}, AI = function(e) {
  return e.sort(function() {
    return 0.5 - Math.random();
  });
}, MI = function(e) {
  if (zi(e))
    return e;
  var t = wl(e) ? e : {
    each: e
  }, n = ld(t.ease), i = t.from || 0, r = parseFloat(t.base) || 0, o = {}, u = i > 0 && i < 1, c = isNaN(i) || u, d = t.axis, p = i, g = i;
  return Pr(i) ? p = g = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[i] || 0 : !u && c && (p = i[0], g = i[1]), function(v, y, S) {
    var T = (S || t).length, E = o[T], M, w, C, D, N, U, O, V, L;
    if (!E) {
      if (L = t.grid === "auto" ? 0 : (t.grid || [1, uo])[1], !L) {
        for (O = -uo; O < (O = S[L++].getBoundingClientRect().left) && L < T; )
          ;
        L < T && L--;
      }
      for (E = o[T] = [], M = c ? Math.min(L, T) * p - 0.5 : i % L, w = L === uo ? 0 : c ? T * g / L - 0.5 : i / L | 0, O = 0, V = uo, U = 0; U < T; U++)
        C = U % L - M, D = w - (U / L | 0), E[U] = N = d ? Math.abs(d === "y" ? D : C) : rI(C * C + D * D), N > O && (O = N), N < V && (V = N);
      i === "random" && AI(E), E.max = O - V, E.min = V, E.v = T = (parseFloat(t.amount) || parseFloat(t.each) * (L > T ? T - 1 : d ? d === "y" ? T / L : L : Math.max(L, T / L)) || 0) * (i === "edges" ? -1 : 1), E.b = T < 0 ? r - T : r, E.u = vs(t.amount || t.each) || 0, n = n && T < 0 ? PI(n) : n;
    }
    return T = (E[v] - E.min) / E.max || 0, lr(E.b + (n ? n(T) : T) * E.v) + E.u;
  };
}, tb = function(e) {
  var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
  return function(n) {
    var i = lr(Math.round(parseFloat(n) / e) * e * t);
    return (i - i % 1) / t + (vu(n) ? 0 : vs(n));
  };
}, EI = function(e, t) {
  var n = Ss(e), i, r;
  return !n && wl(e) && (i = n = e.radius || uo, e.values ? (e = co(e.values), (r = !vu(e[0])) && (i *= i)) : e = tb(e.increment)), Vc(t, n ? zi(e) ? function(o) {
    return r = e(o), Math.abs(r - o) <= i ? r : o;
  } : function(o) {
    for (var u = parseFloat(r ? o.x : o), c = parseFloat(r ? o.y : 0), d = uo, p = 0, g = e.length, v, y; g--; )
      r ? (v = e[g].x - u, y = e[g].y - c, v = v * v + y * y) : v = Math.abs(e[g] - u), v < d && (d = v, p = g);
    return p = !i || d <= i ? e[p] : o, r || p === o || vu(o) ? p : p + vs(o);
  } : tb(e));
}, TI = function(e, t, n, i) {
  return Vc(Ss(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
    return Ss(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) * n * i) / i;
  });
}, cW = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(i) {
    return t.reduce(function(r, o) {
      return o(r);
    }, i);
  };
}, fW = function(e, t) {
  return function(n) {
    return e(parseFloat(n)) + (t || vs(n));
  };
}, dW = function(e, t, n) {
  return CI(e, t, 0, 1, n);
}, bI = function(e, t, n) {
  return Vc(n, function(i) {
    return e[~~t(i)];
  });
}, hW = function s(e, t, n) {
  var i = t - e;
  return Ss(e) ? bI(e, s(0, e.length), t) : Vc(n, function(r) {
    return (i + (r - e) % i) % i + e;
  });
}, pW = function s(e, t, n) {
  var i = t - e, r = i * 2;
  return Ss(e) ? bI(e, s(0, e.length - 1), t) : Vc(n, function(o) {
    return o = (r + (o - e) % r) % r || 0, e + (o > i ? r - o : o);
  });
}, Iv = function(e) {
  for (var t = 0, n = "", i, r, o, u; ~(i = e.indexOf("random(", t)); )
    o = e.indexOf(")", i), u = e.charAt(i + 7) === "[", r = e.substr(i + 7, o - i - 7).match(u ? lI : KT), n += e.substr(t, i - t) + TI(u ? r : +r[0], u ? 0 : +r[1], +r[2] || 1e-5), t = o + 1;
  return n + e.substr(t, e.length - t);
}, CI = function(e, t, n, i, r) {
  var o = t - e, u = i - n;
  return Vc(r, function(c) {
    return n + ((c - e) / o * u || 0);
  });
}, mW = function s(e, t, n, i) {
  var r = isNaN(e + t) ? 0 : function(y) {
    return (1 - y) * e + y * t;
  };
  if (!r) {
    var o = Pr(e), u = {}, c, d, p, g, v;
    if (n === !0 && (i = 1) && (n = null), o)
      e = {
        p: e
      }, t = {
        p: t
      };
    else if (Ss(e) && !Ss(t)) {
      for (p = [], g = e.length, v = g - 2, d = 1; d < g; d++)
        p.push(s(e[d - 1], e[d]));
      g--, r = function(S) {
        S *= g;
        var T = Math.min(v, ~~S);
        return p[T](S - T);
      }, n = t;
    } else i || (e = jp(Ss(e) ? [] : {}, e));
    if (!p) {
      for (c in t)
        MC.call(u, e, c, "get", t[c]);
      r = function(S) {
        return CC(S, u) || (o ? e.p : e);
      };
    }
  }
  return Vc(n, r);
}, KD = function(e, t, n) {
  var i = e.labels, r = uo, o, u, c;
  for (o in i)
    u = i[o] - t, u < 0 == !!n && u && r > (u = Math.abs(u)) && (c = o, r = u);
  return c;
}, Ba = function(e, t, n) {
  var i = e.vars, r = i[t], o = gi, u = e._ctx, c, d, p;
  if (r)
    return c = i[t + "Params"], d = i.callbackScope || e, n && Bc.length && Lx(), u && (gi = u), p = c ? r.apply(d, c) : r.call(d), gi = o, p;
}, Xg = function(e) {
  return Nc(e), e.scrollTrigger && e.scrollTrigger.kill(!!Zr), e.progress() < 1 && Ba(e, "onInterrupt"), e;
}, Rp, wI = [], RI = function(e) {
  if (e)
    if (e = !e.name && e.default || e, gC() || e.headless) {
      var t = e.name, n = zi(e), i = t && !n && e.init ? function() {
        this._props = [];
      } : e, r = {
        init: Pv,
        render: CC,
        add: MC,
        kill: DW,
        modifier: BW,
        rawVars: 0
      }, o = {
        targetTest: 0,
        get: 0,
        getSetter: bC,
        aliases: {},
        register: 0
      };
      if ($p(), e !== i) {
        if (Ea[t])
          return;
        Ua(i, Ua(Px(e, r), o)), jp(i.prototype, jp(r, Px(e, o))), Ea[i.prop = t] = i, e.targetTest && (px.push(i), yC[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
      }
      fI(t, i), e.register && e.register(la, i, aa);
    } else
      wI.push(e);
}, ri = 255, Jg = {
  aqua: [0, ri, ri],
  lime: [0, ri, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, ri],
  navy: [0, 0, 128],
  white: [ri, ri, ri],
  olive: [128, 128, 0],
  yellow: [ri, ri, 0],
  orange: [ri, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [ri, 0, 0],
  pink: [ri, 192, 203],
  cyan: [0, ri, ri],
  transparent: [ri, ri, ri, 0]
}, kE = function(e, t, n) {
  return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (n - t) * e * 6 : e < 0.5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * ri + 0.5 | 0;
}, BI = function(e, t, n) {
  var i = e ? vu(e) ? [e >> 16, e >> 8 & ri, e & ri] : 0 : Jg.black, r, o, u, c, d, p, g, v, y, S;
  if (!i) {
    if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Jg[e])
      i = Jg[e];
    else if (e.charAt(0) === "#") {
      if (e.length < 6 && (r = e.charAt(1), o = e.charAt(2), u = e.charAt(3), e = "#" + r + r + o + o + u + u + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9)
        return i = parseInt(e.substr(1, 6), 16), [i >> 16, i >> 8 & ri, i & ri, parseInt(e.substr(7), 16) / 255];
      e = parseInt(e.substr(1), 16), i = [e >> 16, e >> 8 & ri, e & ri];
    } else if (e.substr(0, 3) === "hsl") {
      if (i = S = e.match(KT), !t)
        c = +i[0] % 360 / 360, d = +i[1] / 100, p = +i[2] / 100, o = p <= 0.5 ? p * (d + 1) : p + d - p * d, r = p * 2 - o, i.length > 3 && (i[3] *= 1), i[0] = kE(c + 1 / 3, r, o), i[1] = kE(c, r, o), i[2] = kE(c - 1 / 3, r, o);
      else if (~e.indexOf("="))
        return i = e.match(aI), n && i.length < 4 && (i[3] = 1), i;
    } else
      i = e.match(KT) || Jg.transparent;
    i = i.map(Number);
  }
  return t && !S && (r = i[0] / ri, o = i[1] / ri, u = i[2] / ri, g = Math.max(r, o, u), v = Math.min(r, o, u), p = (g + v) / 2, g === v ? c = d = 0 : (y = g - v, d = p > 0.5 ? y / (2 - g - v) : y / (g + v), c = g === r ? (o - u) / y + (o < u ? 6 : 0) : g === o ? (u - r) / y + 2 : (r - o) / y + 4, c *= 60), i[0] = ~~(c + 0.5), i[1] = ~~(d * 100 + 0.5), i[2] = ~~(p * 100 + 0.5)), n && i.length < 4 && (i[3] = 1), i;
}, DI = function(e) {
  var t = [], n = [], i = -1;
  return e.split(Dc).forEach(function(r) {
    var o = r.match(wp) || [];
    t.push.apply(t, o), n.push(i += o.length + 1);
  }), t.c = n, t;
}, qD = function(e, t, n) {
  var i = "", r = (e + i).match(Dc), o = t ? "hsla(" : "rgba(", u = 0, c, d, p, g;
  if (!r)
    return e;
  if (r = r.map(function(v) {
    return (v = BI(v, t, 1)) && o + (t ? v[0] + "," + v[1] + "%," + v[2] + "%," + v[3] : v.join(",")) + ")";
  }), n && (p = DI(e), c = n.c, c.join(i) !== p.c.join(i)))
    for (d = e.replace(Dc, "1").split(wp), g = d.length - 1; u < g; u++)
      i += d[u] + (~c.indexOf(u) ? r.shift() || o + "0,0,0,0)" : (p.length ? p : r.length ? r : n).shift());
  if (!d)
    for (d = e.split(Dc), g = d.length - 1; u < g; u++)
      i += d[u] + r[u];
  return i + d[g];
}, Dc = function() {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
  for (e in Jg)
    s += "|" + e + "\\b";
  return new RegExp(s + ")", "gi");
}(), gW = /hsl[a]?\(/, LI = function(e) {
  var t = e.join(" "), n;
  if (Dc.lastIndex = 0, Dc.test(t))
    return n = gW.test(t), e[1] = qD(e[1], n), e[0] = qD(e[0], n, DI(e[1])), !0;
}, Uv, Ca = function() {
  var s = Date.now, e = 500, t = 33, n = s(), i = n, r = 1e3 / 240, o = r, u = [], c, d, p, g, v, y, S = function T(E) {
    var M = s() - i, w = E === !0, C, D, N, U;
    if ((M > e || M < 0) && (n += M - t), i += M, N = i - n, C = N - o, (C > 0 || w) && (U = ++g.frame, v = N - g.time * 1e3, g.time = N = N / 1e3, o += C + (C >= r ? 4 : r - C), D = 1), w || (c = d(T)), D)
      for (y = 0; y < u.length; y++)
        u[y](N, v, U, E);
  };
  return g = {
    time: 0,
    frame: 0,
    tick: function() {
      S(!0);
    },
    deltaRatio: function(E) {
      return v / (1e3 / (E || 60));
    },
    wake: function() {
      uI && (!qT && gC() && (pl = qT = window, vC = pl.document || {}, Ia.gsap = la, (pl.gsapVersions || (pl.gsapVersions = [])).push(la.version), cI(Dx || pl.GreenSockGlobals || !pl.gsap && pl || {}), wI.forEach(RI)), p = typeof requestAnimationFrame < "u" && requestAnimationFrame, c && g.sleep(), d = p || function(E) {
        return setTimeout(E, o - g.time * 1e3 + 1 | 0);
      }, Uv = 1, S(2));
    },
    sleep: function() {
      (p ? cancelAnimationFrame : clearTimeout)(c), Uv = 0, d = Pv;
    },
    lagSmoothing: function(E, M) {
      e = E || 1 / 0, t = Math.min(M || 33, e);
    },
    fps: function(E) {
      r = 1e3 / (E || 240), o = g.time * 1e3 + r;
    },
    add: function(E, M, w) {
      var C = M ? function(D, N, U, O) {
        E(D, N, U, O), g.remove(C);
      } : E;
      return g.remove(E), u[w ? "unshift" : "push"](C), $p(), C;
    },
    remove: function(E, M) {
      ~(M = u.indexOf(E)) && u.splice(M, 1) && y >= M && y--;
    },
    _listeners: u
  }, g;
}(), $p = function() {
  return !Uv && Ca.wake();
}, Un = {}, vW = /^[\d.\-M][\d.\-,\s]/, _W = /["']/g, yW = function(e) {
  for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], r = 1, o = n.length, u, c, d; r < o; r++)
    c = n[r], u = r !== o - 1 ? c.lastIndexOf(",") : c.length, d = c.substr(0, u), t[i] = isNaN(d) ? d.replace(_W, "").trim() : +d, i = c.substr(u + 1).trim();
  return t;
}, xW = function(e) {
  var t = e.indexOf("(") + 1, n = e.indexOf(")"), i = e.indexOf("(", t);
  return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n);
}, SW = function(e) {
  var t = (e + "").split("("), n = Un[t[0]];
  return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [yW(t[1])] : xW(e).split(",").map(mI)) : Un._CE && vW.test(e) ? Un._CE("", e) : n;
}, PI = function(e) {
  return function(t) {
    return 1 - e(1 - t);
  };
}, II = function s(e, t) {
  for (var n = e._first, i; n; )
    n instanceof Os ? s(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? s(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next;
}, ld = function(e, t) {
  return e && (zi(e) ? e : Un[e] || SW(e)) || t;
}, bd = function(e, t, n, i) {
  n === void 0 && (n = function(c) {
    return 1 - t(1 - c);
  }), i === void 0 && (i = function(c) {
    return c < 0.5 ? t(c * 2) / 2 : 1 - t((1 - c) * 2) / 2;
  });
  var r = {
    easeIn: t,
    easeOut: n,
    easeInOut: i
  }, o;
  return sa(e, function(u) {
    Un[u] = Ia[u] = r, Un[o = u.toLowerCase()] = n;
    for (var c in r)
      Un[o + (c === "easeIn" ? ".in" : c === "easeOut" ? ".out" : ".inOut")] = Un[u + "." + c] = r[c];
  }), r;
}, UI = function(e) {
  return function(t) {
    return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
  };
}, VE = function s(e, t, n) {
  var i = t >= 1 ? t : 1, r = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), o = r / YT * (Math.asin(1 / i) || 0), u = function(p) {
    return p === 1 ? 1 : i * Math.pow(2, -10 * p) * q8((p - o) * r) + 1;
  }, c = e === "out" ? u : e === "in" ? function(d) {
    return 1 - u(1 - d);
  } : UI(u);
  return r = YT / r, c.config = function(d, p) {
    return s(e, d, p);
  }, c;
}, WE = function s(e, t) {
  t === void 0 && (t = 1.70158);
  var n = function(o) {
    return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
  }, i = e === "out" ? n : e === "in" ? function(r) {
    return 1 - n(1 - r);
  } : UI(n);
  return i.config = function(r) {
    return s(e, r);
  }, i;
};
sa("Linear,Quad,Cubic,Quart,Quint,Strong", function(s, e) {
  var t = e < 5 ? e + 1 : e;
  bd(s + ",Power" + (t - 1), e ? function(n) {
    return Math.pow(n, t);
  } : function(n) {
    return n;
  }, function(n) {
    return 1 - Math.pow(1 - n, t);
  }, function(n) {
    return n < 0.5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2;
  });
});
Un.Linear.easeNone = Un.none = Un.Linear.easeIn;
bd("Elastic", VE("in"), VE("out"), VE());
(function(s, e) {
  var t = 1 / e, n = 2 * t, i = 2.5 * t, r = function(u) {
    return u < t ? s * u * u : u < n ? s * Math.pow(u - 1.5 / e, 2) + 0.75 : u < i ? s * (u -= 2.25 / e) * u + 0.9375 : s * Math.pow(u - 2.625 / e, 2) + 0.984375;
  };
  bd("Bounce", function(o) {
    return 1 - r(1 - o);
  }, r);
})(7.5625, 2.75);
bd("Expo", function(s) {
  return Math.pow(2, 10 * (s - 1)) * s + s * s * s * s * s * s * (1 - s);
});
bd("Circ", function(s) {
  return -(rI(1 - s * s) - 1);
});
bd("Sine", function(s) {
  return s === 1 ? 1 : -K8(s * J8) + 1;
});
bd("Back", WE("in"), WE("out"), WE());
Un.SteppedEase = Un.steps = Ia.SteppedEase = {
  config: function(e, t) {
    e === void 0 && (e = 1);
    var n = 1 / e, i = e + (t ? 0 : 1), r = t ? 1 : 0, o = 1 - si;
    return function(u) {
      return ((i * n_(0, o, u) | 0) + r) * n;
    };
  }
};
qp.ease = Un["quad.out"];
sa("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(s) {
  return xC += s + "," + s + "Params,";
});
var FI = function(e, t) {
  this.id = Y8++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : hI, this.set = t ? t.getSetter : bC;
}, Fv = /* @__PURE__ */ function() {
  function s(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Zp(this, +t.duration, 1, 1), this.data = t.data, gi && (this._ctx = gi, gi.data.push(this)), Uv || Ca.wake();
  }
  var e = s.prototype;
  return e.delay = function(n) {
    return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay;
  }, e.duration = function(n) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur;
  }, e.totalDuration = function(n) {
    return arguments.length ? (this._dirty = 0, Zp(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, e.totalTime = function(n, i) {
    if ($p(), !arguments.length)
      return this._tTime;
    var r = this._dp;
    if (r && r.smoothChildTiming && this._ts) {
      for (xS(this, n), !r._dp || r.parent || _I(r, this); r && r.parent; )
        r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && vl(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === si || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), pI(this, n, i)), this;
  }, e.time = function(n, i) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + JD(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time;
  }, e.totalProgress = function(n, i) {
    return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
  }, e.progress = function(n, i) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + JD(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(n, i) {
    var r = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (n - 1) * r, i) : this._repeat ? Qp(this._tTime, r) + 1 : 1;
  }, e.timeScale = function(n, i) {
    if (!arguments.length)
      return this._rts === -si ? 0 : this._rts;
    if (this._rts === n)
      return this;
    var r = this.parent && this._ts ? Ix(this.parent._time, this) : this._tTime;
    return this._rts = +n || 0, this._ts = this._ps || n === -si ? 0 : this._rts, this.totalTime(n_(-Math.abs(this._delay), this.totalDuration(), r), i !== !1), yS(this), nW(this);
  }, e.paused = function(n) {
    return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : ($p(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== si && (this._tTime -= si)))), this) : this._ps;
  }, e.startTime = function(n) {
    if (arguments.length) {
      this._start = n;
      var i = this.parent || this._dp;
      return i && (i._sort || !this.parent) && vl(i, this, n - this._delay), this;
    }
    return this._start;
  }, e.endTime = function(n) {
    return this._start + (ra(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, e.rawTime = function(n) {
    var i = this.parent || this._dp;
    return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Ix(i.rawTime(n), this) : this._tTime : this._tTime;
  }, e.revert = function(n) {
    n === void 0 && (n = Z8);
    var i = Zr;
    return Zr = n, AC(this) && (this.timeline && this.timeline.revert(n), this.totalTime(-0.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), Zr = i, this;
  }, e.globalTime = function(n) {
    for (var i = this, r = arguments.length ? n : i.rawTime(); i; )
      r = i._start + r / (Math.abs(i._ts) || 1), i = i._dp;
    return !this.parent && this._sat ? this._sat.globalTime(n) : r;
  }, e.repeat = function(n) {
    return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, YD(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, e.repeatDelay = function(n) {
    if (arguments.length) {
      var i = this._time;
      return this._rDelay = n, YD(this), i ? this.time(i) : this;
    }
    return this._rDelay;
  }, e.yoyo = function(n) {
    return arguments.length ? (this._yoyo = n, this) : this._yoyo;
  }, e.seek = function(n, i) {
    return this.totalTime(so(this, n), ra(i));
  }, e.restart = function(n, i) {
    return this.play().totalTime(n ? -this._delay : 0, ra(i)), this._dur || (this._zTime = -si), this;
  }, e.play = function(n, i) {
    return n != null && this.seek(n, i), this.reversed(!1).paused(!1);
  }, e.reverse = function(n, i) {
    return n != null && this.seek(n || this.totalDuration(), i), this.reversed(!0).paused(!1);
  }, e.pause = function(n, i) {
    return n != null && this.seek(n, i), this.paused(!0);
  }, e.resume = function() {
    return this.paused(!1);
  }, e.reversed = function(n) {
    return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -si : 0)), this) : this._rts < 0;
  }, e.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -si, this;
  }, e.isActive = function() {
    var n = this.parent || this._dp, i = this._start, r;
    return !!(!n || this._ts && this._initted && n.isActive() && (r = n.rawTime(!0)) >= i && r < this.endTime(!0) - si);
  }, e.eventCallback = function(n, i, r) {
    var o = this.vars;
    return arguments.length > 1 ? (i ? (o[n] = i, r && (o[n + "Params"] = r), n === "onUpdate" && (this._onUpdate = i)) : delete o[n], this) : o[n];
  }, e.then = function(n) {
    var i = this;
    return new Promise(function(r) {
      var o = zi(n) ? n : gI, u = function() {
        var d = i.then;
        i.then = null, zi(o) && (o = o(i)) && (o.then || o === i) && (i.then = d), r(o), i.then = d;
      };
      i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? u() : i._prom = u;
    });
  }, e.kill = function() {
    Xg(this);
  }, s;
}();
Ua(Fv.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -si,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Os = /* @__PURE__ */ function(s) {
  iI(e, s);
  function e(n, i) {
    var r;
    return n === void 0 && (n = {}), r = s.call(this, n) || this, r.labels = {}, r.smoothChildTiming = !!n.smoothChildTiming, r.autoRemoveChildren = !!n.autoRemoveChildren, r._sort = ra(n.sortChildren), Ti && vl(n.parent || Ti, ru(r), i), n.reversed && r.reverse(), n.paused && r.paused(!0), n.scrollTrigger && yI(ru(r), n.scrollTrigger), r;
  }
  var t = e.prototype;
  return t.to = function(i, r, o) {
    return sv(0, arguments, this), this;
  }, t.from = function(i, r, o) {
    return sv(1, arguments, this), this;
  }, t.fromTo = function(i, r, o, u) {
    return sv(2, arguments, this), this;
  }, t.set = function(i, r, o) {
    return r.duration = 0, r.parent = this, rv(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new or(i, r, so(this, o), 1), this;
  }, t.call = function(i, r, o) {
    return vl(this, or.delayedCall(0, i, r), o);
  }, t.staggerTo = function(i, r, o, u, c, d, p) {
    return o.duration = r, o.stagger = o.stagger || u, o.onComplete = d, o.onCompleteParams = p, o.parent = this, new or(i, o, so(this, c)), this;
  }, t.staggerFrom = function(i, r, o, u, c, d, p) {
    return o.runBackwards = 1, rv(o).immediateRender = ra(o.immediateRender), this.staggerTo(i, r, o, u, c, d, p);
  }, t.staggerFromTo = function(i, r, o, u, c, d, p, g) {
    return u.startAt = o, rv(u).immediateRender = ra(u.immediateRender), this.staggerTo(i, r, u, c, d, p, g);
  }, t.render = function(i, r, o) {
    var u = this._time, c = this._dirty ? this.totalDuration() : this._tDur, d = this._dur, p = i <= 0 ? 0 : lr(i), g = this._zTime < 0 != i < 0 && (this._initted || !d), v, y, S, T, E, M, w, C, D, N, U, O;
    if (this !== Ti && p > c && i >= 0 && (p = c), p !== this._tTime || o || g) {
      if (u !== this._time && d && (p += this._time - u, i += this._time - u), v = p, D = this._start, C = this._ts, M = !C, g && (d || (u = this._zTime), (i || !r) && (this._zTime = i)), this._repeat) {
        if (U = this._yoyo, E = d + this._rDelay, this._repeat < -1 && i < 0)
          return this.totalTime(E * 100 + i, r, o);
        if (v = lr(p % E), p === c ? (T = this._repeat, v = d) : (N = lr(p / E), T = ~~N, T && T === N && (v = d, T--), v > d && (v = d)), N = Qp(this._tTime, E), !u && this._tTime && N !== T && this._tTime - N * E - this._dur <= 0 && (N = T), U && T & 1 && (v = d - v, O = 1), T !== N && !this._lock) {
          var V = U && N & 1, L = V === (U && T & 1);
          if (T < N && (V = !V), u = V ? 0 : p % d ? d : p, this._lock = 1, this.render(u || (O ? 0 : lr(T * E)), r, !d)._lock = 0, this._tTime = p, !r && this.parent && Ba(this, "onRepeat"), this.vars.repeatRefresh && !O && (this.invalidate()._lock = 1), u && u !== this._time || M !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (d = this._dur, c = this._tDur, L && (this._lock = 2, u = V ? d : -1e-4, this.render(u, !0), this.vars.repeatRefresh && !O && this.invalidate()), this._lock = 0, !this._ts && !M)
            return this;
          II(this, O);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (w = aW(this, lr(u), lr(v)), w && (p -= v - (v = w._start))), this._tTime = p, this._time = v, this._act = !C, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, u = 0), !u && p && !r && !N && (Ba(this, "onStart"), this._tTime !== p))
        return this;
      if (v >= u && i >= 0)
        for (y = this._first; y; ) {
          if (S = y._next, (y._act || v >= y._start) && y._ts && w !== y) {
            if (y.parent !== this)
              return this.render(i, r, o);
            if (y.render(y._ts > 0 ? (v - y._start) * y._ts : (y._dirty ? y.totalDuration() : y._tDur) + (v - y._start) * y._ts, r, o), v !== this._time || !this._ts && !M) {
              w = 0, S && (p += this._zTime = -si);
              break;
            }
          }
          y = S;
        }
      else {
        y = this._last;
        for (var I = i < 0 ? i : v; y; ) {
          if (S = y._prev, (y._act || I <= y._end) && y._ts && w !== y) {
            if (y.parent !== this)
              return this.render(i, r, o);
            if (y.render(y._ts > 0 ? (I - y._start) * y._ts : (y._dirty ? y.totalDuration() : y._tDur) + (I - y._start) * y._ts, r, o || Zr && AC(y)), v !== this._time || !this._ts && !M) {
              w = 0, S && (p += this._zTime = I ? -si : si);
              break;
            }
          }
          y = S;
        }
      }
      if (w && !r && (this.pause(), w.render(v >= u ? 0 : -si)._zTime = v >= u ? 1 : -1, this._ts))
        return this._start = D, yS(this), this.render(i, r, o);
      this._onUpdate && !r && Ba(this, "onUpdate", !0), (p === c && this._tTime >= this.totalDuration() || !p && u) && (D === this._start || Math.abs(C) !== Math.abs(this._ts)) && (this._lock || ((i || !d) && (p === c && this._ts > 0 || !p && this._ts < 0) && Nc(this, 1), !r && !(i < 0 && !u) && (p || u || !c) && (Ba(this, p === c && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(p < c && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, t.add = function(i, r) {
    var o = this;
    if (vu(r) || (r = so(this, r, i)), !(i instanceof Fv)) {
      if (Ss(i))
        return i.forEach(function(u) {
          return o.add(u, r);
        }), this;
      if (Pr(i))
        return this.addLabel(i, r);
      if (zi(i))
        i = or.delayedCall(0, i);
      else
        return this;
    }
    return this !== i ? vl(this, i, r) : this;
  }, t.getChildren = function(i, r, o, u) {
    i === void 0 && (i = !0), r === void 0 && (r = !0), o === void 0 && (o = !0), u === void 0 && (u = -uo);
    for (var c = [], d = this._first; d; )
      d._start >= u && (d instanceof or ? r && c.push(d) : (o && c.push(d), i && c.push.apply(c, d.getChildren(!0, r, o)))), d = d._next;
    return c;
  }, t.getById = function(i) {
    for (var r = this.getChildren(1, 1, 1), o = r.length; o--; )
      if (r[o].vars.id === i)
        return r[o];
  }, t.remove = function(i) {
    return Pr(i) ? this.removeLabel(i) : zi(i) ? this.killTweensOf(i) : (i.parent === this && _S(this, i), i === this._recent && (this._recent = this._last), od(this));
  }, t.totalTime = function(i, r) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = lr(Ca.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), s.prototype.totalTime.call(this, i, r), this._forcing = 0, this) : this._tTime;
  }, t.addLabel = function(i, r) {
    return this.labels[i] = so(this, r), this;
  }, t.removeLabel = function(i) {
    return delete this.labels[i], this;
  }, t.addPause = function(i, r, o) {
    var u = or.delayedCall(0, r || Pv, o);
    return u.data = "isPause", this._hasPause = 1, vl(this, u, so(this, i));
  }, t.removePause = function(i) {
    var r = this._first;
    for (i = so(this, i); r; )
      r._start === i && r.data === "isPause" && Nc(r), r = r._next;
  }, t.killTweensOf = function(i, r, o) {
    for (var u = this.getTweensOf(i, o), c = u.length; c--; )
      xc !== u[c] && u[c].kill(i, r);
    return this;
  }, t.getTweensOf = function(i, r) {
    for (var o = [], u = co(i), c = this._first, d = vu(r), p; c; )
      c instanceof or ? $8(c._targets, u) && (d ? (!xc || c._initted && c._ts) && c.globalTime(0) <= r && c.globalTime(c.totalDuration()) > r : !r || c.isActive()) && o.push(c) : (p = c.getTweensOf(u, r)).length && o.push.apply(o, p), c = c._next;
    return o;
  }, t.tweenTo = function(i, r) {
    r = r || {};
    var o = this, u = so(o, i), c = r, d = c.startAt, p = c.onStart, g = c.onStartParams, v = c.immediateRender, y, S = or.to(o, Ua({
      ease: r.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: u,
      overwrite: "auto",
      duration: r.duration || Math.abs((u - (d && "time" in d ? d.time : o._time)) / o.timeScale()) || si,
      onStart: function() {
        if (o.pause(), !y) {
          var E = r.duration || Math.abs((u - (d && "time" in d ? d.time : o._time)) / o.timeScale());
          S._dur !== E && Zp(S, E, 0, 1).render(S._time, !0, !0), y = 1;
        }
        p && p.apply(S, g || []);
      }
    }, r));
    return v ? S.render(0) : S;
  }, t.tweenFromTo = function(i, r, o) {
    return this.tweenTo(r, Ua({
      startAt: {
        time: so(this, i)
      }
    }, o));
  }, t.recent = function() {
    return this._recent;
  }, t.nextLabel = function(i) {
    return i === void 0 && (i = this._time), KD(this, so(this, i));
  }, t.previousLabel = function(i) {
    return i === void 0 && (i = this._time), KD(this, so(this, i), 1);
  }, t.currentLabel = function(i) {
    return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + si);
  }, t.shiftChildren = function(i, r, o) {
    o === void 0 && (o = 0);
    for (var u = this._first, c = this.labels, d; u; )
      u._start >= o && (u._start += i, u._end += i), u = u._next;
    if (r)
      for (d in c)
        c[d] >= o && (c[d] += i);
    return od(this);
  }, t.invalidate = function(i) {
    var r = this._first;
    for (this._lock = 0; r; )
      r.invalidate(i), r = r._next;
    return s.prototype.invalidate.call(this, i);
  }, t.clear = function(i) {
    i === void 0 && (i = !0);
    for (var r = this._first, o; r; )
      o = r._next, this.remove(r), r = o;
    return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), od(this);
  }, t.totalDuration = function(i) {
    var r = 0, o = this, u = o._last, c = uo, d, p, g;
    if (arguments.length)
      return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -i : i));
    if (o._dirty) {
      for (g = o.parent; u; )
        d = u._prev, u._dirty && u.totalDuration(), p = u._start, p > c && o._sort && u._ts && !o._lock ? (o._lock = 1, vl(o, u, p - u._delay, 1)._lock = 0) : c = p, p < 0 && u._ts && (r -= p, (!g && !o._dp || g && g.smoothChildTiming) && (o._start += p / o._ts, o._time -= p, o._tTime -= p), o.shiftChildren(-p, !1, -1 / 0), c = 0), u._end > r && u._ts && (r = u._end), u = d;
      Zp(o, o === Ti && o._time > r ? o._time : r, 1, 1), o._dirty = 0;
    }
    return o._tDur;
  }, e.updateRoot = function(i) {
    if (Ti._ts && (pI(Ti, Ix(i, Ti)), dI = Ca.frame), Ca.frame >= WD) {
      WD += La.autoSleep || 120;
      var r = Ti._first;
      if ((!r || !r._ts) && La.autoSleep && Ca._listeners.length < 2) {
        for (; r && !r._ts; )
          r = r._next;
        r || Ca.sleep();
      }
    }
  }, e;
}(Fv);
Ua(Os.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var AW = function(e, t, n, i, r, o, u) {
  var c = new aa(this._pt, e, t, 0, 1, kI, null, r), d = 0, p = 0, g, v, y, S, T, E, M, w;
  for (c.b = n, c.e = i, n += "", i += "", (M = ~i.indexOf("random(")) && (i = Iv(i)), o && (w = [n, i], o(w, e, t), n = w[0], i = w[1]), v = n.match(zE) || []; g = zE.exec(i); )
    S = g[0], T = i.substring(d, g.index), y ? y = (y + 1) % 5 : T.substr(-5) === "rgba(" && (y = 1), S !== v[p++] && (E = parseFloat(v[p - 1]) || 0, c._pt = {
      _next: c._pt,
      p: T || p === 1 ? T : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: E,
      c: S.charAt(1) === "=" ? Ip(E, S) - E : parseFloat(S) - E,
      m: y && y < 4 ? Math.round : 0
    }, d = zE.lastIndex);
  return c.c = d < i.length ? i.substring(d, i.length) : "", c.fp = u, (oI.test(i) || M) && (c.e = 0), this._pt = c, c;
}, MC = function(e, t, n, i, r, o, u, c, d, p) {
  zi(i) && (i = i(r || 0, e, o));
  var g = e[t], v = n !== "get" ? n : zi(g) ? d ? e[t.indexOf("set") || !zi(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](d) : e[t]() : g, y = zi(g) ? d ? CW : zI : TC, S;
  if (Pr(i) && (~i.indexOf("random(") && (i = Iv(i)), i.charAt(1) === "=" && (S = Ip(v, i) + (vs(v) || 0), (S || S === 0) && (i = S))), !p || v !== i || nb)
    return !isNaN(v * i) && i !== "" ? (S = new aa(this._pt, e, t, +v || 0, i - (v || 0), typeof g == "boolean" ? RW : GI, 0, y), d && (S.fp = d), u && S.modifier(u, this, e), this._pt = S) : (!g && !(t in e) && _C(t, i), AW.call(this, e, t, v, i, y, c || La.stringFilter, d));
}, MW = function(e, t, n, i, r) {
  if (zi(e) && (e = av(e, r, t, n, i)), !wl(e) || e.style && e.nodeType || Ss(e) || sI(e))
    return Pr(e) ? av(e, r, t, n, i) : e;
  var o = {}, u;
  for (u in e)
    o[u] = av(e[u], r, t, n, i);
  return o;
}, NI = function(e, t, n, i, r, o) {
  var u, c, d, p;
  if (Ea[e] && (u = new Ea[e]()).init(r, u.rawVars ? t[e] : MW(t[e], i, r, o, n), n, i, o) !== !1 && (n._pt = c = new aa(n._pt, r, e, 0, 1, u.render, u, 0, u.priority), n !== Rp))
    for (d = n._ptLookup[n._targets.indexOf(r)], p = u._props.length; p--; )
      d[u._props[p]] = c;
  return u;
}, xc, nb, EC = function s(e, t, n) {
  var i = e.vars, r = i.ease, o = i.startAt, u = i.immediateRender, c = i.lazy, d = i.onUpdate, p = i.runBackwards, g = i.yoyoEase, v = i.keyframes, y = i.autoRevert, S = e._dur, T = e._startAt, E = e._targets, M = e.parent, w = M && M.data === "nested" ? M.vars.targets : E, C = e._overwrite === "auto" && !pC, D = e.timeline, N, U, O, V, L, I, Y, Q, fe, j, ie, re, pe;
  if (D && (!v || !r) && (r = "none"), e._ease = ld(r, qp.ease), e._yEase = g ? PI(ld(g === !0 ? r : g, qp.ease)) : 0, g && e._yoyo && !e._repeat && (g = e._yEase, e._yEase = e._ease, e._ease = g), e._from = !D && !!i.runBackwards, !D || v && !i.stagger) {
    if (Q = E[0] ? ad(E[0]).harness : 0, re = Q && i[Q.prop], N = Px(i, yC), T && (T._zTime < 0 && T.progress(1), t < 0 && p && u && !y ? T.render(-1, !0) : T.revert(p && S ? hx : Q8), T._lazy = 0), o) {
      if (Nc(e._startAt = or.set(E, Ua({
        data: "isStart",
        overwrite: !1,
        parent: M,
        immediateRender: !0,
        lazy: !T && ra(c),
        startAt: null,
        delay: 0,
        onUpdate: d && function() {
          return Ba(e, "onUpdate");
        },
        stagger: 0
      }, o))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Zr || !u && !y) && e._startAt.revert(hx), u && S && t <= 0 && n <= 0) {
        t && (e._zTime = t);
        return;
      }
    } else if (p && S && !T) {
      if (t && (u = !1), O = Ua({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: u && !T && ra(c),
        immediateRender: u,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: M
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, N), re && (O[Q.prop] = re), Nc(e._startAt = or.set(E, O)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Zr ? e._startAt.revert(hx) : e._startAt.render(-1, !0)), e._zTime = t, !u)
        s(e._startAt, si, si);
      else if (!t)
        return;
    }
    for (e._pt = e._ptCache = 0, c = S && ra(c) || c && !S, U = 0; U < E.length; U++) {
      if (L = E[U], Y = L._gsap || SC(E)[U]._gsap, e._ptLookup[U] = j = {}, jT[Y.id] && Bc.length && Lx(), ie = w === E ? U : w.indexOf(L), Q && (fe = new Q()).init(L, re || N, e, ie, w) !== !1 && (e._pt = V = new aa(e._pt, L, fe.name, 0, 1, fe.render, fe, 0, fe.priority), fe._props.forEach(function(J) {
        j[J] = V;
      }), fe.priority && (I = 1)), !Q || re)
        for (O in N)
          Ea[O] && (fe = NI(O, N, e, ie, L, w)) ? fe.priority && (I = 1) : j[O] = V = MC.call(e, L, O, "get", N[O], ie, w, 0, i.stringFilter);
      e._op && e._op[U] && e.kill(L, e._op[U]), C && e._pt && (xc = e, Ti.killTweensOf(L, j, e.globalTime(t)), pe = !e.parent, xc = 0), e._pt && c && (jT[Y.id] = 1);
    }
    I && VI(e), e._onInit && e._onInit(e);
  }
  e._onUpdate = d, e._initted = (!e._op || e._pt) && !pe, v && t <= 0 && D.render(uo, !0, !0);
}, EW = function(e, t, n, i, r, o, u, c) {
  var d = (e._pt && e._ptCache || (e._ptCache = {}))[t], p, g, v, y;
  if (!d)
    for (d = e._ptCache[t] = [], v = e._ptLookup, y = e._targets.length; y--; ) {
      if (p = v[y][t], p && p.d && p.d._pt)
        for (p = p.d._pt; p && p.p !== t && p.fp !== t; )
          p = p._next;
      if (!p)
        return nb = 1, e.vars[t] = "+=0", EC(e, u), nb = 0, c ? Lv(t + " not eligible for reset") : 1;
      d.push(p);
    }
  for (y = d.length; y--; )
    g = d[y], p = g._pt || g, p.s = (i || i === 0) && !r ? i : p.s + (i || 0) + o * p.c, p.c = n - p.s, g.e && (g.e = ji(n) + vs(g.e)), g.b && (g.b = p.s + vs(g.b));
}, TW = function(e, t) {
  var n = e[0] ? ad(e[0]).harness : 0, i = n && n.aliases, r, o, u, c;
  if (!i)
    return t;
  r = jp({}, t);
  for (o in i)
    if (o in r)
      for (c = i[o].split(","), u = c.length; u--; )
        r[c[u]] = r[o];
  return r;
}, bW = function(e, t, n, i) {
  var r = t.ease || i || "power1.inOut", o, u;
  if (Ss(t))
    u = n[e] || (n[e] = []), t.forEach(function(c, d) {
      return u.push({
        t: d / (t.length - 1) * 100,
        v: c,
        e: r
      });
    });
  else
    for (o in t)
      u = n[o] || (n[o] = []), o === "ease" || u.push({
        t: parseFloat(e),
        v: t[o],
        e: r
      });
}, av = function(e, t, n, i, r) {
  return zi(e) ? e.call(t, n, i, r) : Pr(e) && ~e.indexOf("random(") ? Iv(e) : e;
}, OI = xC + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", HI = {};
sa(OI + ",id,stagger,delay,duration,paused,scrollTrigger", function(s) {
  return HI[s] = 1;
});
var or = /* @__PURE__ */ function(s) {
  iI(e, s);
  function e(n, i, r, o) {
    var u;
    typeof i == "number" && (r.duration = i, i = r, r = null), u = s.call(this, o ? i : rv(i)) || this;
    var c = u.vars, d = c.duration, p = c.delay, g = c.immediateRender, v = c.stagger, y = c.overwrite, S = c.keyframes, T = c.defaults, E = c.scrollTrigger, M = c.yoyoEase, w = i.parent || Ti, C = (Ss(n) || sI(n) ? vu(n[0]) : "length" in i) ? [n] : co(n), D, N, U, O, V, L, I, Y;
    if (u._targets = C.length ? SC(C) : Lv("GSAP target " + n + " not found. https://gsap.com", !La.nullTargetWarn) || [], u._ptLookup = [], u._overwrite = y, S || v || J0(d) || J0(p)) {
      if (i = u.vars, D = u.timeline = new Os({
        data: "nested",
        defaults: T || {},
        targets: w && w.data === "nested" ? w.vars.targets : C
      }), D.kill(), D.parent = D._dp = ru(u), D._start = 0, v || J0(d) || J0(p)) {
        if (O = C.length, I = v && MI(v), wl(v))
          for (V in v)
            ~OI.indexOf(V) && (Y || (Y = {}), Y[V] = v[V]);
        for (N = 0; N < O; N++)
          U = Px(i, HI), U.stagger = 0, M && (U.yoyoEase = M), Y && jp(U, Y), L = C[N], U.duration = +av(d, ru(u), N, L, C), U.delay = (+av(p, ru(u), N, L, C) || 0) - u._delay, !v && O === 1 && U.delay && (u._delay = p = U.delay, u._start += p, U.delay = 0), D.to(L, U, I ? I(N, L, C) : 0), D._ease = Un.none;
        D.duration() ? d = p = 0 : u.timeline = 0;
      } else if (S) {
        rv(Ua(D.vars.defaults, {
          ease: "none"
        })), D._ease = ld(S.ease || i.ease || "none");
        var Q = 0, fe, j, ie;
        if (Ss(S))
          S.forEach(function(re) {
            return D.to(C, re, ">");
          }), D.duration();
        else {
          U = {};
          for (V in S)
            V === "ease" || V === "easeEach" || bW(V, S[V], U, S.easeEach);
          for (V in U)
            for (fe = U[V].sort(function(re, pe) {
              return re.t - pe.t;
            }), Q = 0, N = 0; N < fe.length; N++)
              j = fe[N], ie = {
                ease: j.e,
                duration: (j.t - (N ? fe[N - 1].t : 0)) / 100 * d
              }, ie[V] = j.v, D.to(C, ie, Q), Q += ie.duration;
          D.duration() < d && D.to({}, {
            duration: d - D.duration()
          });
        }
      }
      d || u.duration(d = D.duration());
    } else
      u.timeline = 0;
    return y === !0 && !pC && (xc = ru(u), Ti.killTweensOf(C), xc = 0), vl(w, ru(u), r), i.reversed && u.reverse(), i.paused && u.paused(!0), (g || !d && !S && u._start === lr(w._time) && ra(g) && iW(ru(u)) && w.data !== "nested") && (u._tTime = -si, u.render(Math.max(0, -p) || 0)), E && yI(ru(u), E), u;
  }
  var t = e.prototype;
  return t.render = function(i, r, o) {
    var u = this._time, c = this._tDur, d = this._dur, p = i < 0, g = i > c - si && !p ? c : i < si ? 0 : i, v, y, S, T, E, M, w, C, D;
    if (!d)
      sW(this, i, r, o);
    else if (g !== this._tTime || !i || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== p || this._lazy) {
      if (v = g, C = this.timeline, this._repeat) {
        if (T = d + this._rDelay, this._repeat < -1 && p)
          return this.totalTime(T * 100 + i, r, o);
        if (v = lr(g % T), g === c ? (S = this._repeat, v = d) : (E = lr(g / T), S = ~~E, S && S === E ? (v = d, S--) : v > d && (v = d)), M = this._yoyo && S & 1, M && (D = this._yEase, v = d - v), E = Qp(this._tTime, T), v === u && !o && this._initted && S === E)
          return this._tTime = g, this;
        S !== E && (C && this._yEase && II(C, M), this.vars.repeatRefresh && !M && !this._lock && v !== T && this._initted && (this._lock = o = 1, this.render(lr(T * S), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (xI(this, p ? i : v, o, r, g))
          return this._tTime = 0, this;
        if (u !== this._time && !(o && this.vars.repeatRefresh && S !== E))
          return this;
        if (d !== this._dur)
          return this.render(i, r, o);
      }
      if (this._tTime = g, this._time = v, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = w = (D || this._ease)(v / d), this._from && (this.ratio = w = 1 - w), !u && g && !r && !E && (Ba(this, "onStart"), this._tTime !== g))
        return this;
      for (y = this._pt; y; )
        y.r(w, y.d), y = y._next;
      C && C.render(i < 0 ? i : C._dur * C._ease(v / this._dur), r, o) || this._startAt && (this._zTime = i), this._onUpdate && !r && (p && QT(this, i, r, o), Ba(this, "onUpdate")), this._repeat && S !== E && this.vars.onRepeat && !r && this.parent && Ba(this, "onRepeat"), (g === this._tDur || !g) && this._tTime === g && (p && !this._onUpdate && QT(this, i, !0, !0), (i || !d) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && Nc(this, 1), !r && !(p && !u) && (g || u || M) && (Ba(this, g === c ? "onComplete" : "onReverseComplete", !0), this._prom && !(g < c && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, t.targets = function() {
    return this._targets;
  }, t.invalidate = function(i) {
    return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), s.prototype.invalidate.call(this, i);
  }, t.resetTo = function(i, r, o, u, c) {
    Uv || Ca.wake(), this._ts || this.play();
    var d = Math.min(this._dur, (this._dp._time - this._start) * this._ts), p;
    return this._initted || EC(this, d), p = this._ease(d / this._dur), EW(this, i, r, o, u, p, d, c) ? this.resetTo(i, r, o, u, 1) : (xS(this, 0), this.parent || vI(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, t.kill = function(i, r) {
    if (r === void 0 && (r = "all"), !i && (!r || r === "all"))
      return this._lazy = this._pt = 0, this.parent ? Xg(this) : this.scrollTrigger && this.scrollTrigger.kill(!!Zr), this;
    if (this.timeline) {
      var o = this.timeline.totalDuration();
      return this.timeline.killTweensOf(i, r, xc && xc.vars.overwrite !== !0)._first || Xg(this), this.parent && o !== this.timeline.totalDuration() && Zp(this, this._dur * this.timeline._tDur / o, 0, 1), this;
    }
    var u = this._targets, c = i ? co(i) : u, d = this._ptLookup, p = this._pt, g, v, y, S, T, E, M;
    if ((!r || r === "all") && tW(u, c))
      return r === "all" && (this._pt = 0), Xg(this);
    for (g = this._op = this._op || [], r !== "all" && (Pr(r) && (T = {}, sa(r, function(w) {
      return T[w] = 1;
    }), r = T), r = TW(u, r)), M = u.length; M--; )
      if (~c.indexOf(u[M])) {
        v = d[M], r === "all" ? (g[M] = r, S = v, y = {}) : (y = g[M] = g[M] || {}, S = r);
        for (T in S)
          E = v && v[T], E && ((!("kill" in E.d) || E.d.kill(T) === !0) && _S(this, E, "_pt"), delete v[T]), y !== "all" && (y[T] = 1);
      }
    return this._initted && !this._pt && p && Xg(this), this;
  }, e.to = function(i, r) {
    return new e(i, r, arguments[2]);
  }, e.from = function(i, r) {
    return sv(1, arguments);
  }, e.delayedCall = function(i, r, o, u) {
    return new e(r, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: i,
      onComplete: r,
      onReverseComplete: r,
      onCompleteParams: o,
      onReverseCompleteParams: o,
      callbackScope: u
    });
  }, e.fromTo = function(i, r, o) {
    return sv(2, arguments);
  }, e.set = function(i, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(i, r);
  }, e.killTweensOf = function(i, r, o) {
    return Ti.killTweensOf(i, r, o);
  }, e;
}(Fv);
Ua(or.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
sa("staggerTo,staggerFrom,staggerFromTo", function(s) {
  or[s] = function() {
    var e = new Os(), t = $T.call(arguments, 0);
    return t.splice(s === "staggerFromTo" ? 5 : 4, 0, 0), e[s].apply(e, t);
  };
});
var TC = function(e, t, n) {
  return e[t] = n;
}, zI = function(e, t, n) {
  return e[t](n);
}, CW = function(e, t, n, i) {
  return e[t](i.fp, n);
}, wW = function(e, t, n) {
  return e.setAttribute(t, n);
}, bC = function(e, t) {
  return zi(e[t]) ? zI : mC(e[t]) && e.setAttribute ? wW : TC;
}, GI = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
}, RW = function(e, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * e), t);
}, kI = function(e, t) {
  var n = t._pt, i = "";
  if (!e && t.b)
    i = t.b;
  else if (e === 1 && t.e)
    i = t.e;
  else {
    for (; n; )
      i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i, n = n._next;
    i += t.c;
  }
  t.set(t.t, t.p, i, t);
}, CC = function(e, t) {
  for (var n = t._pt; n; )
    n.r(e, n.d), n = n._next;
}, BW = function(e, t, n, i) {
  for (var r = this._pt, o; r; )
    o = r._next, r.p === i && r.modifier(e, t, n), r = o;
}, DW = function(e) {
  for (var t = this._pt, n, i; t; )
    i = t._next, t.p === e && !t.op || t.op === e ? _S(this, t, "_pt") : t.dep || (n = 1), t = i;
  return !n;
}, LW = function(e, t, n, i) {
  i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
}, VI = function(e) {
  for (var t = e._pt, n, i, r, o; t; ) {
    for (n = t._next, i = r; i && i.pr > t.pr; )
      i = i._next;
    (t._prev = i ? i._prev : o) ? t._prev._next = t : r = t, (t._next = i) ? i._prev = t : o = t, t = n;
  }
  e._pt = r;
}, aa = /* @__PURE__ */ function() {
  function s(t, n, i, r, o, u, c, d, p) {
    this.t = n, this.s = r, this.c = o, this.p = i, this.r = u || GI, this.d = c || this, this.set = d || TC, this.pr = p || 0, this._next = t, t && (t._prev = this);
  }
  var e = s.prototype;
  return e.modifier = function(n, i, r) {
    this.mSet = this.mSet || this.set, this.set = LW, this.m = n, this.mt = r, this.tween = i;
  }, s;
}();
sa(xC + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(s) {
  return yC[s] = 1;
});
Ia.TweenMax = Ia.TweenLite = or;
Ia.TimelineLite = Ia.TimelineMax = Os;
Ti = new Os({
  sortChildren: !1,
  defaults: qp,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
La.stringFilter = LI;
var ud = [], mx = {}, PW = [], jD = 0, IW = 0, XE = function(e) {
  return (mx[e] || PW).map(function(t) {
    return t();
  });
}, ib = function() {
  var e = Date.now(), t = [];
  e - jD > 2 && (XE("matchMediaInit"), ud.forEach(function(n) {
    var i = n.queries, r = n.conditions, o, u, c, d;
    for (u in i)
      o = pl.matchMedia(i[u]).matches, o && (c = 1), o !== r[u] && (r[u] = o, d = 1);
    d && (n.revert(), c && t.push(n));
  }), XE("matchMediaRevert"), t.forEach(function(n) {
    return n.onMatch(n, function(i) {
      return n.add(null, i);
    });
  }), jD = e, XE("matchMedia"));
}, WI = /* @__PURE__ */ function() {
  function s(t, n) {
    this.selector = n && eb(n), this.data = [], this._r = [], this.isReverted = !1, this.id = IW++, t && this.add(t);
  }
  var e = s.prototype;
  return e.add = function(n, i, r) {
    zi(n) && (r = i, i = n, n = zi);
    var o = this, u = function() {
      var d = gi, p = o.selector, g;
      return d && d !== o && d.data.push(o), r && (o.selector = eb(r)), gi = o, g = i.apply(o, arguments), zi(g) && o._r.push(g), gi = d, o.selector = p, o.isReverted = !1, g;
    };
    return o.last = u, n === zi ? u(o, function(c) {
      return o.add(null, c);
    }) : n ? o[n] = u : u;
  }, e.ignore = function(n) {
    var i = gi;
    gi = null, n(this), gi = i;
  }, e.getTweens = function() {
    var n = [];
    return this.data.forEach(function(i) {
      return i instanceof s ? n.push.apply(n, i.getTweens()) : i instanceof or && !(i.parent && i.parent.data === "nested") && n.push(i);
    }), n;
  }, e.clear = function() {
    this._r.length = this.data.length = 0;
  }, e.kill = function(n, i) {
    var r = this;
    if (n ? function() {
      for (var u = r.getTweens(), c = r.data.length, d; c--; )
        d = r.data[c], d.data === "isFlip" && (d.revert(), d.getChildren(!0, !0, !1).forEach(function(p) {
          return u.splice(u.indexOf(p), 1);
        }));
      for (u.map(function(p) {
        return {
          g: p._dur || p._delay || p._sat && !p._sat.vars.immediateRender ? p.globalTime(0) : -1 / 0,
          t: p
        };
      }).sort(function(p, g) {
        return g.g - p.g || -1 / 0;
      }).forEach(function(p) {
        return p.t.revert(n);
      }), c = r.data.length; c--; )
        d = r.data[c], d instanceof Os ? d.data !== "nested" && (d.scrollTrigger && d.scrollTrigger.revert(), d.kill()) : !(d instanceof or) && d.revert && d.revert(n);
      r._r.forEach(function(p) {
        return p(n, r);
      }), r.isReverted = !0;
    }() : this.data.forEach(function(u) {
      return u.kill && u.kill();
    }), this.clear(), i)
      for (var o = ud.length; o--; )
        ud[o].id === this.id && ud.splice(o, 1);
  }, e.revert = function(n) {
    this.kill(n || {});
  }, s;
}(), UW = /* @__PURE__ */ function() {
  function s(t) {
    this.contexts = [], this.scope = t, gi && gi.data.push(this);
  }
  var e = s.prototype;
  return e.add = function(n, i, r) {
    wl(n) || (n = {
      matches: n
    });
    var o = new WI(0, r || this.scope), u = o.conditions = {}, c, d, p;
    gi && !o.selector && (o.selector = gi.selector), this.contexts.push(o), i = o.add("onMatch", i), o.queries = n;
    for (d in n)
      d === "all" ? p = 1 : (c = pl.matchMedia(n[d]), c && (ud.indexOf(o) < 0 && ud.push(o), (u[d] = c.matches) && (p = 1), c.addListener ? c.addListener(ib) : c.addEventListener("change", ib)));
    return p && i(o, function(g) {
      return o.add(null, g);
    }), this;
  }, e.revert = function(n) {
    this.kill(n || {});
  }, e.kill = function(n) {
    this.contexts.forEach(function(i) {
      return i.kill(n, !0);
    });
  }, s;
}(), Ux = {
  registerPlugin: function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    t.forEach(function(i) {
      return RI(i);
    });
  },
  timeline: function(e) {
    return new Os(e);
  },
  getTweensOf: function(e, t) {
    return Ti.getTweensOf(e, t);
  },
  getProperty: function(e, t, n, i) {
    Pr(e) && (e = co(e)[0]);
    var r = ad(e || {}).get, o = n ? gI : mI;
    return n === "native" && (n = ""), e && (t ? o((Ea[t] && Ea[t].get || r)(e, t, n, i)) : function(u, c, d) {
      return o((Ea[u] && Ea[u].get || r)(e, u, c, d));
    });
  },
  quickSetter: function(e, t, n) {
    if (e = co(e), e.length > 1) {
      var i = e.map(function(p) {
        return la.quickSetter(p, t, n);
      }), r = i.length;
      return function(p) {
        for (var g = r; g--; )
          i[g](p);
      };
    }
    e = e[0] || {};
    var o = Ea[t], u = ad(e), c = u.harness && (u.harness.aliases || {})[t] || t, d = o ? function(p) {
      var g = new o();
      Rp._pt = 0, g.init(e, n ? p + n : p, Rp, 0, [e]), g.render(1, g), Rp._pt && CC(1, Rp);
    } : u.set(e, c);
    return o ? d : function(p) {
      return d(e, c, n ? p + n : p, u, 1);
    };
  },
  quickTo: function(e, t, n) {
    var i, r = la.to(e, Ua((i = {}, i[t] = "+=0.1", i.paused = !0, i.stagger = 0, i), n || {})), o = function(c, d, p) {
      return r.resetTo(t, c, d, p);
    };
    return o.tween = r, o;
  },
  isTweening: function(e) {
    return Ti.getTweensOf(e, !0).length > 0;
  },
  defaults: function(e) {
    return e && e.ease && (e.ease = ld(e.ease, qp.ease)), XD(qp, e || {});
  },
  config: function(e) {
    return XD(La, e || {});
  },
  registerEffect: function(e) {
    var t = e.name, n = e.effect, i = e.plugins, r = e.defaults, o = e.extendTimeline;
    (i || "").split(",").forEach(function(u) {
      return u && !Ea[u] && !Ia[u] && Lv(t + " effect requires " + u + " plugin.");
    }), GE[t] = function(u, c, d) {
      return n(co(u), Ua(c || {}, r), d);
    }, o && (Os.prototype[t] = function(u, c, d) {
      return this.add(GE[t](u, wl(c) ? c : (d = c) && {}, this), d);
    });
  },
  registerEase: function(e, t) {
    Un[e] = ld(t);
  },
  parseEase: function(e, t) {
    return arguments.length ? ld(e, t) : Un;
  },
  getById: function(e) {
    return Ti.getById(e);
  },
  exportRoot: function(e, t) {
    e === void 0 && (e = {});
    var n = new Os(e), i, r;
    for (n.smoothChildTiming = ra(e.smoothChildTiming), Ti.remove(n), n._dp = 0, n._time = n._tTime = Ti._time, i = Ti._first; i; )
      r = i._next, (t || !(!i._dur && i instanceof or && i.vars.onComplete === i._targets[0])) && vl(n, i, i._start - i._delay), i = r;
    return vl(Ti, n, 0), n;
  },
  context: function(e, t) {
    return e ? new WI(e, t) : gi;
  },
  matchMedia: function(e) {
    return new UW(e);
  },
  matchMediaRefresh: function() {
    return ud.forEach(function(e) {
      var t = e.conditions, n, i;
      for (i in t)
        t[i] && (t[i] = !1, n = 1);
      n && e.revert();
    }) || ib();
  },
  addEventListener: function(e, t) {
    var n = mx[e] || (mx[e] = []);
    ~n.indexOf(t) || n.push(t);
  },
  removeEventListener: function(e, t) {
    var n = mx[e], i = n && n.indexOf(t);
    i >= 0 && n.splice(i, 1);
  },
  utils: {
    wrap: hW,
    wrapYoyo: pW,
    distribute: MI,
    random: TI,
    snap: EI,
    normalize: dW,
    getUnit: vs,
    clamp: lW,
    splitColor: BI,
    toArray: co,
    selector: eb,
    mapRange: CI,
    pipe: cW,
    unitize: fW,
    interpolate: mW,
    shuffle: AI
  },
  install: cI,
  effects: GE,
  ticker: Ca,
  updateRoot: Os.updateRoot,
  plugins: Ea,
  globalTimeline: Ti,
  core: {
    PropTween: aa,
    globals: fI,
    Tween: or,
    Timeline: Os,
    Animation: Fv,
    getCache: ad,
    _removeLinkedListItem: _S,
    reverting: function() {
      return Zr;
    },
    context: function(e) {
      return e && gi && (gi.data.push(e), e._ctx = gi), gi;
    },
    suppressOverwrites: function(e) {
      return pC = e;
    }
  }
};
sa("to,from,fromTo,delayedCall,set,killTweensOf", function(s) {
  return Ux[s] = or[s];
});
Ca.add(Os.updateRoot);
Rp = Ux.to({}, {
  duration: 0
});
var FW = function(e, t) {
  for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
    n = n._next;
  return n;
}, NW = function(e, t) {
  var n = e._targets, i, r, o;
  for (i in t)
    for (r = n.length; r--; )
      o = e._ptLookup[r][i], o && (o = o.d) && (o._pt && (o = FW(o, i)), o && o.modifier && o.modifier(t[i], e, n[r], i));
}, JE = function(e, t) {
  return {
    name: e,
    headless: 1,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(i, r, o) {
      o._onInit = function(u) {
        var c, d;
        if (Pr(r) && (c = {}, sa(r, function(p) {
          return c[p] = 1;
        }), r = c), t) {
          c = {};
          for (d in r)
            c[d] = t(r[d]);
          r = c;
        }
        NW(u, r);
      };
    }
  };
}, la = Ux.registerPlugin({
  name: "attr",
  init: function(e, t, n, i, r) {
    var o, u, c;
    this.tween = n;
    for (o in t)
      c = e.getAttribute(o) || "", u = this.add(e, "setAttribute", (c || 0) + "", t[o], i, r, 0, 0, o), u.op = o, u.b = c, this._props.push(o);
  },
  render: function(e, t) {
    for (var n = t._pt; n; )
      Zr ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next;
  }
}, {
  name: "endArray",
  headless: 1,
  init: function(e, t) {
    for (var n = t.length; n--; )
      this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
  }
}, JE("roundProps", tb), JE("modifiers"), JE("snap", EI)) || Ux;
or.version = Os.version = la.version = "3.13.0";
uI = 1;
gC() && $p();
Un.Power0;
Un.Power1;
Un.Power2;
Un.Power3;
Un.Power4;
Un.Linear;
Un.Quad;
Un.Cubic;
Un.Quart;
Un.Quint;
Un.Strong;
Un.Elastic;
Un.Back;
Un.SteppedEase;
Un.Bounce;
Un.Sine;
Un.Expo;
Un.Circ;
/*!
 * CSSPlugin 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var QD, Sc, Up, wC, $f, ZD, RC, OW = function() {
  return typeof window < "u";
}, _u = {}, Vf = 180 / Math.PI, Fp = Math.PI / 180, gp = Math.atan2, $D = 1e8, BC = /([A-Z])/g, HW = /(left|right|width|margin|padding|x)/i, zW = /[\s,\(]\S/, _l = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, rb = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, GW = function(e, t) {
  return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, kW = function(e, t) {
  return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
}, VW = function(e, t) {
  var n = t.s + t.c * e;
  t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
}, XI = function(e, t) {
  return t.set(t.t, t.p, e ? t.e : t.b, t);
}, JI = function(e, t) {
  return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
}, WW = function(e, t, n) {
  return e.style[t] = n;
}, XW = function(e, t, n) {
  return e.style.setProperty(t, n);
}, JW = function(e, t, n) {
  return e._gsap[t] = n;
}, YW = function(e, t, n) {
  return e._gsap.scaleX = e._gsap.scaleY = n;
}, KW = function(e, t, n, i, r) {
  var o = e._gsap;
  o.scaleX = o.scaleY = n, o.renderTransform(r, o);
}, qW = function(e, t, n, i, r) {
  var o = e._gsap;
  o[t] = n, o.renderTransform(r, o);
}, wi = "transform", oa = wi + "Origin", jW = function s(e, t) {
  var n = this, i = this.target, r = i.style, o = i._gsap;
  if (e in _u && r) {
    if (this.tfm = this.tfm || {}, e !== "transform")
      e = _l[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(u) {
        return n.tfm[u] = su(i, u);
      }) : this.tfm[e] = o.x ? o[e] : su(i, e), e === oa && (this.tfm.zOrigin = o.zOrigin);
    else
      return _l.transform.split(",").forEach(function(u) {
        return s.call(n, u, t);
      });
    if (this.props.indexOf(wi) >= 0)
      return;
    o.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(oa, t, "")), e = wi;
  }
  (r || t) && this.props.push(e, t, r[e]);
}, YI = function(e) {
  e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"));
}, QW = function() {
  var e = this.props, t = this.target, n = t.style, i = t._gsap, r, o;
  for (r = 0; r < e.length; r += 3)
    e[r + 1] ? e[r + 1] === 2 ? t[e[r]](e[r + 2]) : t[e[r]] = e[r + 2] : e[r + 2] ? n[e[r]] = e[r + 2] : n.removeProperty(e[r].substr(0, 2) === "--" ? e[r] : e[r].replace(BC, "-$1").toLowerCase());
  if (this.tfm) {
    for (o in this.tfm)
      i[o] = this.tfm[o];
    i.svg && (i.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), r = RC(), (!r || !r.isStart) && !n[wi] && (YI(n), i.zOrigin && n[oa] && (n[oa] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1);
  }
}, KI = function(e, t) {
  var n = {
    target: e,
    props: [],
    revert: QW,
    save: jW
  };
  return e._gsap || la.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function(i) {
    return n.save(i);
  }), n;
}, qI, sb = function(e, t) {
  var n = Sc.createElementNS ? Sc.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Sc.createElement(e);
  return n && n.style ? n : Sc.createElement(e);
}, fo = function s(e, t, n) {
  var i = getComputedStyle(e);
  return i[t] || i.getPropertyValue(t.replace(BC, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && s(e, em(t) || t, 1) || "";
}, eL = "O,Moz,ms,Ms,Webkit".split(","), em = function(e, t, n) {
  var i = t || $f, r = i.style, o = 5;
  if (e in r && !n)
    return e;
  for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(eL[o] + e in r); )
    ;
  return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? eL[o] : "") + e;
}, ab = function() {
  OW() && window.document && (QD = window, Sc = QD.document, Up = Sc.documentElement, $f = sb("div") || {
    style: {}
  }, sb("div"), wi = em(wi), oa = wi + "Origin", $f.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", qI = !!em("perspective"), RC = la.core.reverting, wC = 1);
}, tL = function(e) {
  var t = e.ownerSVGElement, n = sb("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = e.cloneNode(!0), r;
  i.style.display = "block", n.appendChild(i), Up.appendChild(n);
  try {
    r = i.getBBox();
  } catch {
  }
  return n.removeChild(i), Up.removeChild(n), r;
}, nL = function(e, t) {
  for (var n = t.length; n--; )
    if (e.hasAttribute(t[n]))
      return e.getAttribute(t[n]);
}, jI = function(e) {
  var t, n;
  try {
    t = e.getBBox();
  } catch {
    t = tL(e), n = 1;
  }
  return t && (t.width || t.height) || n || (t = tL(e)), t && !t.width && !t.x && !t.y ? {
    x: +nL(e, ["x", "cx", "x1"]) || 0,
    y: +nL(e, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : t;
}, QI = function(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && jI(e));
}, yd = function(e, t) {
  if (t) {
    var n = e.style, i;
    t in _u && t !== oa && (t = wi), n.removeProperty ? (i = t.substr(0, 2), (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(i === "--" ? t : t.replace(BC, "-$1").toLowerCase())) : n.removeAttribute(t);
  }
}, Ac = function(e, t, n, i, r, o) {
  var u = new aa(e._pt, t, n, 0, 1, o ? JI : XI);
  return e._pt = u, u.b = i, u.e = r, e._props.push(n), u;
}, iL = {
  deg: 1,
  rad: 1,
  turn: 1
}, ZW = {
  grid: 1,
  flex: 1
}, Oc = function s(e, t, n, i) {
  var r = parseFloat(n) || 0, o = (n + "").trim().substr((r + "").length) || "px", u = $f.style, c = HW.test(t), d = e.tagName.toLowerCase() === "svg", p = (d ? "client" : "offset") + (c ? "Width" : "Height"), g = 100, v = i === "px", y = i === "%", S, T, E, M;
  if (i === o || !r || iL[i] || iL[o])
    return r;
  if (o !== "px" && !v && (r = s(e, t, n, "px")), M = e.getCTM && QI(e), (y || o === "%") && (_u[t] || ~t.indexOf("adius")))
    return S = M ? e.getBBox()[c ? "width" : "height"] : e[p], ji(y ? r / S * g : r / 100 * S);
  if (u[c ? "width" : "height"] = g + (v ? o : i), T = i !== "rem" && ~t.indexOf("adius") || i === "em" && e.appendChild && !d ? e : e.parentNode, M && (T = (e.ownerSVGElement || {}).parentNode), (!T || T === Sc || !T.appendChild) && (T = Sc.body), E = T._gsap, E && y && E.width && c && E.time === Ca.time && !E.uncache)
    return ji(r / E.width * g);
  if (y && (t === "height" || t === "width")) {
    var w = e.style[t];
    e.style[t] = g + i, S = e[p], w ? e.style[t] = w : yd(e, t);
  } else
    (y || o === "%") && !ZW[fo(T, "display")] && (u.position = fo(e, "position")), T === e && (u.position = "static"), T.appendChild($f), S = $f[p], T.removeChild($f), u.position = "absolute";
  return c && y && (E = ad(T), E.time = Ca.time, E.width = T[p]), ji(v ? S * r / g : S && r ? g / S * r : 0);
}, su = function(e, t, n, i) {
  var r;
  return wC || ab(), t in _l && t !== "transform" && (t = _l[t], ~t.indexOf(",") && (t = t.split(",")[0])), _u[t] && t !== "transform" ? (r = Ov(e, i), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : Nx(fo(e, oa)) + " " + r.zOrigin + "px") : (r = e.style[t], (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) && (r = Fx[t] && Fx[t](e, t, n) || fo(e, t) || hI(e, t) || (t === "opacity" ? 1 : 0))), n && !~(r + "").trim().indexOf(" ") ? Oc(e, t, r, n) + n : r;
}, $W = function(e, t, n, i) {
  if (!n || n === "none") {
    var r = em(t, e, 1), o = r && fo(e, r, 1);
    o && o !== n ? (t = r, n = o) : t === "borderColor" && (n = fo(e, "borderTopColor"));
  }
  var u = new aa(this._pt, e.style, t, 0, 1, kI), c = 0, d = 0, p, g, v, y, S, T, E, M, w, C, D, N;
  if (u.b = n, u.e = i, n += "", i += "", i.substring(0, 6) === "var(--" && (i = fo(e, i.substring(4, i.indexOf(")")))), i === "auto" && (T = e.style[t], e.style[t] = i, i = fo(e, t) || i, T ? e.style[t] = T : yd(e, t)), p = [n, i], LI(p), n = p[0], i = p[1], v = n.match(wp) || [], N = i.match(wp) || [], N.length) {
    for (; g = wp.exec(i); )
      E = g[0], w = i.substring(c, g.index), S ? S = (S + 1) % 5 : (w.substr(-5) === "rgba(" || w.substr(-5) === "hsla(") && (S = 1), E !== (T = v[d++] || "") && (y = parseFloat(T) || 0, D = T.substr((y + "").length), E.charAt(1) === "=" && (E = Ip(y, E) + D), M = parseFloat(E), C = E.substr((M + "").length), c = wp.lastIndex - C.length, C || (C = C || La.units[t] || D, c === i.length && (i += C, u.e += C)), D !== C && (y = Oc(e, t, T, C) || 0), u._pt = {
        _next: u._pt,
        p: w || d === 1 ? w : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: y,
        c: M - y,
        m: S && S < 4 || t === "zIndex" ? Math.round : 0
      });
    u.c = c < i.length ? i.substring(c, i.length) : "";
  } else
    u.r = t === "display" && i === "none" ? JI : XI;
  return oI.test(i) && (u.e = 0), this._pt = u, u;
}, rL = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, e6 = function(e) {
  var t = e.split(" "), n = t[0], i = t[1] || "50%";
  return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n, n = i, i = e), t[0] = rL[n] || n, t[1] = rL[i] || i, t.join(" ");
}, t6 = function(e, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var n = t.t, i = n.style, r = t.u, o = n._gsap, u, c, d;
    if (r === "all" || r === !0)
      i.cssText = "", c = 1;
    else
      for (r = r.split(","), d = r.length; --d > -1; )
        u = r[d], _u[u] && (c = 1, u = u === "transformOrigin" ? oa : wi), yd(n, u);
    c && (yd(n, wi), o && (o.svg && n.removeAttribute("transform"), i.scale = i.rotate = i.translate = "none", Ov(n, 1), o.uncache = 1, YI(i)));
  }
}, Fx = {
  clearProps: function(e, t, n, i, r) {
    if (r.data !== "isFromStart") {
      var o = e._pt = new aa(e._pt, t, n, 0, 0, t6);
      return o.u = i, o.pr = -10, o.tween = r, e._props.push(n), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, Nv = [1, 0, 0, 1, 0, 0], ZI = {}, $I = function(e) {
  return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
}, sL = function(e) {
  var t = fo(e, wi);
  return $I(t) ? Nv : t.substr(7).match(aI).map(ji);
}, DC = function(e, t) {
  var n = e._gsap || ad(e), i = e.style, r = sL(e), o, u, c, d;
  return n.svg && e.getAttribute("transform") ? (c = e.transform.baseVal.consolidate().matrix, r = [c.a, c.b, c.c, c.d, c.e, c.f], r.join(",") === "1,0,0,1,0,0" ? Nv : r) : (r === Nv && !e.offsetParent && e !== Up && !n.svg && (c = i.display, i.display = "block", o = e.parentNode, (!o || !e.offsetParent && !e.getBoundingClientRect().width) && (d = 1, u = e.nextElementSibling, Up.appendChild(e)), r = sL(e), c ? i.display = c : yd(e, "display"), d && (u ? o.insertBefore(e, u) : o ? o.appendChild(e) : Up.removeChild(e))), t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
}, ob = function(e, t, n, i, r, o) {
  var u = e._gsap, c = r || DC(e, !0), d = u.xOrigin || 0, p = u.yOrigin || 0, g = u.xOffset || 0, v = u.yOffset || 0, y = c[0], S = c[1], T = c[2], E = c[3], M = c[4], w = c[5], C = t.split(" "), D = parseFloat(C[0]) || 0, N = parseFloat(C[1]) || 0, U, O, V, L;
  n ? c !== Nv && (O = y * E - S * T) && (V = D * (E / O) + N * (-T / O) + (T * w - E * M) / O, L = D * (-S / O) + N * (y / O) - (y * w - S * M) / O, D = V, N = L) : (U = jI(e), D = U.x + (~C[0].indexOf("%") ? D / 100 * U.width : D), N = U.y + (~(C[1] || C[0]).indexOf("%") ? N / 100 * U.height : N)), i || i !== !1 && u.smooth ? (M = D - d, w = N - p, u.xOffset = g + (M * y + w * T) - M, u.yOffset = v + (M * S + w * E) - w) : u.xOffset = u.yOffset = 0, u.xOrigin = D, u.yOrigin = N, u.smooth = !!i, u.origin = t, u.originIsAbsolute = !!n, e.style[oa] = "0px 0px", o && (Ac(o, u, "xOrigin", d, D), Ac(o, u, "yOrigin", p, N), Ac(o, u, "xOffset", g, u.xOffset), Ac(o, u, "yOffset", v, u.yOffset)), e.setAttribute("data-svg-origin", D + " " + N);
}, Ov = function(e, t) {
  var n = e._gsap || new FI(e);
  if ("x" in n && !t && !n.uncache)
    return n;
  var i = e.style, r = n.scaleX < 0, o = "px", u = "deg", c = getComputedStyle(e), d = fo(e, oa) || "0", p, g, v, y, S, T, E, M, w, C, D, N, U, O, V, L, I, Y, Q, fe, j, ie, re, pe, J, Z, H, ue, Se, me, ye, Xe;
  return p = g = v = T = E = M = w = C = D = 0, y = S = 1, n.svg = !!(e.getCTM && QI(e)), c.translate && ((c.translate !== "none" || c.scale !== "none" || c.rotate !== "none") && (i[wi] = (c.translate !== "none" ? "translate3d(" + (c.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (c.rotate !== "none" ? "rotate(" + c.rotate + ") " : "") + (c.scale !== "none" ? "scale(" + c.scale.split(" ").join(",") + ") " : "") + (c[wi] !== "none" ? c[wi] : "")), i.scale = i.rotate = i.translate = "none"), O = DC(e, n.svg), n.svg && (n.uncache ? (J = e.getBBox(), d = n.xOrigin - J.x + "px " + (n.yOrigin - J.y) + "px", pe = "") : pe = !t && e.getAttribute("data-svg-origin"), ob(e, pe || d, !!pe || n.originIsAbsolute, n.smooth !== !1, O)), N = n.xOrigin || 0, U = n.yOrigin || 0, O !== Nv && (Y = O[0], Q = O[1], fe = O[2], j = O[3], p = ie = O[4], g = re = O[5], O.length === 6 ? (y = Math.sqrt(Y * Y + Q * Q), S = Math.sqrt(j * j + fe * fe), T = Y || Q ? gp(Q, Y) * Vf : 0, w = fe || j ? gp(fe, j) * Vf + T : 0, w && (S *= Math.abs(Math.cos(w * Fp))), n.svg && (p -= N - (N * Y + U * fe), g -= U - (N * Q + U * j))) : (Xe = O[6], me = O[7], H = O[8], ue = O[9], Se = O[10], ye = O[11], p = O[12], g = O[13], v = O[14], V = gp(Xe, Se), E = V * Vf, V && (L = Math.cos(-V), I = Math.sin(-V), pe = ie * L + H * I, J = re * L + ue * I, Z = Xe * L + Se * I, H = ie * -I + H * L, ue = re * -I + ue * L, Se = Xe * -I + Se * L, ye = me * -I + ye * L, ie = pe, re = J, Xe = Z), V = gp(-fe, Se), M = V * Vf, V && (L = Math.cos(-V), I = Math.sin(-V), pe = Y * L - H * I, J = Q * L - ue * I, Z = fe * L - Se * I, ye = j * I + ye * L, Y = pe, Q = J, fe = Z), V = gp(Q, Y), T = V * Vf, V && (L = Math.cos(V), I = Math.sin(V), pe = Y * L + Q * I, J = ie * L + re * I, Q = Q * L - Y * I, re = re * L - ie * I, Y = pe, ie = J), E && Math.abs(E) + Math.abs(T) > 359.9 && (E = T = 0, M = 180 - M), y = ji(Math.sqrt(Y * Y + Q * Q + fe * fe)), S = ji(Math.sqrt(re * re + Xe * Xe)), V = gp(ie, re), w = Math.abs(V) > 2e-4 ? V * Vf : 0, D = ye ? 1 / (ye < 0 ? -ye : ye) : 0), n.svg && (pe = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !$I(fo(e, wi)), pe && e.setAttribute("transform", pe))), Math.abs(w) > 90 && Math.abs(w) < 270 && (r ? (y *= -1, w += T <= 0 ? 180 : -180, T += T <= 0 ? 180 : -180) : (S *= -1, w += w <= 0 ? 180 : -180)), t = t || n.uncache, n.x = p - ((n.xPercent = p && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-p) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + o, n.y = g - ((n.yPercent = g && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-g) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + o, n.z = v + o, n.scaleX = ji(y), n.scaleY = ji(S), n.rotation = ji(T) + u, n.rotationX = ji(E) + u, n.rotationY = ji(M) + u, n.skewX = w + u, n.skewY = C + u, n.transformPerspective = D + o, (n.zOrigin = parseFloat(d.split(" ")[2]) || !t && n.zOrigin || 0) && (i[oa] = Nx(d)), n.xOffset = n.yOffset = 0, n.force3D = La.force3D, n.renderTransform = n.svg ? i6 : qI ? eU : n6, n.uncache = 0, n;
}, Nx = function(e) {
  return (e = e.split(" "))[0] + " " + e[1];
}, YE = function(e, t, n) {
  var i = vs(t);
  return ji(parseFloat(t) + parseFloat(Oc(e, "x", n + "px", i))) + i;
}, n6 = function(e, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, eU(e, t);
}, Hf = "0deg", Gg = "0px", zf = ") ", eU = function(e, t) {
  var n = t || this, i = n.xPercent, r = n.yPercent, o = n.x, u = n.y, c = n.z, d = n.rotation, p = n.rotationY, g = n.rotationX, v = n.skewX, y = n.skewY, S = n.scaleX, T = n.scaleY, E = n.transformPerspective, M = n.force3D, w = n.target, C = n.zOrigin, D = "", N = M === "auto" && e && e !== 1 || M === !0;
  if (C && (g !== Hf || p !== Hf)) {
    var U = parseFloat(p) * Fp, O = Math.sin(U), V = Math.cos(U), L;
    U = parseFloat(g) * Fp, L = Math.cos(U), o = YE(w, o, O * L * -C), u = YE(w, u, -Math.sin(U) * -C), c = YE(w, c, V * L * -C + C);
  }
  E !== Gg && (D += "perspective(" + E + zf), (i || r) && (D += "translate(" + i + "%, " + r + "%) "), (N || o !== Gg || u !== Gg || c !== Gg) && (D += c !== Gg || N ? "translate3d(" + o + ", " + u + ", " + c + ") " : "translate(" + o + ", " + u + zf), d !== Hf && (D += "rotate(" + d + zf), p !== Hf && (D += "rotateY(" + p + zf), g !== Hf && (D += "rotateX(" + g + zf), (v !== Hf || y !== Hf) && (D += "skew(" + v + ", " + y + zf), (S !== 1 || T !== 1) && (D += "scale(" + S + ", " + T + zf), w.style[wi] = D || "translate(0, 0)";
}, i6 = function(e, t) {
  var n = t || this, i = n.xPercent, r = n.yPercent, o = n.x, u = n.y, c = n.rotation, d = n.skewX, p = n.skewY, g = n.scaleX, v = n.scaleY, y = n.target, S = n.xOrigin, T = n.yOrigin, E = n.xOffset, M = n.yOffset, w = n.forceCSS, C = parseFloat(o), D = parseFloat(u), N, U, O, V, L;
  c = parseFloat(c), d = parseFloat(d), p = parseFloat(p), p && (p = parseFloat(p), d += p, c += p), c || d ? (c *= Fp, d *= Fp, N = Math.cos(c) * g, U = Math.sin(c) * g, O = Math.sin(c - d) * -v, V = Math.cos(c - d) * v, d && (p *= Fp, L = Math.tan(d - p), L = Math.sqrt(1 + L * L), O *= L, V *= L, p && (L = Math.tan(p), L = Math.sqrt(1 + L * L), N *= L, U *= L)), N = ji(N), U = ji(U), O = ji(O), V = ji(V)) : (N = g, V = v, U = O = 0), (C && !~(o + "").indexOf("px") || D && !~(u + "").indexOf("px")) && (C = Oc(y, "x", o, "px"), D = Oc(y, "y", u, "px")), (S || T || E || M) && (C = ji(C + S - (S * N + T * O) + E), D = ji(D + T - (S * U + T * V) + M)), (i || r) && (L = y.getBBox(), C = ji(C + i / 100 * L.width), D = ji(D + r / 100 * L.height)), L = "matrix(" + N + "," + U + "," + O + "," + V + "," + C + "," + D + ")", y.setAttribute("transform", L), w && (y.style[wi] = L);
}, r6 = function(e, t, n, i, r) {
  var o = 360, u = Pr(r), c = parseFloat(r) * (u && ~r.indexOf("rad") ? Vf : 1), d = c - i, p = i + d + "deg", g, v;
  return u && (g = r.split("_")[1], g === "short" && (d %= o, d !== d % (o / 2) && (d += d < 0 ? o : -o)), g === "cw" && d < 0 ? d = (d + o * $D) % o - ~~(d / o) * o : g === "ccw" && d > 0 && (d = (d - o * $D) % o - ~~(d / o) * o)), e._pt = v = new aa(e._pt, t, n, i, d, GW), v.e = p, v.u = "deg", e._props.push(n), v;
}, aL = function(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}, s6 = function(e, t, n) {
  var i = aL({}, n._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", o = n.style, u, c, d, p, g, v, y, S;
  i.svg ? (d = n.getAttribute("transform"), n.setAttribute("transform", ""), o[wi] = t, u = Ov(n, 1), yd(n, wi), n.setAttribute("transform", d)) : (d = getComputedStyle(n)[wi], o[wi] = t, u = Ov(n, 1), o[wi] = d);
  for (c in _u)
    d = i[c], p = u[c], d !== p && r.indexOf(c) < 0 && (y = vs(d), S = vs(p), g = y !== S ? Oc(n, c, d, S) : parseFloat(d), v = parseFloat(p), e._pt = new aa(e._pt, u, c, g, v - g, rb), e._pt.u = S || 0, e._props.push(c));
  aL(u, i);
};
sa("padding,margin,Width,Radius", function(s, e) {
  var t = "Top", n = "Right", i = "Bottom", r = "Left", o = (e < 3 ? [t, n, i, r] : [t + r, t + n, i + n, i + r]).map(function(u) {
    return e < 2 ? s + u : "border" + u + s;
  });
  Fx[e > 1 ? "border" + s : s] = function(u, c, d, p, g) {
    var v, y;
    if (arguments.length < 4)
      return v = o.map(function(S) {
        return su(u, S, d);
      }), y = v.join(" "), y.split(v[0]).length === 5 ? v[0] : y;
    v = (p + "").split(" "), y = {}, o.forEach(function(S, T) {
      return y[S] = v[T] = v[T] || v[(T - 1) / 2 | 0];
    }), u.init(c, y, g);
  };
});
var tU = {
  name: "css",
  register: ab,
  targetTest: function(e) {
    return e.style && e.nodeType;
  },
  init: function(e, t, n, i, r) {
    var o = this._props, u = e.style, c = n.vars.startAt, d, p, g, v, y, S, T, E, M, w, C, D, N, U, O, V;
    wC || ab(), this.styles = this.styles || KI(e), V = this.styles.props, this.tween = n;
    for (T in t)
      if (T !== "autoRound" && (p = t[T], !(Ea[T] && NI(T, t, n, i, e, r)))) {
        if (y = typeof p, S = Fx[T], y === "function" && (p = p.call(n, i, e, r), y = typeof p), y === "string" && ~p.indexOf("random(") && (p = Iv(p)), S)
          S(this, e, T, p, n) && (O = 1);
        else if (T.substr(0, 2) === "--")
          d = (getComputedStyle(e).getPropertyValue(T) + "").trim(), p += "", Dc.lastIndex = 0, Dc.test(d) || (E = vs(d), M = vs(p)), M ? E !== M && (d = Oc(e, T, d, M) + M) : E && (p += E), this.add(u, "setProperty", d, p, i, r, 0, 0, T), o.push(T), V.push(T, 0, u[T]);
        else if (y !== "undefined") {
          if (c && T in c ? (d = typeof c[T] == "function" ? c[T].call(n, i, e, r) : c[T], Pr(d) && ~d.indexOf("random(") && (d = Iv(d)), vs(d + "") || d === "auto" || (d += La.units[T] || vs(su(e, T)) || ""), (d + "").charAt(1) === "=" && (d = su(e, T))) : d = su(e, T), v = parseFloat(d), w = y === "string" && p.charAt(1) === "=" && p.substr(0, 2), w && (p = p.substr(2)), g = parseFloat(p), T in _l && (T === "autoAlpha" && (v === 1 && su(e, "visibility") === "hidden" && g && (v = 0), V.push("visibility", 0, u.visibility), Ac(this, u, "visibility", v ? "inherit" : "hidden", g ? "inherit" : "hidden", !g)), T !== "scale" && T !== "transform" && (T = _l[T], ~T.indexOf(",") && (T = T.split(",")[0]))), C = T in _u, C) {
            if (this.styles.save(T), y === "string" && p.substring(0, 6) === "var(--" && (p = fo(e, p.substring(4, p.indexOf(")"))), g = parseFloat(p)), D || (N = e._gsap, N.renderTransform && !t.parseTransform || Ov(e, t.parseTransform), U = t.smoothOrigin !== !1 && N.smooth, D = this._pt = new aa(this._pt, u, wi, 0, 1, N.renderTransform, N, 0, -1), D.dep = 1), T === "scale")
              this._pt = new aa(this._pt, N, "scaleY", N.scaleY, (w ? Ip(N.scaleY, w + g) : g) - N.scaleY || 0, rb), this._pt.u = 0, o.push("scaleY", T), T += "X";
            else if (T === "transformOrigin") {
              V.push(oa, 0, u[oa]), p = e6(p), N.svg ? ob(e, p, 0, U, 0, this) : (M = parseFloat(p.split(" ")[2]) || 0, M !== N.zOrigin && Ac(this, N, "zOrigin", N.zOrigin, M), Ac(this, u, T, Nx(d), Nx(p)));
              continue;
            } else if (T === "svgOrigin") {
              ob(e, p, 1, U, 0, this);
              continue;
            } else if (T in ZI) {
              r6(this, N, T, v, w ? Ip(v, w + p) : p);
              continue;
            } else if (T === "smoothOrigin") {
              Ac(this, N, "smooth", N.smooth, p);
              continue;
            } else if (T === "force3D") {
              N[T] = p;
              continue;
            } else if (T === "transform") {
              s6(this, p, e);
              continue;
            }
          } else T in u || (T = em(T) || T);
          if (C || (g || g === 0) && (v || v === 0) && !zW.test(p) && T in u)
            E = (d + "").substr((v + "").length), g || (g = 0), M = vs(p) || (T in La.units ? La.units[T] : E), E !== M && (v = Oc(e, T, d, M)), this._pt = new aa(this._pt, C ? N : u, T, v, (w ? Ip(v, w + g) : g) - v, !C && (M === "px" || T === "zIndex") && t.autoRound !== !1 ? VW : rb), this._pt.u = M || 0, E !== M && M !== "%" && (this._pt.b = d, this._pt.r = kW);
          else if (T in u)
            $W.call(this, e, T, d, w ? w + p : p);
          else if (T in e)
            this.add(e, T, d || e[T], w ? w + p : p, i, r);
          else if (T !== "parseTransform") {
            _C(T, p);
            continue;
          }
          C || (T in u ? V.push(T, 0, u[T]) : typeof e[T] == "function" ? V.push(T, 2, e[T]()) : V.push(T, 1, d || e[T])), o.push(T);
        }
      }
    O && VI(this);
  },
  render: function(e, t) {
    if (t.tween._time || !RC())
      for (var n = t._pt; n; )
        n.r(e, n.d), n = n._next;
    else
      t.styles.revert();
  },
  get: su,
  aliases: _l,
  getSetter: function(e, t, n) {
    var i = _l[t];
    return i && i.indexOf(",") < 0 && (t = i), t in _u && t !== oa && (e._gsap.x || su(e, "x")) ? n && ZD === n ? t === "scale" ? YW : JW : (ZD = n || {}) && (t === "scale" ? KW : qW) : e.style && !mC(e.style[t]) ? WW : ~t.indexOf("-") ? XW : bC(e, t);
  },
  core: {
    _removeProperty: yd,
    _getMatrix: DC
  }
};
la.utils.checkPrefix = em;
la.core.getStyleSaver = KI;
(function(s, e, t, n) {
  var i = sa(s + "," + e + "," + t, function(r) {
    _u[r] = 1;
  });
  sa(e, function(r) {
    La.units[r] = "deg", ZI[r] = 1;
  }), _l[i[13]] = s + "," + e, sa(n, function(r) {
    var o = r.split(":");
    _l[o[1]] = i[o[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
sa("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(s) {
  La.units[s] = "px";
});
la.registerPlugin(tU);
var Np = la.registerPlugin(tU) || la;
Np.core.Tween;
function a6(s, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(s, n.key, n);
  }
}
function o6(s, e, t) {
  return e && a6(s.prototype, e), s;
}
/*!
 * Observer 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var jr, gx, wa, Mc, Ec, Op, nU, Wf, ov, iU, fu, Fo, rU, sU = function() {
  return jr || typeof window < "u" && (jr = window.gsap) && jr.registerPlugin && jr;
}, aU = 1, Bp = [], wn = [], Ml = [], lv = Date.now, lb = function(e, t) {
  return t;
}, l6 = function() {
  var e = ov.core, t = e.bridge || {}, n = e._scrollers, i = e._proxies;
  n.push.apply(n, wn), i.push.apply(i, Ml), wn = n, Ml = i, lb = function(o, u) {
    return t[o](u);
  };
}, Lc = function(e, t) {
  return ~Ml.indexOf(e) && Ml[Ml.indexOf(e) + 1][t];
}, uv = function(e) {
  return !!~iU.indexOf(e);
}, Ls = function(e, t, n, i, r) {
  return e.addEventListener(t, n, {
    passive: i !== !1,
    capture: !!r
  });
}, Ds = function(e, t, n, i) {
  return e.removeEventListener(t, n, !!i);
}, Y0 = "scrollLeft", K0 = "scrollTop", ub = function() {
  return fu && fu.isPressed || wn.cache++;
}, Ox = function(e, t) {
  var n = function i(r) {
    if (r || r === 0) {
      aU && (wa.history.scrollRestoration = "manual");
      var o = fu && fu.isPressed;
      r = i.v = Math.round(r) || (fu && fu.iOS ? 1 : 0), e(r), i.cacheID = wn.cache, o && lb("ss", r);
    } else (t || wn.cache !== i.cacheID || lb("ref")) && (i.cacheID = wn.cache, i.v = e());
    return i.v + i.offset;
  };
  return n.offset = 0, e && n;
}, Hs = {
  s: Y0,
  p: "left",
  p2: "Left",
  os: "right",
  os2: "Right",
  d: "width",
  d2: "Width",
  a: "x",
  sc: Ox(function(s) {
    return arguments.length ? wa.scrollTo(s, xr.sc()) : wa.pageXOffset || Mc[Y0] || Ec[Y0] || Op[Y0] || 0;
  })
}, xr = {
  s: K0,
  p: "top",
  p2: "Top",
  os: "bottom",
  os2: "Bottom",
  d: "height",
  d2: "Height",
  a: "y",
  op: Hs,
  sc: Ox(function(s) {
    return arguments.length ? wa.scrollTo(Hs.sc(), s) : wa.pageYOffset || Mc[K0] || Ec[K0] || Op[K0] || 0;
  })
}, ta = function(e, t) {
  return (t && t._ctx && t._ctx.selector || jr.utils.toArray)(e)[0] || (typeof e == "string" && jr.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null);
}, u6 = function(e, t) {
  for (var n = t.length; n--; )
    if (t[n] === e || t[n].contains(e))
      return !0;
  return !1;
}, Hc = function(e, t) {
  var n = t.s, i = t.sc;
  uv(e) && (e = Mc.scrollingElement || Ec);
  var r = wn.indexOf(e), o = i === xr.sc ? 1 : 2;
  !~r && (r = wn.push(e) - 1), wn[r + o] || Ls(e, "scroll", ub);
  var u = wn[r + o], c = u || (wn[r + o] = Ox(Lc(e, n), !0) || (uv(e) ? i : Ox(function(d) {
    return arguments.length ? e[n] = d : e[n];
  })));
  return c.target = e, u || (c.smooth = jr.getProperty(e, "scrollBehavior") === "smooth"), c;
}, cb = function(e, t, n) {
  var i = e, r = e, o = lv(), u = o, c = t || 50, d = Math.max(500, c * 3), p = function(S, T) {
    var E = lv();
    T || E - o > c ? (r = i, i = S, u = o, o = E) : n ? i += S : i = r + (S - r) / (E - u) * (o - u);
  }, g = function() {
    r = i = n ? 0 : i, u = o = 0;
  }, v = function(S) {
    var T = u, E = r, M = lv();
    return (S || S === 0) && S !== i && p(S), o === u || M - u > d ? 0 : (i + (n ? E : -E)) / ((n ? M : o) - T) * 1e3;
  };
  return {
    update: p,
    reset: g,
    getVelocity: v
  };
}, kg = function(e, t) {
  return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e;
}, oL = function(e) {
  var t = Math.max.apply(Math, e), n = Math.min.apply(Math, e);
  return Math.abs(t) >= Math.abs(n) ? t : n;
}, oU = function() {
  ov = jr.core.globals().ScrollTrigger, ov && ov.core && l6();
}, lU = function(e) {
  return jr = e || sU(), !gx && jr && typeof document < "u" && document.body && (wa = window, Mc = document, Ec = Mc.documentElement, Op = Mc.body, iU = [wa, Mc, Ec, Op], jr.utils.clamp, rU = jr.core.context || function() {
  }, Wf = "onpointerenter" in Op ? "pointer" : "mouse", nU = Zi.isTouch = wa.matchMedia && wa.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in wa || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Fo = Zi.eventTypes = ("ontouchstart" in Ec ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Ec ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
    return aU = 0;
  }, 500), oU(), gx = 1), gx;
};
Hs.op = xr;
wn.cache = 0;
var Zi = /* @__PURE__ */ function() {
  function s(t) {
    this.init(t);
  }
  var e = s.prototype;
  return e.init = function(n) {
    gx || lU(jr) || console.warn("Please gsap.registerPlugin(Observer)"), ov || oU();
    var i = n.tolerance, r = n.dragMinimum, o = n.type, u = n.target, c = n.lineHeight, d = n.debounce, p = n.preventDefault, g = n.onStop, v = n.onStopDelay, y = n.ignore, S = n.wheelSpeed, T = n.event, E = n.onDragStart, M = n.onDragEnd, w = n.onDrag, C = n.onPress, D = n.onRelease, N = n.onRight, U = n.onLeft, O = n.onUp, V = n.onDown, L = n.onChangeX, I = n.onChangeY, Y = n.onChange, Q = n.onToggleX, fe = n.onToggleY, j = n.onHover, ie = n.onHoverEnd, re = n.onMove, pe = n.ignoreCheck, J = n.isNormalizer, Z = n.onGestureStart, H = n.onGestureEnd, ue = n.onWheel, Se = n.onEnable, me = n.onDisable, ye = n.onClick, Xe = n.scrollSpeed, Je = n.capture, Ye = n.allowClicks, At = n.lockAxis, Ct = n.onLockAxis;
    this.target = u = ta(u) || Ec, this.vars = n, y && (y = jr.utils.toArray(y)), i = i || 1e-9, r = r || 0, S = S || 1, Xe = Xe || 1, o = o || "wheel,touch,pointer", d = d !== !1, c || (c = parseFloat(wa.getComputedStyle(Op).lineHeight) || 22);
    var pt, mt, ne, we, Ee, He, be, ce = this, nt = 0, X = 0, G = n.passive || !p && n.passive !== !1, le = Hc(u, Hs), Ue = Hc(u, xr), Ve = le(), Oe = Ue(), ct = ~o.indexOf("touch") && !~o.indexOf("pointer") && Fo[0] === "pointerdown", st = uv(u), it = u.ownerDocument || Mc, Lt = [0, 0, 0], zt = [0, 0, 0], ee = 0, Re = function() {
      return ee = lv();
    }, De = function(St, bt) {
      return (ce.event = St) && y && u6(St.target, y) || bt && ct && St.pointerType !== "touch" || pe && pe(St, bt);
    }, Ie = function() {
      ce._vx.reset(), ce._vy.reset(), mt.pause(), g && g(ce);
    }, Qe = function() {
      var St = ce.deltaX = oL(Lt), bt = ce.deltaY = oL(zt), lt = Math.abs(St) >= i, Ot = Math.abs(bt) >= i;
      Y && (lt || Ot) && Y(ce, St, bt, Lt, zt), lt && (N && ce.deltaX > 0 && N(ce), U && ce.deltaX < 0 && U(ce), L && L(ce), Q && ce.deltaX < 0 != nt < 0 && Q(ce), nt = ce.deltaX, Lt[0] = Lt[1] = Lt[2] = 0), Ot && (V && ce.deltaY > 0 && V(ce), O && ce.deltaY < 0 && O(ce), I && I(ce), fe && ce.deltaY < 0 != X < 0 && fe(ce), X = ce.deltaY, zt[0] = zt[1] = zt[2] = 0), (we || ne) && (re && re(ce), ne && (E && ne === 1 && E(ce), w && w(ce), ne = 0), we = !1), He && !(He = !1) && Ct && Ct(ce), Ee && (ue(ce), Ee = !1), pt = 0;
    }, rt = function(St, bt, lt) {
      Lt[lt] += St, zt[lt] += bt, ce._vx.update(St), ce._vy.update(bt), d ? pt || (pt = requestAnimationFrame(Qe)) : Qe();
    }, Fe = function(St, bt) {
      At && !be && (ce.axis = be = Math.abs(St) > Math.abs(bt) ? "x" : "y", He = !0), be !== "y" && (Lt[2] += St, ce._vx.update(St, !0)), be !== "x" && (zt[2] += bt, ce._vy.update(bt, !0)), d ? pt || (pt = requestAnimationFrame(Qe)) : Qe();
    }, Ke = function(St) {
      if (!De(St, 1)) {
        St = kg(St, p);
        var bt = St.clientX, lt = St.clientY, Ot = bt - ce.x, kt = lt - ce.y, en = ce.isDragging;
        ce.x = bt, ce.y = lt, (en || (Ot || kt) && (Math.abs(ce.startX - bt) >= r || Math.abs(ce.startY - lt) >= r)) && (ne = en ? 2 : 1, en || (ce.isDragging = !0), Fe(Ot, kt));
      }
    }, Dt = ce.onPress = function(wt) {
      De(wt, 1) || wt && wt.button || (ce.axis = be = null, mt.pause(), ce.isPressed = !0, wt = kg(wt), nt = X = 0, ce.startX = ce.x = wt.clientX, ce.startY = ce.y = wt.clientY, ce._vx.reset(), ce._vy.reset(), Ls(J ? u : it, Fo[1], Ke, G, !0), ce.deltaX = ce.deltaY = 0, C && C(ce));
    }, We = ce.onRelease = function(wt) {
      if (!De(wt, 1)) {
        Ds(J ? u : it, Fo[1], Ke, !0);
        var St = !isNaN(ce.y - ce.startY), bt = ce.isDragging, lt = bt && (Math.abs(ce.x - ce.startX) > 3 || Math.abs(ce.y - ce.startY) > 3), Ot = kg(wt);
        !lt && St && (ce._vx.reset(), ce._vy.reset(), p && Ye && jr.delayedCall(0.08, function() {
          if (lv() - ee > 300 && !wt.defaultPrevented) {
            if (wt.target.click)
              wt.target.click();
            else if (it.createEvent) {
              var kt = it.createEvent("MouseEvents");
              kt.initMouseEvent("click", !0, !0, wa, 1, Ot.screenX, Ot.screenY, Ot.clientX, Ot.clientY, !1, !1, !1, !1, 0, null), wt.target.dispatchEvent(kt);
            }
          }
        })), ce.isDragging = ce.isGesturing = ce.isPressed = !1, g && bt && !J && mt.restart(!0), ne && Qe(), M && bt && M(ce), D && D(ce, lt);
      }
    }, Pe = function(St) {
      return St.touches && St.touches.length > 1 && (ce.isGesturing = !0) && Z(St, ce.isDragging);
    }, ae = function() {
      return (ce.isGesturing = !1) || H(ce);
    }, et = function(St) {
      if (!De(St)) {
        var bt = le(), lt = Ue();
        rt((bt - Ve) * Xe, (lt - Oe) * Xe, 1), Ve = bt, Oe = lt, g && mt.restart(!0);
      }
    }, at = function(St) {
      if (!De(St)) {
        St = kg(St, p), ue && (Ee = !0);
        var bt = (St.deltaMode === 1 ? c : St.deltaMode === 2 ? wa.innerHeight : 1) * S;
        rt(St.deltaX * bt, St.deltaY * bt, 0), g && !J && mt.restart(!0);
      }
    }, Wt = function(St) {
      if (!De(St)) {
        var bt = St.clientX, lt = St.clientY, Ot = bt - ce.x, kt = lt - ce.y;
        ce.x = bt, ce.y = lt, we = !0, g && mt.restart(!0), (Ot || kt) && Fe(Ot, kt);
      }
    }, ot = function(St) {
      ce.event = St, j(ce);
    }, an = function(St) {
      ce.event = St, ie(ce);
    }, un = function(St) {
      return De(St) || kg(St, p) && ye(ce);
    };
    mt = ce._dc = jr.delayedCall(v || 0.25, Ie).pause(), ce.deltaX = ce.deltaY = 0, ce._vx = cb(0, 50, !0), ce._vy = cb(0, 50, !0), ce.scrollX = le, ce.scrollY = Ue, ce.isDragging = ce.isGesturing = ce.isPressed = !1, rU(this), ce.enable = function(wt) {
      return ce.isEnabled || (Ls(st ? it : u, "scroll", ub), o.indexOf("scroll") >= 0 && Ls(st ? it : u, "scroll", et, G, Je), o.indexOf("wheel") >= 0 && Ls(u, "wheel", at, G, Je), (o.indexOf("touch") >= 0 && nU || o.indexOf("pointer") >= 0) && (Ls(u, Fo[0], Dt, G, Je), Ls(it, Fo[2], We), Ls(it, Fo[3], We), Ye && Ls(u, "click", Re, !0, !0), ye && Ls(u, "click", un), Z && Ls(it, "gesturestart", Pe), H && Ls(it, "gestureend", ae), j && Ls(u, Wf + "enter", ot), ie && Ls(u, Wf + "leave", an), re && Ls(u, Wf + "move", Wt)), ce.isEnabled = !0, ce.isDragging = ce.isGesturing = ce.isPressed = we = ne = !1, ce._vx.reset(), ce._vy.reset(), Ve = le(), Oe = Ue(), wt && wt.type && Dt(wt), Se && Se(ce)), ce;
    }, ce.disable = function() {
      ce.isEnabled && (Bp.filter(function(wt) {
        return wt !== ce && uv(wt.target);
      }).length || Ds(st ? it : u, "scroll", ub), ce.isPressed && (ce._vx.reset(), ce._vy.reset(), Ds(J ? u : it, Fo[1], Ke, !0)), Ds(st ? it : u, "scroll", et, Je), Ds(u, "wheel", at, Je), Ds(u, Fo[0], Dt, Je), Ds(it, Fo[2], We), Ds(it, Fo[3], We), Ds(u, "click", Re, !0), Ds(u, "click", un), Ds(it, "gesturestart", Pe), Ds(it, "gestureend", ae), Ds(u, Wf + "enter", ot), Ds(u, Wf + "leave", an), Ds(u, Wf + "move", Wt), ce.isEnabled = ce.isPressed = ce.isDragging = !1, me && me(ce));
    }, ce.kill = ce.revert = function() {
      ce.disable();
      var wt = Bp.indexOf(ce);
      wt >= 0 && Bp.splice(wt, 1), fu === ce && (fu = 0);
    }, Bp.push(ce), J && uv(u) && (fu = ce), ce.enable(T);
  }, o6(s, [{
    key: "velocityX",
    get: function() {
      return this._vx.getVelocity();
    }
  }, {
    key: "velocityY",
    get: function() {
      return this._vy.getVelocity();
    }
  }]), s;
}();
Zi.version = "3.13.0";
Zi.create = function(s) {
  return new Zi(s);
};
Zi.register = lU;
Zi.getAll = function() {
  return Bp.slice();
};
Zi.getById = function(s) {
  return Bp.filter(function(e) {
    return e.vars.id === s;
  })[0];
};
sU() && jr.registerPlugin(Zi);
/*!
 * ScrollTrigger 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var Gt, Sp, Cn, ui, Ta, qn, LC, Hx, Hv, cv, Yg, q0, ms, SS, fb, Us, lL, uL, Ap, uU, KE, cU, Is, db, fU, dU, vc, hb, PC, Hp, IC, zx, pb, qE, j0 = 1, gs = Date.now, jE = gs(), ho = 0, Kg = 0, cL = function(e, t, n) {
  var i = Ma(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
  return n["_" + t + "Clamp"] = i, i ? e.substr(6, e.length - 7) : e;
}, fL = function(e, t) {
  return t && (!Ma(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e;
}, c6 = function s() {
  return Kg && requestAnimationFrame(s);
}, dL = function() {
  return SS = 1;
}, hL = function() {
  return SS = 0;
}, ml = function(e) {
  return e;
}, qg = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, hU = function() {
  return typeof window < "u";
}, pU = function() {
  return Gt || hU() && (Gt = window.gsap) && Gt.registerPlugin && Gt;
}, xd = function(e) {
  return !!~LC.indexOf(e);
}, mU = function(e) {
  return (e === "Height" ? IC : Cn["inner" + e]) || Ta["client" + e] || qn["client" + e];
}, gU = function(e) {
  return Lc(e, "getBoundingClientRect") || (xd(e) ? function() {
    return Sx.width = Cn.innerWidth, Sx.height = IC, Sx;
  } : function() {
    return ou(e);
  });
}, f6 = function(e, t, n) {
  var i = n.d, r = n.d2, o = n.a;
  return (o = Lc(e, "getBoundingClientRect")) ? function() {
    return o()[i];
  } : function() {
    return (t ? mU(r) : e["client" + r]) || 0;
  };
}, d6 = function(e, t) {
  return !t || ~Ml.indexOf(e) ? gU(e) : function() {
    return Sx;
  };
}, yl = function(e, t) {
  var n = t.s, i = t.d2, r = t.d, o = t.a;
  return Math.max(0, (n = "scroll" + i) && (o = Lc(e, n)) ? o() - gU(e)()[r] : xd(e) ? (Ta[n] || qn[n]) - mU(i) : e[n] - e["offset" + i]);
}, Q0 = function(e, t) {
  for (var n = 0; n < Ap.length; n += 3)
    (!t || ~t.indexOf(Ap[n + 1])) && e(Ap[n], Ap[n + 1], Ap[n + 2]);
}, Ma = function(e) {
  return typeof e == "string";
}, _s = function(e) {
  return typeof e == "function";
}, jg = function(e) {
  return typeof e == "number";
}, Xf = function(e) {
  return typeof e == "object";
}, Vg = function(e, t, n) {
  return e && e.progress(t ? 0 : 1) && n && e.pause();
}, QE = function(e, t) {
  if (e.enabled) {
    var n = e._ctx ? e._ctx.add(function() {
      return t(e);
    }) : t(e);
    n && n.totalTime && (e.callbackAnimation = n);
  }
}, vp = Math.abs, vU = "left", _U = "top", UC = "right", FC = "bottom", cd = "width", fd = "height", fv = "Right", dv = "Left", hv = "Top", pv = "Bottom", ar = "padding", oo = "margin", tm = "Width", NC = "Height", yr = "px", lo = function(e) {
  return Cn.getComputedStyle(e);
}, h6 = function(e) {
  var t = lo(e).position;
  e.style.position = t === "absolute" || t === "fixed" ? t : "relative";
}, pL = function(e, t) {
  for (var n in t)
    n in e || (e[n] = t[n]);
  return e;
}, ou = function(e, t) {
  var n = t && lo(e)[fb] !== "matrix(1, 0, 0, 1, 0, 0)" && Gt.to(e, {
    x: 0,
    y: 0,
    xPercent: 0,
    yPercent: 0,
    rotation: 0,
    rotationX: 0,
    rotationY: 0,
    scale: 1,
    skewX: 0,
    skewY: 0
  }).progress(1), i = e.getBoundingClientRect();
  return n && n.progress(0).kill(), i;
}, Gx = function(e, t) {
  var n = t.d2;
  return e["offset" + n] || e["client" + n] || 0;
}, yU = function(e) {
  var t = [], n = e.labels, i = e.duration(), r;
  for (r in n)
    t.push(n[r] / i);
  return t;
}, p6 = function(e) {
  return function(t) {
    return Gt.utils.snap(yU(e), t);
  };
}, OC = function(e) {
  var t = Gt.utils.snap(e), n = Array.isArray(e) && e.slice(0).sort(function(i, r) {
    return i - r;
  });
  return n ? function(i, r, o) {
    o === void 0 && (o = 1e-3);
    var u;
    if (!r)
      return t(i);
    if (r > 0) {
      for (i -= o, u = 0; u < n.length; u++)
        if (n[u] >= i)
          return n[u];
      return n[u - 1];
    } else
      for (u = n.length, i += o; u--; )
        if (n[u] <= i)
          return n[u];
    return n[0];
  } : function(i, r, o) {
    o === void 0 && (o = 1e-3);
    var u = t(i);
    return !r || Math.abs(u - i) < o || u - i < 0 == r < 0 ? u : t(r < 0 ? i - e : i + e);
  };
}, m6 = function(e) {
  return function(t, n) {
    return OC(yU(e))(t, n.direction);
  };
}, Z0 = function(e, t, n, i) {
  return n.split(",").forEach(function(r) {
    return e(t, r, i);
  });
}, Lr = function(e, t, n, i, r) {
  return e.addEventListener(t, n, {
    passive: !i,
    capture: !!r
  });
}, Dr = function(e, t, n, i) {
  return e.removeEventListener(t, n, !!i);
}, $0 = function(e, t, n) {
  n = n && n.wheelHandler, n && (e(t, "wheel", n), e(t, "touchmove", n));
}, mL = {
  startColor: "green",
  endColor: "red",
  indent: 0,
  fontSize: "16px",
  fontWeight: "normal"
}, ex = {
  toggleActions: "play",
  anticipatePin: 0
}, kx = {
  top: 0,
  left: 0,
  center: 0.5,
  bottom: 1,
  right: 1
}, vx = function(e, t) {
  if (Ma(e)) {
    var n = e.indexOf("="), i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
    ~n && (e.indexOf("%") > n && (i *= t / 100), e = e.substr(0, n - 1)), e = i + (e in kx ? kx[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0);
  }
  return e;
}, tx = function(e, t, n, i, r, o, u, c) {
  var d = r.startColor, p = r.endColor, g = r.fontSize, v = r.indent, y = r.fontWeight, S = ui.createElement("div"), T = xd(n) || Lc(n, "pinType") === "fixed", E = e.indexOf("scroller") !== -1, M = T ? qn : n, w = e.indexOf("start") !== -1, C = w ? d : p, D = "border-color:" + C + ";font-size:" + g + ";color:" + C + ";font-weight:" + y + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
  return D += "position:" + ((E || c) && T ? "fixed;" : "absolute;"), (E || c || !T) && (D += (i === xr ? UC : FC) + ":" + (o + parseFloat(v)) + "px;"), u && (D += "box-sizing:border-box;text-align:left;width:" + u.offsetWidth + "px;"), S._isStart = w, S.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), S.style.cssText = D, S.innerText = t || t === 0 ? e + "-" + t : e, M.children[0] ? M.insertBefore(S, M.children[0]) : M.appendChild(S), S._offset = S["offset" + i.op.d2], _x(S, 0, i, w), S;
}, _x = function(e, t, n, i) {
  var r = {
    display: "block"
  }, o = n[i ? "os2" : "p2"], u = n[i ? "p2" : "os2"];
  e._isFlipped = i, r[n.a + "Percent"] = i ? -100 : 0, r[n.a] = i ? "1px" : 0, r["border" + o + tm] = 1, r["border" + u + tm] = 0, r[n.p] = t + "px", Gt.set(e, r);
}, Tn = [], mb = {}, zv, gL = function() {
  return gs() - ho > 34 && (zv || (zv = requestAnimationFrame(pu)));
}, _p = function() {
  (!Is || !Is.isPressed || Is.startX > qn.clientWidth) && (wn.cache++, Is ? zv || (zv = requestAnimationFrame(pu)) : pu(), ho || Ad("scrollStart"), ho = gs());
}, ZE = function() {
  dU = Cn.innerWidth, fU = Cn.innerHeight;
}, Qg = function(e) {
  wn.cache++, (e === !0 || !ms && !cU && !ui.fullscreenElement && !ui.webkitFullscreenElement && (!db || dU !== Cn.innerWidth || Math.abs(Cn.innerHeight - fU) > Cn.innerHeight * 0.25)) && Hx.restart(!0);
}, Sd = {}, g6 = [], xU = function s() {
  return Dr(Rn, "scrollEnd", s) || ed(!0);
}, Ad = function(e) {
  return Sd[e] && Sd[e].map(function(t) {
    return t();
  }) || g6;
}, Aa = [], SU = function(e) {
  for (var t = 0; t < Aa.length; t += 5)
    (!e || Aa[t + 4] && Aa[t + 4].query === e) && (Aa[t].style.cssText = Aa[t + 1], Aa[t].getBBox && Aa[t].setAttribute("transform", Aa[t + 2] || ""), Aa[t + 3].uncache = 1);
}, HC = function(e, t) {
  var n;
  for (Us = 0; Us < Tn.length; Us++)
    n = Tn[Us], n && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0));
  zx = !0, t && SU(t), t || Ad("revert");
}, AU = function(e, t) {
  wn.cache++, (t || !Fs) && wn.forEach(function(n) {
    return _s(n) && n.cacheID++ && (n.rec = 0);
  }), Ma(e) && (Cn.history.scrollRestoration = PC = e);
}, Fs, dd = 0, vL, v6 = function() {
  if (vL !== dd) {
    var e = vL = dd;
    requestAnimationFrame(function() {
      return e === dd && ed(!0);
    });
  }
}, MU = function() {
  qn.appendChild(Hp), IC = !Is && Hp.offsetHeight || Cn.innerHeight, qn.removeChild(Hp);
}, _L = function(e) {
  return Hv(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
    return t.style.display = e ? "none" : "block";
  });
}, ed = function(e, t) {
  if (Ta = ui.documentElement, qn = ui.body, LC = [Cn, ui, Ta, qn], ho && !e && !zx) {
    Lr(Rn, "scrollEnd", xU);
    return;
  }
  MU(), Fs = Rn.isRefreshing = !0, wn.forEach(function(i) {
    return _s(i) && ++i.cacheID && (i.rec = i());
  });
  var n = Ad("refreshInit");
  uU && Rn.sort(), t || HC(), wn.forEach(function(i) {
    _s(i) && (i.smooth && (i.target.style.scrollBehavior = "auto"), i(0));
  }), Tn.slice(0).forEach(function(i) {
    return i.refresh();
  }), zx = !1, Tn.forEach(function(i) {
    if (i._subPinOffset && i.pin) {
      var r = i.vars.horizontal ? "offsetWidth" : "offsetHeight", o = i.pin[r];
      i.revert(!0, 1), i.adjustPinSpacing(i.pin[r] - o), i.refresh();
    }
  }), pb = 1, _L(!0), Tn.forEach(function(i) {
    var r = yl(i.scroller, i._dir), o = i.vars.end === "max" || i._endClamp && i.end > r, u = i._startClamp && i.start >= r;
    (o || u) && i.setPositions(u ? r - 1 : i.start, o ? Math.max(u ? r : i.start + 1, r) : i.end, !0);
  }), _L(!1), pb = 0, n.forEach(function(i) {
    return i && i.render && i.render(-1);
  }), wn.forEach(function(i) {
    _s(i) && (i.smooth && requestAnimationFrame(function() {
      return i.target.style.scrollBehavior = "smooth";
    }), i.rec && i(i.rec));
  }), AU(PC, 1), Hx.pause(), dd++, Fs = 2, pu(2), Tn.forEach(function(i) {
    return _s(i.vars.onRefresh) && i.vars.onRefresh(i);
  }), Fs = Rn.isRefreshing = !1, Ad("refresh");
}, gb = 0, yx = 1, mv, pu = function(e) {
  if (e === 2 || !Fs && !zx) {
    Rn.isUpdating = !0, mv && mv.update(0);
    var t = Tn.length, n = gs(), i = n - jE >= 50, r = t && Tn[0].scroll();
    if (yx = gb > r ? -1 : 1, Fs || (gb = r), i && (ho && !SS && n - ho > 200 && (ho = 0, Ad("scrollEnd")), Yg = jE, jE = n), yx < 0) {
      for (Us = t; Us-- > 0; )
        Tn[Us] && Tn[Us].update(0, i);
      yx = 1;
    } else
      for (Us = 0; Us < t; Us++)
        Tn[Us] && Tn[Us].update(0, i);
    Rn.isUpdating = !1;
  }
  zv = 0;
}, vb = [vU, _U, FC, UC, oo + pv, oo + fv, oo + hv, oo + dv, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], xx = vb.concat([cd, fd, "boxSizing", "max" + tm, "max" + NC, "position", oo, ar, ar + hv, ar + fv, ar + pv, ar + dv]), _6 = function(e, t, n) {
  zp(n);
  var i = e._gsap;
  if (i.spacerIsNative)
    zp(i.spacerState);
  else if (e._gsap.swappedIn) {
    var r = t.parentNode;
    r && (r.insertBefore(e, t), r.removeChild(t));
  }
  e._gsap.swappedIn = !1;
}, $E = function(e, t, n, i) {
  if (!e._gsap.swappedIn) {
    for (var r = vb.length, o = t.style, u = e.style, c; r--; )
      c = vb[r], o[c] = n[c];
    o.position = n.position === "absolute" ? "absolute" : "relative", n.display === "inline" && (o.display = "inline-block"), u[FC] = u[UC] = "auto", o.flexBasis = n.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[cd] = Gx(e, Hs) + yr, o[fd] = Gx(e, xr) + yr, o[ar] = u[oo] = u[_U] = u[vU] = "0", zp(i), u[cd] = u["max" + tm] = n[cd], u[fd] = u["max" + NC] = n[fd], u[ar] = n[ar], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0;
  }
}, y6 = /([A-Z])/g, zp = function(e) {
  if (e) {
    var t = e.t.style, n = e.length, i = 0, r, o;
    for ((e.t._gsap || Gt.core.getCache(e.t)).uncache = 1; i < n; i += 2)
      o = e[i + 1], r = e[i], o ? t[r] = o : t[r] && t.removeProperty(r.replace(y6, "-$1").toLowerCase());
  }
}, nx = function(e) {
  for (var t = xx.length, n = e.style, i = [], r = 0; r < t; r++)
    i.push(xx[r], n[xx[r]]);
  return i.t = e, i;
}, x6 = function(e, t, n) {
  for (var i = [], r = e.length, o = n ? 8 : 0, u; o < r; o += 2)
    u = e[o], i.push(u, u in t ? t[u] : e[o + 1]);
  return i.t = e.t, i;
}, Sx = {
  left: 0,
  top: 0
}, yL = function(e, t, n, i, r, o, u, c, d, p, g, v, y, S) {
  _s(e) && (e = e(c)), Ma(e) && e.substr(0, 3) === "max" && (e = v + (e.charAt(4) === "=" ? vx("0" + e.substr(3), n) : 0));
  var T = y ? y.time() : 0, E, M, w;
  if (y && y.seek(0), isNaN(e) || (e = +e), jg(e))
    y && (e = Gt.utils.mapRange(y.scrollTrigger.start, y.scrollTrigger.end, 0, v, e)), u && _x(u, n, i, !0);
  else {
    _s(t) && (t = t(c));
    var C = (e || "0").split(" "), D, N, U, O;
    w = ta(t, c) || qn, D = ou(w) || {}, (!D || !D.left && !D.top) && lo(w).display === "none" && (O = w.style.display, w.style.display = "block", D = ou(w), O ? w.style.display = O : w.style.removeProperty("display")), N = vx(C[0], D[i.d]), U = vx(C[1] || "0", n), e = D[i.p] - d[i.p] - p + N + r - U, u && _x(u, U, i, n - U < 20 || u._isStart && U > 20), n -= n - U;
  }
  if (S && (c[S] = e || -1e-3, e < 0 && (e = 0)), o) {
    var V = e + n, L = o._isStart;
    E = "scroll" + i.d2, _x(o, V, i, L && V > 20 || !L && (g ? Math.max(qn[E], Ta[E]) : o.parentNode[E]) <= V + 1), g && (d = ou(u), g && (o.style[i.op.p] = d[i.op.p] - i.op.m - o._offset + yr));
  }
  return y && w && (E = ou(w), y.seek(v), M = ou(w), y._caScrollDist = E[i.p] - M[i.p], e = e / y._caScrollDist * v), y && y.seek(T), y ? e : Math.round(e);
}, S6 = /(webkit|moz|length|cssText|inset)/i, xL = function(e, t, n, i) {
  if (e.parentNode !== t) {
    var r = e.style, o, u;
    if (t === qn) {
      e._stOrig = r.cssText, u = lo(e);
      for (o in u)
        !+o && !S6.test(o) && u[o] && typeof r[o] == "string" && o !== "0" && (r[o] = u[o]);
      r.top = n, r.left = i;
    } else
      r.cssText = e._stOrig;
    Gt.core.getCache(e).uncache = 1, t.appendChild(e);
  }
}, EU = function(e, t, n) {
  var i = t, r = i;
  return function(o) {
    var u = Math.round(e());
    return u !== i && u !== r && Math.abs(u - i) > 3 && Math.abs(u - r) > 3 && (o = u, n && n()), r = i, i = Math.round(o), i;
  };
}, ix = function(e, t, n) {
  var i = {};
  i[t.p] = "+=" + n, Gt.set(e, i);
}, SL = function(e, t) {
  var n = Hc(e, t), i = "_scroll" + t.p2, r = function o(u, c, d, p, g) {
    var v = o.tween, y = c.onComplete, S = {};
    d = d || n();
    var T = EU(n, d, function() {
      v.kill(), o.tween = 0;
    });
    return g = p && g || 0, p = p || u - d, v && v.kill(), c[i] = u, c.inherit = !1, c.modifiers = S, S[i] = function() {
      return T(d + p * v.ratio + g * v.ratio * v.ratio);
    }, c.onUpdate = function() {
      wn.cache++, o.tween && pu();
    }, c.onComplete = function() {
      o.tween = 0, y && y.call(v);
    }, v = o.tween = Gt.to(e, c), v;
  };
  return e[i] = n, n.wheelHandler = function() {
    return r.tween && r.tween.kill() && (r.tween = 0);
  }, Lr(e, "wheel", n.wheelHandler), Rn.isTouch && Lr(e, "touchmove", n.wheelHandler), r;
}, Rn = /* @__PURE__ */ function() {
  function s(t, n) {
    Sp || s.register(Gt) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), hb(this), this.init(t, n);
  }
  var e = s.prototype;
  return e.init = function(n, i) {
    if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !Kg) {
      this.update = this.refresh = this.kill = ml;
      return;
    }
    n = pL(Ma(n) || jg(n) || n.nodeType ? {
      trigger: n
    } : n, ex);
    var r = n, o = r.onUpdate, u = r.toggleClass, c = r.id, d = r.onToggle, p = r.onRefresh, g = r.scrub, v = r.trigger, y = r.pin, S = r.pinSpacing, T = r.invalidateOnRefresh, E = r.anticipatePin, M = r.onScrubComplete, w = r.onSnapComplete, C = r.once, D = r.snap, N = r.pinReparent, U = r.pinSpacer, O = r.containerAnimation, V = r.fastScrollEnd, L = r.preventOverlaps, I = n.horizontal || n.containerAnimation && n.horizontal !== !1 ? Hs : xr, Y = !g && g !== 0, Q = ta(n.scroller || Cn), fe = Gt.core.getCache(Q), j = xd(Q), ie = ("pinType" in n ? n.pinType : Lc(Q, "pinType") || j && "fixed") === "fixed", re = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack], pe = Y && n.toggleActions.split(" "), J = "markers" in n ? n.markers : ex.markers, Z = j ? 0 : parseFloat(lo(Q)["border" + I.p2 + tm]) || 0, H = this, ue = n.onRefreshInit && function() {
      return n.onRefreshInit(H);
    }, Se = f6(Q, j, I), me = d6(Q, j), ye = 0, Xe = 0, Je = 0, Ye = Hc(Q, I), At, Ct, pt, mt, ne, we, Ee, He, be, ce, nt, X, G, le, Ue, Ve, Oe, ct, st, it, Lt, zt, ee, Re, De, Ie, Qe, rt, Fe, Ke, Dt, We, Pe, ae, et, at, Wt, ot, an;
    if (H._startClamp = H._endClamp = !1, H._dir = I, E *= 45, H.scroller = Q, H.scroll = O ? O.time.bind(O) : Ye, mt = Ye(), H.vars = n, i = i || n.animation, "refreshPriority" in n && (uU = 1, n.refreshPriority === -9999 && (mv = H)), fe.tweenScroll = fe.tweenScroll || {
      top: SL(Q, xr),
      left: SL(Q, Hs)
    }, H.tweenTo = At = fe.tweenScroll[I.p], H.scrubDuration = function(lt) {
      Pe = jg(lt) && lt, Pe ? We ? We.duration(lt) : We = Gt.to(i, {
        ease: "expo",
        totalProgress: "+=0",
        inherit: !1,
        duration: Pe,
        paused: !0,
        onComplete: function() {
          return M && M(H);
        }
      }) : (We && We.progress(1).kill(), We = 0);
    }, i && (i.vars.lazy = !1, i._initted && !H.isReverted || i.vars.immediateRender !== !1 && n.immediateRender !== !1 && i.duration() && i.render(0, !0, !0), H.animation = i.pause(), i.scrollTrigger = H, H.scrubDuration(g), Ke = 0, c || (c = i.vars.id)), D && ((!Xf(D) || D.push) && (D = {
      snapTo: D
    }), "scrollBehavior" in qn.style && Gt.set(j ? [qn, Ta] : Q, {
      scrollBehavior: "auto"
    }), wn.forEach(function(lt) {
      return _s(lt) && lt.target === (j ? ui.scrollingElement || Ta : Q) && (lt.smooth = !1);
    }), pt = _s(D.snapTo) ? D.snapTo : D.snapTo === "labels" ? p6(i) : D.snapTo === "labelsDirectional" ? m6(i) : D.directional !== !1 ? function(lt, Ot) {
      return OC(D.snapTo)(lt, gs() - Xe < 500 ? 0 : Ot.direction);
    } : Gt.utils.snap(D.snapTo), ae = D.duration || {
      min: 0.1,
      max: 2
    }, ae = Xf(ae) ? cv(ae.min, ae.max) : cv(ae, ae), et = Gt.delayedCall(D.delay || Pe / 2 || 0.1, function() {
      var lt = Ye(), Ot = gs() - Xe < 500, kt = At.tween;
      if ((Ot || Math.abs(H.getVelocity()) < 10) && !kt && !SS && ye !== lt) {
        var en = (lt - we) / le, Vn = i && !Y ? i.totalProgress() : en, Yt = Ot ? 0 : (Vn - Dt) / (gs() - Yg) * 1e3 || 0, te = Gt.utils.clamp(-en, 1 - en, vp(Yt / 2) * Yt / 0.185), ze = en + (D.inertia === !1 ? 0 : te), tt, gt, Ht = D, tn = Ht.onStart, k = Ht.onInterrupt, se = Ht.onComplete;
        if (tt = pt(ze, H), jg(tt) || (tt = ze), gt = Math.max(0, Math.round(we + tt * le)), lt <= Ee && lt >= we && gt !== lt) {
          if (kt && !kt._initted && kt.data <= vp(gt - lt))
            return;
          D.inertia === !1 && (te = tt - en), At(gt, {
            duration: ae(vp(Math.max(vp(ze - Vn), vp(tt - Vn)) * 0.185 / Yt / 0.05 || 0)),
            ease: D.ease || "power3",
            data: vp(gt - lt),
            // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
            onInterrupt: function() {
              return et.restart(!0) && k && k(H);
            },
            onComplete: function() {
              H.update(), ye = Ye(), i && !Y && (We ? We.resetTo("totalProgress", tt, i._tTime / i._tDur) : i.progress(tt)), Ke = Dt = i && !Y ? i.totalProgress() : H.progress, w && w(H), se && se(H);
            }
          }, lt, te * le, gt - lt - te * le), tn && tn(H, At.tween);
        }
      } else H.isActive && ye !== lt && et.restart(!0);
    }).pause()), c && (mb[c] = H), v = H.trigger = ta(v || y !== !0 && y), an = v && v._gsap && v._gsap.stRevert, an && (an = an(H)), y = y === !0 ? v : ta(y), Ma(u) && (u = {
      targets: v,
      className: u
    }), y && (S === !1 || S === oo || (S = !S && y.parentNode && y.parentNode.style && lo(y.parentNode).display === "flex" ? !1 : ar), H.pin = y, Ct = Gt.core.getCache(y), Ct.spacer ? Ue = Ct.pinState : (U && (U = ta(U), U && !U.nodeType && (U = U.current || U.nativeElement), Ct.spacerIsNative = !!U, U && (Ct.spacerState = nx(U))), Ct.spacer = ct = U || ui.createElement("div"), ct.classList.add("pin-spacer"), c && ct.classList.add("pin-spacer-" + c), Ct.pinState = Ue = nx(y)), n.force3D !== !1 && Gt.set(y, {
      force3D: !0
    }), H.spacer = ct = Ct.spacer, Fe = lo(y), Re = Fe[S + I.os2], it = Gt.getProperty(y), Lt = Gt.quickSetter(y, I.a, yr), $E(y, ct, Fe), Oe = nx(y)), J) {
      X = Xf(J) ? pL(J, mL) : mL, ce = tx("scroller-start", c, Q, I, X, 0), nt = tx("scroller-end", c, Q, I, X, 0, ce), st = ce["offset" + I.op.d2];
      var un = ta(Lc(Q, "content") || Q);
      He = this.markerStart = tx("start", c, un, I, X, st, 0, O), be = this.markerEnd = tx("end", c, un, I, X, st, 0, O), O && (ot = Gt.quickSetter([He, be], I.a, yr)), !ie && !(Ml.length && Lc(Q, "fixedMarkers") === !0) && (h6(j ? qn : Q), Gt.set([ce, nt], {
        force3D: !0
      }), Ie = Gt.quickSetter(ce, I.a, yr), rt = Gt.quickSetter(nt, I.a, yr));
    }
    if (O) {
      var wt = O.vars.onUpdate, St = O.vars.onUpdateParams;
      O.eventCallback("onUpdate", function() {
        H.update(0, 0, 1), wt && wt.apply(O, St || []);
      });
    }
    if (H.previous = function() {
      return Tn[Tn.indexOf(H) - 1];
    }, H.next = function() {
      return Tn[Tn.indexOf(H) + 1];
    }, H.revert = function(lt, Ot) {
      if (!Ot)
        return H.kill(!0);
      var kt = lt !== !1 || !H.enabled, en = ms;
      kt !== H.isReverted && (kt && (at = Math.max(Ye(), H.scroll.rec || 0), Je = H.progress, Wt = i && i.progress()), He && [He, be, ce, nt].forEach(function(Vn) {
        return Vn.style.display = kt ? "none" : "block";
      }), kt && (ms = H, H.update(kt)), y && (!N || !H.isActive) && (kt ? _6(y, ct, Ue) : $E(y, ct, lo(y), De)), kt || H.update(kt), ms = en, H.isReverted = kt);
    }, H.refresh = function(lt, Ot, kt, en) {
      if (!((ms || !H.enabled) && !Ot)) {
        if (y && lt && ho) {
          Lr(s, "scrollEnd", xU);
          return;
        }
        !Fs && ue && ue(H), ms = H, At.tween && !kt && (At.tween.kill(), At.tween = 0), We && We.pause(), T && i && (i.revert({
          kill: !1
        }).invalidate(), i.getChildren && i.getChildren(!0, !0, !1).forEach(function(ht) {
          return ht.vars.immediateRender && ht.render(0, !0, !0);
        })), H.isReverted || H.revert(!0, !0), H._subPinOffset = !1;
        var Vn = Se(), Yt = me(), te = O ? O.duration() : yl(Q, I), ze = le <= 0.01 || !le, tt = 0, gt = en || 0, Ht = Xf(kt) ? kt.end : n.end, tn = n.endTrigger || v, k = Xf(kt) ? kt.start : n.start || (n.start === 0 || !v ? 0 : y ? "0 0" : "0 100%"), se = H.pinnedContainer = n.pinnedContainer && ta(n.pinnedContainer, H), _e = v && Math.max(0, Tn.indexOf(H)) || 0, ge = _e, he, je, Rt, Ft, vt, It, Xt, $t, Kn, ai, bn, ti, Qt;
        for (J && Xf(kt) && (ti = Gt.getProperty(ce, I.p), Qt = Gt.getProperty(nt, I.p)); ge-- > 0; )
          It = Tn[ge], It.end || It.refresh(0, 1) || (ms = H), Xt = It.pin, Xt && (Xt === v || Xt === y || Xt === se) && !It.isReverted && (ai || (ai = []), ai.unshift(It), It.revert(!0, !0)), It !== Tn[ge] && (_e--, ge--);
        for (_s(k) && (k = k(H)), k = cL(k, "start", H), we = yL(k, v, Vn, I, Ye(), He, ce, H, Yt, Z, ie, te, O, H._startClamp && "_startClamp") || (y ? -1e-3 : 0), _s(Ht) && (Ht = Ht(H)), Ma(Ht) && !Ht.indexOf("+=") && (~Ht.indexOf(" ") ? Ht = (Ma(k) ? k.split(" ")[0] : "") + Ht : (tt = vx(Ht.substr(2), Vn), Ht = Ma(k) ? k : (O ? Gt.utils.mapRange(0, O.duration(), O.scrollTrigger.start, O.scrollTrigger.end, we) : we) + tt, tn = v)), Ht = cL(Ht, "end", H), Ee = Math.max(we, yL(Ht || (tn ? "100% 0" : te), tn, Vn, I, Ye() + tt, be, nt, H, Yt, Z, ie, te, O, H._endClamp && "_endClamp")) || -1e-3, tt = 0, ge = _e; ge--; )
          It = Tn[ge], Xt = It.pin, Xt && It.start - It._pinPush <= we && !O && It.end > 0 && (he = It.end - (H._startClamp ? Math.max(0, It.start) : It.start), (Xt === v && It.start - It._pinPush < we || Xt === se) && isNaN(k) && (tt += he * (1 - It.progress)), Xt === y && (gt += he));
        if (we += tt, Ee += tt, H._startClamp && (H._startClamp += tt), H._endClamp && !Fs && (H._endClamp = Ee || -1e-3, Ee = Math.min(Ee, yl(Q, I))), le = Ee - we || (we -= 0.01) && 1e-3, ze && (Je = Gt.utils.clamp(0, 1, Gt.utils.normalize(we, Ee, at))), H._pinPush = gt, He && tt && (he = {}, he[I.a] = "+=" + tt, se && (he[I.p] = "-=" + Ye()), Gt.set([He, be], he)), y && !(pb && H.end >= yl(Q, I)))
          he = lo(y), Ft = I === xr, Rt = Ye(), zt = parseFloat(it(I.a)) + gt, !te && Ee > 1 && (bn = (j ? ui.scrollingElement || Ta : Q).style, bn = {
            style: bn,
            value: bn["overflow" + I.a.toUpperCase()]
          }, j && lo(qn)["overflow" + I.a.toUpperCase()] !== "scroll" && (bn.style["overflow" + I.a.toUpperCase()] = "scroll")), $E(y, ct, he), Oe = nx(y), je = ou(y, !0), $t = ie && Hc(Q, Ft ? Hs : xr)(), S ? (De = [S + I.os2, le + gt + yr], De.t = ct, ge = S === ar ? Gx(y, I) + le + gt : 0, ge && (De.push(I.d, ge + yr), ct.style.flexBasis !== "auto" && (ct.style.flexBasis = ge + yr)), zp(De), se && Tn.forEach(function(ht) {
            ht.pin === se && ht.vars.pinSpacing !== !1 && (ht._subPinOffset = !0);
          }), ie && Ye(at)) : (ge = Gx(y, I), ge && ct.style.flexBasis !== "auto" && (ct.style.flexBasis = ge + yr)), ie && (vt = {
            top: je.top + (Ft ? Rt - we : $t) + yr,
            left: je.left + (Ft ? $t : Rt - we) + yr,
            boxSizing: "border-box",
            position: "fixed"
          }, vt[cd] = vt["max" + tm] = Math.ceil(je.width) + yr, vt[fd] = vt["max" + NC] = Math.ceil(je.height) + yr, vt[oo] = vt[oo + hv] = vt[oo + fv] = vt[oo + pv] = vt[oo + dv] = "0", vt[ar] = he[ar], vt[ar + hv] = he[ar + hv], vt[ar + fv] = he[ar + fv], vt[ar + pv] = he[ar + pv], vt[ar + dv] = he[ar + dv], Ve = x6(Ue, vt, N), Fs && Ye(0)), i ? (Kn = i._initted, KE(1), i.render(i.duration(), !0, !0), ee = it(I.a) - zt + le + gt, Qe = Math.abs(le - ee) > 1, ie && Qe && Ve.splice(Ve.length - 2, 2), i.render(0, !0, !0), Kn || i.invalidate(!0), i.parent || i.totalTime(i.totalTime()), KE(0)) : ee = le, bn && (bn.value ? bn.style["overflow" + I.a.toUpperCase()] = bn.value : bn.style.removeProperty("overflow-" + I.a));
        else if (v && Ye() && !O)
          for (je = v.parentNode; je && je !== qn; )
            je._pinOffset && (we -= je._pinOffset, Ee -= je._pinOffset), je = je.parentNode;
        ai && ai.forEach(function(ht) {
          return ht.revert(!1, !0);
        }), H.start = we, H.end = Ee, mt = ne = Fs ? at : Ye(), !O && !Fs && (mt < at && Ye(at), H.scroll.rec = 0), H.revert(!1, !0), Xe = gs(), et && (ye = -1, et.restart(!0)), ms = 0, i && Y && (i._initted || Wt) && i.progress() !== Wt && i.progress(Wt || 0, !0).render(i.time(), !0, !0), (ze || Je !== H.progress || O || T || i && !i._initted) && (i && !Y && (i._initted || Je || i.vars.immediateRender !== !1) && i.totalProgress(O && we < -1e-3 && !Je ? Gt.utils.normalize(we, Ee, 0) : Je, !0), H.progress = ze || (mt - we) / le === Je ? 0 : Je), y && S && (ct._pinOffset = Math.round(H.progress * ee)), We && We.invalidate(), isNaN(ti) || (ti -= Gt.getProperty(ce, I.p), Qt -= Gt.getProperty(nt, I.p), ix(ce, I, ti), ix(He, I, ti - (en || 0)), ix(nt, I, Qt), ix(be, I, Qt - (en || 0))), ze && !Fs && H.update(), p && !Fs && !G && (G = !0, p(H), G = !1);
      }
    }, H.getVelocity = function() {
      return (Ye() - ne) / (gs() - Yg) * 1e3 || 0;
    }, H.endAnimation = function() {
      Vg(H.callbackAnimation), i && (We ? We.progress(1) : i.paused() ? Y || Vg(i, H.direction < 0, 1) : Vg(i, i.reversed()));
    }, H.labelToScroll = function(lt) {
      return i && i.labels && (we || H.refresh() || we) + i.labels[lt] / i.duration() * le || 0;
    }, H.getTrailing = function(lt) {
      var Ot = Tn.indexOf(H), kt = H.direction > 0 ? Tn.slice(0, Ot).reverse() : Tn.slice(Ot + 1);
      return (Ma(lt) ? kt.filter(function(en) {
        return en.vars.preventOverlaps === lt;
      }) : kt).filter(function(en) {
        return H.direction > 0 ? en.end <= we : en.start >= Ee;
      });
    }, H.update = function(lt, Ot, kt) {
      if (!(O && !kt && !lt)) {
        var en = Fs === !0 ? at : H.scroll(), Vn = lt ? 0 : (en - we) / le, Yt = Vn < 0 ? 0 : Vn > 1 ? 1 : Vn || 0, te = H.progress, ze, tt, gt, Ht, tn, k, se, _e;
        if (Ot && (ne = mt, mt = O ? Ye() : en, D && (Dt = Ke, Ke = i && !Y ? i.totalProgress() : Yt)), E && y && !ms && !j0 && ho && (!Yt && we < en + (en - ne) / (gs() - Yg) * E ? Yt = 1e-4 : Yt === 1 && Ee > en + (en - ne) / (gs() - Yg) * E && (Yt = 0.9999)), Yt !== te && H.enabled) {
          if (ze = H.isActive = !!Yt && Yt < 1, tt = !!te && te < 1, k = ze !== tt, tn = k || !!Yt != !!te, H.direction = Yt > te ? 1 : -1, H.progress = Yt, tn && !ms && (gt = Yt && !te ? 0 : Yt === 1 ? 1 : te === 1 ? 2 : 3, Y && (Ht = !k && pe[gt + 1] !== "none" && pe[gt + 1] || pe[gt], _e = i && (Ht === "complete" || Ht === "reset" || Ht in i))), L && (k || _e) && (_e || g || !i) && (_s(L) ? L(H) : H.getTrailing(L).forEach(function(Rt) {
            return Rt.endAnimation();
          })), Y || (We && !ms && !j0 ? (We._dp._time - We._start !== We._time && We.render(We._dp._time - We._start), We.resetTo ? We.resetTo("totalProgress", Yt, i._tTime / i._tDur) : (We.vars.totalProgress = Yt, We.invalidate().restart())) : i && i.totalProgress(Yt, !!(ms && (Xe || lt)))), y) {
            if (lt && S && (ct.style[S + I.os2] = Re), !ie)
              Lt(qg(zt + ee * Yt));
            else if (tn) {
              if (se = !lt && Yt > te && Ee + 1 > en && en + 1 >= yl(Q, I), N)
                if (!lt && (ze || se)) {
                  var ge = ou(y, !0), he = en - we;
                  xL(y, qn, ge.top + (I === xr ? he : 0) + yr, ge.left + (I === xr ? 0 : he) + yr);
                } else
                  xL(y, ct);
              zp(ze || se ? Ve : Oe), Qe && Yt < 1 && ze || Lt(zt + (Yt === 1 && !se ? ee : 0));
            }
          }
          D && !At.tween && !ms && !j0 && et.restart(!0), u && (k || C && Yt && (Yt < 1 || !qE)) && Hv(u.targets).forEach(function(Rt) {
            return Rt.classList[ze || C ? "add" : "remove"](u.className);
          }), o && !Y && !lt && o(H), tn && !ms ? (Y && (_e && (Ht === "complete" ? i.pause().totalProgress(1) : Ht === "reset" ? i.restart(!0).pause() : Ht === "restart" ? i.restart(!0) : i[Ht]()), o && o(H)), (k || !qE) && (d && k && QE(H, d), re[gt] && QE(H, re[gt]), C && (Yt === 1 ? H.kill(!1, 1) : re[gt] = 0), k || (gt = Yt === 1 ? 1 : 3, re[gt] && QE(H, re[gt]))), V && !ze && Math.abs(H.getVelocity()) > (jg(V) ? V : 2500) && (Vg(H.callbackAnimation), We ? We.progress(1) : Vg(i, Ht === "reverse" ? 1 : !Yt, 1))) : Y && o && !ms && o(H);
        }
        if (rt) {
          var je = O ? en / O.duration() * (O._caScrollDist || 0) : en;
          Ie(je + (ce._isFlipped ? 1 : 0)), rt(je);
        }
        ot && ot(-en / O.duration() * (O._caScrollDist || 0));
      }
    }, H.enable = function(lt, Ot) {
      H.enabled || (H.enabled = !0, Lr(Q, "resize", Qg), j || Lr(Q, "scroll", _p), ue && Lr(s, "refreshInit", ue), lt !== !1 && (H.progress = Je = 0, mt = ne = ye = Ye()), Ot !== !1 && H.refresh());
    }, H.getTween = function(lt) {
      return lt && At ? At.tween : We;
    }, H.setPositions = function(lt, Ot, kt, en) {
      if (O) {
        var Vn = O.scrollTrigger, Yt = O.duration(), te = Vn.end - Vn.start;
        lt = Vn.start + te * lt / Yt, Ot = Vn.start + te * Ot / Yt;
      }
      H.refresh(!1, !1, {
        start: fL(lt, kt && !!H._startClamp),
        end: fL(Ot, kt && !!H._endClamp)
      }, en), H.update();
    }, H.adjustPinSpacing = function(lt) {
      if (De && lt) {
        var Ot = De.indexOf(I.d) + 1;
        De[Ot] = parseFloat(De[Ot]) + lt + yr, De[1] = parseFloat(De[1]) + lt + yr, zp(De);
      }
    }, H.disable = function(lt, Ot) {
      if (H.enabled && (lt !== !1 && H.revert(!0, !0), H.enabled = H.isActive = !1, Ot || We && We.pause(), at = 0, Ct && (Ct.uncache = 1), ue && Dr(s, "refreshInit", ue), et && (et.pause(), At.tween && At.tween.kill() && (At.tween = 0)), !j)) {
        for (var kt = Tn.length; kt--; )
          if (Tn[kt].scroller === Q && Tn[kt] !== H)
            return;
        Dr(Q, "resize", Qg), j || Dr(Q, "scroll", _p);
      }
    }, H.kill = function(lt, Ot) {
      H.disable(lt, Ot), We && !Ot && We.kill(), c && delete mb[c];
      var kt = Tn.indexOf(H);
      kt >= 0 && Tn.splice(kt, 1), kt === Us && yx > 0 && Us--, kt = 0, Tn.forEach(function(en) {
        return en.scroller === H.scroller && (kt = 1);
      }), kt || Fs || (H.scroll.rec = 0), i && (i.scrollTrigger = null, lt && i.revert({
        kill: !1
      }), Ot || i.kill()), He && [He, be, ce, nt].forEach(function(en) {
        return en.parentNode && en.parentNode.removeChild(en);
      }), mv === H && (mv = 0), y && (Ct && (Ct.uncache = 1), kt = 0, Tn.forEach(function(en) {
        return en.pin === y && kt++;
      }), kt || (Ct.spacer = 0)), n.onKill && n.onKill(H);
    }, Tn.push(H), H.enable(!1, !1), an && an(H), i && i.add && !le) {
      var bt = H.update;
      H.update = function() {
        H.update = bt, wn.cache++, we || Ee || H.refresh();
      }, Gt.delayedCall(0.01, H.update), le = 0.01, we = Ee = 0;
    } else
      H.refresh();
    y && v6();
  }, s.register = function(n) {
    return Sp || (Gt = n || pU(), hU() && window.document && s.enable(), Sp = Kg), Sp;
  }, s.defaults = function(n) {
    if (n)
      for (var i in n)
        ex[i] = n[i];
    return ex;
  }, s.disable = function(n, i) {
    Kg = 0, Tn.forEach(function(o) {
      return o[i ? "kill" : "disable"](n);
    }), Dr(Cn, "wheel", _p), Dr(ui, "scroll", _p), clearInterval(q0), Dr(ui, "touchcancel", ml), Dr(qn, "touchstart", ml), Z0(Dr, ui, "pointerdown,touchstart,mousedown", dL), Z0(Dr, ui, "pointerup,touchend,mouseup", hL), Hx.kill(), Q0(Dr);
    for (var r = 0; r < wn.length; r += 3)
      $0(Dr, wn[r], wn[r + 1]), $0(Dr, wn[r], wn[r + 2]);
  }, s.enable = function() {
    if (Cn = window, ui = document, Ta = ui.documentElement, qn = ui.body, Gt && (Hv = Gt.utils.toArray, cv = Gt.utils.clamp, hb = Gt.core.context || ml, KE = Gt.core.suppressOverwrites || ml, PC = Cn.history.scrollRestoration || "auto", gb = Cn.pageYOffset || 0, Gt.core.globals("ScrollTrigger", s), qn)) {
      Kg = 1, Hp = document.createElement("div"), Hp.style.height = "100vh", Hp.style.position = "absolute", MU(), c6(), Zi.register(Gt), s.isTouch = Zi.isTouch, vc = Zi.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), db = Zi.isTouch === 1, Lr(Cn, "wheel", _p), LC = [Cn, ui, Ta, qn], Gt.matchMedia ? (s.matchMedia = function(d) {
        var p = Gt.matchMedia(), g;
        for (g in d)
          p.add(g, d[g]);
        return p;
      }, Gt.addEventListener("matchMediaInit", function() {
        return HC();
      }), Gt.addEventListener("matchMediaRevert", function() {
        return SU();
      }), Gt.addEventListener("matchMedia", function() {
        ed(0, 1), Ad("matchMedia");
      }), Gt.matchMedia().add("(orientation: portrait)", function() {
        return ZE(), ZE;
      })) : console.warn("Requires GSAP 3.11.0 or later"), ZE(), Lr(ui, "scroll", _p);
      var n = qn.hasAttribute("style"), i = qn.style, r = i.borderTopStyle, o = Gt.core.Animation.prototype, u, c;
      for (o.revert || Object.defineProperty(o, "revert", {
        value: function() {
          return this.time(-0.01, !0);
        }
      }), i.borderTopStyle = "solid", u = ou(qn), xr.m = Math.round(u.top + xr.sc()) || 0, Hs.m = Math.round(u.left + Hs.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), n || (qn.setAttribute("style", ""), qn.removeAttribute("style")), q0 = setInterval(gL, 250), Gt.delayedCall(0.5, function() {
        return j0 = 0;
      }), Lr(ui, "touchcancel", ml), Lr(qn, "touchstart", ml), Z0(Lr, ui, "pointerdown,touchstart,mousedown", dL), Z0(Lr, ui, "pointerup,touchend,mouseup", hL), fb = Gt.utils.checkPrefix("transform"), xx.push(fb), Sp = gs(), Hx = Gt.delayedCall(0.2, ed).pause(), Ap = [ui, "visibilitychange", function() {
        var d = Cn.innerWidth, p = Cn.innerHeight;
        ui.hidden ? (lL = d, uL = p) : (lL !== d || uL !== p) && Qg();
      }, ui, "DOMContentLoaded", ed, Cn, "load", ed, Cn, "resize", Qg], Q0(Lr), Tn.forEach(function(d) {
        return d.enable(0, 1);
      }), c = 0; c < wn.length; c += 3)
        $0(Dr, wn[c], wn[c + 1]), $0(Dr, wn[c], wn[c + 2]);
    }
  }, s.config = function(n) {
    "limitCallbacks" in n && (qE = !!n.limitCallbacks);
    var i = n.syncInterval;
    i && clearInterval(q0) || (q0 = i) && setInterval(gL, i), "ignoreMobileResize" in n && (db = s.isTouch === 1 && n.ignoreMobileResize), "autoRefreshEvents" in n && (Q0(Dr) || Q0(Lr, n.autoRefreshEvents || "none"), cU = (n.autoRefreshEvents + "").indexOf("resize") === -1);
  }, s.scrollerProxy = function(n, i) {
    var r = ta(n), o = wn.indexOf(r), u = xd(r);
    ~o && wn.splice(o, u ? 6 : 2), i && (u ? Ml.unshift(Cn, i, qn, i, Ta, i) : Ml.unshift(r, i));
  }, s.clearMatchMedia = function(n) {
    Tn.forEach(function(i) {
      return i._ctx && i._ctx.query === n && i._ctx.kill(!0, !0);
    });
  }, s.isInViewport = function(n, i, r) {
    var o = (Ma(n) ? ta(n) : n).getBoundingClientRect(), u = o[r ? cd : fd] * i || 0;
    return r ? o.right - u > 0 && o.left + u < Cn.innerWidth : o.bottom - u > 0 && o.top + u < Cn.innerHeight;
  }, s.positionInViewport = function(n, i, r) {
    Ma(n) && (n = ta(n));
    var o = n.getBoundingClientRect(), u = o[r ? cd : fd], c = i == null ? u / 2 : i in kx ? kx[i] * u : ~i.indexOf("%") ? parseFloat(i) * u / 100 : parseFloat(i) || 0;
    return r ? (o.left + c) / Cn.innerWidth : (o.top + c) / Cn.innerHeight;
  }, s.killAll = function(n) {
    if (Tn.slice(0).forEach(function(r) {
      return r.vars.id !== "ScrollSmoother" && r.kill();
    }), n !== !0) {
      var i = Sd.killAll || [];
      Sd = {}, i.forEach(function(r) {
        return r();
      });
    }
  }, s;
}();
Rn.version = "3.13.0";
Rn.saveStyles = function(s) {
  return s ? Hv(s).forEach(function(e) {
    if (e && e.style) {
      var t = Aa.indexOf(e);
      t >= 0 && Aa.splice(t, 5), Aa.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Gt.core.getCache(e), hb());
    }
  }) : Aa;
};
Rn.revert = function(s, e) {
  return HC(!s, e);
};
Rn.create = function(s, e) {
  return new Rn(s, e);
};
Rn.refresh = function(s) {
  return s ? Qg(!0) : (Sp || Rn.register()) && ed(!0);
};
Rn.update = function(s) {
  return ++wn.cache && pu(s === !0 ? 2 : 0);
};
Rn.clearScrollMemory = AU;
Rn.maxScroll = function(s, e) {
  return yl(s, e ? Hs : xr);
};
Rn.getScrollFunc = function(s, e) {
  return Hc(ta(s), e ? Hs : xr);
};
Rn.getById = function(s) {
  return mb[s];
};
Rn.getAll = function() {
  return Tn.filter(function(s) {
    return s.vars.id !== "ScrollSmoother";
  });
};
Rn.isScrolling = function() {
  return !!ho;
};
Rn.snapDirectional = OC;
Rn.addEventListener = function(s, e) {
  var t = Sd[s] || (Sd[s] = []);
  ~t.indexOf(e) || t.push(e);
};
Rn.removeEventListener = function(s, e) {
  var t = Sd[s], n = t && t.indexOf(e);
  n >= 0 && t.splice(n, 1);
};
Rn.batch = function(s, e) {
  var t = [], n = {}, i = e.interval || 0.016, r = e.batchMax || 1e9, o = function(d, p) {
    var g = [], v = [], y = Gt.delayedCall(i, function() {
      p(g, v), g = [], v = [];
    }).pause();
    return function(S) {
      g.length || y.restart(!0), g.push(S.trigger), v.push(S), r <= g.length && y.progress(1);
    };
  }, u;
  for (u in e)
    n[u] = u.substr(0, 2) === "on" && _s(e[u]) && u !== "onRefreshInit" ? o(u, e[u]) : e[u];
  return _s(r) && (r = r(), Lr(Rn, "refresh", function() {
    return r = e.batchMax();
  })), Hv(s).forEach(function(c) {
    var d = {};
    for (u in n)
      d[u] = n[u];
    d.trigger = c, t.push(Rn.create(d));
  }), t;
};
var AL = function(e, t, n, i) {
  return t > i ? e(i) : t < 0 && e(0), n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1;
}, eT = function s(e, t) {
  t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (Zi.isTouch ? " pinch-zoom" : "") : "none", e === Ta && s(qn, t);
}, rx = {
  auto: 1,
  scroll: 1
}, A6 = function(e) {
  var t = e.event, n = e.target, i = e.axis, r = (t.changedTouches ? t.changedTouches[0] : t).target, o = r._gsap || Gt.core.getCache(r), u = gs(), c;
  if (!o._isScrollT || u - o._isScrollT > 2e3) {
    for (; r && r !== qn && (r.scrollHeight <= r.clientHeight && r.scrollWidth <= r.clientWidth || !(rx[(c = lo(r)).overflowY] || rx[c.overflowX])); )
      r = r.parentNode;
    o._isScroll = r && r !== n && !xd(r) && (rx[(c = lo(r)).overflowY] || rx[c.overflowX]), o._isScrollT = u;
  }
  (o._isScroll || i === "x") && (t.stopPropagation(), t._gsapAllow = !0);
}, TU = function(e, t, n, i) {
  return Zi.create({
    target: e,
    capture: !0,
    debounce: !1,
    lockAxis: !0,
    type: t,
    onWheel: i = i && A6,
    onPress: i,
    onDrag: i,
    onScroll: i,
    onEnable: function() {
      return n && Lr(ui, Zi.eventTypes[0], EL, !1, !0);
    },
    onDisable: function() {
      return Dr(ui, Zi.eventTypes[0], EL, !0);
    }
  });
}, M6 = /(input|label|select|textarea)/i, ML, EL = function(e) {
  var t = M6.test(e.target.tagName);
  (t || ML) && (e._gsapAllow = !0, ML = t);
}, E6 = function(e) {
  Xf(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
  var t = e, n = t.normalizeScrollX, i = t.momentum, r = t.allowNestedScroll, o = t.onRelease, u, c, d = ta(e.target) || Ta, p = Gt.core.globals().ScrollSmoother, g = p && p.get(), v = vc && (e.content && ta(e.content) || g && e.content !== !1 && !g.smooth() && g.content()), y = Hc(d, xr), S = Hc(d, Hs), T = 1, E = (Zi.isTouch && Cn.visualViewport ? Cn.visualViewport.scale * Cn.visualViewport.width : Cn.outerWidth) / Cn.innerWidth, M = 0, w = _s(i) ? function() {
    return i(u);
  } : function() {
    return i || 2.8;
  }, C, D, N = TU(d, e.type, !0, r), U = function() {
    return D = !1;
  }, O = ml, V = ml, L = function() {
    c = yl(d, xr), V = cv(vc ? 1 : 0, c), n && (O = cv(0, yl(d, Hs))), C = dd;
  }, I = function() {
    v._gsap.y = qg(parseFloat(v._gsap.y) + y.offset) + "px", v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)", y.offset = y.cacheID = 0;
  }, Y = function() {
    if (D) {
      requestAnimationFrame(U);
      var J = qg(u.deltaY / 2), Z = V(y.v - J);
      if (v && Z !== y.v + y.offset) {
        y.offset = Z - y.v;
        var H = qg((parseFloat(v && v._gsap.y) || 0) - y.offset);
        v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + H + ", 0, 1)", v._gsap.y = H + "px", y.cacheID = wn.cache, pu();
      }
      return !0;
    }
    y.offset && I(), D = !0;
  }, Q, fe, j, ie, re = function() {
    L(), Q.isActive() && Q.vars.scrollY > c && (y() > c ? Q.progress(1) && y(c) : Q.resetTo("scrollY", c));
  };
  return v && Gt.set(v, {
    y: "+=0"
  }), e.ignoreCheck = function(pe) {
    return vc && pe.type === "touchmove" && Y() || T > 1.05 && pe.type !== "touchstart" || u.isGesturing || pe.touches && pe.touches.length > 1;
  }, e.onPress = function() {
    D = !1;
    var pe = T;
    T = qg((Cn.visualViewport && Cn.visualViewport.scale || 1) / E), Q.pause(), pe !== T && eT(d, T > 1.01 ? !0 : n ? !1 : "x"), fe = S(), j = y(), L(), C = dd;
  }, e.onRelease = e.onGestureStart = function(pe, J) {
    if (y.offset && I(), !J)
      ie.restart(!0);
    else {
      wn.cache++;
      var Z = w(), H, ue;
      n && (H = S(), ue = H + Z * 0.05 * -pe.velocityX / 0.227, Z *= AL(S, H, ue, yl(d, Hs)), Q.vars.scrollX = O(ue)), H = y(), ue = H + Z * 0.05 * -pe.velocityY / 0.227, Z *= AL(y, H, ue, yl(d, xr)), Q.vars.scrollY = V(ue), Q.invalidate().duration(Z).play(0.01), (vc && Q.vars.scrollY >= c || H >= c - 1) && Gt.to({}, {
        onUpdate: re,
        duration: Z
      });
    }
    o && o(pe);
  }, e.onWheel = function() {
    Q._ts && Q.pause(), gs() - M > 1e3 && (C = 0, M = gs());
  }, e.onChange = function(pe, J, Z, H, ue) {
    if (dd !== C && L(), J && n && S(O(H[2] === J ? fe + (pe.startX - pe.x) : S() + J - H[1])), Z) {
      y.offset && I();
      var Se = ue[2] === Z, me = Se ? j + pe.startY - pe.y : y() + Z - ue[1], ye = V(me);
      Se && me !== ye && (j += ye - me), y(ye);
    }
    (Z || J) && pu();
  }, e.onEnable = function() {
    eT(d, n ? !1 : "x"), Rn.addEventListener("refresh", re), Lr(Cn, "resize", re), y.smooth && (y.target.style.scrollBehavior = "auto", y.smooth = S.smooth = !1), N.enable();
  }, e.onDisable = function() {
    eT(d, !0), Dr(Cn, "resize", re), Rn.removeEventListener("refresh", re), N.kill();
  }, e.lockAxis = e.lockAxis !== !1, u = new Zi(e), u.iOS = vc, vc && !y() && y(1), vc && Gt.ticker.add(ml), ie = u._dc, Q = Gt.to(u, {
    ease: "power4",
    paused: !0,
    inherit: !1,
    scrollX: n ? "+=0.1" : "+=0",
    scrollY: "+=0.1",
    modifiers: {
      scrollY: EU(y, y(), function() {
        return Q.pause();
      })
    },
    onUpdate: pu,
    onComplete: ie.vars.onComplete
  }), u;
};
Rn.sort = function(s) {
  if (_s(s))
    return Tn.sort(s);
  var e = Cn.pageYOffset || 0;
  return Rn.getAll().forEach(function(t) {
    return t._sortY = t.trigger ? e + t.trigger.getBoundingClientRect().top : t.start + Cn.innerHeight;
  }), Tn.sort(s || function(t, n) {
    return (t.vars.refreshPriority || 0) * -1e6 + (t.vars.containerAnimation ? 1e6 : t._sortY) - ((n.vars.containerAnimation ? 1e6 : n._sortY) + (n.vars.refreshPriority || 0) * -1e6);
  });
};
Rn.observe = function(s) {
  return new Zi(s);
};
Rn.normalizeScroll = function(s) {
  if (typeof s > "u")
    return Is;
  if (s === !0 && Is)
    return Is.enable();
  if (s === !1) {
    Is && Is.kill(), Is = s;
    return;
  }
  var e = s instanceof Zi ? s : E6(s);
  return Is && Is.target === e.target && Is.kill(), xd(e.target) && (Is = e), e;
};
Rn.core = {
  // smaller file size way to leverage in ScrollSmoother and Observer
  _getVelocityProp: cb,
  _inputObserver: TU,
  _scrollers: wn,
  _proxies: Ml,
  bridge: {
    // when normalizeScroll sets the scroll position (ss = setScroll)
    ss: function() {
      ho || Ad("scrollStart"), ho = gs();
    },
    // a way to get the _refreshing value in Observer
    ref: function() {
      return ms;
    }
  }
};
pU() && Gt.registerPlugin(Rn);
const T6 = {
  "sec-1": { name: "sec-1", modelTransform: { posX: -1, posY: 0, posZ: 0, rotX: 0, rotY: -5, rotZ: 0 }, background: { type: "solid", color1: "#fbfbfb", color2: "#350000" }, lights: [{ id: 17530033689119426e-4, type: "Point", intensity: 9.999999999999998, color: "#e8d8d4", position: [2, 5, 3], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }, { id: 17530033689117395e-4, type: "Ambient", intensity: 28, color: "#7f7f7f", position: [0, 0, 0], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }, { id: 17530039069154421e-4, type: "Directional", intensity: 9.700000000000001, color: "#ffeeee", position: [6.7, 8.700000000000001, 0], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }], selectedAnimation: "Idle", loopCount: "Infinity" },
  "sec-2": { name: "sec-2", modelTransform: { posX: 0, posY: 0, posZ: 0, rotX: 0, rotY: -0.7000000000000001, rotZ: 0 }, background: { type: "solid", color1: "#ff6262", color2: "#350000" }, lights: [{ id: 1753003615642278e-3, type: "Directional", intensity: 25, color: "#ff3300", position: [2, 5, 3], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }, { id: 17530036156426309e-4, type: "Ambient", intensity: 28, color: "#803030", position: [0, 0, 0], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }], selectedAnimation: "Idle", loopCount: "Infinity" },
  "sec-3": { name: "sec-3", modelTransform: { posX: -2.7, posY: -0.9, posZ: 3.4000000000000004, rotX: 0, rotY: 1.2000000000000002, rotZ: 0 }, background: { type: "solid", color1: "#0bbc96", color2: "#350000" }, lights: [{ id: 17530037182022205e-4, type: "Directional", intensity: 25, color: "#07ff00", position: [-11102230246251565e-32, 5, 3], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }, { id: 17530037182026328e-4, type: "Ambient", intensity: 28, color: "#2d5c36", position: [0, 0, 0], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }], selectedAnimation: "Take 001", loopCount: "Infinity" },
  "sec-4": { name: "sec-4", modelTransform: { posX: 0, posY: -1.2000000000000002, posZ: 4.9, rotX: 0, rotY: -6.1000000000000005, rotZ: 0 }, background: { type: "solid", color1: "#cfb82f", color2: "#350000" }, lights: [{ id: 1753003968378131e-3, type: "Directional", intensity: 6.699999999999999, color: "#e1ff00", position: [2, 5, 3], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }, { id: 17530039683783835e-4, type: "Ambient", intensity: 5.999999999999999, color: "#708030", position: [0, 0, 0], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }], selectedAnimation: "Idle", loopCount: "Infinity" }
};
Np.registerPlugin(Rn);
function b6({ modelPath: s, activeSection: e, sceneSettings: t }) {
  const n = gl(), { scene: i } = Dv(s);
  Dv.preload(s);
  const { scene: r } = H5(), o = gl({
    position: new q(),
    rotation: new rm()
  }).current, [u, c] = Ax([]);
  return Tc(() => {
    if (!e) return;
    const d = t[e];
    if (!d || !d.modelTransform) return;
    const { modelTransform: p, background: g, lights: v } = d;
    if (Np.to(o.position, {
      x: p.posX,
      y: p.posY,
      z: p.posZ,
      duration: 1,
      ease: "power1.out"
    }), Np.to(o.rotation, {
      x: p.rotX,
      y: p.rotY,
      z: p.rotZ,
      duration: 1,
      ease: "power1.out"
    }), g.type === "solid") {
      const y = new Tt(g.color1);
      r.background || (r.background = new Tt(y));
      const S = r.background;
      Np.to(S, {
        r: y.r,
        g: y.g,
        b: y.b,
        duration: 1,
        onUpdate: () => {
          r.background.setRGB(S.r, S.g, S.b);
        }
      });
    } else
      r.background = null;
    c(v || []);
  }, [e, r, t]), z5(() => {
    n.current && (n.current.position.lerp(o.position, 0.1), n.current.rotation.x = ev.lerp(n.current.rotation.x, o.rotation.x, 0.1), n.current.rotation.y = ev.lerp(n.current.rotation.y, o.rotation.y, 0.1), n.current.rotation.z = ev.lerp(n.current.rotation.z, o.rotation.z, 0.1));
  }), /* @__PURE__ */ Qi.jsxs(Qi.Fragment, { children: [
    u.map((d) => {
      const p = {
        key: d.id,
        position: d.position,
        intensity: d.intensity,
        color: d.color,
        castShadow: d.castShadow
      };
      switch (d.type) {
        case "Directional":
          return /* @__PURE__ */ Qi.jsx("directionalLight", { ...p });
        case "Point":
          return /* @__PURE__ */ Qi.jsx("pointLight", { ...p });
        case "Ambient":
          return /* @__PURE__ */ Qi.jsx("ambientLight", { ...p });
        case "Spot":
          return /* @__PURE__ */ Qi.jsx(
            "spotLight",
            {
              ...p,
              angle: d.angle || Math.PI / 6,
              penumbra: d.penumbra || 0,
              decay: d.decay || 1,
              distance: d.distance || 0
            }
          );
        default:
          return null;
      }
    }),
    /* @__PURE__ */ Qi.jsx("primitive", { object: i, ref: n })
  ] });
}
function B6({ modelPath: s = "https://white-deane-36.tiiny.site/models/Compressed-Sphere-Bot.glb" }) {
  const [e, t] = Ax(T6), [n, i] = Ax(Object.values(e)[0].name);
  return Tc(() => {
    const r = (o) => {
      o?.data?.type && o.data.type === "UPDATE_SCENE_SETTINGS" && t(o.data.data);
    };
    return window.addEventListener("message", r), () => window.removeEventListener("message", r);
  }, []), TL(() => {
    const r = Np.context(() => {
      Object.values(e).forEach((u, c, d) => {
        Rn.create({
          trigger: `#${u.name}`,
          start: "top center",
          end: "bottom center",
          onEnter: () => i(u.name),
          onEnterBack: () => i(u.name)
        });
      });
    });
    return () => r.revert();
  }, [e]), /* @__PURE__ */ Qi.jsx(
    "div",
    {
      style: {
        width: "100%",
        height: "100%",
        position: "fixed",
        top: 0,
        left: 0,
        zIndex: -1,
        pointerEvents: "none"
      },
      children: /* @__PURE__ */ Qi.jsx(
        o8,
        {
          style: { background: "transparent" },
          camera: { position: [0, 0, 10], fov: 50 },
          shadows: !0,
          children: /* @__PURE__ */ Qi.jsx(b6, { modelPath: s, activeSection: n, sceneSettings: e })
        }
      )
    }
  );
}
export {
  B6 as default
};
