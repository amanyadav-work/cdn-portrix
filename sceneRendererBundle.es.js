function sC(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var zm = { exports: {} }, Vc = {}, Vm = { exports: {} }, Lt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tx;
function oC() {
  if (Tx) return Lt;
  Tx = 1;
  var s = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), r = Symbol.for("react.provider"), o = Symbol.for("react.context"), a = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), h = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), d = Symbol.iterator;
  function p(D) {
    return D === null || typeof D != "object" ? null : (D = d && D[d] || D["@@iterator"], typeof D == "function" ? D : null);
  }
  var m = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, _ = Object.assign, x = {};
  function y(D, J, K) {
    this.props = D, this.context = J, this.refs = x, this.updater = K || m;
  }
  y.prototype.isReactComponent = {}, y.prototype.setState = function(D, J) {
    if (typeof D != "object" && typeof D != "function" && D != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, D, J, "setState");
  }, y.prototype.forceUpdate = function(D) {
    this.updater.enqueueForceUpdate(this, D, "forceUpdate");
  };
  function v() {
  }
  v.prototype = y.prototype;
  function S(D, J, K) {
    this.props = D, this.context = J, this.refs = x, this.updater = K || m;
  }
  var M = S.prototype = new v();
  M.constructor = S, _(M, y.prototype), M.isPureReactComponent = !0;
  var T = Array.isArray, P = Object.prototype.hasOwnProperty, b = { current: null }, R = { key: !0, ref: !0, __self: !0, __source: !0 };
  function U(D, J, K) {
    var ie, he = {}, ge = null, me = null;
    if (J != null) for (ie in J.ref !== void 0 && (me = J.ref), J.key !== void 0 && (ge = "" + J.key), J) P.call(J, ie) && !R.hasOwnProperty(ie) && (he[ie] = J[ie]);
    var Be = arguments.length - 2;
    if (Be === 1) he.children = K;
    else if (1 < Be) {
      for (var Pe = Array(Be), De = 0; De < Be; De++) Pe[De] = arguments[De + 2];
      he.children = Pe;
    }
    if (D && D.defaultProps) for (ie in Be = D.defaultProps, Be) he[ie] === void 0 && (he[ie] = Be[ie]);
    return { $$typeof: s, type: D, key: ge, ref: me, props: he, _owner: b.current };
  }
  function C(D, J) {
    return { $$typeof: s, type: D.type, key: J, ref: D.ref, props: D.props, _owner: D._owner };
  }
  function B(D) {
    return typeof D == "object" && D !== null && D.$$typeof === s;
  }
  function G(D) {
    var J = { "=": "=0", ":": "=2" };
    return "$" + D.replace(/[=:]/g, function(K) {
      return J[K];
    });
  }
  var W = /\/+/g;
  function se(D, J) {
    return typeof D == "object" && D !== null && D.key != null ? G("" + D.key) : J.toString(36);
  }
  function z(D, J, K, ie, he) {
    var ge = typeof D;
    (ge === "undefined" || ge === "boolean") && (D = null);
    var me = !1;
    if (D === null) me = !0;
    else switch (ge) {
      case "string":
      case "number":
        me = !0;
        break;
      case "object":
        switch (D.$$typeof) {
          case s:
          case e:
            me = !0;
        }
    }
    if (me) return me = D, he = he(me), D = ie === "" ? "." + se(me, 0) : ie, T(he) ? (K = "", D != null && (K = D.replace(W, "$&/") + "/"), z(he, J, K, "", function(De) {
      return De;
    })) : he != null && (B(he) && (he = C(he, K + (!he.key || me && me.key === he.key ? "" : ("" + he.key).replace(W, "$&/") + "/") + D)), J.push(he)), 1;
    if (me = 0, ie = ie === "" ? "." : ie + ":", T(D)) for (var Be = 0; Be < D.length; Be++) {
      ge = D[Be];
      var Pe = ie + se(ge, Be);
      me += z(ge, J, K, Pe, he);
    }
    else if (Pe = p(D), typeof Pe == "function") for (D = Pe.call(D), Be = 0; !(ge = D.next()).done; ) ge = ge.value, Pe = ie + se(ge, Be++), me += z(ge, J, K, Pe, he);
    else if (ge === "object") throw J = String(D), Error("Objects are not valid as a React child (found: " + (J === "[object Object]" ? "object with keys {" + Object.keys(D).join(", ") + "}" : J) + "). If you meant to render a collection of children, use an array instead.");
    return me;
  }
  function q(D, J, K) {
    if (D == null) return D;
    var ie = [], he = 0;
    return z(D, ie, "", "", function(ge) {
      return J.call(K, ge, he++);
    }), ie;
  }
  function j(D) {
    if (D._status === -1) {
      var J = D._result;
      J = J(), J.then(function(K) {
        (D._status === 0 || D._status === -1) && (D._status = 1, D._result = K);
      }, function(K) {
        (D._status === 0 || D._status === -1) && (D._status = 2, D._result = K);
      }), D._status === -1 && (D._status = 0, D._result = J);
    }
    if (D._status === 1) return D._result.default;
    throw D._result;
  }
  var ee = { current: null }, N = { transition: null }, V = { ReactCurrentDispatcher: ee, ReactCurrentBatchConfig: N, ReactCurrentOwner: b };
  function I() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return Lt.Children = { map: q, forEach: function(D, J, K) {
    q(D, function() {
      J.apply(this, arguments);
    }, K);
  }, count: function(D) {
    var J = 0;
    return q(D, function() {
      J++;
    }), J;
  }, toArray: function(D) {
    return q(D, function(J) {
      return J;
    }) || [];
  }, only: function(D) {
    if (!B(D)) throw Error("React.Children.only expected to receive a single React element child.");
    return D;
  } }, Lt.Component = y, Lt.Fragment = t, Lt.Profiler = i, Lt.PureComponent = S, Lt.StrictMode = n, Lt.Suspense = l, Lt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = V, Lt.act = I, Lt.cloneElement = function(D, J, K) {
    if (D == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + D + ".");
    var ie = _({}, D.props), he = D.key, ge = D.ref, me = D._owner;
    if (J != null) {
      if (J.ref !== void 0 && (ge = J.ref, me = b.current), J.key !== void 0 && (he = "" + J.key), D.type && D.type.defaultProps) var Be = D.type.defaultProps;
      for (Pe in J) P.call(J, Pe) && !R.hasOwnProperty(Pe) && (ie[Pe] = J[Pe] === void 0 && Be !== void 0 ? Be[Pe] : J[Pe]);
    }
    var Pe = arguments.length - 2;
    if (Pe === 1) ie.children = K;
    else if (1 < Pe) {
      Be = Array(Pe);
      for (var De = 0; De < Pe; De++) Be[De] = arguments[De + 2];
      ie.children = Be;
    }
    return { $$typeof: s, type: D.type, key: he, ref: ge, props: ie, _owner: me };
  }, Lt.createContext = function(D) {
    return D = { $$typeof: o, _currentValue: D, _currentValue2: D, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, D.Provider = { $$typeof: r, _context: D }, D.Consumer = D;
  }, Lt.createElement = U, Lt.createFactory = function(D) {
    var J = U.bind(null, D);
    return J.type = D, J;
  }, Lt.createRef = function() {
    return { current: null };
  }, Lt.forwardRef = function(D) {
    return { $$typeof: a, render: D };
  }, Lt.isValidElement = B, Lt.lazy = function(D) {
    return { $$typeof: f, _payload: { _status: -1, _result: D }, _init: j };
  }, Lt.memo = function(D, J) {
    return { $$typeof: h, type: D, compare: J === void 0 ? null : J };
  }, Lt.startTransition = function(D) {
    var J = N.transition;
    N.transition = {};
    try {
      D();
    } finally {
      N.transition = J;
    }
  }, Lt.unstable_act = I, Lt.useCallback = function(D, J) {
    return ee.current.useCallback(D, J);
  }, Lt.useContext = function(D) {
    return ee.current.useContext(D);
  }, Lt.useDebugValue = function() {
  }, Lt.useDeferredValue = function(D) {
    return ee.current.useDeferredValue(D);
  }, Lt.useEffect = function(D, J) {
    return ee.current.useEffect(D, J);
  }, Lt.useId = function() {
    return ee.current.useId();
  }, Lt.useImperativeHandle = function(D, J, K) {
    return ee.current.useImperativeHandle(D, J, K);
  }, Lt.useInsertionEffect = function(D, J) {
    return ee.current.useInsertionEffect(D, J);
  }, Lt.useLayoutEffect = function(D, J) {
    return ee.current.useLayoutEffect(D, J);
  }, Lt.useMemo = function(D, J) {
    return ee.current.useMemo(D, J);
  }, Lt.useReducer = function(D, J, K) {
    return ee.current.useReducer(D, J, K);
  }, Lt.useRef = function(D) {
    return ee.current.useRef(D);
  }, Lt.useState = function(D) {
    return ee.current.useState(D);
  }, Lt.useSyncExternalStore = function(D, J, K) {
    return ee.current.useSyncExternalStore(D, J, K);
  }, Lt.useTransition = function() {
    return ee.current.useTransition();
  }, Lt.version = "18.3.1", Lt;
}
var wx;
function T0() {
  return wx || (wx = 1, Vm.exports = oC()), Vm.exports;
}
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cx;
function aC() {
  if (Cx) return Vc;
  Cx = 1;
  var s = T0(), e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, r = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, l, h) {
    var f, d = {}, p = null, m = null;
    h !== void 0 && (p = "" + h), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (f in l) n.call(l, f) && !r.hasOwnProperty(f) && (d[f] = l[f]);
    if (a && a.defaultProps) for (f in l = a.defaultProps, l) d[f] === void 0 && (d[f] = l[f]);
    return { $$typeof: e, type: a, key: p, ref: m, props: d, _owner: i.current };
  }
  return Vc.Fragment = t, Vc.jsx = o, Vc.jsxs = o, Vc;
}
var bx;
function lC() {
  return bx || (bx = 1, zm.exports = aC()), zm.exports;
}
var Pn = lC(), nt = T0();
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const rh = "160", cC = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, uC = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, gS = 0, l_ = 1, _S = 2, hC = 3, vS = 0, op = 1, mu = 2, Vr = 3, gs = 0, Oi = 1, Xr = 2, fC = 2, zs = 0, Ma = 1, c_ = 2, u_ = 3, h_ = 4, yS = 5, go = 100, xS = 101, AS = 102, f_ = 103, d_ = 104, MS = 200, SS = 201, ES = 202, TS = 203, Gd = 204, Hd = 205, wS = 206, CS = 207, bS = 208, RS = 209, BS = 210, PS = 211, IS = 212, LS = 213, DS = 214, FS = 0, US = 1, OS = 2, Lu = 3, NS = 4, kS = 5, GS = 6, HS = 7, sh = 0, zS = 1, VS = 2, fs = 0, WS = 1, XS = 2, JS = 3, w0 = 4, YS = 5, KS = 6, p_ = "attached", qS = "detached", ap = 300, Xs = 301, Ro = 302, Du = 303, Fu = 304, _c = 306, Bo = 1e3, ri = 1001, nc = 1002, Sn = 1003, Uu = 1004, dC = 1004, Jl = 1005, pC = 1005, gn = 1006, lp = 1007, mC = 1007, _s = 1008, gC = 1008, ds = 1009, QS = 1010, ZS = 1011, cp = 1012, C0 = 1013, Ns = 1014, Jr = 1015, ic = 1016, b0 = 1017, R0 = 1018, Mo = 1020, jS = 1021, Di = 1023, $S = 1024, eE = 1025, So = 1026, Da = 1027, tE = 1028, B0 = 1029, nE = 1030, P0 = 1031, I0 = 1033, Sd = 33776, Ed = 33777, Td = 33778, wd = 33779, m_ = 35840, g_ = 35841, __ = 35842, v_ = 35843, L0 = 36196, y_ = 37492, x_ = 37496, A_ = 37808, M_ = 37809, S_ = 37810, E_ = 37811, T_ = 37812, w_ = 37813, C_ = 37814, b_ = 37815, R_ = 37816, B_ = 37817, P_ = 37818, I_ = 37819, L_ = 37820, D_ = 37821, Cd = 36492, F_ = 36494, U_ = 36495, iE = 36283, O_ = 36284, N_ = 36285, k_ = 36286, rE = 2200, sE = 2201, oE = 2202, rc = 2300, Fa = 2301, bd = 2302, pa = 2400, ma = 2401, Ou = 2402, up = 2500, D0 = 2501, aE = 0, F0 = 1, zd = 2, U0 = 3e3, Eo = 3001, lE = 3200, cE = 3201, Uo = 0, uE = 1, ar = "", Vn = "srgb", vs = "srgb-linear", hp = "display-p3", oh = "display-p3-linear", Nu = "linear", on = "srgb", ku = "rec709", Gu = "p3", _C = 0, la = 7680, vC = 7681, yC = 7682, xC = 7683, AC = 34055, MC = 34056, SC = 5386, EC = 512, TC = 513, wC = 514, CC = 515, bC = 516, RC = 517, BC = 518, G_ = 519, hE = 512, fE = 513, dE = 514, O0 = 515, pE = 516, mE = 517, gE = 518, _E = 519, Hu = 35044, PC = 35048, IC = 35040, LC = 35045, DC = 35049, FC = 35041, UC = 35046, OC = 35050, NC = 35042, kC = "100", H_ = "300 es", Vd = 1035, Yr = 2e3, sc = 2001;
class qs {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const r = i.indexOf(t);
      r !== -1 && i.splice(r, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let r = 0, o = i.length; r < o; r++)
        i[r].call(this, e);
      e.target = null;
    }
  }
}
const fi = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Rx = 1234567;
const Sa = Math.PI / 180, oc = 180 / Math.PI;
function fr() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (fi[s & 255] + fi[s >> 8 & 255] + fi[s >> 16 & 255] + fi[s >> 24 & 255] + "-" + fi[e & 255] + fi[e >> 8 & 255] + "-" + fi[e >> 16 & 15 | 64] + fi[e >> 24 & 255] + "-" + fi[t & 63 | 128] + fi[t >> 8 & 255] + "-" + fi[t >> 16 & 255] + fi[t >> 24 & 255] + fi[n & 255] + fi[n >> 8 & 255] + fi[n >> 16 & 255] + fi[n >> 24 & 255]).toLowerCase();
}
function En(s, e, t) {
  return Math.max(e, Math.min(t, s));
}
function N0(s, e) {
  return (s % e + e) % e;
}
function GC(s, e, t, n, i) {
  return n + (s - e) * (i - n) / (t - e);
}
function HC(s, e, t) {
  return s !== e ? (t - s) / (e - s) : 0;
}
function gu(s, e, t) {
  return (1 - t) * s + t * e;
}
function zC(s, e, t, n) {
  return gu(s, e, 1 - Math.exp(-t * n));
}
function VC(s, e = 1) {
  return e - Math.abs(N0(s, e * 2) - e);
}
function WC(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
}
function XC(s, e, t) {
  return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
}
function JC(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function YC(s, e) {
  return s + Math.random() * (e - s);
}
function KC(s) {
  return s * (0.5 - Math.random());
}
function qC(s) {
  s !== void 0 && (Rx = s);
  let e = Rx += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function QC(s) {
  return s * Sa;
}
function ZC(s) {
  return s * oc;
}
function z_(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function jC(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function Wd(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function $C(s, e, t, n, i) {
  const r = Math.cos, o = Math.sin, a = r(t / 2), l = o(t / 2), h = r((e + n) / 2), f = o((e + n) / 2), d = r((e - n) / 2), p = o((e - n) / 2), m = r((n - e) / 2), _ = o((n - e) / 2);
  switch (i) {
    case "XYX":
      s.set(a * f, l * d, l * p, a * h);
      break;
    case "YZY":
      s.set(l * p, a * f, l * d, a * h);
      break;
    case "ZXZ":
      s.set(l * d, l * p, a * f, a * h);
      break;
    case "XZX":
      s.set(a * f, l * _, l * m, a * h);
      break;
    case "YXY":
      s.set(l * m, a * f, l * _, a * h);
      break;
    case "ZYZ":
      s.set(l * _, l * m, a * f, a * h);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function Wi(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Tt(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const _u = {
  DEG2RAD: Sa,
  RAD2DEG: oc,
  generateUUID: fr,
  clamp: En,
  euclideanModulo: N0,
  mapLinear: GC,
  inverseLerp: HC,
  lerp: gu,
  damp: zC,
  pingpong: VC,
  smoothstep: WC,
  smootherstep: XC,
  randInt: JC,
  randFloat: YC,
  randFloatSpread: KC,
  seededRandom: qC,
  degToRad: QC,
  radToDeg: ZC,
  isPowerOfTwo: z_,
  ceilPowerOfTwo: jC,
  floorPowerOfTwo: Wd,
  setQuaternionFromProperEuler: $C,
  normalize: Tt,
  denormalize: Wi
};
class ve {
  constructor(e = 0, t = 0) {
    ve.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(En(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t), i = Math.sin(t), r = this.x - e.x, o = this.y - e.y;
    return this.x = r * n - o * i + e.x, this.y = r * i + o * n + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Ct {
  constructor(e, t, n, i, r, o, a, l, h) {
    Ct.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, r, o, a, l, h);
  }
  set(e, t, n, i, r, o, a, l, h) {
    const f = this.elements;
    return f[0] = e, f[1] = i, f[2] = a, f[3] = t, f[4] = r, f[5] = l, f[6] = n, f[7] = o, f[8] = h, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, r = this.elements, o = n[0], a = n[3], l = n[6], h = n[1], f = n[4], d = n[7], p = n[2], m = n[5], _ = n[8], x = i[0], y = i[3], v = i[6], S = i[1], M = i[4], T = i[7], P = i[2], b = i[5], R = i[8];
    return r[0] = o * x + a * S + l * P, r[3] = o * y + a * M + l * b, r[6] = o * v + a * T + l * R, r[1] = h * x + f * S + d * P, r[4] = h * y + f * M + d * b, r[7] = h * v + f * T + d * R, r[2] = p * x + m * S + _ * P, r[5] = p * y + m * M + _ * b, r[8] = p * v + m * T + _ * R, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], l = e[6], h = e[7], f = e[8];
    return t * o * f - t * a * h - n * r * f + n * a * l + i * r * h - i * o * l;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], l = e[6], h = e[7], f = e[8], d = f * o - a * h, p = a * l - f * r, m = h * r - o * l, _ = t * d + n * p + i * m;
    if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / _;
    return e[0] = d * x, e[1] = (i * h - f * n) * x, e[2] = (a * n - i * o) * x, e[3] = p * x, e[4] = (f * t - i * l) * x, e[5] = (i * r - a * t) * x, e[6] = m * x, e[7] = (n * l - h * t) * x, e[8] = (o * t - n * r) * x, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, n, i, r, o, a) {
    const l = Math.cos(r), h = Math.sin(r);
    return this.set(
      n * l,
      n * h,
      -n * (l * o + h * a) + o + e,
      -i * h,
      i * l,
      -i * (-h * o + l * a) + a + t,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, t) {
    return this.premultiply(Wm.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Wm.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Wm.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Wm = /* @__PURE__ */ new Ct();
function vE(s) {
  for (let e = s.length - 1; e >= 0; --e)
    if (s[e] >= 65535) return !0;
  return !1;
}
const eb = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function Nl(s, e) {
  return new eb[s](e);
}
function zu(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function yE() {
  const s = zu("canvas");
  return s.style.display = "block", s;
}
const Bx = {};
function vu(s) {
  s in Bx || (Bx[s] = !0, console.warn(s));
}
const Px = /* @__PURE__ */ new Ct().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
), Ix = /* @__PURE__ */ new Ct().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
), pf = {
  [vs]: {
    transfer: Nu,
    primaries: ku,
    toReference: (s) => s,
    fromReference: (s) => s
  },
  [Vn]: {
    transfer: on,
    primaries: ku,
    toReference: (s) => s.convertSRGBToLinear(),
    fromReference: (s) => s.convertLinearToSRGB()
  },
  [oh]: {
    transfer: Nu,
    primaries: Gu,
    toReference: (s) => s.applyMatrix3(Ix),
    fromReference: (s) => s.applyMatrix3(Px)
  },
  [hp]: {
    transfer: on,
    primaries: Gu,
    toReference: (s) => s.convertSRGBToLinear().applyMatrix3(Ix),
    fromReference: (s) => s.applyMatrix3(Px).convertLinearToSRGB()
  }
}, tb = /* @__PURE__ */ new Set([vs, oh]), Qt = {
  enabled: !0,
  _workingColorSpace: vs,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(s) {
    if (!tb.has(s))
      throw new Error(`Unsupported working color space, "${s}".`);
    this._workingColorSpace = s;
  },
  convert: function(s, e, t) {
    if (this.enabled === !1 || e === t || !e || !t)
      return s;
    const n = pf[e].toReference, i = pf[t].fromReference;
    return i(n(s));
  },
  fromWorkingColorSpace: function(s, e) {
    return this.convert(s, this._workingColorSpace, e);
  },
  toWorkingColorSpace: function(s, e) {
    return this.convert(s, e, this._workingColorSpace);
  },
  getPrimaries: function(s) {
    return pf[s].primaries;
  },
  getTransfer: function(s) {
    return s === ar ? Nu : pf[s].transfer;
  }
};
function Yl(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function Xm(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
let ll;
class k0 {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let t;
    if (e instanceof HTMLCanvasElement)
      t = e;
    else {
      ll === void 0 && (ll = zu("canvas")), ll.width = e.width, ll.height = e.height;
      const n = ll.getContext("2d");
      e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = ll;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = zu("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height), r = i.data;
      for (let o = 0; o < r.length; o++)
        r[o] = Yl(r[o] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Yl(t[n] / 255) * 255) : t[n] = Yl(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let nb = 0;
class ga {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: nb++ }), this.uuid = fr(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let r;
      if (Array.isArray(i)) {
        r = [];
        for (let o = 0, a = i.length; o < a; o++)
          i[o].isDataTexture ? r.push(Jm(i[o].image)) : r.push(Jm(i[o]));
      } else
        r = Jm(i);
      n.url = r;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function Jm(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? k0.getDataURL(s) : s.data ? {
    data: Array.from(s.data),
    width: s.width,
    height: s.height,
    type: s.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let ib = 0;
class yn extends qs {
  constructor(e = yn.DEFAULT_IMAGE, t = yn.DEFAULT_MAPPING, n = ri, i = ri, r = gn, o = _s, a = Di, l = ds, h = yn.DEFAULT_ANISOTROPY, f = ar) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: ib++ }), this.uuid = fr(), this.name = "", this.source = new ga(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = o, this.anisotropy = h, this.format = a, this.internalFormat = null, this.type = l, this.offset = new ve(0, 0), this.repeat = new ve(1, 1), this.center = new ve(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ct(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, typeof f == "string" ? this.colorSpace = f : (vu("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = f === Eo ? Vn : ar), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== ap) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Bo:
          e.x = e.x - Math.floor(e.x);
          break;
        case ri:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case nc:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Bo:
          e.y = e.y - Math.floor(e.y);
          break;
        case ri:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case nc:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  get encoding() {
    return vu("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Vn ? Eo : U0;
  }
  set encoding(e) {
    vu("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === Eo ? Vn : ar;
  }
}
yn.DEFAULT_IMAGE = null;
yn.DEFAULT_MAPPING = ap;
yn.DEFAULT_ANISOTROPY = 1;
class Zt {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    Zt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, r = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, r;
    const l = e.elements, h = l[0], f = l[4], d = l[8], p = l[1], m = l[5], _ = l[9], x = l[2], y = l[6], v = l[10];
    if (Math.abs(f - p) < 0.01 && Math.abs(d - x) < 0.01 && Math.abs(_ - y) < 0.01) {
      if (Math.abs(f + p) < 0.1 && Math.abs(d + x) < 0.1 && Math.abs(_ + y) < 0.1 && Math.abs(h + m + v - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const M = (h + 1) / 2, T = (m + 1) / 2, P = (v + 1) / 2, b = (f + p) / 4, R = (d + x) / 4, U = (_ + y) / 4;
      return M > T && M > P ? M < 0.01 ? (n = 0, i = 0.707106781, r = 0.707106781) : (n = Math.sqrt(M), i = b / n, r = R / n) : T > P ? T < 0.01 ? (n = 0.707106781, i = 0, r = 0.707106781) : (i = Math.sqrt(T), n = b / i, r = U / i) : P < 0.01 ? (n = 0.707106781, i = 0.707106781, r = 0) : (r = Math.sqrt(P), n = R / r, i = U / r), this.set(n, i, r, t), this;
    }
    let S = Math.sqrt((y - _) * (y - _) + (d - x) * (d - x) + (p - f) * (p - f));
    return Math.abs(S) < 1e-3 && (S = 1), this.x = (y - _) / S, this.y = (d - x) / S, this.z = (p - f) / S, this.w = Math.acos((h + m + v - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class xE extends qs {
  constructor(e = 1, t = 1, n = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Zt(0, 0, e, t), this.scissorTest = !1, this.viewport = new Zt(0, 0, e, t);
    const i = { width: e, height: t, depth: 1 };
    n.encoding !== void 0 && (vu("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), n.colorSpace = n.encoding === Eo ? Vn : ar), n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: gn,
      depthBuffer: !0,
      stencilBuffer: !1,
      depthTexture: null,
      samples: 0
    }, n), this.texture = new yn(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps, this.texture.internalFormat = n.internalFormat, this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) && (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new ga(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Kr extends xE {
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class fp extends yn {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = Sn, this.minFilter = Sn, this.wrapR = ri, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class rb extends Kr {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new fp(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class G0 extends yn {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = Sn, this.minFilter = Sn, this.wrapR = ri, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class sb extends Kr {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new G0(null, e, t, n), this.texture.isRenderTargetTexture = !0;
  }
}
class ob extends Kr {
  constructor(e = 1, t = 1, n = 1, i = {}) {
    super(e, t, i), this.isWebGLMultipleRenderTargets = !0;
    const r = this.texture;
    this.texture = [];
    for (let o = 0; o < n; o++)
      this.texture[o] = r.clone(), this.texture[o].isRenderTargetTexture = !0;
  }
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let i = 0, r = this.texture.length; i < r; i++)
        this.texture[i].image.width = e, this.texture[i].image.height = t, this.texture[i].image.depth = n;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, n = e.texture.length; t < n; t++)
      this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = !0;
    return this;
  }
}
class yi {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
  }
  static slerpFlat(e, t, n, i, r, o, a) {
    let l = n[i + 0], h = n[i + 1], f = n[i + 2], d = n[i + 3];
    const p = r[o + 0], m = r[o + 1], _ = r[o + 2], x = r[o + 3];
    if (a === 0) {
      e[t + 0] = l, e[t + 1] = h, e[t + 2] = f, e[t + 3] = d;
      return;
    }
    if (a === 1) {
      e[t + 0] = p, e[t + 1] = m, e[t + 2] = _, e[t + 3] = x;
      return;
    }
    if (d !== x || l !== p || h !== m || f !== _) {
      let y = 1 - a;
      const v = l * p + h * m + f * _ + d * x, S = v >= 0 ? 1 : -1, M = 1 - v * v;
      if (M > Number.EPSILON) {
        const P = Math.sqrt(M), b = Math.atan2(P, v * S);
        y = Math.sin(y * b) / P, a = Math.sin(a * b) / P;
      }
      const T = a * S;
      if (l = l * y + p * T, h = h * y + m * T, f = f * y + _ * T, d = d * y + x * T, y === 1 - a) {
        const P = 1 / Math.sqrt(l * l + h * h + f * f + d * d);
        l *= P, h *= P, f *= P, d *= P;
      }
    }
    e[t] = l, e[t + 1] = h, e[t + 2] = f, e[t + 3] = d;
  }
  static multiplyQuaternionsFlat(e, t, n, i, r, o) {
    const a = n[i], l = n[i + 1], h = n[i + 2], f = n[i + 3], d = r[o], p = r[o + 1], m = r[o + 2], _ = r[o + 3];
    return e[t] = a * _ + f * d + l * m - h * p, e[t + 1] = l * _ + f * p + h * d - a * m, e[t + 2] = h * _ + f * m + a * p - l * d, e[t + 3] = f * _ - a * d - l * p - h * m, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, n, i) {
    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = !0) {
    const n = e._x, i = e._y, r = e._z, o = e._order, a = Math.cos, l = Math.sin, h = a(n / 2), f = a(i / 2), d = a(r / 2), p = l(n / 2), m = l(i / 2), _ = l(r / 2);
    switch (o) {
      case "XYZ":
        this._x = p * f * d + h * m * _, this._y = h * m * d - p * f * _, this._z = h * f * _ + p * m * d, this._w = h * f * d - p * m * _;
        break;
      case "YXZ":
        this._x = p * f * d + h * m * _, this._y = h * m * d - p * f * _, this._z = h * f * _ - p * m * d, this._w = h * f * d + p * m * _;
        break;
      case "ZXY":
        this._x = p * f * d - h * m * _, this._y = h * m * d + p * f * _, this._z = h * f * _ + p * m * d, this._w = h * f * d - p * m * _;
        break;
      case "ZYX":
        this._x = p * f * d - h * m * _, this._y = h * m * d + p * f * _, this._z = h * f * _ - p * m * d, this._w = h * f * d + p * m * _;
        break;
      case "YZX":
        this._x = p * f * d + h * m * _, this._y = h * m * d + p * f * _, this._z = h * f * _ - p * m * d, this._w = h * f * d - p * m * _;
        break;
      case "XZY":
        this._x = p * f * d - h * m * _, this._y = h * m * d - p * f * _, this._z = h * f * _ + p * m * d, this._w = h * f * d + p * m * _;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2, i = Math.sin(n);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], i = t[4], r = t[8], o = t[1], a = t[5], l = t[9], h = t[2], f = t[6], d = t[10], p = n + a + d;
    if (p > 0) {
      const m = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / m, this._x = (f - l) * m, this._y = (r - h) * m, this._z = (o - i) * m;
    } else if (n > a && n > d) {
      const m = 2 * Math.sqrt(1 + n - a - d);
      this._w = (f - l) / m, this._x = 0.25 * m, this._y = (i + o) / m, this._z = (r + h) / m;
    } else if (a > d) {
      const m = 2 * Math.sqrt(1 + a - n - d);
      this._w = (r - h) / m, this._x = (i + o) / m, this._y = 0.25 * m, this._z = (l + f) / m;
    } else {
      const m = 2 * Math.sqrt(1 + d - n - a);
      this._w = (o - i) / m, this._x = (r + h) / m, this._y = (l + f) / m, this._z = 0.25 * m;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(En(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x, i = e._y, r = e._z, o = e._w, a = t._x, l = t._y, h = t._z, f = t._w;
    return this._x = n * f + o * a + i * h - r * l, this._y = i * f + o * l + r * a - n * h, this._z = r * f + o * h + n * l - i * a, this._w = o * f - n * a - i * l - r * h, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x, i = this._y, r = this._z, o = this._w;
    let a = o * e._w + n * e._x + i * e._y + r * e._z;
    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1)
      return this._w = o, this._x = n, this._y = i, this._z = r, this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const m = 1 - t;
      return this._w = m * o + t * this._w, this._x = m * n + t * this._x, this._y = m * i + t * this._y, this._z = m * r + t * this._z, this.normalize(), this;
    }
    const h = Math.sqrt(l), f = Math.atan2(h, a), d = Math.sin((1 - t) * f) / h, p = Math.sin(t * f) / h;
    return this._w = o * d + this._w * p, this._x = n * d + this._x * p, this._y = i * d + this._y * p, this._z = r * d + this._z * p, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), n = Math.sqrt(e), i = 2 * Math.PI * Math.random(), r = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      n * Math.sin(r),
      n * Math.cos(r),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class k {
  constructor(e = 0, t = 0, n = 0) {
    k.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Lx.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Lx.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements, o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, n = this.y, i = this.z, r = e.x, o = e.y, a = e.z, l = e.w, h = 2 * (o * i - a * n), f = 2 * (a * t - r * i), d = 2 * (r * n - o * t);
    return this.x = t + l * h + o * d - a * f, this.y = n + l * f + a * h - r * d, this.z = i + l * d + r * f - o * h, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, n = this.y, i = this.z, r = e.elements;
    return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x, i = e.y, r = e.z, o = t.x, a = t.y, l = t.z;
    return this.x = i * l - r * a, this.y = r * o - n * l, this.z = n * a - i * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Ym.copy(this).projectOnVector(e), this.sub(Ym);
  }
  reflect(e) {
    return this.sub(Ym.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(En(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = i, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, n = Math.sqrt(1 - e ** 2);
    return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Ym = /* @__PURE__ */ new k(), Lx = /* @__PURE__ */ new yi();
class xi {
  constructor(e = new k(1 / 0, 1 / 0, 1 / 0), t = new k(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(kr.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(kr.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = kr.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const r = n.getAttribute("position");
      if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = r.count; o < a; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, kr) : kr.fromBufferAttribute(r, o), kr.applyMatrix4(e.matrixWorld), this.expandByPoint(kr);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), mf.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), mf.copy(n.boundingBox)), mf.applyMatrix4(e.matrixWorld), this.union(mf);
    }
    const i = e.children;
    for (let r = 0, o = i.length; r < o; r++)
      this.expandByObject(i[r], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, kr), kr.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Wc), gf.subVectors(this.max, Wc), cl.subVectors(e.a, Wc), ul.subVectors(e.b, Wc), hl.subVectors(e.c, Wc), ro.subVectors(ul, cl), so.subVectors(hl, ul), qo.subVectors(cl, hl);
    let t = [
      0,
      -ro.z,
      ro.y,
      0,
      -so.z,
      so.y,
      0,
      -qo.z,
      qo.y,
      ro.z,
      0,
      -ro.x,
      so.z,
      0,
      -so.x,
      qo.z,
      0,
      -qo.x,
      -ro.y,
      ro.x,
      0,
      -so.y,
      so.x,
      0,
      -qo.y,
      qo.x,
      0
    ];
    return !Km(t, cl, ul, hl, gf) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Km(t, cl, ul, hl, gf)) ? !1 : (_f.crossVectors(ro, so), t = [_f.x, _f.y, _f.z], Km(t, cl, ul, hl, gf));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, kr).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(kr).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Cs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Cs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Cs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Cs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Cs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Cs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Cs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Cs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Cs), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Cs = [
  /* @__PURE__ */ new k(),
  /* @__PURE__ */ new k(),
  /* @__PURE__ */ new k(),
  /* @__PURE__ */ new k(),
  /* @__PURE__ */ new k(),
  /* @__PURE__ */ new k(),
  /* @__PURE__ */ new k(),
  /* @__PURE__ */ new k()
], kr = /* @__PURE__ */ new k(), mf = /* @__PURE__ */ new xi(), cl = /* @__PURE__ */ new k(), ul = /* @__PURE__ */ new k(), hl = /* @__PURE__ */ new k(), ro = /* @__PURE__ */ new k(), so = /* @__PURE__ */ new k(), qo = /* @__PURE__ */ new k(), Wc = /* @__PURE__ */ new k(), gf = /* @__PURE__ */ new k(), _f = /* @__PURE__ */ new k(), Qo = /* @__PURE__ */ new k();
function Km(s, e, t, n, i) {
  for (let r = 0, o = s.length - 3; r <= o; r += 3) {
    Qo.fromArray(s, r);
    const a = i.x * Math.abs(Qo.x) + i.y * Math.abs(Qo.y) + i.z * Math.abs(Qo.z), l = e.dot(Qo), h = t.dot(Qo), f = n.dot(Qo);
    if (Math.max(-Math.max(l, h, f), Math.min(l, h, f)) > a)
      return !1;
  }
  return !0;
}
const ab = /* @__PURE__ */ new xi(), Xc = /* @__PURE__ */ new k(), qm = /* @__PURE__ */ new k();
class oi {
  constructor(e = new k(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : ab.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let r = 0, o = e.length; r < o; r++)
      i = Math.max(i, n.distanceToSquared(e[r]));
    return this.radius = Math.sqrt(i), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Xc.subVectors(e, this.center);
    const t = Xc.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
      this.center.addScaledVector(Xc, i / n), this.radius += i;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (qm.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Xc.copy(e.center).add(qm)), this.expandByPoint(Xc.copy(e.center).sub(qm))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const bs = /* @__PURE__ */ new k(), Qm = /* @__PURE__ */ new k(), vf = /* @__PURE__ */ new k(), oo = /* @__PURE__ */ new k(), Zm = /* @__PURE__ */ new k(), yf = /* @__PURE__ */ new k(), jm = /* @__PURE__ */ new k();
class vc {
  constructor(e = new k(), t = new k(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, bs)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = bs.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (bs.copy(this.origin).addScaledVector(this.direction, t), bs.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    Qm.copy(e).add(t).multiplyScalar(0.5), vf.copy(t).sub(e).normalize(), oo.copy(this.origin).sub(Qm);
    const r = e.distanceTo(t) * 0.5, o = -this.direction.dot(vf), a = oo.dot(this.direction), l = -oo.dot(vf), h = oo.lengthSq(), f = Math.abs(1 - o * o);
    let d, p, m, _;
    if (f > 0)
      if (d = o * l - a, p = o * a - l, _ = r * f, d >= 0)
        if (p >= -_)
          if (p <= _) {
            const x = 1 / f;
            d *= x, p *= x, m = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + h;
          } else
            p = r, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + h;
        else
          p = -r, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + h;
      else
        p <= -_ ? (d = Math.max(0, -(-o * r + a)), p = d > 0 ? -r : Math.min(Math.max(-r, -l), r), m = -d * d + p * (p + 2 * l) + h) : p <= _ ? (d = 0, p = Math.min(Math.max(-r, -l), r), m = p * (p + 2 * l) + h) : (d = Math.max(0, -(o * r + a)), p = d > 0 ? r : Math.min(Math.max(-r, -l), r), m = -d * d + p * (p + 2 * l) + h);
    else
      p = o > 0 ? -r : r, d = Math.max(0, -(o * p + a)), m = -d * d + p * (p + 2 * l) + h;
    return n && n.copy(this.origin).addScaledVector(this.direction, d), i && i.copy(Qm).addScaledVector(vf, p), m;
  }
  intersectSphere(e, t) {
    bs.subVectors(e.center, this.origin);
    const n = bs.dot(this.direction), i = bs.dot(bs) - n * n, r = e.radius * e.radius;
    if (i > r) return null;
    const o = Math.sqrt(r - i), a = n - o, l = n + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, r, o, a, l;
    const h = 1 / this.direction.x, f = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin;
    return h >= 0 ? (n = (e.min.x - p.x) * h, i = (e.max.x - p.x) * h) : (n = (e.max.x - p.x) * h, i = (e.min.x - p.x) * h), f >= 0 ? (r = (e.min.y - p.y) * f, o = (e.max.y - p.y) * f) : (r = (e.max.y - p.y) * f, o = (e.min.y - p.y) * f), n > o || r > i || ((r > n || isNaN(n)) && (n = r), (o < i || isNaN(i)) && (i = o), d >= 0 ? (a = (e.min.z - p.z) * d, l = (e.max.z - p.z) * d) : (a = (e.max.z - p.z) * d, l = (e.min.z - p.z) * d), n > l || a > i) || ((a > n || n !== n) && (n = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, bs) !== null;
  }
  intersectTriangle(e, t, n, i, r) {
    Zm.subVectors(t, e), yf.subVectors(n, e), jm.crossVectors(Zm, yf);
    let o = this.direction.dot(jm), a;
    if (o > 0) {
      if (i) return null;
      a = 1;
    } else if (o < 0)
      a = -1, o = -o;
    else
      return null;
    oo.subVectors(this.origin, e);
    const l = a * this.direction.dot(yf.crossVectors(oo, yf));
    if (l < 0)
      return null;
    const h = a * this.direction.dot(Zm.cross(oo));
    if (h < 0 || l + h > o)
      return null;
    const f = -a * oo.dot(jm);
    return f < 0 ? null : this.at(f / o, r);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class pt {
  constructor(e, t, n, i, r, o, a, l, h, f, d, p, m, _, x, y) {
    pt.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, r, o, a, l, h, f, d, p, m, _, x, y);
  }
  set(e, t, n, i, r, o, a, l, h, f, d, p, m, _, x, y) {
    const v = this.elements;
    return v[0] = e, v[4] = t, v[8] = n, v[12] = i, v[1] = r, v[5] = o, v[9] = a, v[13] = l, v[2] = h, v[6] = f, v[10] = d, v[14] = p, v[3] = m, v[7] = _, v[11] = x, v[15] = y, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new pt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const t = this.elements, n = e.elements, i = 1 / fl.setFromMatrixColumn(e, 0).length(), r = 1 / fl.setFromMatrixColumn(e, 1).length(), o = 1 / fl.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, i = e.y, r = e.z, o = Math.cos(n), a = Math.sin(n), l = Math.cos(i), h = Math.sin(i), f = Math.cos(r), d = Math.sin(r);
    if (e.order === "XYZ") {
      const p = o * f, m = o * d, _ = a * f, x = a * d;
      t[0] = l * f, t[4] = -l * d, t[8] = h, t[1] = m + _ * h, t[5] = p - x * h, t[9] = -a * l, t[2] = x - p * h, t[6] = _ + m * h, t[10] = o * l;
    } else if (e.order === "YXZ") {
      const p = l * f, m = l * d, _ = h * f, x = h * d;
      t[0] = p + x * a, t[4] = _ * a - m, t[8] = o * h, t[1] = o * d, t[5] = o * f, t[9] = -a, t[2] = m * a - _, t[6] = x + p * a, t[10] = o * l;
    } else if (e.order === "ZXY") {
      const p = l * f, m = l * d, _ = h * f, x = h * d;
      t[0] = p - x * a, t[4] = -o * d, t[8] = _ + m * a, t[1] = m + _ * a, t[5] = o * f, t[9] = x - p * a, t[2] = -o * h, t[6] = a, t[10] = o * l;
    } else if (e.order === "ZYX") {
      const p = o * f, m = o * d, _ = a * f, x = a * d;
      t[0] = l * f, t[4] = _ * h - m, t[8] = p * h + x, t[1] = l * d, t[5] = x * h + p, t[9] = m * h - _, t[2] = -h, t[6] = a * l, t[10] = o * l;
    } else if (e.order === "YZX") {
      const p = o * l, m = o * h, _ = a * l, x = a * h;
      t[0] = l * f, t[4] = x - p * d, t[8] = _ * d + m, t[1] = d, t[5] = o * f, t[9] = -a * f, t[2] = -h * f, t[6] = m * d + _, t[10] = p - x * d;
    } else if (e.order === "XZY") {
      const p = o * l, m = o * h, _ = a * l, x = a * h;
      t[0] = l * f, t[4] = -d, t[8] = h * f, t[1] = p * d + x, t[5] = o * f, t[9] = m * d - _, t[2] = _ * d - m, t[6] = a * f, t[10] = x * d + p;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(lb, e, cb);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return tr.subVectors(e, t), tr.lengthSq() === 0 && (tr.z = 1), tr.normalize(), ao.crossVectors(n, tr), ao.lengthSq() === 0 && (Math.abs(n.z) === 1 ? tr.x += 1e-4 : tr.z += 1e-4, tr.normalize(), ao.crossVectors(n, tr)), ao.normalize(), xf.crossVectors(tr, ao), i[0] = ao.x, i[4] = xf.x, i[8] = tr.x, i[1] = ao.y, i[5] = xf.y, i[9] = tr.y, i[2] = ao.z, i[6] = xf.z, i[10] = tr.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, r = this.elements, o = n[0], a = n[4], l = n[8], h = n[12], f = n[1], d = n[5], p = n[9], m = n[13], _ = n[2], x = n[6], y = n[10], v = n[14], S = n[3], M = n[7], T = n[11], P = n[15], b = i[0], R = i[4], U = i[8], C = i[12], B = i[1], G = i[5], W = i[9], se = i[13], z = i[2], q = i[6], j = i[10], ee = i[14], N = i[3], V = i[7], I = i[11], D = i[15];
    return r[0] = o * b + a * B + l * z + h * N, r[4] = o * R + a * G + l * q + h * V, r[8] = o * U + a * W + l * j + h * I, r[12] = o * C + a * se + l * ee + h * D, r[1] = f * b + d * B + p * z + m * N, r[5] = f * R + d * G + p * q + m * V, r[9] = f * U + d * W + p * j + m * I, r[13] = f * C + d * se + p * ee + m * D, r[2] = _ * b + x * B + y * z + v * N, r[6] = _ * R + x * G + y * q + v * V, r[10] = _ * U + x * W + y * j + v * I, r[14] = _ * C + x * se + y * ee + v * D, r[3] = S * b + M * B + T * z + P * N, r[7] = S * R + M * G + T * q + P * V, r[11] = S * U + M * W + T * j + P * I, r[15] = S * C + M * se + T * ee + P * D, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], n = e[4], i = e[8], r = e[12], o = e[1], a = e[5], l = e[9], h = e[13], f = e[2], d = e[6], p = e[10], m = e[14], _ = e[3], x = e[7], y = e[11], v = e[15];
    return _ * (+r * l * d - i * h * d - r * a * p + n * h * p + i * a * m - n * l * m) + x * (+t * l * m - t * h * p + r * o * p - i * o * m + i * h * f - r * l * f) + y * (+t * h * d - t * a * m - r * o * d + n * o * m + r * a * f - n * h * f) + v * (-i * a * f - t * l * d + t * a * p + i * o * d - n * o * p + n * l * f);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
  }
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], r = e[3], o = e[4], a = e[5], l = e[6], h = e[7], f = e[8], d = e[9], p = e[10], m = e[11], _ = e[12], x = e[13], y = e[14], v = e[15], S = d * y * h - x * p * h + x * l * m - a * y * m - d * l * v + a * p * v, M = _ * p * h - f * y * h - _ * l * m + o * y * m + f * l * v - o * p * v, T = f * x * h - _ * d * h + _ * a * m - o * x * m - f * a * v + o * d * v, P = _ * d * l - f * x * l - _ * a * p + o * x * p + f * a * y - o * d * y, b = t * S + n * M + i * T + r * P;
    if (b === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const R = 1 / b;
    return e[0] = S * R, e[1] = (x * p * r - d * y * r - x * i * m + n * y * m + d * i * v - n * p * v) * R, e[2] = (a * y * r - x * l * r + x * i * h - n * y * h - a * i * v + n * l * v) * R, e[3] = (d * l * r - a * p * r - d * i * h + n * p * h + a * i * m - n * l * m) * R, e[4] = M * R, e[5] = (f * y * r - _ * p * r + _ * i * m - t * y * m - f * i * v + t * p * v) * R, e[6] = (_ * l * r - o * y * r - _ * i * h + t * y * h + o * i * v - t * l * v) * R, e[7] = (o * p * r - f * l * r + f * i * h - t * p * h - o * i * m + t * l * m) * R, e[8] = T * R, e[9] = (_ * d * r - f * x * r - _ * n * m + t * x * m + f * n * v - t * d * v) * R, e[10] = (o * x * r - _ * a * r + _ * n * h - t * x * h - o * n * v + t * a * v) * R, e[11] = (f * a * r - o * d * r - f * n * h + t * d * h + o * n * m - t * a * m) * R, e[12] = P * R, e[13] = (f * x * i - _ * d * i + _ * n * p - t * x * p - f * n * y + t * d * y) * R, e[14] = (_ * a * i - o * x * i - _ * n * l + t * x * l + o * n * y - t * a * y) * R, e[15] = (o * d * i - f * a * i + f * n * l - t * d * l - o * n * p + t * a * p) * R, this;
  }
  scale(e) {
    const t = this.elements, n = e.x, i = e.y, r = e.z;
    return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t), i = Math.sin(t), r = 1 - n, o = e.x, a = e.y, l = e.z, h = r * o, f = r * a;
    return this.set(
      h * o + n,
      h * a - i * l,
      h * l + i * a,
      0,
      h * a + i * l,
      f * a + n,
      f * l - i * o,
      0,
      h * l - i * a,
      f * l + i * o,
      r * l * l + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, t, n, i, r, o) {
    return this.set(
      1,
      n,
      r,
      0,
      e,
      1,
      o,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, t, n) {
    const i = this.elements, r = t._x, o = t._y, a = t._z, l = t._w, h = r + r, f = o + o, d = a + a, p = r * h, m = r * f, _ = r * d, x = o * f, y = o * d, v = a * d, S = l * h, M = l * f, T = l * d, P = n.x, b = n.y, R = n.z;
    return i[0] = (1 - (x + v)) * P, i[1] = (m + T) * P, i[2] = (_ - M) * P, i[3] = 0, i[4] = (m - T) * b, i[5] = (1 - (p + v)) * b, i[6] = (y + S) * b, i[7] = 0, i[8] = (_ + M) * R, i[9] = (y - S) * R, i[10] = (1 - (p + x)) * R, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  decompose(e, t, n) {
    const i = this.elements;
    let r = fl.set(i[0], i[1], i[2]).length();
    const o = fl.set(i[4], i[5], i[6]).length(), a = fl.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Gr.copy(this);
    const h = 1 / r, f = 1 / o, d = 1 / a;
    return Gr.elements[0] *= h, Gr.elements[1] *= h, Gr.elements[2] *= h, Gr.elements[4] *= f, Gr.elements[5] *= f, Gr.elements[6] *= f, Gr.elements[8] *= d, Gr.elements[9] *= d, Gr.elements[10] *= d, t.setFromRotationMatrix(Gr), n.x = r, n.y = o, n.z = a, this;
  }
  makePerspective(e, t, n, i, r, o, a = Yr) {
    const l = this.elements, h = 2 * r / (t - e), f = 2 * r / (n - i), d = (t + e) / (t - e), p = (n + i) / (n - i);
    let m, _;
    if (a === Yr)
      m = -(o + r) / (o - r), _ = -2 * o * r / (o - r);
    else if (a === sc)
      m = -o / (o - r), _ = -o * r / (o - r);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
    return l[0] = h, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = f, l[9] = p, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = m, l[14] = _, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, t, n, i, r, o, a = Yr) {
    const l = this.elements, h = 1 / (t - e), f = 1 / (n - i), d = 1 / (o - r), p = (t + e) * h, m = (n + i) * f;
    let _, x;
    if (a === Yr)
      _ = (o + r) * d, x = -2 * d;
    else if (a === sc)
      _ = r * d, x = -1 * d;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
    return l[0] = 2 * h, l[4] = 0, l[8] = 0, l[12] = -p, l[1] = 0, l[5] = 2 * f, l[9] = 0, l[13] = -m, l[2] = 0, l[6] = 0, l[10] = x, l[14] = -_, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const fl = /* @__PURE__ */ new k(), Gr = /* @__PURE__ */ new pt(), lb = /* @__PURE__ */ new k(0, 0, 0), cb = /* @__PURE__ */ new k(1, 1, 1), ao = /* @__PURE__ */ new k(), xf = /* @__PURE__ */ new k(), tr = /* @__PURE__ */ new k(), Dx = /* @__PURE__ */ new pt(), Fx = /* @__PURE__ */ new yi();
class yc {
  constructor(e = 0, t = 0, n = 0, i = yc.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements, r = i[0], o = i[4], a = i[8], l = i[1], h = i[5], f = i[9], d = i[2], p = i[6], m = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(En(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-f, m), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(p, h), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-En(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(a, m), this._z = Math.atan2(l, h)) : (this._y = Math.atan2(-d, r), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(En(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, m), this._z = Math.atan2(-o, h)) : (this._y = 0, this._z = Math.atan2(l, r));
        break;
      case "ZYX":
        this._y = Math.asin(-En(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, m), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-o, h));
        break;
      case "YZX":
        this._z = Math.asin(En(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-f, h), this._y = Math.atan2(-d, r)) : (this._x = 0, this._y = Math.atan2(a, m));
        break;
      case "XZY":
        this._z = Math.asin(-En(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, h), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-f, m), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return Dx.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Dx, t, n);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return Fx.setFromEuler(this), this.setFromQuaternion(Fx, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
yc.DEFAULT_ORDER = "XYZ";
class Ea {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let ub = 0;
const Ux = /* @__PURE__ */ new k(), dl = /* @__PURE__ */ new yi(), Rs = /* @__PURE__ */ new pt(), Af = /* @__PURE__ */ new k(), Jc = /* @__PURE__ */ new k(), hb = /* @__PURE__ */ new k(), fb = /* @__PURE__ */ new yi(), Ox = /* @__PURE__ */ new k(1, 0, 0), Nx = /* @__PURE__ */ new k(0, 1, 0), kx = /* @__PURE__ */ new k(0, 0, 1), db = { type: "added" }, pb = { type: "removed" };
class zt extends qs {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: ub++ }), this.uuid = fr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = zt.DEFAULT_UP.clone();
    const e = new k(), t = new yc(), n = new yi(), i = new k(1, 1, 1);
    function r() {
      n.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(r), n._onChange(o), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      modelViewMatrix: {
        value: new pt()
      },
      normalMatrix: {
        value: new Ct()
      }
    }), this.matrix = new pt(), this.matrixWorld = new pt(), this.matrixAutoUpdate = zt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = zt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Ea(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return dl.setFromAxisAngle(e, t), this.quaternion.multiply(dl), this;
  }
  rotateOnWorldAxis(e, t) {
    return dl.setFromAxisAngle(e, t), this.quaternion.premultiply(dl), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Ox, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Nx, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(kx, e);
  }
  translateOnAxis(e, t) {
    return Ux.copy(e).applyQuaternion(this.quaternion), this.position.add(Ux.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Ox, e);
  }
  translateY(e) {
    return this.translateOnAxis(Nx, e);
  }
  translateZ(e) {
    return this.translateOnAxis(kx, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Rs.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, n) {
    e.isVector3 ? Af.copy(e) : Af.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), Jc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Rs.lookAt(Jc, Af, this.up) : Rs.lookAt(Af, Jc, this.up), this.quaternion.setFromRotationMatrix(Rs), i && (Rs.extractRotation(i.matrixWorld), dl.setFromRotationMatrix(Rs), this.quaternion.premultiply(dl.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(db)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(pb)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Rs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Rs.multiply(e.parent.matrixWorld)), e.applyMatrix4(Rs), this.add(e), e.updateWorldMatrix(!1, !0), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const o = this.children[n].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let r = 0, o = i.length; r < o; r++)
      i[r].getObjectsByProperty(e, t, n);
    return n;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jc, e, hb), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jc, fb, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
      const i = this.children;
      for (let r = 0, o = i.length; r < o; r++) {
        const a = i[r];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((a) => ({
      boxInitialized: a.boxInitialized,
      boxMin: a.box.min.toArray(),
      boxMax: a.box.max.toArray(),
      sphereInitialized: a.sphereInitialized,
      sphereRadius: a.sphere.radius,
      sphereCenter: a.sphere.center.toArray()
    })), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (i.boundingSphere = {
      center: i.boundingSphere.center.toArray(),
      radius: i.boundingSphere.radius
    }), this.boundingBox !== null && (i.boundingBox = {
      min: i.boundingBox.min.toArray(),
      max: i.boundingBox.max.toArray()
    }));
    function r(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = r(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let h = 0, f = l.length; h < f; h++) {
            const d = l[h];
            r(e.shapes, d);
          }
        else
          r(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, h = this.material.length; l < h; l++)
          a.push(r(e.materials, this.material[l]));
        i.material = a;
      } else
        i.material = r(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        i.animations.push(r(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries), l = o(e.materials), h = o(e.textures), f = o(e.images), d = o(e.shapes), p = o(e.skeletons), m = o(e.animations), _ = o(e.nodes);
      a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), h.length > 0 && (n.textures = h), f.length > 0 && (n.images = f), d.length > 0 && (n.shapes = d), p.length > 0 && (n.skeletons = p), m.length > 0 && (n.animations = m), _.length > 0 && (n.nodes = _);
    }
    return n.object = i, n;
    function o(a) {
      const l = [];
      for (const h in a) {
        const f = a[h];
        delete f.metadata, l.push(f);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
zt.DEFAULT_UP = /* @__PURE__ */ new k(0, 1, 0);
zt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
zt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Hr = /* @__PURE__ */ new k(), Bs = /* @__PURE__ */ new k(), $m = /* @__PURE__ */ new k(), Ps = /* @__PURE__ */ new k(), pl = /* @__PURE__ */ new k(), ml = /* @__PURE__ */ new k(), Gx = /* @__PURE__ */ new k(), eg = /* @__PURE__ */ new k(), tg = /* @__PURE__ */ new k(), ng = /* @__PURE__ */ new k();
let Mf = !1;
class Vi {
  constructor(e = new k(), t = new k(), n = new k()) {
    this.a = e, this.b = t, this.c = n;
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), Hr.subVectors(e, t), i.cross(Hr);
    const r = i.lengthSq();
    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, t, n, i, r) {
    Hr.subVectors(i, t), Bs.subVectors(n, t), $m.subVectors(e, t);
    const o = Hr.dot(Hr), a = Hr.dot(Bs), l = Hr.dot($m), h = Bs.dot(Bs), f = Bs.dot($m), d = o * h - a * a;
    if (d === 0)
      return r.set(0, 0, 0), null;
    const p = 1 / d, m = (h * l - a * f) * p, _ = (o * f - a * l) * p;
    return r.set(1 - m - _, _, m);
  }
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, Ps) === null ? !1 : Ps.x >= 0 && Ps.y >= 0 && Ps.x + Ps.y <= 1;
  }
  static getUV(e, t, n, i, r, o, a, l) {
    return Mf === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Mf = !0), this.getInterpolation(e, t, n, i, r, o, a, l);
  }
  static getInterpolation(e, t, n, i, r, o, a, l) {
    return this.getBarycoord(e, t, n, i, Ps) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, Ps.x), l.addScaledVector(o, Ps.y), l.addScaledVector(a, Ps.z), l);
  }
  static isFrontFacing(e, t, n, i) {
    return Hr.subVectors(n, t), Bs.subVectors(e, t), Hr.cross(Bs).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Hr.subVectors(this.c, this.b), Bs.subVectors(this.a, this.b), Hr.cross(Bs).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Vi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Vi.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, i, r) {
    return Mf === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), Mf = !0), Vi.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
  }
  getInterpolation(e, t, n, i, r) {
    return Vi.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
  }
  containsPoint(e) {
    return Vi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Vi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a, i = this.b, r = this.c;
    let o, a;
    pl.subVectors(i, n), ml.subVectors(r, n), eg.subVectors(e, n);
    const l = pl.dot(eg), h = ml.dot(eg);
    if (l <= 0 && h <= 0)
      return t.copy(n);
    tg.subVectors(e, i);
    const f = pl.dot(tg), d = ml.dot(tg);
    if (f >= 0 && d <= f)
      return t.copy(i);
    const p = l * d - f * h;
    if (p <= 0 && l >= 0 && f <= 0)
      return o = l / (l - f), t.copy(n).addScaledVector(pl, o);
    ng.subVectors(e, r);
    const m = pl.dot(ng), _ = ml.dot(ng);
    if (_ >= 0 && m <= _)
      return t.copy(r);
    const x = m * h - l * _;
    if (x <= 0 && h >= 0 && _ <= 0)
      return a = h / (h - _), t.copy(n).addScaledVector(ml, a);
    const y = f * _ - m * d;
    if (y <= 0 && d - f >= 0 && m - _ >= 0)
      return Gx.subVectors(r, i), a = (d - f) / (d - f + (m - _)), t.copy(i).addScaledVector(Gx, a);
    const v = 1 / (y + x + p);
    return o = x * v, a = p * v, t.copy(n).addScaledVector(pl, o).addScaledVector(ml, a);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const AE = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, lo = { h: 0, s: 0, l: 0 }, Sf = { h: 0, s: 0, l: 0 };
function ig(s, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
}
class Ne {
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = Vn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Qt.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, n, i = Qt.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, Qt.toWorkingColorSpace(this, i), this;
  }
  setHSL(e, t, n, i = Qt.workingColorSpace) {
    if (e = N0(e, 1), t = En(t, 0, 1), n = En(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const r = n <= 0.5 ? n * (1 + t) : n + t - n * t, o = 2 * n - r;
      this.r = ig(o, r, e + 1 / 3), this.g = ig(o, r, e), this.b = ig(o, r, e - 1 / 3);
    }
    return Qt.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Vn) {
    function n(r) {
      r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let r;
      const o = i[1], a = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(r[4]), this.setRGB(
              Math.min(255, parseInt(r[1], 10)) / 255,
              Math.min(255, parseInt(r[2], 10)) / 255,
              Math.min(255, parseInt(r[3], 10)) / 255,
              t
            );
          if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(r[4]), this.setRGB(
              Math.min(100, parseInt(r[1], 10)) / 100,
              Math.min(100, parseInt(r[2], 10)) / 100,
              Math.min(100, parseInt(r[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(r[4]), this.setHSL(
              parseFloat(r[1]) / 360,
              parseFloat(r[2]) / 100,
              parseFloat(r[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const r = i[1], o = r.length;
      if (o === 3)
        return this.setRGB(
          parseInt(r.charAt(0), 16) / 15,
          parseInt(r.charAt(1), 16) / 15,
          parseInt(r.charAt(2), 16) / 15,
          t
        );
      if (o === 6)
        return this.setHex(parseInt(r, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Vn) {
    const n = AE[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Yl(e.r), this.g = Yl(e.g), this.b = Yl(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Xm(e.r), this.g = Xm(e.g), this.b = Xm(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Vn) {
    return Qt.fromWorkingColorSpace(di.copy(this), e), Math.round(En(di.r * 255, 0, 255)) * 65536 + Math.round(En(di.g * 255, 0, 255)) * 256 + Math.round(En(di.b * 255, 0, 255));
  }
  getHexString(e = Vn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Qt.workingColorSpace) {
    Qt.fromWorkingColorSpace(di.copy(this), t);
    const n = di.r, i = di.g, r = di.b, o = Math.max(n, i, r), a = Math.min(n, i, r);
    let l, h;
    const f = (a + o) / 2;
    if (a === o)
      l = 0, h = 0;
    else {
      const d = o - a;
      switch (h = f <= 0.5 ? d / (o + a) : d / (2 - o - a), o) {
        case n:
          l = (i - r) / d + (i < r ? 6 : 0);
          break;
        case i:
          l = (r - n) / d + 2;
          break;
        case r:
          l = (n - i) / d + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = h, e.l = f, e;
  }
  getRGB(e, t = Qt.workingColorSpace) {
    return Qt.fromWorkingColorSpace(di.copy(this), t), e.r = di.r, e.g = di.g, e.b = di.b, e;
  }
  getStyle(e = Vn) {
    Qt.fromWorkingColorSpace(di.copy(this), e);
    const t = di.r, n = di.g, i = di.b;
    return e !== Vn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  offsetHSL(e, t, n) {
    return this.getHSL(lo), this.setHSL(lo.h + e, lo.s + t, lo.l + n);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  lerpHSL(e, t) {
    this.getHSL(lo), e.getHSL(Sf);
    const n = gu(lo.h, Sf.h, t), i = gu(lo.s, Sf.s, t), r = gu(lo.l, Sf.l, t);
    return this.setHSL(n, i, r), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, n = this.g, i = this.b, r = e.elements;
    return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const di = /* @__PURE__ */ new Ne();
Ne.NAMES = AE;
let mb = 0;
class Xn extends qs {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: mb++ }), this.uuid = fr(), this.name = "", this.type = "Material", this.blending = Ma, this.side = gs, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Gd, this.blendDst = Hd, this.blendEquation = go, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ne(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Lu, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = G_, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = la, this.stencilZFail = la, this.stencilZPass = la, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Ma && (n.blending = this.blending), this.side !== gs && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Gd && (n.blendSrc = this.blendSrc), this.blendDst !== Hd && (n.blendDst = this.blendDst), this.blendEquation !== go && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== Lu && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== G_ && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== la && (n.stencilFail = this.stencilFail), this.stencilZFail !== la && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== la && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(r) {
      const o = [];
      for (const a in r) {
        const l = r[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const r = i(e.textures), o = i(e.images);
      r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let r = 0; r !== i; ++r)
        n[r] = t[r].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class ur extends Xn {
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Ne(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = sh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Us = /* @__PURE__ */ gb();
function gb() {
  const s = new ArrayBuffer(4), e = new Float32Array(s), t = new Uint32Array(s), n = new Uint32Array(512), i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const h = l - 127;
    h < -27 ? (n[l] = 0, n[l | 256] = 32768, i[l] = 24, i[l | 256] = 24) : h < -14 ? (n[l] = 1024 >> -h - 14, n[l | 256] = 1024 >> -h - 14 | 32768, i[l] = -h - 1, i[l | 256] = -h - 1) : h <= 15 ? (n[l] = h + 15 << 10, n[l | 256] = h + 15 << 10 | 32768, i[l] = 13, i[l | 256] = 13) : h < 128 ? (n[l] = 31744, n[l | 256] = 64512, i[l] = 24, i[l | 256] = 24) : (n[l] = 31744, n[l | 256] = 64512, i[l] = 13, i[l | 256] = 13);
  }
  const r = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let h = l << 13, f = 0;
    for (; (h & 8388608) === 0; )
      h <<= 1, f -= 8388608;
    h &= -8388609, f += 947912704, r[l] = h | f;
  }
  for (let l = 1024; l < 2048; ++l)
    r[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    o[l] = l << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    o[l] = 2147483648 + (l - 32 << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: r,
    exponentTable: o,
    offsetTable: a
  };
}
function Hi(s) {
  Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = En(s, -65504, 65504), Us.floatView[0] = s;
  const e = Us.uint32View[0], t = e >> 23 & 511;
  return Us.baseTable[t] + ((e & 8388607) >> Us.shiftTable[t]);
}
function au(s) {
  const e = s >> 10;
  return Us.uint32View[0] = Us.mantissaTable[Us.offsetTable[e] + (s & 1023)] + Us.exponentTable[e], Us.floatView[0];
}
const _b = {
  toHalfFloat: Hi,
  fromHalfFloat: au
}, Fn = /* @__PURE__ */ new k(), Ef = /* @__PURE__ */ new ve();
class Vt {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = Hu, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = Jr, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return console.warn("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let i = 0, r = this.itemSize; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        Ef.fromBufferAttribute(this, t), Ef.applyMatrix3(e), this.setXY(t, Ef.x, Ef.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        Fn.fromBufferAttribute(this, t), Fn.applyMatrix3(e), this.setXYZ(t, Fn.x, Fn.y, Fn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Fn.fromBufferAttribute(this, t), Fn.applyMatrix4(e), this.setXYZ(t, Fn.x, Fn.y, Fn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Fn.fromBufferAttribute(this, t), Fn.applyNormalMatrix(e), this.setXYZ(t, Fn.x, Fn.y, Fn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Fn.fromBufferAttribute(this, t), Fn.transformDirection(e), this.setXYZ(t, Fn.x, Fn.y, Fn.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = Wi(n, this.array)), n;
  }
  setComponent(e, t, n) {
    return this.normalized && (n = Tt(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = Tt(t, this.array), n = Tt(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = Tt(t, this.array), n = Tt(n, this.array), i = Tt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, r) {
    return e *= this.itemSize, this.normalized && (t = Tt(t, this.array), n = Tt(n, this.array), i = Tt(i, this.array), r = Tt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Hu && (e.usage = this.usage), e;
  }
}
class vb extends Vt {
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class yb extends Vt {
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class xb extends Vt {
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class Ab extends Vt {
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class H0 extends Vt {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class Mb extends Vt {
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class z0 extends Vt {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class Sb extends Vt {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = au(this.array[e * this.itemSize]);
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.array[e * this.itemSize] = Hi(t), this;
  }
  getY(e) {
    let t = au(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.array[e * this.itemSize + 1] = Hi(t), this;
  }
  getZ(e) {
    let t = au(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.array[e * this.itemSize + 2] = Hi(t), this;
  }
  getW(e) {
    let t = au(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.array[e * this.itemSize + 3] = Hi(t), this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = Tt(t, this.array), n = Tt(n, this.array)), this.array[e + 0] = Hi(t), this.array[e + 1] = Hi(n), this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = Tt(t, this.array), n = Tt(n, this.array), i = Tt(i, this.array)), this.array[e + 0] = Hi(t), this.array[e + 1] = Hi(n), this.array[e + 2] = Hi(i), this;
  }
  setXYZW(e, t, n, i, r) {
    return e *= this.itemSize, this.normalized && (t = Tt(t, this.array), n = Tt(n, this.array), i = Tt(i, this.array), r = Tt(r, this.array)), this.array[e + 0] = Hi(t), this.array[e + 1] = Hi(n), this.array[e + 2] = Hi(i), this.array[e + 3] = Hi(r), this;
  }
}
class $e extends Vt {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
class Eb extends Vt {
  constructor(e, t, n) {
    super(new Float64Array(e), t, n);
  }
}
let Tb = 0;
const Cr = /* @__PURE__ */ new pt(), rg = /* @__PURE__ */ new zt(), gl = /* @__PURE__ */ new k(), nr = /* @__PURE__ */ new xi(), Yc = /* @__PURE__ */ new xi(), jn = /* @__PURE__ */ new k();
class Mt extends qs {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Tb++ }), this.uuid = fr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (vE(e) ? z0 : H0)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const r = new Ct().getNormalMatrix(e);
      n.applyNormalMatrix(r), n.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Cr.makeRotationFromQuaternion(e), this.applyMatrix4(Cr), this;
  }
  rotateX(e) {
    return Cr.makeRotationX(e), this.applyMatrix4(Cr), this;
  }
  rotateY(e) {
    return Cr.makeRotationY(e), this.applyMatrix4(Cr), this;
  }
  rotateZ(e) {
    return Cr.makeRotationZ(e), this.applyMatrix4(Cr), this;
  }
  translate(e, t, n) {
    return Cr.makeTranslation(e, t, n), this.applyMatrix4(Cr), this;
  }
  scale(e, t, n) {
    return Cr.makeScale(e, t, n), this.applyMatrix4(Cr), this;
  }
  lookAt(e) {
    return rg.lookAt(e), rg.updateMatrix(), this.applyMatrix4(rg.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(gl).negate(), this.translate(gl.x, gl.y, gl.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const r = e[n];
      t.push(r.x, r.y, r.z || 0);
    }
    return this.setAttribute("position", new $e(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new xi());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(
        new k(-1 / 0, -1 / 0, -1 / 0),
        new k(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, i = t.length; n < i; n++) {
          const r = t[n];
          nr.setFromBufferAttribute(r), this.morphTargetsRelative ? (jn.addVectors(this.boundingBox.min, nr.min), this.boundingBox.expandByPoint(jn), jn.addVectors(this.boundingBox.max, nr.max), this.boundingBox.expandByPoint(jn)) : (this.boundingBox.expandByPoint(nr.min), this.boundingBox.expandByPoint(nr.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new oi());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new k(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (nr.setFromBufferAttribute(e), t)
        for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r];
          Yc.setFromBufferAttribute(a), this.morphTargetsRelative ? (jn.addVectors(nr.min, Yc.min), nr.expandByPoint(jn), jn.addVectors(nr.max, Yc.max), nr.expandByPoint(jn)) : (nr.expandByPoint(Yc.min), nr.expandByPoint(Yc.max));
        }
      nr.getCenter(n);
      let i = 0;
      for (let r = 0, o = e.count; r < o; r++)
        jn.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(jn));
      if (t)
        for (let r = 0, o = t.length; r < o; r++) {
          const a = t[r], l = this.morphTargetsRelative;
          for (let h = 0, f = a.count; h < f; h++)
            jn.fromBufferAttribute(a, h), l && (gl.fromBufferAttribute(e, h), jn.add(gl)), i = Math.max(i, n.distanceToSquared(jn));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = e.array, i = t.position.array, r = t.normal.array, o = t.uv.array, a = i.length / 3;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Vt(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array, h = [], f = [];
    for (let B = 0; B < a; B++)
      h[B] = new k(), f[B] = new k();
    const d = new k(), p = new k(), m = new k(), _ = new ve(), x = new ve(), y = new ve(), v = new k(), S = new k();
    function M(B, G, W) {
      d.fromArray(i, B * 3), p.fromArray(i, G * 3), m.fromArray(i, W * 3), _.fromArray(o, B * 2), x.fromArray(o, G * 2), y.fromArray(o, W * 2), p.sub(d), m.sub(d), x.sub(_), y.sub(_);
      const se = 1 / (x.x * y.y - y.x * x.y);
      isFinite(se) && (v.copy(p).multiplyScalar(y.y).addScaledVector(m, -x.y).multiplyScalar(se), S.copy(m).multiplyScalar(x.x).addScaledVector(p, -y.x).multiplyScalar(se), h[B].add(v), h[G].add(v), h[W].add(v), f[B].add(S), f[G].add(S), f[W].add(S));
    }
    let T = this.groups;
    T.length === 0 && (T = [{
      start: 0,
      count: n.length
    }]);
    for (let B = 0, G = T.length; B < G; ++B) {
      const W = T[B], se = W.start, z = W.count;
      for (let q = se, j = se + z; q < j; q += 3)
        M(
          n[q + 0],
          n[q + 1],
          n[q + 2]
        );
    }
    const P = new k(), b = new k(), R = new k(), U = new k();
    function C(B) {
      R.fromArray(r, B * 3), U.copy(R);
      const G = h[B];
      P.copy(G), P.sub(R.multiplyScalar(R.dot(G))).normalize(), b.crossVectors(U, G);
      const se = b.dot(f[B]) < 0 ? -1 : 1;
      l[B * 4] = P.x, l[B * 4 + 1] = P.y, l[B * 4 + 2] = P.z, l[B * 4 + 3] = se;
    }
    for (let B = 0, G = T.length; B < G; ++B) {
      const W = T[B], se = W.start, z = W.count;
      for (let q = se, j = se + z; q < j; q += 3)
        C(n[q + 0]), C(n[q + 1]), C(n[q + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Vt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let p = 0, m = n.count; p < m; p++)
          n.setXYZ(p, 0, 0, 0);
      const i = new k(), r = new k(), o = new k(), a = new k(), l = new k(), h = new k(), f = new k(), d = new k();
      if (e)
        for (let p = 0, m = e.count; p < m; p += 3) {
          const _ = e.getX(p + 0), x = e.getX(p + 1), y = e.getX(p + 2);
          i.fromBufferAttribute(t, _), r.fromBufferAttribute(t, x), o.fromBufferAttribute(t, y), f.subVectors(o, r), d.subVectors(i, r), f.cross(d), a.fromBufferAttribute(n, _), l.fromBufferAttribute(n, x), h.fromBufferAttribute(n, y), a.add(f), l.add(f), h.add(f), n.setXYZ(_, a.x, a.y, a.z), n.setXYZ(x, l.x, l.y, l.z), n.setXYZ(y, h.x, h.y, h.z);
        }
      else
        for (let p = 0, m = t.count; p < m; p += 3)
          i.fromBufferAttribute(t, p + 0), r.fromBufferAttribute(t, p + 1), o.fromBufferAttribute(t, p + 2), f.subVectors(o, r), d.subVectors(i, r), f.cross(d), n.setXYZ(p + 0, f.x, f.y, f.z), n.setXYZ(p + 1, f.x, f.y, f.z), n.setXYZ(p + 2, f.x, f.y, f.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      jn.fromBufferAttribute(e, t), jn.normalize(), e.setXYZ(t, jn.x, jn.y, jn.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const h = a.array, f = a.itemSize, d = a.normalized, p = new h.constructor(l.length * f);
      let m = 0, _ = 0;
      for (let x = 0, y = l.length; x < y; x++) {
        a.isInterleavedBufferAttribute ? m = l[x] * a.data.stride + a.offset : m = l[x] * f;
        for (let v = 0; v < f; v++)
          p[_++] = h[m++];
      }
      return new Vt(p, f, d);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Mt(), n = this.index.array, i = this.attributes;
    for (const a in i) {
      const l = i[a], h = e(l, n);
      t.setAttribute(a, h);
    }
    const r = this.morphAttributes;
    for (const a in r) {
      const l = [], h = r[a];
      for (let f = 0, d = h.length; f < d; f++) {
        const p = h[f], m = e(p, n);
        l.push(m);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const h = o[a];
      t.addGroup(h.start, h.count, h.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const h in l)
        l[h] !== void 0 && (e[h] = l[h]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const l in n) {
      const h = n[l];
      e.data.attributes[l] = h.toJSON(e.data);
    }
    const i = {};
    let r = !1;
    for (const l in this.morphAttributes) {
      const h = this.morphAttributes[l], f = [];
      for (let d = 0, p = h.length; d < p; d++) {
        const m = h[d];
        f.push(m.toJSON(e.data));
      }
      f.length > 0 && (i[l] = f, r = !0);
    }
    r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return a !== null && (e.data.boundingSphere = {
      center: a.center.toArray(),
      radius: a.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const h in i) {
      const f = i[h];
      this.setAttribute(h, f.clone(t));
    }
    const r = e.morphAttributes;
    for (const h in r) {
      const f = [], d = r[h];
      for (let p = 0, m = d.length; p < m; p++)
        f.push(d[p].clone(t));
      this.morphAttributes[h] = f;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let h = 0, f = o.length; h < f; h++) {
      const d = o[h];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Hx = /* @__PURE__ */ new pt(), Zo = /* @__PURE__ */ new vc(), Tf = /* @__PURE__ */ new oi(), zx = /* @__PURE__ */ new k(), _l = /* @__PURE__ */ new k(), vl = /* @__PURE__ */ new k(), yl = /* @__PURE__ */ new k(), sg = /* @__PURE__ */ new k(), wf = /* @__PURE__ */ new k(), Cf = /* @__PURE__ */ new ve(), bf = /* @__PURE__ */ new ve(), Rf = /* @__PURE__ */ new ve(), Vx = /* @__PURE__ */ new k(), Wx = /* @__PURE__ */ new k(), Xx = /* @__PURE__ */ new k(), Bf = /* @__PURE__ */ new k(), Pf = /* @__PURE__ */ new k();
class kn extends zt {
  constructor(e = new Mt(), t = new ur()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = i.length; r < o; r++) {
          const a = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry, i = n.attributes.position, r = n.morphAttributes.position, o = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const a = this.morphTargetInfluences;
    if (r && a) {
      wf.set(0, 0, 0);
      for (let l = 0, h = r.length; l < h; l++) {
        const f = a[l], d = r[l];
        f !== 0 && (sg.fromBufferAttribute(d, e), o ? wf.addScaledVector(sg, f) : wf.addScaledVector(sg.sub(t), f));
      }
      t.add(wf);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.material, r = this.matrixWorld;
    i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), Tf.copy(n.boundingSphere), Tf.applyMatrix4(r), Zo.copy(e.ray).recast(e.near), !(Tf.containsPoint(Zo.origin) === !1 && (Zo.intersectSphere(Tf, zx) === null || Zo.origin.distanceToSquared(zx) > (e.far - e.near) ** 2)) && (Hx.copy(r).invert(), Zo.copy(e.ray).applyMatrix4(Hx), !(n.boundingBox !== null && Zo.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Zo)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const r = this.geometry, o = this.material, a = r.index, l = r.attributes.position, h = r.attributes.uv, f = r.attributes.uv1, d = r.attributes.normal, p = r.groups, m = r.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let _ = 0, x = p.length; _ < x; _++) {
          const y = p[_], v = o[y.materialIndex], S = Math.max(y.start, m.start), M = Math.min(a.count, Math.min(y.start + y.count, m.start + m.count));
          for (let T = S, P = M; T < P; T += 3) {
            const b = a.getX(T), R = a.getX(T + 1), U = a.getX(T + 2);
            i = If(this, v, e, n, h, f, d, b, R, U), i && (i.faceIndex = Math.floor(T / 3), i.face.materialIndex = y.materialIndex, t.push(i));
          }
        }
      else {
        const _ = Math.max(0, m.start), x = Math.min(a.count, m.start + m.count);
        for (let y = _, v = x; y < v; y += 3) {
          const S = a.getX(y), M = a.getX(y + 1), T = a.getX(y + 2);
          i = If(this, o, e, n, h, f, d, S, M, T), i && (i.faceIndex = Math.floor(y / 3), t.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let _ = 0, x = p.length; _ < x; _++) {
          const y = p[_], v = o[y.materialIndex], S = Math.max(y.start, m.start), M = Math.min(l.count, Math.min(y.start + y.count, m.start + m.count));
          for (let T = S, P = M; T < P; T += 3) {
            const b = T, R = T + 1, U = T + 2;
            i = If(this, v, e, n, h, f, d, b, R, U), i && (i.faceIndex = Math.floor(T / 3), i.face.materialIndex = y.materialIndex, t.push(i));
          }
        }
      else {
        const _ = Math.max(0, m.start), x = Math.min(l.count, m.start + m.count);
        for (let y = _, v = x; y < v; y += 3) {
          const S = y, M = y + 1, T = y + 2;
          i = If(this, o, e, n, h, f, d, S, M, T), i && (i.faceIndex = Math.floor(y / 3), t.push(i));
        }
      }
  }
}
function wb(s, e, t, n, i, r, o, a) {
  let l;
  if (e.side === Oi ? l = n.intersectTriangle(o, r, i, !0, a) : l = n.intersectTriangle(i, r, o, e.side === gs, a), l === null) return null;
  Pf.copy(a), Pf.applyMatrix4(s.matrixWorld);
  const h = t.ray.origin.distanceTo(Pf);
  return h < t.near || h > t.far ? null : {
    distance: h,
    point: Pf.clone(),
    object: s
  };
}
function If(s, e, t, n, i, r, o, a, l, h) {
  s.getVertexPosition(a, _l), s.getVertexPosition(l, vl), s.getVertexPosition(h, yl);
  const f = wb(s, e, t, n, _l, vl, yl, Bf);
  if (f) {
    i && (Cf.fromBufferAttribute(i, a), bf.fromBufferAttribute(i, l), Rf.fromBufferAttribute(i, h), f.uv = Vi.getInterpolation(Bf, _l, vl, yl, Cf, bf, Rf, new ve())), r && (Cf.fromBufferAttribute(r, a), bf.fromBufferAttribute(r, l), Rf.fromBufferAttribute(r, h), f.uv1 = Vi.getInterpolation(Bf, _l, vl, yl, Cf, bf, Rf, new ve()), f.uv2 = f.uv1), o && (Vx.fromBufferAttribute(o, a), Wx.fromBufferAttribute(o, l), Xx.fromBufferAttribute(o, h), f.normal = Vi.getInterpolation(Bf, _l, vl, yl, Vx, Wx, Xx, new k()), f.normal.dot(n.direction) > 0 && f.normal.multiplyScalar(-1));
    const d = {
      a,
      b: l,
      c: h,
      normal: new k(),
      materialIndex: 0
    };
    Vi.getNormal(_l, vl, yl, d.normal), f.face = d;
  }
  return f;
}
class Wa extends Mt {
  constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: i,
      heightSegments: r,
      depthSegments: o
    };
    const a = this;
    i = Math.floor(i), r = Math.floor(r), o = Math.floor(o);
    const l = [], h = [], f = [], d = [];
    let p = 0, m = 0;
    _("z", "y", "x", -1, -1, n, t, e, o, r, 0), _("z", "y", "x", 1, -1, n, t, -e, o, r, 1), _("x", "z", "y", 1, 1, e, n, t, i, o, 2), _("x", "z", "y", 1, -1, e, n, -t, i, o, 3), _("x", "y", "z", 1, -1, e, t, n, i, r, 4), _("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(l), this.setAttribute("position", new $e(h, 3)), this.setAttribute("normal", new $e(f, 3)), this.setAttribute("uv", new $e(d, 2));
    function _(x, y, v, S, M, T, P, b, R, U, C) {
      const B = T / R, G = P / U, W = T / 2, se = P / 2, z = b / 2, q = R + 1, j = U + 1;
      let ee = 0, N = 0;
      const V = new k();
      for (let I = 0; I < j; I++) {
        const D = I * G - se;
        for (let J = 0; J < q; J++) {
          const K = J * B - W;
          V[x] = K * S, V[y] = D * M, V[v] = z, h.push(V.x, V.y, V.z), V[x] = 0, V[y] = 0, V[v] = b > 0 ? 1 : -1, f.push(V.x, V.y, V.z), d.push(J / R), d.push(1 - I / U), ee += 1;
        }
      }
      for (let I = 0; I < U; I++)
        for (let D = 0; D < R; D++) {
          const J = p + D + q * I, K = p + D + q * (I + 1), ie = p + (D + 1) + q * (I + 1), he = p + (D + 1) + q * I;
          l.push(J, K, he), l.push(K, ie, he), N += 6;
        }
      a.addGroup(m, N, C), m += N, p += ee;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Wa(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function ac(s) {
  const e = {};
  for (const t in s) {
    e[t] = {};
    for (const n in s[t]) {
      const i = s[t][n];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
    }
  }
  return e;
}
function Bi(s) {
  const e = {};
  for (let t = 0; t < s.length; t++) {
    const n = ac(s[t]);
    for (const i in n)
      e[i] = n[i];
  }
  return e;
}
function Cb(s) {
  const e = [];
  for (let t = 0; t < s.length; t++)
    e.push(s[t].clone());
  return e;
}
function ME(s) {
  return s.getRenderTarget() === null ? s.outputColorSpace : Qt.workingColorSpace;
}
const SE = { clone: ac, merge: Bi };
var bb = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Rb = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ys extends Xn {
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = bb, this.fragmentShader = Rb, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      derivatives: !1,
      // set to use derivatives
      fragDepth: !1,
      // set to use fragment depth values
      drawBuffers: !1,
      // set to use draw buffers
      shaderTextureLOD: !1,
      // set to use shader texture LOD
      clipCullDistance: !1
      // set to use vertex shader clipping
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ac(e.uniforms), this.uniformsGroups = Cb(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture ? t.uniforms[i] = {
        type: "t",
        value: o.toJSON(e).uuid
      } : o && o.isColor ? t.uniforms[i] = {
        type: "c",
        value: o.getHex()
      } : o && o.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: o.toArray()
      } : o && o.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: o.toArray()
      } : o && o.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: o.toArray()
      } : o && o.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: o.toArray()
      } : o && o.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: o.toArray()
      } : t.uniforms[i] = {
        value: o
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class ah extends zt {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new pt(), this.projectionMatrix = new pt(), this.projectionMatrixInverse = new pt(), this.coordinateSystem = Yr;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Wn extends ah {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = oc * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(Sa * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return oc * 2 * Math.atan(
      Math.tan(Sa * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, t, n, i, r, o) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(Sa * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, r = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, h = o.fullHeight;
      r += o.offsetX * i / l, t -= o.offsetY * n / h, i *= o.width / l, n *= o.height / h;
    }
    const a = this.filmOffset;
    a !== 0 && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const xl = -90, Al = 1;
class EE extends zt {
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new Wn(xl, Al, e, t);
    i.layers = this.layers, this.add(i);
    const r = new Wn(xl, Al, e, t);
    r.layers = this.layers, this.add(r);
    const o = new Wn(xl, Al, e, t);
    o.layers = this.layers, this.add(o);
    const a = new Wn(xl, Al, e, t);
    a.layers = this.layers, this.add(a);
    const l = new Wn(xl, Al, e, t);
    l.layers = this.layers, this.add(l);
    const h = new Wn(xl, Al, e, t);
    h.layers = this.layers, this.add(h);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, i, r, o, a, l] = t;
    for (const h of t) this.remove(h);
    if (e === Yr)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (e === sc)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const h of t)
      this.add(h), h.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [r, o, a, l, h, f] = this.children, d = e.getRenderTarget(), p = e.getActiveCubeFace(), m = e.getActiveMipmapLevel(), _ = e.xr.enabled;
    e.xr.enabled = !1;
    const x = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, o), e.setRenderTarget(n, 2, i), e.render(t, a), e.setRenderTarget(n, 3, i), e.render(t, l), e.setRenderTarget(n, 4, i), e.render(t, h), n.texture.generateMipmaps = x, e.setRenderTarget(n, 5, i), e.render(t, f), e.setRenderTarget(d, p, m), e.xr.enabled = _, n.texture.needsPMREMUpdate = !0;
  }
}
class lh extends yn {
  constructor(e, t, n, i, r, o, a, l, h, f) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : Xs, super(e, t, n, i, r, o, a, l, h, f), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class TE extends Kr {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n];
    t.encoding !== void 0 && (vu("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === Eo ? Vn : ar), this.texture = new lh(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : gn;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new Wa(5, 5, 5), r = new ys({
      name: "CubemapFromEquirect",
      uniforms: ac(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: Oi,
      blending: zs
    });
    r.uniforms.tEquirect.value = t;
    const o = new kn(i, r), a = t.minFilter;
    return t.minFilter === _s && (t.minFilter = gn), new EE(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, t, n, i) {
    const r = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(t, n, i);
    e.setRenderTarget(r);
  }
}
const og = /* @__PURE__ */ new k(), Bb = /* @__PURE__ */ new k(), Pb = /* @__PURE__ */ new Ct();
class mo {
  constructor(e = new k(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), this.constant = i, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = og.subVectors(n, t).cross(Bb.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(og), i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const r = -(e.start.dot(this.normal) + this.constant) / i;
    return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || Pb.getNormalMatrix(e), i = this.coplanarPoint(og).applyMatrix4(e), r = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(r), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const jo = /* @__PURE__ */ new oi(), Lf = /* @__PURE__ */ new k();
class ch {
  constructor(e = new mo(), t = new mo(), n = new mo(), i = new mo(), r = new mo(), o = new mo()) {
    this.planes = [e, t, n, i, r, o];
  }
  set(e, t, n, i, r, o) {
    const a = this.planes;
    return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this;
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e, t = Yr) {
    const n = this.planes, i = e.elements, r = i[0], o = i[1], a = i[2], l = i[3], h = i[4], f = i[5], d = i[6], p = i[7], m = i[8], _ = i[9], x = i[10], y = i[11], v = i[12], S = i[13], M = i[14], T = i[15];
    if (n[0].setComponents(l - r, p - h, y - m, T - v).normalize(), n[1].setComponents(l + r, p + h, y + m, T + v).normalize(), n[2].setComponents(l + o, p + f, y + _, T + S).normalize(), n[3].setComponents(l - o, p - f, y - _, T - S).normalize(), n[4].setComponents(l - a, p - d, y - x, T - M).normalize(), t === Yr)
      n[5].setComponents(l + a, p + d, y + x, T + M).normalize();
    else if (t === sc)
      n[5].setComponents(a, d, x, M).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), jo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), jo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(jo);
  }
  intersectsSprite(e) {
    return jo.center.set(0, 0, 0), jo.radius = 0.7071067811865476, jo.applyMatrix4(e.matrixWorld), this.intersectsSphere(jo);
  }
  intersectsSphere(e) {
    const t = this.planes, n = e.center, i = -e.radius;
    for (let r = 0; r < 6; r++)
      if (t[r].distanceToPoint(n) < i)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (Lf.x = i.normal.x > 0 ? e.max.x : e.min.x, Lf.y = i.normal.y > 0 ? e.max.y : e.min.y, Lf.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Lf) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function wE() {
  let s = null, e = !1, t = null, n = null;
  function i(r, o) {
    t(r, o), n = s.requestAnimationFrame(i);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = s.requestAnimationFrame(i), e = !0);
    },
    stop: function() {
      s.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(r) {
      t = r;
    },
    setContext: function(r) {
      s = r;
    }
  };
}
function Ib(s, e) {
  const t = e.isWebGL2, n = /* @__PURE__ */ new WeakMap();
  function i(h, f) {
    const d = h.array, p = h.usage, m = d.byteLength, _ = s.createBuffer();
    s.bindBuffer(f, _), s.bufferData(f, d, p), h.onUploadCallback();
    let x;
    if (d instanceof Float32Array)
      x = s.FLOAT;
    else if (d instanceof Uint16Array)
      if (h.isFloat16BufferAttribute)
        if (t)
          x = s.HALF_FLOAT;
        else
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
      else
        x = s.UNSIGNED_SHORT;
    else if (d instanceof Int16Array)
      x = s.SHORT;
    else if (d instanceof Uint32Array)
      x = s.UNSIGNED_INT;
    else if (d instanceof Int32Array)
      x = s.INT;
    else if (d instanceof Int8Array)
      x = s.BYTE;
    else if (d instanceof Uint8Array)
      x = s.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray)
      x = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d);
    return {
      buffer: _,
      type: x,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: h.version,
      size: m
    };
  }
  function r(h, f, d) {
    const p = f.array, m = f._updateRange, _ = f.updateRanges;
    if (s.bindBuffer(d, h), m.count === -1 && _.length === 0 && s.bufferSubData(d, 0, p), _.length !== 0) {
      for (let x = 0, y = _.length; x < y; x++) {
        const v = _[x];
        t ? s.bufferSubData(
          d,
          v.start * p.BYTES_PER_ELEMENT,
          p,
          v.start,
          v.count
        ) : s.bufferSubData(
          d,
          v.start * p.BYTES_PER_ELEMENT,
          p.subarray(v.start, v.start + v.count)
        );
      }
      f.clearUpdateRanges();
    }
    m.count !== -1 && (t ? s.bufferSubData(
      d,
      m.offset * p.BYTES_PER_ELEMENT,
      p,
      m.offset,
      m.count
    ) : s.bufferSubData(
      d,
      m.offset * p.BYTES_PER_ELEMENT,
      p.subarray(m.offset, m.offset + m.count)
    ), m.count = -1), f.onUploadCallback();
  }
  function o(h) {
    return h.isInterleavedBufferAttribute && (h = h.data), n.get(h);
  }
  function a(h) {
    h.isInterleavedBufferAttribute && (h = h.data);
    const f = n.get(h);
    f && (s.deleteBuffer(f.buffer), n.delete(h));
  }
  function l(h, f) {
    if (h.isGLBufferAttribute) {
      const p = n.get(h);
      (!p || p.version < h.version) && n.set(h, {
        buffer: h.buffer,
        type: h.type,
        bytesPerElement: h.elementSize,
        version: h.version
      });
      return;
    }
    h.isInterleavedBufferAttribute && (h = h.data);
    const d = n.get(h);
    if (d === void 0)
      n.set(h, i(h, f));
    else if (d.version < h.version) {
      if (d.size !== h.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      r(d.buffer, h, f), d.version = h.version;
    }
  }
  return {
    get: o,
    remove: a,
    update: l
  };
}
class uh extends Mt {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: i
    };
    const r = e / 2, o = t / 2, a = Math.floor(n), l = Math.floor(i), h = a + 1, f = l + 1, d = e / a, p = t / l, m = [], _ = [], x = [], y = [];
    for (let v = 0; v < f; v++) {
      const S = v * p - o;
      for (let M = 0; M < h; M++) {
        const T = M * d - r;
        _.push(T, -S, 0), x.push(0, 0, 1), y.push(M / a), y.push(1 - v / l);
      }
    }
    for (let v = 0; v < l; v++)
      for (let S = 0; S < a; S++) {
        const M = S + h * v, T = S + h * (v + 1), P = S + 1 + h * (v + 1), b = S + 1 + h * v;
        m.push(M, T, b), m.push(T, P, b);
      }
    this.setIndex(m), this.setAttribute("position", new $e(_, 3)), this.setAttribute("normal", new $e(x, 3)), this.setAttribute("uv", new $e(y, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new uh(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var Lb = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Db = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, Fb = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Ub = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Ob = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, Nb = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, kb = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Gb = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Hb = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, zb = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, Vb = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, Wb = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Xb = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, Jb = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Yb = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Kb = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, qb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Qb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, Zb = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, jb = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, $b = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, eR = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, tR = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, nR = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, iR = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, rR = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, sR = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, oR = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, aR = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, lR = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, cR = "gl_FragColor = linearToOutputTexel( gl_FragColor );", uR = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, hR = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, fR = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, dR = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, pR = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, mR = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, gR = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, _R = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, vR = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, yR = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, xR = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, AR = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, MR = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, SR = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, ER = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, TR = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, wR = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, CR = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, bR = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, RR = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, BR = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, PR = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, IR = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, LR = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, DR = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, FR = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, UR = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, OR = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, NR = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, kR = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, GR = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, HR = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, zR = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, VR = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, WR = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, XR = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, JR = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, YR = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, KR = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, qR = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, QR = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, ZR = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, jR = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, $R = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, eB = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, tB = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, nB = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, iB = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, rB = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, sB = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, oB = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, aB = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, lB = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, cB = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, uB = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, hB = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, fB = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, dB = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, pB = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, mB = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, gB = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, _B = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, vB = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, yB = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, xB = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, AB = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, MB = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, SB = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, EB = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, TB = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color *= toneMappingExposure;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, wB = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, CB = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, bB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, RB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, BB = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, PB = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const IB = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, LB = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, DB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, FB = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, UB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, OB = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, NB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, kB = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, GB = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, HB = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, zB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, VB = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, WB = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, XB = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, JB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, YB = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, KB = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, qB = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, QB = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, ZB = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, jB = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, $B = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, eP = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, tP = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, nP = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, iP = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, rP = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, sP = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, oP = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, aP = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, lP = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, cP = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, uP = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, hP = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Et = {
  alphahash_fragment: Lb,
  alphahash_pars_fragment: Db,
  alphamap_fragment: Fb,
  alphamap_pars_fragment: Ub,
  alphatest_fragment: Ob,
  alphatest_pars_fragment: Nb,
  aomap_fragment: kb,
  aomap_pars_fragment: Gb,
  batching_pars_vertex: Hb,
  batching_vertex: zb,
  begin_vertex: Vb,
  beginnormal_vertex: Wb,
  bsdfs: Xb,
  iridescence_fragment: Jb,
  bumpmap_pars_fragment: Yb,
  clipping_planes_fragment: Kb,
  clipping_planes_pars_fragment: qb,
  clipping_planes_pars_vertex: Qb,
  clipping_planes_vertex: Zb,
  color_fragment: jb,
  color_pars_fragment: $b,
  color_pars_vertex: eR,
  color_vertex: tR,
  common: nR,
  cube_uv_reflection_fragment: iR,
  defaultnormal_vertex: rR,
  displacementmap_pars_vertex: sR,
  displacementmap_vertex: oR,
  emissivemap_fragment: aR,
  emissivemap_pars_fragment: lR,
  colorspace_fragment: cR,
  colorspace_pars_fragment: uR,
  envmap_fragment: hR,
  envmap_common_pars_fragment: fR,
  envmap_pars_fragment: dR,
  envmap_pars_vertex: pR,
  envmap_physical_pars_fragment: wR,
  envmap_vertex: mR,
  fog_vertex: gR,
  fog_pars_vertex: _R,
  fog_fragment: vR,
  fog_pars_fragment: yR,
  gradientmap_pars_fragment: xR,
  lightmap_fragment: AR,
  lightmap_pars_fragment: MR,
  lights_lambert_fragment: SR,
  lights_lambert_pars_fragment: ER,
  lights_pars_begin: TR,
  lights_toon_fragment: CR,
  lights_toon_pars_fragment: bR,
  lights_phong_fragment: RR,
  lights_phong_pars_fragment: BR,
  lights_physical_fragment: PR,
  lights_physical_pars_fragment: IR,
  lights_fragment_begin: LR,
  lights_fragment_maps: DR,
  lights_fragment_end: FR,
  logdepthbuf_fragment: UR,
  logdepthbuf_pars_fragment: OR,
  logdepthbuf_pars_vertex: NR,
  logdepthbuf_vertex: kR,
  map_fragment: GR,
  map_pars_fragment: HR,
  map_particle_fragment: zR,
  map_particle_pars_fragment: VR,
  metalnessmap_fragment: WR,
  metalnessmap_pars_fragment: XR,
  morphcolor_vertex: JR,
  morphnormal_vertex: YR,
  morphtarget_pars_vertex: KR,
  morphtarget_vertex: qR,
  normal_fragment_begin: QR,
  normal_fragment_maps: ZR,
  normal_pars_fragment: jR,
  normal_pars_vertex: $R,
  normal_vertex: eB,
  normalmap_pars_fragment: tB,
  clearcoat_normal_fragment_begin: nB,
  clearcoat_normal_fragment_maps: iB,
  clearcoat_pars_fragment: rB,
  iridescence_pars_fragment: sB,
  opaque_fragment: oB,
  packing: aB,
  premultiplied_alpha_fragment: lB,
  project_vertex: cB,
  dithering_fragment: uB,
  dithering_pars_fragment: hB,
  roughnessmap_fragment: fB,
  roughnessmap_pars_fragment: dB,
  shadowmap_pars_fragment: pB,
  shadowmap_pars_vertex: mB,
  shadowmap_vertex: gB,
  shadowmask_pars_fragment: _B,
  skinbase_vertex: vB,
  skinning_pars_vertex: yB,
  skinning_vertex: xB,
  skinnormal_vertex: AB,
  specularmap_fragment: MB,
  specularmap_pars_fragment: SB,
  tonemapping_fragment: EB,
  tonemapping_pars_fragment: TB,
  transmission_fragment: wB,
  transmission_pars_fragment: CB,
  uv_pars_fragment: bB,
  uv_pars_vertex: RB,
  uv_vertex: BB,
  worldpos_vertex: PB,
  background_vert: IB,
  background_frag: LB,
  backgroundCube_vert: DB,
  backgroundCube_frag: FB,
  cube_vert: UB,
  cube_frag: OB,
  depth_vert: NB,
  depth_frag: kB,
  distanceRGBA_vert: GB,
  distanceRGBA_frag: HB,
  equirect_vert: zB,
  equirect_frag: VB,
  linedashed_vert: WB,
  linedashed_frag: XB,
  meshbasic_vert: JB,
  meshbasic_frag: YB,
  meshlambert_vert: KB,
  meshlambert_frag: qB,
  meshmatcap_vert: QB,
  meshmatcap_frag: ZB,
  meshnormal_vert: jB,
  meshnormal_frag: $B,
  meshphong_vert: eP,
  meshphong_frag: tP,
  meshphysical_vert: nP,
  meshphysical_frag: iP,
  meshtoon_vert: rP,
  meshtoon_frag: sP,
  points_vert: oP,
  points_frag: aP,
  shadow_vert: lP,
  shadow_frag: cP,
  sprite_vert: uP,
  sprite_frag: hP
}, Fe = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Ne(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Ct() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ct() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Ct() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Ct() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Ct() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Ct() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Ct() },
    normalScale: { value: /* @__PURE__ */ new ve(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Ct() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Ct() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Ct() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Ct() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Ne(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Ne(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ct() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Ct() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Ne(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new ve(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Ct() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Ct() },
    alphaTest: { value: 0 }
  }
}, Wr = {
  basic: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.common,
      Fe.specularmap,
      Fe.envmap,
      Fe.aomap,
      Fe.lightmap,
      Fe.fog
    ]),
    vertexShader: Et.meshbasic_vert,
    fragmentShader: Et.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.common,
      Fe.specularmap,
      Fe.envmap,
      Fe.aomap,
      Fe.lightmap,
      Fe.emissivemap,
      Fe.bumpmap,
      Fe.normalmap,
      Fe.displacementmap,
      Fe.fog,
      Fe.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ne(0) }
      }
    ]),
    vertexShader: Et.meshlambert_vert,
    fragmentShader: Et.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.common,
      Fe.specularmap,
      Fe.envmap,
      Fe.aomap,
      Fe.lightmap,
      Fe.emissivemap,
      Fe.bumpmap,
      Fe.normalmap,
      Fe.displacementmap,
      Fe.fog,
      Fe.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ne(0) },
        specular: { value: /* @__PURE__ */ new Ne(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Et.meshphong_vert,
    fragmentShader: Et.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.common,
      Fe.envmap,
      Fe.aomap,
      Fe.lightmap,
      Fe.emissivemap,
      Fe.bumpmap,
      Fe.normalmap,
      Fe.displacementmap,
      Fe.roughnessmap,
      Fe.metalnessmap,
      Fe.fog,
      Fe.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ne(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: Et.meshphysical_vert,
    fragmentShader: Et.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.common,
      Fe.aomap,
      Fe.lightmap,
      Fe.emissivemap,
      Fe.bumpmap,
      Fe.normalmap,
      Fe.displacementmap,
      Fe.gradientmap,
      Fe.fog,
      Fe.lights,
      {
        emissive: { value: /* @__PURE__ */ new Ne(0) }
      }
    ]),
    vertexShader: Et.meshtoon_vert,
    fragmentShader: Et.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.common,
      Fe.bumpmap,
      Fe.normalmap,
      Fe.displacementmap,
      Fe.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Et.meshmatcap_vert,
    fragmentShader: Et.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.points,
      Fe.fog
    ]),
    vertexShader: Et.points_vert,
    fragmentShader: Et.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.common,
      Fe.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Et.linedashed_vert,
    fragmentShader: Et.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.common,
      Fe.displacementmap
    ]),
    vertexShader: Et.depth_vert,
    fragmentShader: Et.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.common,
      Fe.bumpmap,
      Fe.normalmap,
      Fe.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Et.meshnormal_vert,
    fragmentShader: Et.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.sprite,
      Fe.fog
    ]),
    vertexShader: Et.sprite_vert,
    fragmentShader: Et.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Ct() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Et.background_vert,
    fragmentShader: Et.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Et.backgroundCube_vert,
    fragmentShader: Et.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Et.cube_vert,
    fragmentShader: Et.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Et.equirect_vert,
    fragmentShader: Et.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.common,
      Fe.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new k() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Et.distanceRGBA_vert,
    fragmentShader: Et.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Bi([
      Fe.lights,
      Fe.fog,
      {
        color: { value: /* @__PURE__ */ new Ne(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Et.shadow_vert,
    fragmentShader: Et.shadow_frag
  }
};
Wr.physical = {
  uniforms: /* @__PURE__ */ Bi([
    Wr.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Ct() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Ct() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new ve(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Ct() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Ct() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Ct() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Ne(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Ct() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Ct() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Ct() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new ve() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Ct() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Ne(0) },
      specularColor: { value: /* @__PURE__ */ new Ne(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Ct() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Ct() },
      anisotropyVector: { value: /* @__PURE__ */ new ve() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Ct() }
    }
  ]),
  vertexShader: Et.meshphysical_vert,
  fragmentShader: Et.meshphysical_frag
};
const Df = { r: 0, b: 0, g: 0 };
function fP(s, e, t, n, i, r, o) {
  const a = new Ne(0);
  let l = r === !0 ? 0 : 1, h, f, d = null, p = 0, m = null;
  function _(y, v) {
    let S = !1, M = v.isScene === !0 ? v.background : null;
    M && M.isTexture && (M = (v.backgroundBlurriness > 0 ? t : e).get(M)), M === null ? x(a, l) : M && M.isColor && (x(M, 1), S = !0);
    const T = s.xr.getEnvironmentBlendMode();
    T === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : T === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (s.autoClear || S) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil), M && (M.isCubeTexture || M.mapping === _c) ? (f === void 0 && (f = new kn(
      new Wa(1, 1, 1),
      new ys({
        name: "BackgroundCubeMaterial",
        uniforms: ac(Wr.backgroundCube.uniforms),
        vertexShader: Wr.backgroundCube.vertexShader,
        fragmentShader: Wr.backgroundCube.fragmentShader,
        side: Oi,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), f.geometry.deleteAttribute("normal"), f.geometry.deleteAttribute("uv"), f.onBeforeRender = function(P, b, R) {
      this.matrixWorld.copyPosition(R.matrixWorld);
    }, Object.defineProperty(f.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), i.update(f)), f.material.uniforms.envMap.value = M, f.material.uniforms.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, f.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness, f.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, f.material.toneMapped = Qt.getTransfer(M.colorSpace) !== on, (d !== M || p !== M.version || m !== s.toneMapping) && (f.material.needsUpdate = !0, d = M, p = M.version, m = s.toneMapping), f.layers.enableAll(), y.unshift(f, f.geometry, f.material, 0, 0, null)) : M && M.isTexture && (h === void 0 && (h = new kn(
      new uh(2, 2),
      new ys({
        name: "BackgroundMaterial",
        uniforms: ac(Wr.background.uniforms),
        vertexShader: Wr.background.vertexShader,
        fragmentShader: Wr.background.fragmentShader,
        side: gs,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), h.geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), i.update(h)), h.material.uniforms.t2D.value = M, h.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, h.material.toneMapped = Qt.getTransfer(M.colorSpace) !== on, M.matrixAutoUpdate === !0 && M.updateMatrix(), h.material.uniforms.uvTransform.value.copy(M.matrix), (d !== M || p !== M.version || m !== s.toneMapping) && (h.material.needsUpdate = !0, d = M, p = M.version, m = s.toneMapping), h.layers.enableAll(), y.unshift(h, h.geometry, h.material, 0, 0, null));
  }
  function x(y, v) {
    y.getRGB(Df, ME(s)), n.buffers.color.setClear(Df.r, Df.g, Df.b, v, o);
  }
  return {
    getClearColor: function() {
      return a;
    },
    setClearColor: function(y, v = 1) {
      a.set(y), l = v, x(a, l);
    },
    getClearAlpha: function() {
      return l;
    },
    setClearAlpha: function(y) {
      l = y, x(a, l);
    },
    render: _
  };
}
function dP(s, e, t, n) {
  const i = s.getParameter(s.MAX_VERTEX_ATTRIBS), r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = n.isWebGL2 || r !== null, a = {}, l = y(null);
  let h = l, f = !1;
  function d(z, q, j, ee, N) {
    let V = !1;
    if (o) {
      const I = x(ee, j, q);
      h !== I && (h = I, m(h.object)), V = v(z, ee, j, N), V && S(z, ee, j, N);
    } else {
      const I = q.wireframe === !0;
      (h.geometry !== ee.id || h.program !== j.id || h.wireframe !== I) && (h.geometry = ee.id, h.program = j.id, h.wireframe = I, V = !0);
    }
    N !== null && t.update(N, s.ELEMENT_ARRAY_BUFFER), (V || f) && (f = !1, U(z, q, j, ee), N !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t.get(N).buffer));
  }
  function p() {
    return n.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
  }
  function m(z) {
    return n.isWebGL2 ? s.bindVertexArray(z) : r.bindVertexArrayOES(z);
  }
  function _(z) {
    return n.isWebGL2 ? s.deleteVertexArray(z) : r.deleteVertexArrayOES(z);
  }
  function x(z, q, j) {
    const ee = j.wireframe === !0;
    let N = a[z.id];
    N === void 0 && (N = {}, a[z.id] = N);
    let V = N[q.id];
    V === void 0 && (V = {}, N[q.id] = V);
    let I = V[ee];
    return I === void 0 && (I = y(p()), V[ee] = I), I;
  }
  function y(z) {
    const q = [], j = [], ee = [];
    for (let N = 0; N < i; N++)
      q[N] = 0, j[N] = 0, ee[N] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: q,
      enabledAttributes: j,
      attributeDivisors: ee,
      object: z,
      attributes: {},
      index: null
    };
  }
  function v(z, q, j, ee) {
    const N = h.attributes, V = q.attributes;
    let I = 0;
    const D = j.getAttributes();
    for (const J in D)
      if (D[J].location >= 0) {
        const ie = N[J];
        let he = V[J];
        if (he === void 0 && (J === "instanceMatrix" && z.instanceMatrix && (he = z.instanceMatrix), J === "instanceColor" && z.instanceColor && (he = z.instanceColor)), ie === void 0 || ie.attribute !== he || he && ie.data !== he.data) return !0;
        I++;
      }
    return h.attributesNum !== I || h.index !== ee;
  }
  function S(z, q, j, ee) {
    const N = {}, V = q.attributes;
    let I = 0;
    const D = j.getAttributes();
    for (const J in D)
      if (D[J].location >= 0) {
        let ie = V[J];
        ie === void 0 && (J === "instanceMatrix" && z.instanceMatrix && (ie = z.instanceMatrix), J === "instanceColor" && z.instanceColor && (ie = z.instanceColor));
        const he = {};
        he.attribute = ie, ie && ie.data && (he.data = ie.data), N[J] = he, I++;
      }
    h.attributes = N, h.attributesNum = I, h.index = ee;
  }
  function M() {
    const z = h.newAttributes;
    for (let q = 0, j = z.length; q < j; q++)
      z[q] = 0;
  }
  function T(z) {
    P(z, 0);
  }
  function P(z, q) {
    const j = h.newAttributes, ee = h.enabledAttributes, N = h.attributeDivisors;
    j[z] = 1, ee[z] === 0 && (s.enableVertexAttribArray(z), ee[z] = 1), N[z] !== q && ((n.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](z, q), N[z] = q);
  }
  function b() {
    const z = h.newAttributes, q = h.enabledAttributes;
    for (let j = 0, ee = q.length; j < ee; j++)
      q[j] !== z[j] && (s.disableVertexAttribArray(j), q[j] = 0);
  }
  function R(z, q, j, ee, N, V, I) {
    I === !0 ? s.vertexAttribIPointer(z, q, j, N, V) : s.vertexAttribPointer(z, q, j, ee, N, V);
  }
  function U(z, q, j, ee) {
    if (n.isWebGL2 === !1 && (z.isInstancedMesh || ee.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
      return;
    M();
    const N = ee.attributes, V = j.getAttributes(), I = q.defaultAttributeValues;
    for (const D in V) {
      const J = V[D];
      if (J.location >= 0) {
        let K = N[D];
        if (K === void 0 && (D === "instanceMatrix" && z.instanceMatrix && (K = z.instanceMatrix), D === "instanceColor" && z.instanceColor && (K = z.instanceColor)), K !== void 0) {
          const ie = K.normalized, he = K.itemSize, ge = t.get(K);
          if (ge === void 0) continue;
          const me = ge.buffer, Be = ge.type, Pe = ge.bytesPerElement, De = n.isWebGL2 === !0 && (Be === s.INT || Be === s.UNSIGNED_INT || K.gpuType === C0);
          if (K.isInterleavedBufferAttribute) {
            const ze = K.data, X = ze.stride, pe = K.offset;
            if (ze.isInstancedInterleavedBuffer) {
              for (let ce = 0; ce < J.locationSize; ce++)
                P(J.location + ce, ze.meshPerAttribute);
              z.isInstancedMesh !== !0 && ee._maxInstanceCount === void 0 && (ee._maxInstanceCount = ze.meshPerAttribute * ze.count);
            } else
              for (let ce = 0; ce < J.locationSize; ce++)
                T(J.location + ce);
            s.bindBuffer(s.ARRAY_BUFFER, me);
            for (let ce = 0; ce < J.locationSize; ce++)
              R(
                J.location + ce,
                he / J.locationSize,
                Be,
                ie,
                X * Pe,
                (pe + he / J.locationSize * ce) * Pe,
                De
              );
          } else {
            if (K.isInstancedBufferAttribute) {
              for (let ze = 0; ze < J.locationSize; ze++)
                P(J.location + ze, K.meshPerAttribute);
              z.isInstancedMesh !== !0 && ee._maxInstanceCount === void 0 && (ee._maxInstanceCount = K.meshPerAttribute * K.count);
            } else
              for (let ze = 0; ze < J.locationSize; ze++)
                T(J.location + ze);
            s.bindBuffer(s.ARRAY_BUFFER, me);
            for (let ze = 0; ze < J.locationSize; ze++)
              R(
                J.location + ze,
                he / J.locationSize,
                Be,
                ie,
                he * Pe,
                he / J.locationSize * ze * Pe,
                De
              );
          }
        } else if (I !== void 0) {
          const ie = I[D];
          if (ie !== void 0)
            switch (ie.length) {
              case 2:
                s.vertexAttrib2fv(J.location, ie);
                break;
              case 3:
                s.vertexAttrib3fv(J.location, ie);
                break;
              case 4:
                s.vertexAttrib4fv(J.location, ie);
                break;
              default:
                s.vertexAttrib1fv(J.location, ie);
            }
        }
      }
    }
    b();
  }
  function C() {
    W();
    for (const z in a) {
      const q = a[z];
      for (const j in q) {
        const ee = q[j];
        for (const N in ee)
          _(ee[N].object), delete ee[N];
        delete q[j];
      }
      delete a[z];
    }
  }
  function B(z) {
    if (a[z.id] === void 0) return;
    const q = a[z.id];
    for (const j in q) {
      const ee = q[j];
      for (const N in ee)
        _(ee[N].object), delete ee[N];
      delete q[j];
    }
    delete a[z.id];
  }
  function G(z) {
    for (const q in a) {
      const j = a[q];
      if (j[z.id] === void 0) continue;
      const ee = j[z.id];
      for (const N in ee)
        _(ee[N].object), delete ee[N];
      delete j[z.id];
    }
  }
  function W() {
    se(), f = !0, h !== l && (h = l, m(h.object));
  }
  function se() {
    l.geometry = null, l.program = null, l.wireframe = !1;
  }
  return {
    setup: d,
    reset: W,
    resetDefaultState: se,
    dispose: C,
    releaseStatesOfGeometry: B,
    releaseStatesOfProgram: G,
    initAttributes: M,
    enableAttribute: T,
    disableUnusedAttributes: b
  };
}
function pP(s, e, t, n) {
  const i = n.isWebGL2;
  let r;
  function o(f) {
    r = f;
  }
  function a(f, d) {
    s.drawArrays(r, f, d), t.update(d, r, 1);
  }
  function l(f, d, p) {
    if (p === 0) return;
    let m, _;
    if (i)
      m = s, _ = "drawArraysInstanced";
    else if (m = e.get("ANGLE_instanced_arrays"), _ = "drawArraysInstancedANGLE", m === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    m[_](r, f, d, p), t.update(d, r, p);
  }
  function h(f, d, p) {
    if (p === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null)
      for (let _ = 0; _ < p; _++)
        this.render(f[_], d[_]);
    else {
      m.multiDrawArraysWEBGL(r, f, 0, d, 0, p);
      let _ = 0;
      for (let x = 0; x < p; x++)
        _ += d[x];
      t.update(_, r, 1);
    }
  }
  this.setMode = o, this.render = a, this.renderInstances = l, this.renderMultiDraw = h;
}
function mP(s, e, t) {
  let n;
  function i() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const R = e.get("EXT_texture_filter_anisotropic");
      n = s.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      n = 0;
    return n;
  }
  function r(R) {
    if (R === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
        return "highp";
      R = "mediump";
    }
    return R === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const o = typeof WebGL2RenderingContext < "u" && s.constructor.name === "WebGL2RenderingContext";
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = r(a);
  l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
  const h = o || e.has("WEBGL_draw_buffers"), f = t.logarithmicDepthBuffer === !0, d = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), p = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), m = s.getParameter(s.MAX_TEXTURE_SIZE), _ = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), x = s.getParameter(s.MAX_VERTEX_ATTRIBS), y = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), v = s.getParameter(s.MAX_VARYING_VECTORS), S = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), M = p > 0, T = o || e.has("OES_texture_float"), P = M && T, b = o ? s.getParameter(s.MAX_SAMPLES) : 0;
  return {
    isWebGL2: o,
    drawBuffers: h,
    getMaxAnisotropy: i,
    getMaxPrecision: r,
    precision: a,
    logarithmicDepthBuffer: f,
    maxTextures: d,
    maxVertexTextures: p,
    maxTextureSize: m,
    maxCubemapSize: _,
    maxAttributes: x,
    maxVertexUniforms: y,
    maxVaryings: v,
    maxFragmentUniforms: S,
    vertexTextures: M,
    floatFragmentTextures: T,
    floatVertexTextures: P,
    maxSamples: b
  };
}
function gP(s) {
  const e = this;
  let t = null, n = 0, i = !1, r = !1;
  const o = new mo(), a = new Ct(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, p) {
    const m = d.length !== 0 || p || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || i;
    return i = p, n = d.length, m;
  }, this.beginShadows = function() {
    r = !0, f(null);
  }, this.endShadows = function() {
    r = !1;
  }, this.setGlobalState = function(d, p) {
    t = f(d, p, 0);
  }, this.setState = function(d, p, m) {
    const _ = d.clippingPlanes, x = d.clipIntersection, y = d.clipShadows, v = s.get(d);
    if (!i || _ === null || _.length === 0 || r && !y)
      r ? f(null) : h();
    else {
      const S = r ? 0 : n, M = S * 4;
      let T = v.clippingState || null;
      l.value = T, T = f(_, p, M, m);
      for (let P = 0; P !== M; ++P)
        T[P] = t[P];
      v.clippingState = T, this.numIntersection = x ? this.numPlanes : 0, this.numPlanes += S;
    }
  };
  function h() {
    l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function f(d, p, m, _) {
    const x = d !== null ? d.length : 0;
    let y = null;
    if (x !== 0) {
      if (y = l.value, _ !== !0 || y === null) {
        const v = m + x * 4, S = p.matrixWorldInverse;
        a.getNormalMatrix(S), (y === null || y.length < v) && (y = new Float32Array(v));
        for (let M = 0, T = m; M !== x; ++M, T += 4)
          o.copy(d[M]).applyMatrix4(S, a), o.normal.toArray(y, T), y[T + 3] = o.constant;
      }
      l.value = y, l.needsUpdate = !0;
    }
    return e.numPlanes = x, e.numIntersection = 0, y;
  }
}
function _P(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, a) {
    return a === Du ? o.mapping = Xs : a === Fu && (o.mapping = Ro), o;
  }
  function n(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === Du || a === Fu)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const h = new TE(l.height / 2);
            return h.fromEquirectangularTexture(s, o), e.set(o, h), o.addEventListener("dispose", i), t(h.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function i(o) {
    const a = o.target;
    a.removeEventListener("dispose", i);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: r
  };
}
class xc extends ah {
  constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, n, i, r, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let r = n - e, o = n + e, a = i + t, l = i - t;
    if (this.view !== null && this.view.enabled) {
      const h = (this.right - this.left) / this.view.fullWidth / this.zoom, f = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      r += h * this.view.offsetX, o = r + h * this.view.width, a -= f * this.view.offsetY, l = a - f * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const kl = 4, Jx = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], da = 20, ag = /* @__PURE__ */ new xc(), Yx = /* @__PURE__ */ new Ne();
let lg = null, cg = 0, ug = 0;
const ca = (1 + Math.sqrt(5)) / 2, Ml = 1 / ca, Kx = [
  /* @__PURE__ */ new k(1, 1, 1),
  /* @__PURE__ */ new k(-1, 1, 1),
  /* @__PURE__ */ new k(1, 1, -1),
  /* @__PURE__ */ new k(-1, 1, -1),
  /* @__PURE__ */ new k(0, ca, Ml),
  /* @__PURE__ */ new k(0, ca, -Ml),
  /* @__PURE__ */ new k(Ml, 0, ca),
  /* @__PURE__ */ new k(-Ml, 0, ca),
  /* @__PURE__ */ new k(ca, Ml, 0),
  /* @__PURE__ */ new k(-ca, Ml, 0)
];
class V_ {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, t = 0, n = 0.1, i = 100) {
    lg = this._renderer.getRenderTarget(), cg = this._renderer.getActiveCubeFace(), ug = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const r = this._allocateTargets();
    return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = Zx(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = Qx(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(lg, cg, ug), e.scissorTest = !1, Ff(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Xs || e.mapping === Ro ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), lg = this._renderer.getRenderTarget(), cg = this._renderer.getActiveCubeFace(), ug = this._renderer.getActiveMipmapLevel();
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: gn,
      minFilter: gn,
      generateMipmaps: !1,
      type: ic,
      format: Di,
      colorSpace: vs,
      depthBuffer: !1
    }, i = qx(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = qx(e, t, n);
      const { _lodMax: r } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = vP(r)), this._blurMaterial = yP(r, e, t);
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new kn(this._lodPlanes[0], e);
    this._renderer.compile(t, ag);
  }
  _sceneToCubeUV(e, t, n, i) {
    const a = new Wn(90, 1, t, n), l = [1, -1, 1, 1, 1, 1], h = [1, 1, 1, -1, -1, -1], f = this._renderer, d = f.autoClear, p = f.toneMapping;
    f.getClearColor(Yx), f.toneMapping = fs, f.autoClear = !1;
    const m = new ur({
      name: "PMREM.Background",
      side: Oi,
      depthWrite: !1,
      depthTest: !1
    }), _ = new kn(new Wa(), m);
    let x = !1;
    const y = e.background;
    y ? y.isColor && (m.color.copy(y), e.background = null, x = !0) : (m.color.copy(Yx), x = !0);
    for (let v = 0; v < 6; v++) {
      const S = v % 3;
      S === 0 ? (a.up.set(0, l[v], 0), a.lookAt(h[v], 0, 0)) : S === 1 ? (a.up.set(0, 0, l[v]), a.lookAt(0, h[v], 0)) : (a.up.set(0, l[v], 0), a.lookAt(0, 0, h[v]));
      const M = this._cubeSize;
      Ff(i, S * M, v > 2 ? M : 0, M, M), f.setRenderTarget(i), x && f.render(_, a), f.render(e, a);
    }
    _.geometry.dispose(), _.material.dispose(), f.toneMapping = p, f.autoClear = d, e.background = y;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, i = e.mapping === Xs || e.mapping === Ro;
    i ? (this._cubemapMaterial === null && (this._cubemapMaterial = Zx()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Qx());
    const r = i ? this._cubemapMaterial : this._equirectMaterial, o = new kn(this._lodPlanes[0], r), a = r.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    Ff(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, ag);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const r = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]), o = Kx[(i - 1) % Kx.length];
      this._blur(e, i - 1, i, r, o);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, t, n, i, r) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      t,
      n,
      i,
      "latitudinal",
      r
    ), this._halfBlur(
      o,
      e,
      n,
      n,
      i,
      "longitudinal",
      r
    );
  }
  _halfBlur(e, t, n, i, r, o, a) {
    const l = this._renderer, h = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const f = 3, d = new kn(this._lodPlanes[i], h), p = h.uniforms, m = this._sizeLods[n] - 1, _ = isFinite(r) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * da - 1), x = r / _, y = isFinite(r) ? 1 + Math.floor(f * x) : da;
    y > da && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${da}`);
    const v = [];
    let S = 0;
    for (let R = 0; R < da; ++R) {
      const U = R / x, C = Math.exp(-U * U / 2);
      v.push(C), R === 0 ? S += C : R < y && (S += 2 * C);
    }
    for (let R = 0; R < v.length; R++)
      v[R] = v[R] / S;
    p.envMap.value = e.texture, p.samples.value = y, p.weights.value = v, p.latitudinal.value = o === "latitudinal", a && (p.poleAxis.value = a);
    const { _lodMax: M } = this;
    p.dTheta.value = _, p.mipInt.value = M - n;
    const T = this._sizeLods[i], P = 3 * T * (i > M - kl ? i - M + kl : 0), b = 4 * (this._cubeSize - T);
    Ff(t, P, b, 3 * T, 2 * T), l.setRenderTarget(t), l.render(d, ag);
  }
}
function vP(s) {
  const e = [], t = [], n = [];
  let i = s;
  const r = s - kl + 1 + Jx.length;
  for (let o = 0; o < r; o++) {
    const a = Math.pow(2, i);
    t.push(a);
    let l = 1 / a;
    o > s - kl ? l = Jx[o - s + kl - 1] : o === 0 && (l = 0), n.push(l);
    const h = 1 / (a - 2), f = -h, d = 1 + h, p = [f, f, d, f, d, d, f, f, d, d, f, d], m = 6, _ = 6, x = 3, y = 2, v = 1, S = new Float32Array(x * _ * m), M = new Float32Array(y * _ * m), T = new Float32Array(v * _ * m);
    for (let b = 0; b < m; b++) {
      const R = b % 3 * 2 / 3 - 1, U = b > 2 ? 0 : -1, C = [
        R,
        U,
        0,
        R + 2 / 3,
        U,
        0,
        R + 2 / 3,
        U + 1,
        0,
        R,
        U,
        0,
        R + 2 / 3,
        U + 1,
        0,
        R,
        U + 1,
        0
      ];
      S.set(C, x * _ * b), M.set(p, y * _ * b);
      const B = [b, b, b, b, b, b];
      T.set(B, v * _ * b);
    }
    const P = new Mt();
    P.setAttribute("position", new Vt(S, x)), P.setAttribute("uv", new Vt(M, y)), P.setAttribute("faceIndex", new Vt(T, v)), e.push(P), i > kl && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function qx(s, e, t) {
  const n = new Kr(s, e, t);
  return n.texture.mapping = _c, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Ff(s, e, t, n, i) {
  s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
}
function yP(s, e, t) {
  const n = new Float32Array(da), i = new k(0, 1, 0);
  return new ys({
    name: "SphericalGaussianBlur",
    defines: {
      n: da,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${s}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i }
    },
    vertexShader: V0(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: zs,
    depthTest: !1,
    depthWrite: !1
  });
}
function Qx() {
  return new ys({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: V0(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: zs,
    depthTest: !1,
    depthWrite: !1
  });
}
function Zx() {
  return new ys({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: V0(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: zs,
    depthTest: !1,
    depthWrite: !1
  });
}
function V0() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function xP(s) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(a) {
    if (a && a.isTexture) {
      const l = a.mapping, h = l === Du || l === Fu, f = l === Xs || l === Ro;
      if (h || f)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let d = e.get(a);
          return t === null && (t = new V_(s)), d = h ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), e.set(a, d), d.texture;
        } else {
          if (e.has(a))
            return e.get(a).texture;
          {
            const d = a.image;
            if (h && d && d.height > 0 || f && d && i(d)) {
              t === null && (t = new V_(s));
              const p = h ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, p), a.addEventListener("dispose", r), p.texture;
            } else
              return null;
          }
        }
    }
    return a;
  }
  function i(a) {
    let l = 0;
    const h = 6;
    for (let f = 0; f < h; f++)
      a[f] !== void 0 && l++;
    return l === h;
  }
  function r(a) {
    const l = a.target;
    l.removeEventListener("dispose", r);
    const h = e.get(l);
    h !== void 0 && (e.delete(l), h.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: o
  };
}
function AP(s) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = s.getExtension(n);
    }
    return e[n] = i, i;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function(n) {
      n.isWebGL2 ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
    },
    get: function(n) {
      const i = t(n);
      return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
    }
  };
}
function MP(s, e, t, n) {
  const i = {}, r = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const _ in p.attributes)
      e.remove(p.attributes[_]);
    for (const _ in p.morphAttributes) {
      const x = p.morphAttributes[_];
      for (let y = 0, v = x.length; y < v; y++)
        e.remove(x[y]);
    }
    p.removeEventListener("dispose", o), delete i[p.id];
    const m = r.get(p);
    m && (e.remove(m), r.delete(p)), n.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, t.memory.geometries--;
  }
  function a(d, p) {
    return i[p.id] === !0 || (p.addEventListener("dispose", o), i[p.id] = !0, t.memory.geometries++), p;
  }
  function l(d) {
    const p = d.attributes;
    for (const _ in p)
      e.update(p[_], s.ARRAY_BUFFER);
    const m = d.morphAttributes;
    for (const _ in m) {
      const x = m[_];
      for (let y = 0, v = x.length; y < v; y++)
        e.update(x[y], s.ARRAY_BUFFER);
    }
  }
  function h(d) {
    const p = [], m = d.index, _ = d.attributes.position;
    let x = 0;
    if (m !== null) {
      const S = m.array;
      x = m.version;
      for (let M = 0, T = S.length; M < T; M += 3) {
        const P = S[M + 0], b = S[M + 1], R = S[M + 2];
        p.push(P, b, b, R, R, P);
      }
    } else if (_ !== void 0) {
      const S = _.array;
      x = _.version;
      for (let M = 0, T = S.length / 3 - 1; M < T; M += 3) {
        const P = M + 0, b = M + 1, R = M + 2;
        p.push(P, b, b, R, R, P);
      }
    } else
      return;
    const y = new (vE(p) ? z0 : H0)(p, 1);
    y.version = x;
    const v = r.get(d);
    v && e.remove(v), r.set(d, y);
  }
  function f(d) {
    const p = r.get(d);
    if (p) {
      const m = d.index;
      m !== null && p.version < m.version && h(d);
    } else
      h(d);
    return r.get(d);
  }
  return {
    get: a,
    update: l,
    getWireframeAttribute: f
  };
}
function SP(s, e, t, n) {
  const i = n.isWebGL2;
  let r;
  function o(m) {
    r = m;
  }
  let a, l;
  function h(m) {
    a = m.type, l = m.bytesPerElement;
  }
  function f(m, _) {
    s.drawElements(r, _, a, m * l), t.update(_, r, 1);
  }
  function d(m, _, x) {
    if (x === 0) return;
    let y, v;
    if (i)
      y = s, v = "drawElementsInstanced";
    else if (y = e.get("ANGLE_instanced_arrays"), v = "drawElementsInstancedANGLE", y === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    y[v](r, _, a, m * l, x), t.update(_, r, x);
  }
  function p(m, _, x) {
    if (x === 0) return;
    const y = e.get("WEBGL_multi_draw");
    if (y === null)
      for (let v = 0; v < x; v++)
        this.render(m[v] / l, _[v]);
    else {
      y.multiDrawElementsWEBGL(r, _, 0, a, m, 0, x);
      let v = 0;
      for (let S = 0; S < x; S++)
        v += _[S];
      t.update(v, r, 1);
    }
  }
  this.setMode = o, this.setIndex = h, this.render = f, this.renderInstances = d, this.renderMultiDraw = p;
}
function EP(s) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(r, o, a) {
    switch (t.calls++, o) {
      case s.TRIANGLES:
        t.triangles += a * (r / 3);
        break;
      case s.LINES:
        t.lines += a * (r / 2);
        break;
      case s.LINE_STRIP:
        t.lines += a * (r - 1);
        break;
      case s.LINE_LOOP:
        t.lines += a * r;
        break;
      case s.POINTS:
        t.points += a * r;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n
  };
}
function TP(s, e) {
  return s[0] - e[0];
}
function wP(s, e) {
  return Math.abs(e[1]) - Math.abs(s[1]);
}
function CP(s, e, t) {
  const n = {}, i = new Float32Array(8), r = /* @__PURE__ */ new WeakMap(), o = new Zt(), a = [];
  for (let h = 0; h < 8; h++)
    a[h] = [h, 0];
  function l(h, f, d) {
    const p = h.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const m = f.morphAttributes.position || f.morphAttributes.normal || f.morphAttributes.color, _ = m !== void 0 ? m.length : 0;
      let x = r.get(f);
      if (x === void 0 || x.count !== _) {
        let z = function() {
          W.dispose(), r.delete(f), f.removeEventListener("dispose", z);
        };
        x !== void 0 && x.texture.dispose();
        const S = f.morphAttributes.position !== void 0, M = f.morphAttributes.normal !== void 0, T = f.morphAttributes.color !== void 0, P = f.morphAttributes.position || [], b = f.morphAttributes.normal || [], R = f.morphAttributes.color || [];
        let U = 0;
        S === !0 && (U = 1), M === !0 && (U = 2), T === !0 && (U = 3);
        let C = f.attributes.position.count * U, B = 1;
        C > e.maxTextureSize && (B = Math.ceil(C / e.maxTextureSize), C = e.maxTextureSize);
        const G = new Float32Array(C * B * 4 * _), W = new fp(G, C, B, _);
        W.type = Jr, W.needsUpdate = !0;
        const se = U * 4;
        for (let q = 0; q < _; q++) {
          const j = P[q], ee = b[q], N = R[q], V = C * B * 4 * q;
          for (let I = 0; I < j.count; I++) {
            const D = I * se;
            S === !0 && (o.fromBufferAttribute(j, I), G[V + D + 0] = o.x, G[V + D + 1] = o.y, G[V + D + 2] = o.z, G[V + D + 3] = 0), M === !0 && (o.fromBufferAttribute(ee, I), G[V + D + 4] = o.x, G[V + D + 5] = o.y, G[V + D + 6] = o.z, G[V + D + 7] = 0), T === !0 && (o.fromBufferAttribute(N, I), G[V + D + 8] = o.x, G[V + D + 9] = o.y, G[V + D + 10] = o.z, G[V + D + 11] = N.itemSize === 4 ? o.w : 1);
          }
        }
        x = {
          count: _,
          texture: W,
          size: new ve(C, B)
        }, r.set(f, x), f.addEventListener("dispose", z);
      }
      let y = 0;
      for (let S = 0; S < p.length; S++)
        y += p[S];
      const v = f.morphTargetsRelative ? 1 : 1 - y;
      d.getUniforms().setValue(s, "morphTargetBaseInfluence", v), d.getUniforms().setValue(s, "morphTargetInfluences", p), d.getUniforms().setValue(s, "morphTargetsTexture", x.texture, t), d.getUniforms().setValue(s, "morphTargetsTextureSize", x.size);
    } else {
      const m = p === void 0 ? 0 : p.length;
      let _ = n[f.id];
      if (_ === void 0 || _.length !== m) {
        _ = [];
        for (let M = 0; M < m; M++)
          _[M] = [M, 0];
        n[f.id] = _;
      }
      for (let M = 0; M < m; M++) {
        const T = _[M];
        T[0] = M, T[1] = p[M];
      }
      _.sort(wP);
      for (let M = 0; M < 8; M++)
        M < m && _[M][1] ? (a[M][0] = _[M][0], a[M][1] = _[M][1]) : (a[M][0] = Number.MAX_SAFE_INTEGER, a[M][1] = 0);
      a.sort(TP);
      const x = f.morphAttributes.position, y = f.morphAttributes.normal;
      let v = 0;
      for (let M = 0; M < 8; M++) {
        const T = a[M], P = T[0], b = T[1];
        P !== Number.MAX_SAFE_INTEGER && b ? (x && f.getAttribute("morphTarget" + M) !== x[P] && f.setAttribute("morphTarget" + M, x[P]), y && f.getAttribute("morphNormal" + M) !== y[P] && f.setAttribute("morphNormal" + M, y[P]), i[M] = b, v += b) : (x && f.hasAttribute("morphTarget" + M) === !0 && f.deleteAttribute("morphTarget" + M), y && f.hasAttribute("morphNormal" + M) === !0 && f.deleteAttribute("morphNormal" + M), i[M] = 0);
      }
      const S = f.morphTargetsRelative ? 1 : 1 - v;
      d.getUniforms().setValue(s, "morphTargetBaseInfluence", S), d.getUniforms().setValue(s, "morphTargetInfluences", i);
    }
  }
  return {
    update: l
  };
}
function bP(s, e, t, n) {
  let i = /* @__PURE__ */ new WeakMap();
  function r(l) {
    const h = n.render.frame, f = l.geometry, d = e.get(l, f);
    if (i.get(d) !== h && (e.update(d), i.set(d, h)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), i.get(l) !== h && (t.update(l.instanceMatrix, s.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER), i.set(l, h))), l.isSkinnedMesh) {
      const p = l.skeleton;
      i.get(p) !== h && (p.update(), i.set(p, h));
    }
    return d;
  }
  function o() {
    i = /* @__PURE__ */ new WeakMap();
  }
  function a(l) {
    const h = l.target;
    h.removeEventListener("dispose", a), t.remove(h.instanceMatrix), h.instanceColor !== null && t.remove(h.instanceColor);
  }
  return {
    update: r,
    dispose: o
  };
}
class W0 extends yn {
  constructor(e, t, n, i, r, o, a, l, h, f) {
    if (f = f !== void 0 ? f : So, f !== So && f !== Da)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    n === void 0 && f === So && (n = Ns), n === void 0 && f === Da && (n = Mo), super(null, i, r, o, a, l, f, n, h), this.isDepthTexture = !0, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : Sn, this.minFilter = l !== void 0 ? l : Sn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const CE = /* @__PURE__ */ new yn(), bE = /* @__PURE__ */ new W0(1, 1);
bE.compareFunction = O0;
const RE = /* @__PURE__ */ new fp(), BE = /* @__PURE__ */ new G0(), PE = /* @__PURE__ */ new lh(), jx = [], $x = [], eA = new Float32Array(16), tA = new Float32Array(9), nA = new Float32Array(4);
function Ac(s, e, t) {
  const n = s[0];
  if (n <= 0 || n > 0) return s;
  const i = e * t;
  let r = jx[i];
  if (r === void 0 && (r = new Float32Array(i), jx[i] = r), e !== 0) {
    n.toArray(r, 0);
    for (let o = 1, a = 0; o !== e; ++o)
      a += t, s[o].toArray(r, a);
  }
  return r;
}
function Jn(s, e) {
  if (s.length !== e.length) return !1;
  for (let t = 0, n = s.length; t < n; t++)
    if (s[t] !== e[t]) return !1;
  return !0;
}
function Yn(s, e) {
  for (let t = 0, n = e.length; t < n; t++)
    s[t] = e[t];
}
function dp(s, e) {
  let t = $x[e];
  t === void 0 && (t = new Int32Array(e), $x[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = s.allocateTextureUnit();
  return t;
}
function RP(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
}
function BP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Jn(t, e)) return;
    s.uniform2fv(this.addr, e), Yn(t, e);
  }
}
function PP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (Jn(t, e)) return;
    s.uniform3fv(this.addr, e), Yn(t, e);
  }
}
function IP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Jn(t, e)) return;
    s.uniform4fv(this.addr, e), Yn(t, e);
  }
}
function LP(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (Jn(t, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), Yn(t, e);
  } else {
    if (Jn(t, n)) return;
    nA.set(n), s.uniformMatrix2fv(this.addr, !1, nA), Yn(t, n);
  }
}
function DP(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (Jn(t, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), Yn(t, e);
  } else {
    if (Jn(t, n)) return;
    tA.set(n), s.uniformMatrix3fv(this.addr, !1, tA), Yn(t, n);
  }
}
function FP(s, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (Jn(t, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), Yn(t, e);
  } else {
    if (Jn(t, n)) return;
    eA.set(n), s.uniformMatrix4fv(this.addr, !1, eA), Yn(t, n);
  }
}
function UP(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
}
function OP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Jn(t, e)) return;
    s.uniform2iv(this.addr, e), Yn(t, e);
  }
}
function NP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Jn(t, e)) return;
    s.uniform3iv(this.addr, e), Yn(t, e);
  }
}
function kP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Jn(t, e)) return;
    s.uniform4iv(this.addr, e), Yn(t, e);
  }
}
function GP(s, e) {
  const t = this.cache;
  t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
}
function HP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (Jn(t, e)) return;
    s.uniform2uiv(this.addr, e), Yn(t, e);
  }
}
function zP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (Jn(t, e)) return;
    s.uniform3uiv(this.addr, e), Yn(t, e);
  }
}
function VP(s, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (Jn(t, e)) return;
    s.uniform4uiv(this.addr, e), Yn(t, e);
  }
}
function WP(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i);
  const r = this.type === s.SAMPLER_2D_SHADOW ? bE : CE;
  t.setTexture2D(e || r, i);
}
function XP(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || BE, i);
}
function JP(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || PE, i);
}
function YP(s, e, t) {
  const n = this.cache, i = t.allocateTextureUnit();
  n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || RE, i);
}
function KP(s) {
  switch (s) {
    case 5126:
      return RP;
    // FLOAT
    case 35664:
      return BP;
    // _VEC2
    case 35665:
      return PP;
    // _VEC3
    case 35666:
      return IP;
    // _VEC4
    case 35674:
      return LP;
    // _MAT2
    case 35675:
      return DP;
    // _MAT3
    case 35676:
      return FP;
    // _MAT4
    case 5124:
    case 35670:
      return UP;
    // INT, BOOL
    case 35667:
    case 35671:
      return OP;
    // _VEC2
    case 35668:
    case 35672:
      return NP;
    // _VEC3
    case 35669:
    case 35673:
      return kP;
    // _VEC4
    case 5125:
      return GP;
    // UINT
    case 36294:
      return HP;
    // _VEC2
    case 36295:
      return zP;
    // _VEC3
    case 36296:
      return VP;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return WP;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return XP;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return JP;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return YP;
  }
}
function qP(s, e) {
  s.uniform1fv(this.addr, e);
}
function QP(s, e) {
  const t = Ac(e, this.size, 2);
  s.uniform2fv(this.addr, t);
}
function ZP(s, e) {
  const t = Ac(e, this.size, 3);
  s.uniform3fv(this.addr, t);
}
function jP(s, e) {
  const t = Ac(e, this.size, 4);
  s.uniform4fv(this.addr, t);
}
function $P(s, e) {
  const t = Ac(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, t);
}
function eI(s, e) {
  const t = Ac(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, t);
}
function tI(s, e) {
  const t = Ac(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, t);
}
function nI(s, e) {
  s.uniform1iv(this.addr, e);
}
function iI(s, e) {
  s.uniform2iv(this.addr, e);
}
function rI(s, e) {
  s.uniform3iv(this.addr, e);
}
function sI(s, e) {
  s.uniform4iv(this.addr, e);
}
function oI(s, e) {
  s.uniform1uiv(this.addr, e);
}
function aI(s, e) {
  s.uniform2uiv(this.addr, e);
}
function lI(s, e) {
  s.uniform3uiv(this.addr, e);
}
function cI(s, e) {
  s.uniform4uiv(this.addr, e);
}
function uI(s, e, t) {
  const n = this.cache, i = e.length, r = dp(t, i);
  Jn(n, r) || (s.uniform1iv(this.addr, r), Yn(n, r));
  for (let o = 0; o !== i; ++o)
    t.setTexture2D(e[o] || CE, r[o]);
}
function hI(s, e, t) {
  const n = this.cache, i = e.length, r = dp(t, i);
  Jn(n, r) || (s.uniform1iv(this.addr, r), Yn(n, r));
  for (let o = 0; o !== i; ++o)
    t.setTexture3D(e[o] || BE, r[o]);
}
function fI(s, e, t) {
  const n = this.cache, i = e.length, r = dp(t, i);
  Jn(n, r) || (s.uniform1iv(this.addr, r), Yn(n, r));
  for (let o = 0; o !== i; ++o)
    t.setTextureCube(e[o] || PE, r[o]);
}
function dI(s, e, t) {
  const n = this.cache, i = e.length, r = dp(t, i);
  Jn(n, r) || (s.uniform1iv(this.addr, r), Yn(n, r));
  for (let o = 0; o !== i; ++o)
    t.setTexture2DArray(e[o] || RE, r[o]);
}
function pI(s) {
  switch (s) {
    case 5126:
      return qP;
    // FLOAT
    case 35664:
      return QP;
    // _VEC2
    case 35665:
      return ZP;
    // _VEC3
    case 35666:
      return jP;
    // _VEC4
    case 35674:
      return $P;
    // _MAT2
    case 35675:
      return eI;
    // _MAT3
    case 35676:
      return tI;
    // _MAT4
    case 5124:
    case 35670:
      return nI;
    // INT, BOOL
    case 35667:
    case 35671:
      return iI;
    // _VEC2
    case 35668:
    case 35672:
      return rI;
    // _VEC3
    case 35669:
    case 35673:
      return sI;
    // _VEC4
    case 5125:
      return oI;
    // UINT
    case 36294:
      return aI;
    // _VEC2
    case 36295:
      return lI;
    // _VEC3
    case 36296:
      return cI;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return uI;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return hI;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return fI;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return dI;
  }
}
class mI {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = KP(t.type);
  }
}
class gI {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = pI(t.type);
  }
}
class _I {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let r = 0, o = i.length; r !== o; ++r) {
      const a = i[r];
      a.setValue(e, t[a.id], n);
    }
  }
}
const hg = /(\w+)(\])?(\[|\.)?/g;
function iA(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function vI(s, e, t) {
  const n = s.name, i = n.length;
  for (hg.lastIndex = 0; ; ) {
    const r = hg.exec(n), o = hg.lastIndex;
    let a = r[1];
    const l = r[2] === "]", h = r[3];
    if (l && (a = a | 0), h === void 0 || h === "[" && o + 2 === i) {
      iA(t, h === void 0 ? new mI(a, s, e) : new gI(a, s, e));
      break;
    } else {
      let d = t.map[a];
      d === void 0 && (d = new _I(a), iA(t, d)), t = d;
    }
  }
}
class Rd {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const r = e.getActiveUniform(t, i), o = e.getUniformLocation(t, r.name);
      vI(r, o, this);
    }
  }
  setValue(e, t, n, i) {
    const r = this.map[t];
    r !== void 0 && r.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let r = 0, o = t.length; r !== o; ++r) {
      const a = t[r], l = n[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, r = e.length; i !== r; ++i) {
      const o = e[i];
      o.id in t && n.push(o);
    }
    return n;
  }
}
function rA(s, e, t) {
  const n = s.createShader(e);
  return s.shaderSource(n, t), s.compileShader(n), n;
}
const yI = 37297;
let xI = 0;
function AI(s, e) {
  const t = s.split(`
`), n = [], i = Math.max(e - 6, 0), r = Math.min(e + 6, t.length);
  for (let o = i; o < r; o++) {
    const a = o + 1;
    n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return n.join(`
`);
}
function MI(s) {
  const e = Qt.getPrimaries(Qt.workingColorSpace), t = Qt.getPrimaries(s);
  let n;
  switch (e === t ? n = "" : e === Gu && t === ku ? n = "LinearDisplayP3ToLinearSRGB" : e === ku && t === Gu && (n = "LinearSRGBToLinearDisplayP3"), s) {
    case vs:
    case oh:
      return [n, "LinearTransferOETF"];
    case Vn:
    case hp:
      return [n, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", s), [n, "LinearTransferOETF"];
  }
}
function sA(s, e, t) {
  const n = s.getShaderParameter(e, s.COMPILE_STATUS), i = s.getShaderInfoLog(e).trim();
  if (n && i === "") return "";
  const r = /ERROR: 0:(\d+)/.exec(i);
  if (r) {
    const o = parseInt(r[1]);
    return t.toUpperCase() + `

` + i + `

` + AI(s.getShaderSource(e), o);
  } else
    return i;
}
function SI(s, e) {
  const t = MI(e);
  return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function EI(s, e) {
  let t;
  switch (e) {
    case WS:
      t = "Linear";
      break;
    case XS:
      t = "Reinhard";
      break;
    case JS:
      t = "OptimizedCineon";
      break;
    case w0:
      t = "ACESFilmic";
      break;
    case KS:
      t = "AgX";
      break;
    case YS:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function TI(s) {
  return [
    s.extensionDerivatives || s.envMapCubeUVHeight || s.bumpMap || s.normalMapTangentSpace || s.clearcoatNormalMap || s.flatShading || s.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (s.extensionFragDepth || s.logarithmicDepthBuffer) && s.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    s.extensionDrawBuffers && s.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (s.extensionShaderTextureLOD || s.envMap || s.transmission) && s.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ].filter(Gl).join(`
`);
}
function wI(s) {
  return [
    s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : ""
  ].filter(Gl).join(`
`);
}
function CI(s) {
  const e = [];
  for (const t in s) {
    const n = s[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function bI(s, e) {
  const t = {}, n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const r = s.getActiveAttrib(e, i), o = r.name;
    let a = 1;
    r.type === s.FLOAT_MAT2 && (a = 2), r.type === s.FLOAT_MAT3 && (a = 3), r.type === s.FLOAT_MAT4 && (a = 4), t[o] = {
      type: r.type,
      location: s.getAttribLocation(e, o),
      locationSize: a
    };
  }
  return t;
}
function Gl(s) {
  return s !== "";
}
function oA(s, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function aA(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const RI = /^[ \t]*#include +<([\w\d./]+)>/gm;
function W_(s) {
  return s.replace(RI, PI);
}
const BI = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function PI(s, e) {
  let t = Et[e];
  if (t === void 0) {
    const n = BI.get(e);
    if (n !== void 0)
      t = Et[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return W_(t);
}
const II = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function lA(s) {
  return s.replace(II, LI);
}
function LI(s, e, t, n) {
  let i = "";
  for (let r = parseInt(e); r < parseInt(t); r++)
    i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
  return i;
}
function cA(s) {
  let e = "precision " + s.precision + ` float;
precision ` + s.precision + " int;";
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function DI(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === op ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === mu ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === Vr && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function FI(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case Xs:
      case Ro:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case _c:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function UI(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case Ro:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function OI(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case sh:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case zS:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case VS:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function NI(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)), texelHeight: n, maxMip: t };
}
function kI(s, e, t, n) {
  const i = s.getContext(), r = t.defines;
  let o = t.vertexShader, a = t.fragmentShader;
  const l = DI(t), h = FI(t), f = UI(t), d = OI(t), p = NI(t), m = t.isWebGL2 ? "" : TI(t), _ = wI(t), x = CI(r), y = i.createProgram();
  let v, S, M = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (v = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    x
  ].filter(Gl).join(`
`), v.length > 0 && (v += `
`), S = [
    m,
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    x
  ].filter(Gl).join(`
`), S.length > 0 && (S += `
`)) : (v = [
    cA(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    x,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + f : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
    "	attribute vec3 morphTarget0;",
    "	attribute vec3 morphTarget1;",
    "	attribute vec3 morphTarget2;",
    "	attribute vec3 morphTarget3;",
    "	#ifdef USE_MORPHNORMALS",
    "		attribute vec3 morphNormal0;",
    "		attribute vec3 morphNormal1;",
    "		attribute vec3 morphNormal2;",
    "		attribute vec3 morphNormal3;",
    "	#else",
    "		attribute vec3 morphTarget4;",
    "		attribute vec3 morphTarget5;",
    "		attribute vec3 morphTarget6;",
    "		attribute vec3 morphTarget7;",
    "	#endif",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Gl).join(`
`), S = [
    m,
    cA(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    x,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + h : "",
    t.envMap ? "#define " + f : "",
    t.envMap ? "#define " + d : "",
    p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
    p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
    p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== fs ? "#define TONE_MAPPING" : "",
    t.toneMapping !== fs ? Et.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== fs ? EI("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    Et.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    SI("linearToOutputTexel", t.outputColorSpace),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(Gl).join(`
`)), o = W_(o), o = oA(o, t), o = aA(o, t), a = W_(a), a = oA(a, t), a = aA(a, t), o = lA(o), a = lA(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (M = `#version 300 es
`, v = [
    _,
    "precision mediump sampler2DArray;",
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + v, S = [
    "precision mediump sampler2DArray;",
    "#define varying in",
    t.glslVersion === H_ ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === H_ ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + S);
  const T = M + v + o, P = M + S + a, b = rA(i, i.VERTEX_SHADER, T), R = rA(i, i.FRAGMENT_SHADER, P);
  i.attachShader(y, b), i.attachShader(y, R), t.index0AttributeName !== void 0 ? i.bindAttribLocation(y, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(y, 0, "position"), i.linkProgram(y);
  function U(W) {
    if (s.debug.checkShaderErrors) {
      const se = i.getProgramInfoLog(y).trim(), z = i.getShaderInfoLog(b).trim(), q = i.getShaderInfoLog(R).trim();
      let j = !0, ee = !0;
      if (i.getProgramParameter(y, i.LINK_STATUS) === !1)
        if (j = !1, typeof s.debug.onShaderError == "function")
          s.debug.onShaderError(i, y, b, R);
        else {
          const N = sA(i, b, "vertex"), V = sA(i, R, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(y, i.VALIDATE_STATUS) + `

Program Info Log: ` + se + `
` + N + `
` + V
          );
        }
      else se !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", se) : (z === "" || q === "") && (ee = !1);
      ee && (W.diagnostics = {
        runnable: j,
        programLog: se,
        vertexShader: {
          log: z,
          prefix: v
        },
        fragmentShader: {
          log: q,
          prefix: S
        }
      });
    }
    i.deleteShader(b), i.deleteShader(R), C = new Rd(i, y), B = bI(i, y);
  }
  let C;
  this.getUniforms = function() {
    return C === void 0 && U(this), C;
  };
  let B;
  this.getAttributes = function() {
    return B === void 0 && U(this), B;
  };
  let G = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return G === !1 && (G = i.getProgramParameter(y, yI)), G;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), i.deleteProgram(y), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = xI++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = b, this.fragmentShader = R, this;
}
let GI = 0;
class HI {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, i = this._getShaderStage(t), r = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
    return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(r) === !1 && (o.add(r), r.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new zI(e), t.set(e, n)), n;
  }
}
class zI {
  constructor(e) {
    this.id = GI++, this.code = e, this.usedTimes = 0;
  }
}
function VI(s, e, t, n, i, r, o) {
  const a = new Ea(), l = new HI(), h = [], f = i.isWebGL2, d = i.logarithmicDepthBuffer, p = i.vertexTextures;
  let m = i.precision;
  const _ = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function x(C) {
    return C === 0 ? "uv" : `uv${C}`;
  }
  function y(C, B, G, W, se) {
    const z = W.fog, q = se.geometry, j = C.isMeshStandardMaterial ? W.environment : null, ee = (C.isMeshStandardMaterial ? t : e).get(C.envMap || j), N = ee && ee.mapping === _c ? ee.image.height : null, V = _[C.type];
    C.precision !== null && (m = i.getMaxPrecision(C.precision), m !== C.precision && console.warn("THREE.WebGLProgram.getParameters:", C.precision, "not supported, using", m, "instead."));
    const I = q.morphAttributes.position || q.morphAttributes.normal || q.morphAttributes.color, D = I !== void 0 ? I.length : 0;
    let J = 0;
    q.morphAttributes.position !== void 0 && (J = 1), q.morphAttributes.normal !== void 0 && (J = 2), q.morphAttributes.color !== void 0 && (J = 3);
    let K, ie, he, ge;
    if (V) {
      const We = Wr[V];
      K = We.vertexShader, ie = We.fragmentShader;
    } else
      K = C.vertexShader, ie = C.fragmentShader, l.update(C), he = l.getVertexShaderID(C), ge = l.getFragmentShaderID(C);
    const me = s.getRenderTarget(), Be = se.isInstancedMesh === !0, Pe = se.isBatchedMesh === !0, De = !!C.map, ze = !!C.matcap, X = !!ee, pe = !!C.aoMap, ce = !!C.lightMap, Me = !!C.bumpMap, fe = !!C.normalMap, Q = !!C.displacementMap, Ie = !!C.emissiveMap, O = !!C.metalnessMap, L = !!C.roughnessMap, $ = C.anisotropy > 0, xe = C.clearcoat > 0, Ae = C.iridescence > 0, _e = C.sheen > 0, Ue = C.transmission > 0, Le = $ && !!C.anisotropyMap, Te = xe && !!C.clearcoatMap, Ze = xe && !!C.clearcoatNormalMap, ct = xe && !!C.clearcoatRoughnessMap, ye = Ae && !!C.iridescenceMap, bt = Ae && !!C.iridescenceThicknessMap, et = _e && !!C.sheenColorMap, mt = _e && !!C.sheenRoughnessMap, je = !!C.specularMap, Ve = !!C.specularColorMap, gt = !!C.specularIntensityMap, St = Ue && !!C.transmissionMap, Wt = Ue && !!C.thicknessMap, Oe = !!C.gradientMap, Ee = !!C.alphaMap, Y = C.alphaTest > 0, Ce = !!C.alphaHash, be = !!C.extensions, ot = !!q.attributes.uv1, it = !!q.attributes.uv2, It = !!q.attributes.uv3;
    let kt = fs;
    return C.toneMapped && (me === null || me.isXRRenderTarget === !0) && (kt = s.toneMapping), {
      isWebGL2: f,
      shaderID: V,
      shaderType: C.type,
      shaderName: C.name,
      vertexShader: K,
      fragmentShader: ie,
      defines: C.defines,
      customVertexShaderID: he,
      customFragmentShaderID: ge,
      isRawShaderMaterial: C.isRawShaderMaterial === !0,
      glslVersion: C.glslVersion,
      precision: m,
      batching: Pe,
      instancing: Be,
      instancingColor: Be && se.instanceColor !== null,
      supportsVertexTextures: p,
      outputColorSpace: me === null ? s.outputColorSpace : me.isXRRenderTarget === !0 ? me.texture.colorSpace : vs,
      map: De,
      matcap: ze,
      envMap: X,
      envMapMode: X && ee.mapping,
      envMapCubeUVHeight: N,
      aoMap: pe,
      lightMap: ce,
      bumpMap: Me,
      normalMap: fe,
      displacementMap: p && Q,
      emissiveMap: Ie,
      normalMapObjectSpace: fe && C.normalMapType === uE,
      normalMapTangentSpace: fe && C.normalMapType === Uo,
      metalnessMap: O,
      roughnessMap: L,
      anisotropy: $,
      anisotropyMap: Le,
      clearcoat: xe,
      clearcoatMap: Te,
      clearcoatNormalMap: Ze,
      clearcoatRoughnessMap: ct,
      iridescence: Ae,
      iridescenceMap: ye,
      iridescenceThicknessMap: bt,
      sheen: _e,
      sheenColorMap: et,
      sheenRoughnessMap: mt,
      specularMap: je,
      specularColorMap: Ve,
      specularIntensityMap: gt,
      transmission: Ue,
      transmissionMap: St,
      thicknessMap: Wt,
      gradientMap: Oe,
      opaque: C.transparent === !1 && C.blending === Ma,
      alphaMap: Ee,
      alphaTest: Y,
      alphaHash: Ce,
      combine: C.combine,
      //
      mapUv: De && x(C.map.channel),
      aoMapUv: pe && x(C.aoMap.channel),
      lightMapUv: ce && x(C.lightMap.channel),
      bumpMapUv: Me && x(C.bumpMap.channel),
      normalMapUv: fe && x(C.normalMap.channel),
      displacementMapUv: Q && x(C.displacementMap.channel),
      emissiveMapUv: Ie && x(C.emissiveMap.channel),
      metalnessMapUv: O && x(C.metalnessMap.channel),
      roughnessMapUv: L && x(C.roughnessMap.channel),
      anisotropyMapUv: Le && x(C.anisotropyMap.channel),
      clearcoatMapUv: Te && x(C.clearcoatMap.channel),
      clearcoatNormalMapUv: Ze && x(C.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: ct && x(C.clearcoatRoughnessMap.channel),
      iridescenceMapUv: ye && x(C.iridescenceMap.channel),
      iridescenceThicknessMapUv: bt && x(C.iridescenceThicknessMap.channel),
      sheenColorMapUv: et && x(C.sheenColorMap.channel),
      sheenRoughnessMapUv: mt && x(C.sheenRoughnessMap.channel),
      specularMapUv: je && x(C.specularMap.channel),
      specularColorMapUv: Ve && x(C.specularColorMap.channel),
      specularIntensityMapUv: gt && x(C.specularIntensityMap.channel),
      transmissionMapUv: St && x(C.transmissionMap.channel),
      thicknessMapUv: Wt && x(C.thicknessMap.channel),
      alphaMapUv: Ee && x(C.alphaMap.channel),
      //
      vertexTangents: !!q.attributes.tangent && (fe || $),
      vertexColors: C.vertexColors,
      vertexAlphas: C.vertexColors === !0 && !!q.attributes.color && q.attributes.color.itemSize === 4,
      vertexUv1s: ot,
      vertexUv2s: it,
      vertexUv3s: It,
      pointsUvs: se.isPoints === !0 && !!q.attributes.uv && (De || Ee),
      fog: !!z,
      useFog: C.fog === !0,
      fogExp2: z && z.isFogExp2,
      flatShading: C.flatShading === !0,
      sizeAttenuation: C.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      skinning: se.isSkinnedMesh === !0,
      morphTargets: q.morphAttributes.position !== void 0,
      morphNormals: q.morphAttributes.normal !== void 0,
      morphColors: q.morphAttributes.color !== void 0,
      morphTargetsCount: D,
      morphTextureStride: J,
      numDirLights: B.directional.length,
      numPointLights: B.point.length,
      numSpotLights: B.spot.length,
      numSpotLightMaps: B.spotLightMap.length,
      numRectAreaLights: B.rectArea.length,
      numHemiLights: B.hemi.length,
      numDirLightShadows: B.directionalShadowMap.length,
      numPointLightShadows: B.pointShadowMap.length,
      numSpotLightShadows: B.spotShadowMap.length,
      numSpotLightShadowsWithMaps: B.numSpotLightShadowsWithMaps,
      numLightProbes: B.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: C.dithering,
      shadowMapEnabled: s.shadowMap.enabled && G.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: kt,
      useLegacyLights: s._useLegacyLights,
      decodeVideoTexture: De && C.map.isVideoTexture === !0 && Qt.getTransfer(C.map.colorSpace) === on,
      premultipliedAlpha: C.premultipliedAlpha,
      doubleSided: C.side === Xr,
      flipSided: C.side === Oi,
      useDepthPacking: C.depthPacking >= 0,
      depthPacking: C.depthPacking || 0,
      index0AttributeName: C.index0AttributeName,
      extensionDerivatives: be && C.extensions.derivatives === !0,
      extensionFragDepth: be && C.extensions.fragDepth === !0,
      extensionDrawBuffers: be && C.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: be && C.extensions.shaderTextureLOD === !0,
      extensionClipCullDistance: be && C.extensions.clipCullDistance && n.has("WEBGL_clip_cull_distance"),
      rendererExtensionFragDepth: f || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: f || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: f || n.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: C.customProgramCacheKey()
    };
  }
  function v(C) {
    const B = [];
    if (C.shaderID ? B.push(C.shaderID) : (B.push(C.customVertexShaderID), B.push(C.customFragmentShaderID)), C.defines !== void 0)
      for (const G in C.defines)
        B.push(G), B.push(C.defines[G]);
    return C.isRawShaderMaterial === !1 && (S(B, C), M(B, C), B.push(s.outputColorSpace)), B.push(C.customProgramCacheKey), B.join();
  }
  function S(C, B) {
    C.push(B.precision), C.push(B.outputColorSpace), C.push(B.envMapMode), C.push(B.envMapCubeUVHeight), C.push(B.mapUv), C.push(B.alphaMapUv), C.push(B.lightMapUv), C.push(B.aoMapUv), C.push(B.bumpMapUv), C.push(B.normalMapUv), C.push(B.displacementMapUv), C.push(B.emissiveMapUv), C.push(B.metalnessMapUv), C.push(B.roughnessMapUv), C.push(B.anisotropyMapUv), C.push(B.clearcoatMapUv), C.push(B.clearcoatNormalMapUv), C.push(B.clearcoatRoughnessMapUv), C.push(B.iridescenceMapUv), C.push(B.iridescenceThicknessMapUv), C.push(B.sheenColorMapUv), C.push(B.sheenRoughnessMapUv), C.push(B.specularMapUv), C.push(B.specularColorMapUv), C.push(B.specularIntensityMapUv), C.push(B.transmissionMapUv), C.push(B.thicknessMapUv), C.push(B.combine), C.push(B.fogExp2), C.push(B.sizeAttenuation), C.push(B.morphTargetsCount), C.push(B.morphAttributeCount), C.push(B.numDirLights), C.push(B.numPointLights), C.push(B.numSpotLights), C.push(B.numSpotLightMaps), C.push(B.numHemiLights), C.push(B.numRectAreaLights), C.push(B.numDirLightShadows), C.push(B.numPointLightShadows), C.push(B.numSpotLightShadows), C.push(B.numSpotLightShadowsWithMaps), C.push(B.numLightProbes), C.push(B.shadowMapType), C.push(B.toneMapping), C.push(B.numClippingPlanes), C.push(B.numClipIntersection), C.push(B.depthPacking);
  }
  function M(C, B) {
    a.disableAll(), B.isWebGL2 && a.enable(0), B.supportsVertexTextures && a.enable(1), B.instancing && a.enable(2), B.instancingColor && a.enable(3), B.matcap && a.enable(4), B.envMap && a.enable(5), B.normalMapObjectSpace && a.enable(6), B.normalMapTangentSpace && a.enable(7), B.clearcoat && a.enable(8), B.iridescence && a.enable(9), B.alphaTest && a.enable(10), B.vertexColors && a.enable(11), B.vertexAlphas && a.enable(12), B.vertexUv1s && a.enable(13), B.vertexUv2s && a.enable(14), B.vertexUv3s && a.enable(15), B.vertexTangents && a.enable(16), B.anisotropy && a.enable(17), B.alphaHash && a.enable(18), B.batching && a.enable(19), C.push(a.mask), a.disableAll(), B.fog && a.enable(0), B.useFog && a.enable(1), B.flatShading && a.enable(2), B.logarithmicDepthBuffer && a.enable(3), B.skinning && a.enable(4), B.morphTargets && a.enable(5), B.morphNormals && a.enable(6), B.morphColors && a.enable(7), B.premultipliedAlpha && a.enable(8), B.shadowMapEnabled && a.enable(9), B.useLegacyLights && a.enable(10), B.doubleSided && a.enable(11), B.flipSided && a.enable(12), B.useDepthPacking && a.enable(13), B.dithering && a.enable(14), B.transmission && a.enable(15), B.sheen && a.enable(16), B.opaque && a.enable(17), B.pointsUvs && a.enable(18), B.decodeVideoTexture && a.enable(19), C.push(a.mask);
  }
  function T(C) {
    const B = _[C.type];
    let G;
    if (B) {
      const W = Wr[B];
      G = SE.clone(W.uniforms);
    } else
      G = C.uniforms;
    return G;
  }
  function P(C, B) {
    let G;
    for (let W = 0, se = h.length; W < se; W++) {
      const z = h[W];
      if (z.cacheKey === B) {
        G = z, ++G.usedTimes;
        break;
      }
    }
    return G === void 0 && (G = new kI(s, B, C, r), h.push(G)), G;
  }
  function b(C) {
    if (--C.usedTimes === 0) {
      const B = h.indexOf(C);
      h[B] = h[h.length - 1], h.pop(), C.destroy();
    }
  }
  function R(C) {
    l.remove(C);
  }
  function U() {
    l.dispose();
  }
  return {
    getParameters: y,
    getProgramCacheKey: v,
    getUniforms: T,
    acquireProgram: P,
    releaseProgram: b,
    releaseShaderCache: R,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: h,
    dispose: U
  };
}
function WI() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(r) {
    let o = s.get(r);
    return o === void 0 && (o = {}, s.set(r, o)), o;
  }
  function t(r) {
    s.delete(r);
  }
  function n(r, o, a) {
    s.get(r)[o] = a;
  }
  function i() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    remove: t,
    update: n,
    dispose: i
  };
}
function XI(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function uA(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function hA() {
  const s = [];
  let e = 0;
  const t = [], n = [], i = [];
  function r() {
    e = 0, t.length = 0, n.length = 0, i.length = 0;
  }
  function o(d, p, m, _, x, y) {
    let v = s[e];
    return v === void 0 ? (v = {
      id: d.id,
      object: d,
      geometry: p,
      material: m,
      groupOrder: _,
      renderOrder: d.renderOrder,
      z: x,
      group: y
    }, s[e] = v) : (v.id = d.id, v.object = d, v.geometry = p, v.material = m, v.groupOrder = _, v.renderOrder = d.renderOrder, v.z = x, v.group = y), e++, v;
  }
  function a(d, p, m, _, x, y) {
    const v = o(d, p, m, _, x, y);
    m.transmission > 0 ? n.push(v) : m.transparent === !0 ? i.push(v) : t.push(v);
  }
  function l(d, p, m, _, x, y) {
    const v = o(d, p, m, _, x, y);
    m.transmission > 0 ? n.unshift(v) : m.transparent === !0 ? i.unshift(v) : t.unshift(v);
  }
  function h(d, p) {
    t.length > 1 && t.sort(d || XI), n.length > 1 && n.sort(p || uA), i.length > 1 && i.sort(p || uA);
  }
  function f() {
    for (let d = e, p = s.length; d < p; d++) {
      const m = s[d];
      if (m.id === null) break;
      m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: r,
    push: a,
    unshift: l,
    finish: f,
    sort: h
  };
}
function JI() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(n, i) {
    const r = s.get(n);
    let o;
    return r === void 0 ? (o = new hA(), s.set(n, [o])) : i >= r.length ? (o = new hA(), r.push(o)) : o = r[i], o;
  }
  function t() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function YI() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new k(),
            color: new Ne()
          };
          break;
        case "SpotLight":
          t = {
            position: new k(),
            direction: new k(),
            color: new Ne(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new k(),
            color: new Ne(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new k(),
            skyColor: new Ne(),
            groundColor: new Ne()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new Ne(),
            position: new k(),
            halfWidth: new k(),
            halfHeight: new k()
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
function KI() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ve()
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ve()
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ve(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return s[e.id] = t, t;
    }
  };
}
let qI = 0;
function QI(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function ZI(s, e) {
  const t = new YI(), n = KI(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let f = 0; f < 9; f++) i.probe.push(new k());
  const r = new k(), o = new pt(), a = new pt();
  function l(f, d) {
    let p = 0, m = 0, _ = 0;
    for (let W = 0; W < 9; W++) i.probe[W].set(0, 0, 0);
    let x = 0, y = 0, v = 0, S = 0, M = 0, T = 0, P = 0, b = 0, R = 0, U = 0, C = 0;
    f.sort(QI);
    const B = d === !0 ? Math.PI : 1;
    for (let W = 0, se = f.length; W < se; W++) {
      const z = f[W], q = z.color, j = z.intensity, ee = z.distance, N = z.shadow && z.shadow.map ? z.shadow.map.texture : null;
      if (z.isAmbientLight)
        p += q.r * j * B, m += q.g * j * B, _ += q.b * j * B;
      else if (z.isLightProbe) {
        for (let V = 0; V < 9; V++)
          i.probe[V].addScaledVector(z.sh.coefficients[V], j);
        C++;
      } else if (z.isDirectionalLight) {
        const V = t.get(z);
        if (V.color.copy(z.color).multiplyScalar(z.intensity * B), z.castShadow) {
          const I = z.shadow, D = n.get(z);
          D.shadowBias = I.bias, D.shadowNormalBias = I.normalBias, D.shadowRadius = I.radius, D.shadowMapSize = I.mapSize, i.directionalShadow[x] = D, i.directionalShadowMap[x] = N, i.directionalShadowMatrix[x] = z.shadow.matrix, T++;
        }
        i.directional[x] = V, x++;
      } else if (z.isSpotLight) {
        const V = t.get(z);
        V.position.setFromMatrixPosition(z.matrixWorld), V.color.copy(q).multiplyScalar(j * B), V.distance = ee, V.coneCos = Math.cos(z.angle), V.penumbraCos = Math.cos(z.angle * (1 - z.penumbra)), V.decay = z.decay, i.spot[v] = V;
        const I = z.shadow;
        if (z.map && (i.spotLightMap[R] = z.map, R++, I.updateMatrices(z), z.castShadow && U++), i.spotLightMatrix[v] = I.matrix, z.castShadow) {
          const D = n.get(z);
          D.shadowBias = I.bias, D.shadowNormalBias = I.normalBias, D.shadowRadius = I.radius, D.shadowMapSize = I.mapSize, i.spotShadow[v] = D, i.spotShadowMap[v] = N, b++;
        }
        v++;
      } else if (z.isRectAreaLight) {
        const V = t.get(z);
        V.color.copy(q).multiplyScalar(j), V.halfWidth.set(z.width * 0.5, 0, 0), V.halfHeight.set(0, z.height * 0.5, 0), i.rectArea[S] = V, S++;
      } else if (z.isPointLight) {
        const V = t.get(z);
        if (V.color.copy(z.color).multiplyScalar(z.intensity * B), V.distance = z.distance, V.decay = z.decay, z.castShadow) {
          const I = z.shadow, D = n.get(z);
          D.shadowBias = I.bias, D.shadowNormalBias = I.normalBias, D.shadowRadius = I.radius, D.shadowMapSize = I.mapSize, D.shadowCameraNear = I.camera.near, D.shadowCameraFar = I.camera.far, i.pointShadow[y] = D, i.pointShadowMap[y] = N, i.pointShadowMatrix[y] = z.shadow.matrix, P++;
        }
        i.point[y] = V, y++;
      } else if (z.isHemisphereLight) {
        const V = t.get(z);
        V.skyColor.copy(z.color).multiplyScalar(j * B), V.groundColor.copy(z.groundColor).multiplyScalar(j * B), i.hemi[M] = V, M++;
      }
    }
    S > 0 && (e.isWebGL2 ? s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = Fe.LTC_FLOAT_1, i.rectAreaLTC2 = Fe.LTC_FLOAT_2) : (i.rectAreaLTC1 = Fe.LTC_HALF_1, i.rectAreaLTC2 = Fe.LTC_HALF_2) : s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = Fe.LTC_FLOAT_1, i.rectAreaLTC2 = Fe.LTC_FLOAT_2) : s.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = Fe.LTC_HALF_1, i.rectAreaLTC2 = Fe.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = p, i.ambient[1] = m, i.ambient[2] = _;
    const G = i.hash;
    (G.directionalLength !== x || G.pointLength !== y || G.spotLength !== v || G.rectAreaLength !== S || G.hemiLength !== M || G.numDirectionalShadows !== T || G.numPointShadows !== P || G.numSpotShadows !== b || G.numSpotMaps !== R || G.numLightProbes !== C) && (i.directional.length = x, i.spot.length = v, i.rectArea.length = S, i.point.length = y, i.hemi.length = M, i.directionalShadow.length = T, i.directionalShadowMap.length = T, i.pointShadow.length = P, i.pointShadowMap.length = P, i.spotShadow.length = b, i.spotShadowMap.length = b, i.directionalShadowMatrix.length = T, i.pointShadowMatrix.length = P, i.spotLightMatrix.length = b + R - U, i.spotLightMap.length = R, i.numSpotLightShadowsWithMaps = U, i.numLightProbes = C, G.directionalLength = x, G.pointLength = y, G.spotLength = v, G.rectAreaLength = S, G.hemiLength = M, G.numDirectionalShadows = T, G.numPointShadows = P, G.numSpotShadows = b, G.numSpotMaps = R, G.numLightProbes = C, i.version = qI++);
  }
  function h(f, d) {
    let p = 0, m = 0, _ = 0, x = 0, y = 0;
    const v = d.matrixWorldInverse;
    for (let S = 0, M = f.length; S < M; S++) {
      const T = f[S];
      if (T.isDirectionalLight) {
        const P = i.directional[p];
        P.direction.setFromMatrixPosition(T.matrixWorld), r.setFromMatrixPosition(T.target.matrixWorld), P.direction.sub(r), P.direction.transformDirection(v), p++;
      } else if (T.isSpotLight) {
        const P = i.spot[_];
        P.position.setFromMatrixPosition(T.matrixWorld), P.position.applyMatrix4(v), P.direction.setFromMatrixPosition(T.matrixWorld), r.setFromMatrixPosition(T.target.matrixWorld), P.direction.sub(r), P.direction.transformDirection(v), _++;
      } else if (T.isRectAreaLight) {
        const P = i.rectArea[x];
        P.position.setFromMatrixPosition(T.matrixWorld), P.position.applyMatrix4(v), a.identity(), o.copy(T.matrixWorld), o.premultiply(v), a.extractRotation(o), P.halfWidth.set(T.width * 0.5, 0, 0), P.halfHeight.set(0, T.height * 0.5, 0), P.halfWidth.applyMatrix4(a), P.halfHeight.applyMatrix4(a), x++;
      } else if (T.isPointLight) {
        const P = i.point[m];
        P.position.setFromMatrixPosition(T.matrixWorld), P.position.applyMatrix4(v), m++;
      } else if (T.isHemisphereLight) {
        const P = i.hemi[y];
        P.direction.setFromMatrixPosition(T.matrixWorld), P.direction.transformDirection(v), y++;
      }
    }
  }
  return {
    setup: l,
    setupView: h,
    state: i
  };
}
function fA(s, e) {
  const t = new ZI(s, e), n = [], i = [];
  function r() {
    n.length = 0, i.length = 0;
  }
  function o(d) {
    n.push(d);
  }
  function a(d) {
    i.push(d);
  }
  function l(d) {
    t.setup(n, d);
  }
  function h(d) {
    t.setupView(n, d);
  }
  return {
    init: r,
    state: {
      lightsArray: n,
      shadowsArray: i,
      lights: t
    },
    setupLights: l,
    setupLightsView: h,
    pushLight: o,
    pushShadow: a
  };
}
function jI(s, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function n(r, o = 0) {
    const a = t.get(r);
    let l;
    return a === void 0 ? (l = new fA(s, e), t.set(r, [l])) : o >= a.length ? (l = new fA(s, e), a.push(l)) : l = a[o], l;
  }
  function i() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: i
  };
}
class X0 extends Xn {
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = lE, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class J0 extends Xn {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const $I = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, eL = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function tL(s, e, t) {
  let n = new ch();
  const i = new ve(), r = new ve(), o = new Zt(), a = new X0({ depthPacking: cE }), l = new J0(), h = {}, f = t.maxTextureSize, d = { [gs]: Oi, [Oi]: gs, [Xr]: Xr }, p = new ys({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new ve() },
      radius: { value: 4 }
    },
    vertexShader: $I,
    fragmentShader: eL
  }), m = p.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const _ = new Mt();
  _.setAttribute(
    "position",
    new Vt(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const x = new kn(_, p), y = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = op;
  let v = this.type;
  this.render = function(b, R, U) {
    if (y.enabled === !1 || y.autoUpdate === !1 && y.needsUpdate === !1 || b.length === 0) return;
    const C = s.getRenderTarget(), B = s.getActiveCubeFace(), G = s.getActiveMipmapLevel(), W = s.state;
    W.setBlending(zs), W.buffers.color.setClear(1, 1, 1, 1), W.buffers.depth.setTest(!0), W.setScissorTest(!1);
    const se = v !== Vr && this.type === Vr, z = v === Vr && this.type !== Vr;
    for (let q = 0, j = b.length; q < j; q++) {
      const ee = b[q], N = ee.shadow;
      if (N === void 0) {
        console.warn("THREE.WebGLShadowMap:", ee, "has no shadow.");
        continue;
      }
      if (N.autoUpdate === !1 && N.needsUpdate === !1) continue;
      i.copy(N.mapSize);
      const V = N.getFrameExtents();
      if (i.multiply(V), r.copy(N.mapSize), (i.x > f || i.y > f) && (i.x > f && (r.x = Math.floor(f / V.x), i.x = r.x * V.x, N.mapSize.x = r.x), i.y > f && (r.y = Math.floor(f / V.y), i.y = r.y * V.y, N.mapSize.y = r.y)), N.map === null || se === !0 || z === !0) {
        const D = this.type !== Vr ? { minFilter: Sn, magFilter: Sn } : {};
        N.map !== null && N.map.dispose(), N.map = new Kr(i.x, i.y, D), N.map.texture.name = ee.name + ".shadowMap", N.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(N.map), s.clear();
      const I = N.getViewportCount();
      for (let D = 0; D < I; D++) {
        const J = N.getViewport(D);
        o.set(
          r.x * J.x,
          r.y * J.y,
          r.x * J.z,
          r.y * J.w
        ), W.viewport(o), N.updateMatrices(ee, D), n = N.getFrustum(), T(R, U, N.camera, ee, this.type);
      }
      N.isPointLightShadow !== !0 && this.type === Vr && S(N, U), N.needsUpdate = !1;
    }
    v = this.type, y.needsUpdate = !1, s.setRenderTarget(C, B, G);
  };
  function S(b, R) {
    const U = e.update(x);
    p.defines.VSM_SAMPLES !== b.blurSamples && (p.defines.VSM_SAMPLES = b.blurSamples, m.defines.VSM_SAMPLES = b.blurSamples, p.needsUpdate = !0, m.needsUpdate = !0), b.mapPass === null && (b.mapPass = new Kr(i.x, i.y)), p.uniforms.shadow_pass.value = b.map.texture, p.uniforms.resolution.value = b.mapSize, p.uniforms.radius.value = b.radius, s.setRenderTarget(b.mapPass), s.clear(), s.renderBufferDirect(R, null, U, p, x, null), m.uniforms.shadow_pass.value = b.mapPass.texture, m.uniforms.resolution.value = b.mapSize, m.uniforms.radius.value = b.radius, s.setRenderTarget(b.map), s.clear(), s.renderBufferDirect(R, null, U, m, x, null);
  }
  function M(b, R, U, C) {
    let B = null;
    const G = U.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial;
    if (G !== void 0)
      B = G;
    else if (B = U.isPointLight === !0 ? l : a, s.localClippingEnabled && R.clipShadows === !0 && Array.isArray(R.clippingPlanes) && R.clippingPlanes.length !== 0 || R.displacementMap && R.displacementScale !== 0 || R.alphaMap && R.alphaTest > 0 || R.map && R.alphaTest > 0) {
      const W = B.uuid, se = R.uuid;
      let z = h[W];
      z === void 0 && (z = {}, h[W] = z);
      let q = z[se];
      q === void 0 && (q = B.clone(), z[se] = q, R.addEventListener("dispose", P)), B = q;
    }
    if (B.visible = R.visible, B.wireframe = R.wireframe, C === Vr ? B.side = R.shadowSide !== null ? R.shadowSide : R.side : B.side = R.shadowSide !== null ? R.shadowSide : d[R.side], B.alphaMap = R.alphaMap, B.alphaTest = R.alphaTest, B.map = R.map, B.clipShadows = R.clipShadows, B.clippingPlanes = R.clippingPlanes, B.clipIntersection = R.clipIntersection, B.displacementMap = R.displacementMap, B.displacementScale = R.displacementScale, B.displacementBias = R.displacementBias, B.wireframeLinewidth = R.wireframeLinewidth, B.linewidth = R.linewidth, U.isPointLight === !0 && B.isMeshDistanceMaterial === !0) {
      const W = s.properties.get(B);
      W.light = U;
    }
    return B;
  }
  function T(b, R, U, C, B) {
    if (b.visible === !1) return;
    if (b.layers.test(R.layers) && (b.isMesh || b.isLine || b.isPoints) && (b.castShadow || b.receiveShadow && B === Vr) && (!b.frustumCulled || n.intersectsObject(b))) {
      b.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, b.matrixWorld);
      const se = e.update(b), z = b.material;
      if (Array.isArray(z)) {
        const q = se.groups;
        for (let j = 0, ee = q.length; j < ee; j++) {
          const N = q[j], V = z[N.materialIndex];
          if (V && V.visible) {
            const I = M(b, V, C, B);
            b.onBeforeShadow(s, b, R, U, se, I, N), s.renderBufferDirect(U, null, se, I, b, N), b.onAfterShadow(s, b, R, U, se, I, N);
          }
        }
      } else if (z.visible) {
        const q = M(b, z, C, B);
        b.onBeforeShadow(s, b, R, U, se, q, null), s.renderBufferDirect(U, null, se, q, b, null), b.onAfterShadow(s, b, R, U, se, q, null);
      }
    }
    const W = b.children;
    for (let se = 0, z = W.length; se < z; se++)
      T(W[se], R, U, C, B);
  }
  function P(b) {
    b.target.removeEventListener("dispose", P);
    for (const U in h) {
      const C = h[U], B = b.target.uuid;
      B in C && (C[B].dispose(), delete C[B]);
    }
  }
}
function nL(s, e, t) {
  const n = t.isWebGL2;
  function i() {
    let Y = !1;
    const Ce = new Zt();
    let be = null;
    const ot = new Zt(0, 0, 0, 0);
    return {
      setMask: function(it) {
        be !== it && !Y && (s.colorMask(it, it, it, it), be = it);
      },
      setLocked: function(it) {
        Y = it;
      },
      setClear: function(it, It, kt, Qe, We) {
        We === !0 && (it *= Qe, It *= Qe, kt *= Qe), Ce.set(it, It, kt, Qe), ot.equals(Ce) === !1 && (s.clearColor(it, It, kt, Qe), ot.copy(Ce));
      },
      reset: function() {
        Y = !1, be = null, ot.set(-1, 0, 0, 0);
      }
    };
  }
  function r() {
    let Y = !1, Ce = null, be = null, ot = null;
    return {
      setTest: function(it) {
        it ? Pe(s.DEPTH_TEST) : De(s.DEPTH_TEST);
      },
      setMask: function(it) {
        Ce !== it && !Y && (s.depthMask(it), Ce = it);
      },
      setFunc: function(it) {
        if (be !== it) {
          switch (it) {
            case FS:
              s.depthFunc(s.NEVER);
              break;
            case US:
              s.depthFunc(s.ALWAYS);
              break;
            case OS:
              s.depthFunc(s.LESS);
              break;
            case Lu:
              s.depthFunc(s.LEQUAL);
              break;
            case NS:
              s.depthFunc(s.EQUAL);
              break;
            case kS:
              s.depthFunc(s.GEQUAL);
              break;
            case GS:
              s.depthFunc(s.GREATER);
              break;
            case HS:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          be = it;
        }
      },
      setLocked: function(it) {
        Y = it;
      },
      setClear: function(it) {
        ot !== it && (s.clearDepth(it), ot = it);
      },
      reset: function() {
        Y = !1, Ce = null, be = null, ot = null;
      }
    };
  }
  function o() {
    let Y = !1, Ce = null, be = null, ot = null, it = null, It = null, kt = null, Qe = null, We = null;
    return {
      setTest: function(tt) {
        Y || (tt ? Pe(s.STENCIL_TEST) : De(s.STENCIL_TEST));
      },
      setMask: function(tt) {
        Ce !== tt && !Y && (s.stencilMask(tt), Ce = tt);
      },
      setFunc: function(tt, Se, ut) {
        (be !== tt || ot !== Se || it !== ut) && (s.stencilFunc(tt, Se, ut), be = tt, ot = Se, it = ut);
      },
      setOp: function(tt, Se, ut) {
        (It !== tt || kt !== Se || Qe !== ut) && (s.stencilOp(tt, Se, ut), It = tt, kt = Se, Qe = ut);
      },
      setLocked: function(tt) {
        Y = tt;
      },
      setClear: function(tt) {
        We !== tt && (s.clearStencil(tt), We = tt);
      },
      reset: function() {
        Y = !1, Ce = null, be = null, ot = null, it = null, It = null, kt = null, Qe = null, We = null;
      }
    };
  }
  const a = new i(), l = new r(), h = new o(), f = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap();
  let p = {}, m = {}, _ = /* @__PURE__ */ new WeakMap(), x = [], y = null, v = !1, S = null, M = null, T = null, P = null, b = null, R = null, U = null, C = new Ne(0, 0, 0), B = 0, G = !1, W = null, se = null, z = null, q = null, j = null;
  const ee = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let N = !1, V = 0;
  const I = s.getParameter(s.VERSION);
  I.indexOf("WebGL") !== -1 ? (V = parseFloat(/^WebGL (\d)/.exec(I)[1]), N = V >= 1) : I.indexOf("OpenGL ES") !== -1 && (V = parseFloat(/^OpenGL ES (\d)/.exec(I)[1]), N = V >= 2);
  let D = null, J = {};
  const K = s.getParameter(s.SCISSOR_BOX), ie = s.getParameter(s.VIEWPORT), he = new Zt().fromArray(K), ge = new Zt().fromArray(ie);
  function me(Y, Ce, be, ot) {
    const it = new Uint8Array(4), It = s.createTexture();
    s.bindTexture(Y, It), s.texParameteri(Y, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(Y, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let kt = 0; kt < be; kt++)
      n && (Y === s.TEXTURE_3D || Y === s.TEXTURE_2D_ARRAY) ? s.texImage3D(Ce, 0, s.RGBA, 1, 1, ot, 0, s.RGBA, s.UNSIGNED_BYTE, it) : s.texImage2D(Ce + kt, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, it);
    return It;
  }
  const Be = {};
  Be[s.TEXTURE_2D] = me(s.TEXTURE_2D, s.TEXTURE_2D, 1), Be[s.TEXTURE_CUBE_MAP] = me(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n && (Be[s.TEXTURE_2D_ARRAY] = me(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), Be[s.TEXTURE_3D] = me(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1)), a.setClear(0, 0, 0, 1), l.setClear(1), h.setClear(0), Pe(s.DEPTH_TEST), l.setFunc(Lu), Ie(!1), O(l_), Pe(s.CULL_FACE), fe(zs);
  function Pe(Y) {
    p[Y] !== !0 && (s.enable(Y), p[Y] = !0);
  }
  function De(Y) {
    p[Y] !== !1 && (s.disable(Y), p[Y] = !1);
  }
  function ze(Y, Ce) {
    return m[Y] !== Ce ? (s.bindFramebuffer(Y, Ce), m[Y] = Ce, n && (Y === s.DRAW_FRAMEBUFFER && (m[s.FRAMEBUFFER] = Ce), Y === s.FRAMEBUFFER && (m[s.DRAW_FRAMEBUFFER] = Ce)), !0) : !1;
  }
  function X(Y, Ce) {
    let be = x, ot = !1;
    if (Y)
      if (be = _.get(Ce), be === void 0 && (be = [], _.set(Ce, be)), Y.isWebGLMultipleRenderTargets) {
        const it = Y.texture;
        if (be.length !== it.length || be[0] !== s.COLOR_ATTACHMENT0) {
          for (let It = 0, kt = it.length; It < kt; It++)
            be[It] = s.COLOR_ATTACHMENT0 + It;
          be.length = it.length, ot = !0;
        }
      } else
        be[0] !== s.COLOR_ATTACHMENT0 && (be[0] = s.COLOR_ATTACHMENT0, ot = !0);
    else
      be[0] !== s.BACK && (be[0] = s.BACK, ot = !0);
    ot && (t.isWebGL2 ? s.drawBuffers(be) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(be));
  }
  function pe(Y) {
    return y !== Y ? (s.useProgram(Y), y = Y, !0) : !1;
  }
  const ce = {
    [go]: s.FUNC_ADD,
    [xS]: s.FUNC_SUBTRACT,
    [AS]: s.FUNC_REVERSE_SUBTRACT
  };
  if (n)
    ce[f_] = s.MIN, ce[d_] = s.MAX;
  else {
    const Y = e.get("EXT_blend_minmax");
    Y !== null && (ce[f_] = Y.MIN_EXT, ce[d_] = Y.MAX_EXT);
  }
  const Me = {
    [MS]: s.ZERO,
    [SS]: s.ONE,
    [ES]: s.SRC_COLOR,
    [Gd]: s.SRC_ALPHA,
    [BS]: s.SRC_ALPHA_SATURATE,
    [bS]: s.DST_COLOR,
    [wS]: s.DST_ALPHA,
    [TS]: s.ONE_MINUS_SRC_COLOR,
    [Hd]: s.ONE_MINUS_SRC_ALPHA,
    [RS]: s.ONE_MINUS_DST_COLOR,
    [CS]: s.ONE_MINUS_DST_ALPHA,
    [PS]: s.CONSTANT_COLOR,
    [IS]: s.ONE_MINUS_CONSTANT_COLOR,
    [LS]: s.CONSTANT_ALPHA,
    [DS]: s.ONE_MINUS_CONSTANT_ALPHA
  };
  function fe(Y, Ce, be, ot, it, It, kt, Qe, We, tt) {
    if (Y === zs) {
      v === !0 && (De(s.BLEND), v = !1);
      return;
    }
    if (v === !1 && (Pe(s.BLEND), v = !0), Y !== yS) {
      if (Y !== S || tt !== G) {
        if ((M !== go || b !== go) && (s.blendEquation(s.FUNC_ADD), M = go, b = go), tt)
          switch (Y) {
            case Ma:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case c_:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case u_:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case h_:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Y);
              break;
          }
        else
          switch (Y) {
            case Ma:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case c_:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case u_:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case h_:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Y);
              break;
          }
        T = null, P = null, R = null, U = null, C.set(0, 0, 0), B = 0, S = Y, G = tt;
      }
      return;
    }
    it = it || Ce, It = It || be, kt = kt || ot, (Ce !== M || it !== b) && (s.blendEquationSeparate(ce[Ce], ce[it]), M = Ce, b = it), (be !== T || ot !== P || It !== R || kt !== U) && (s.blendFuncSeparate(Me[be], Me[ot], Me[It], Me[kt]), T = be, P = ot, R = It, U = kt), (Qe.equals(C) === !1 || We !== B) && (s.blendColor(Qe.r, Qe.g, Qe.b, We), C.copy(Qe), B = We), S = Y, G = !1;
  }
  function Q(Y, Ce) {
    Y.side === Xr ? De(s.CULL_FACE) : Pe(s.CULL_FACE);
    let be = Y.side === Oi;
    Ce && (be = !be), Ie(be), Y.blending === Ma && Y.transparent === !1 ? fe(zs) : fe(Y.blending, Y.blendEquation, Y.blendSrc, Y.blendDst, Y.blendEquationAlpha, Y.blendSrcAlpha, Y.blendDstAlpha, Y.blendColor, Y.blendAlpha, Y.premultipliedAlpha), l.setFunc(Y.depthFunc), l.setTest(Y.depthTest), l.setMask(Y.depthWrite), a.setMask(Y.colorWrite);
    const ot = Y.stencilWrite;
    h.setTest(ot), ot && (h.setMask(Y.stencilWriteMask), h.setFunc(Y.stencilFunc, Y.stencilRef, Y.stencilFuncMask), h.setOp(Y.stencilFail, Y.stencilZFail, Y.stencilZPass)), $(Y.polygonOffset, Y.polygonOffsetFactor, Y.polygonOffsetUnits), Y.alphaToCoverage === !0 ? Pe(s.SAMPLE_ALPHA_TO_COVERAGE) : De(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ie(Y) {
    W !== Y && (Y ? s.frontFace(s.CW) : s.frontFace(s.CCW), W = Y);
  }
  function O(Y) {
    Y !== gS ? (Pe(s.CULL_FACE), Y !== se && (Y === l_ ? s.cullFace(s.BACK) : Y === _S ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : De(s.CULL_FACE), se = Y;
  }
  function L(Y) {
    Y !== z && (N && s.lineWidth(Y), z = Y);
  }
  function $(Y, Ce, be) {
    Y ? (Pe(s.POLYGON_OFFSET_FILL), (q !== Ce || j !== be) && (s.polygonOffset(Ce, be), q = Ce, j = be)) : De(s.POLYGON_OFFSET_FILL);
  }
  function xe(Y) {
    Y ? Pe(s.SCISSOR_TEST) : De(s.SCISSOR_TEST);
  }
  function Ae(Y) {
    Y === void 0 && (Y = s.TEXTURE0 + ee - 1), D !== Y && (s.activeTexture(Y), D = Y);
  }
  function _e(Y, Ce, be) {
    be === void 0 && (D === null ? be = s.TEXTURE0 + ee - 1 : be = D);
    let ot = J[be];
    ot === void 0 && (ot = { type: void 0, texture: void 0 }, J[be] = ot), (ot.type !== Y || ot.texture !== Ce) && (D !== be && (s.activeTexture(be), D = be), s.bindTexture(Y, Ce || Be[Y]), ot.type = Y, ot.texture = Ce);
  }
  function Ue() {
    const Y = J[D];
    Y !== void 0 && Y.type !== void 0 && (s.bindTexture(Y.type, null), Y.type = void 0, Y.texture = void 0);
  }
  function Le() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function Te() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function Ze() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function ct() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function ye() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function bt() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function et() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function mt() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function je() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function Ve() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (Y) {
      console.error("THREE.WebGLState:", Y);
    }
  }
  function gt(Y) {
    he.equals(Y) === !1 && (s.scissor(Y.x, Y.y, Y.z, Y.w), he.copy(Y));
  }
  function St(Y) {
    ge.equals(Y) === !1 && (s.viewport(Y.x, Y.y, Y.z, Y.w), ge.copy(Y));
  }
  function Wt(Y, Ce) {
    let be = d.get(Ce);
    be === void 0 && (be = /* @__PURE__ */ new WeakMap(), d.set(Ce, be));
    let ot = be.get(Y);
    ot === void 0 && (ot = s.getUniformBlockIndex(Ce, Y.name), be.set(Y, ot));
  }
  function Oe(Y, Ce) {
    const ot = d.get(Ce).get(Y);
    f.get(Ce) !== ot && (s.uniformBlockBinding(Ce, ot, Y.__bindingPointIndex), f.set(Ce, ot));
  }
  function Ee() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), n === !0 && (s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null)), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), p = {}, D = null, J = {}, m = {}, _ = /* @__PURE__ */ new WeakMap(), x = [], y = null, v = !1, S = null, M = null, T = null, P = null, b = null, R = null, U = null, C = new Ne(0, 0, 0), B = 0, G = !1, W = null, se = null, z = null, q = null, j = null, he.set(0, 0, s.canvas.width, s.canvas.height), ge.set(0, 0, s.canvas.width, s.canvas.height), a.reset(), l.reset(), h.reset();
  }
  return {
    buffers: {
      color: a,
      depth: l,
      stencil: h
    },
    enable: Pe,
    disable: De,
    bindFramebuffer: ze,
    drawBuffers: X,
    useProgram: pe,
    setBlending: fe,
    setMaterial: Q,
    setFlipSided: Ie,
    setCullFace: O,
    setLineWidth: L,
    setPolygonOffset: $,
    setScissorTest: xe,
    activeTexture: Ae,
    bindTexture: _e,
    unbindTexture: Ue,
    compressedTexImage2D: Le,
    compressedTexImage3D: Te,
    texImage2D: je,
    texImage3D: Ve,
    updateUBOMapping: Wt,
    uniformBlockBinding: Oe,
    texStorage2D: et,
    texStorage3D: mt,
    texSubImage2D: Ze,
    texSubImage3D: ct,
    compressedTexSubImage2D: ye,
    compressedTexSubImage3D: bt,
    scissor: gt,
    viewport: St,
    reset: Ee
  };
}
function iL(s, e, t, n, i, r, o) {
  const a = i.isWebGL2, l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, h = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), f = /* @__PURE__ */ new WeakMap();
  let d;
  const p = /* @__PURE__ */ new WeakMap();
  let m = !1;
  try {
    m = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function _(O, L) {
    return m ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(O, L)
    ) : zu("canvas");
  }
  function x(O, L, $, xe) {
    let Ae = 1;
    if ((O.width > xe || O.height > xe) && (Ae = xe / Math.max(O.width, O.height)), Ae < 1 || L === !0)
      if (typeof HTMLImageElement < "u" && O instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && O instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && O instanceof ImageBitmap) {
        const _e = L ? Wd : Math.floor, Ue = _e(Ae * O.width), Le = _e(Ae * O.height);
        d === void 0 && (d = _(Ue, Le));
        const Te = $ ? _(Ue, Le) : d;
        return Te.width = Ue, Te.height = Le, Te.getContext("2d").drawImage(O, 0, 0, Ue, Le), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + O.width + "x" + O.height + ") to (" + Ue + "x" + Le + ")."), Te;
      } else
        return "data" in O && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + O.width + "x" + O.height + ")."), O;
    return O;
  }
  function y(O) {
    return z_(O.width) && z_(O.height);
  }
  function v(O) {
    return a ? !1 : O.wrapS !== ri || O.wrapT !== ri || O.minFilter !== Sn && O.minFilter !== gn;
  }
  function S(O, L) {
    return O.generateMipmaps && L && O.minFilter !== Sn && O.minFilter !== gn;
  }
  function M(O) {
    s.generateMipmap(O);
  }
  function T(O, L, $, xe, Ae = !1) {
    if (a === !1) return L;
    if (O !== null) {
      if (s[O] !== void 0) return s[O];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + O + "'");
    }
    let _e = L;
    if (L === s.RED && ($ === s.FLOAT && (_e = s.R32F), $ === s.HALF_FLOAT && (_e = s.R16F), $ === s.UNSIGNED_BYTE && (_e = s.R8)), L === s.RED_INTEGER && ($ === s.UNSIGNED_BYTE && (_e = s.R8UI), $ === s.UNSIGNED_SHORT && (_e = s.R16UI), $ === s.UNSIGNED_INT && (_e = s.R32UI), $ === s.BYTE && (_e = s.R8I), $ === s.SHORT && (_e = s.R16I), $ === s.INT && (_e = s.R32I)), L === s.RG && ($ === s.FLOAT && (_e = s.RG32F), $ === s.HALF_FLOAT && (_e = s.RG16F), $ === s.UNSIGNED_BYTE && (_e = s.RG8)), L === s.RGBA) {
      const Ue = Ae ? Nu : Qt.getTransfer(xe);
      $ === s.FLOAT && (_e = s.RGBA32F), $ === s.HALF_FLOAT && (_e = s.RGBA16F), $ === s.UNSIGNED_BYTE && (_e = Ue === on ? s.SRGB8_ALPHA8 : s.RGBA8), $ === s.UNSIGNED_SHORT_4_4_4_4 && (_e = s.RGBA4), $ === s.UNSIGNED_SHORT_5_5_5_1 && (_e = s.RGB5_A1);
    }
    return (_e === s.R16F || _e === s.R32F || _e === s.RG16F || _e === s.RG32F || _e === s.RGBA16F || _e === s.RGBA32F) && e.get("EXT_color_buffer_float"), _e;
  }
  function P(O, L, $) {
    return S(O, $) === !0 || O.isFramebufferTexture && O.minFilter !== Sn && O.minFilter !== gn ? Math.log2(Math.max(L.width, L.height)) + 1 : O.mipmaps !== void 0 && O.mipmaps.length > 0 ? O.mipmaps.length : O.isCompressedTexture && Array.isArray(O.image) ? L.mipmaps.length : 1;
  }
  function b(O) {
    return O === Sn || O === Uu || O === Jl ? s.NEAREST : s.LINEAR;
  }
  function R(O) {
    const L = O.target;
    L.removeEventListener("dispose", R), C(L), L.isVideoTexture && f.delete(L);
  }
  function U(O) {
    const L = O.target;
    L.removeEventListener("dispose", U), G(L);
  }
  function C(O) {
    const L = n.get(O);
    if (L.__webglInit === void 0) return;
    const $ = O.source, xe = p.get($);
    if (xe) {
      const Ae = xe[L.__cacheKey];
      Ae.usedTimes--, Ae.usedTimes === 0 && B(O), Object.keys(xe).length === 0 && p.delete($);
    }
    n.remove(O);
  }
  function B(O) {
    const L = n.get(O);
    s.deleteTexture(L.__webglTexture);
    const $ = O.source, xe = p.get($);
    delete xe[L.__cacheKey], o.memory.textures--;
  }
  function G(O) {
    const L = O.texture, $ = n.get(O), xe = n.get(L);
    if (xe.__webglTexture !== void 0 && (s.deleteTexture(xe.__webglTexture), o.memory.textures--), O.depthTexture && O.depthTexture.dispose(), O.isWebGLCubeRenderTarget)
      for (let Ae = 0; Ae < 6; Ae++) {
        if (Array.isArray($.__webglFramebuffer[Ae]))
          for (let _e = 0; _e < $.__webglFramebuffer[Ae].length; _e++) s.deleteFramebuffer($.__webglFramebuffer[Ae][_e]);
        else
          s.deleteFramebuffer($.__webglFramebuffer[Ae]);
        $.__webglDepthbuffer && s.deleteRenderbuffer($.__webglDepthbuffer[Ae]);
      }
    else {
      if (Array.isArray($.__webglFramebuffer))
        for (let Ae = 0; Ae < $.__webglFramebuffer.length; Ae++) s.deleteFramebuffer($.__webglFramebuffer[Ae]);
      else
        s.deleteFramebuffer($.__webglFramebuffer);
      if ($.__webglDepthbuffer && s.deleteRenderbuffer($.__webglDepthbuffer), $.__webglMultisampledFramebuffer && s.deleteFramebuffer($.__webglMultisampledFramebuffer), $.__webglColorRenderbuffer)
        for (let Ae = 0; Ae < $.__webglColorRenderbuffer.length; Ae++)
          $.__webglColorRenderbuffer[Ae] && s.deleteRenderbuffer($.__webglColorRenderbuffer[Ae]);
      $.__webglDepthRenderbuffer && s.deleteRenderbuffer($.__webglDepthRenderbuffer);
    }
    if (O.isWebGLMultipleRenderTargets)
      for (let Ae = 0, _e = L.length; Ae < _e; Ae++) {
        const Ue = n.get(L[Ae]);
        Ue.__webglTexture && (s.deleteTexture(Ue.__webglTexture), o.memory.textures--), n.remove(L[Ae]);
      }
    n.remove(L), n.remove(O);
  }
  let W = 0;
  function se() {
    W = 0;
  }
  function z() {
    const O = W;
    return O >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + O + " texture units while this GPU supports only " + i.maxTextures), W += 1, O;
  }
  function q(O) {
    const L = [];
    return L.push(O.wrapS), L.push(O.wrapT), L.push(O.wrapR || 0), L.push(O.magFilter), L.push(O.minFilter), L.push(O.anisotropy), L.push(O.internalFormat), L.push(O.format), L.push(O.type), L.push(O.generateMipmaps), L.push(O.premultiplyAlpha), L.push(O.flipY), L.push(O.unpackAlignment), L.push(O.colorSpace), L.join();
  }
  function j(O, L) {
    const $ = n.get(O);
    if (O.isVideoTexture && Q(O), O.isRenderTargetTexture === !1 && O.version > 0 && $.__version !== O.version) {
      const xe = O.image;
      if (xe === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (xe.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        he($, O, L);
        return;
      }
    }
    t.bindTexture(s.TEXTURE_2D, $.__webglTexture, s.TEXTURE0 + L);
  }
  function ee(O, L) {
    const $ = n.get(O);
    if (O.version > 0 && $.__version !== O.version) {
      he($, O, L);
      return;
    }
    t.bindTexture(s.TEXTURE_2D_ARRAY, $.__webglTexture, s.TEXTURE0 + L);
  }
  function N(O, L) {
    const $ = n.get(O);
    if (O.version > 0 && $.__version !== O.version) {
      he($, O, L);
      return;
    }
    t.bindTexture(s.TEXTURE_3D, $.__webglTexture, s.TEXTURE0 + L);
  }
  function V(O, L) {
    const $ = n.get(O);
    if (O.version > 0 && $.__version !== O.version) {
      ge($, O, L);
      return;
    }
    t.bindTexture(s.TEXTURE_CUBE_MAP, $.__webglTexture, s.TEXTURE0 + L);
  }
  const I = {
    [Bo]: s.REPEAT,
    [ri]: s.CLAMP_TO_EDGE,
    [nc]: s.MIRRORED_REPEAT
  }, D = {
    [Sn]: s.NEAREST,
    [Uu]: s.NEAREST_MIPMAP_NEAREST,
    [Jl]: s.NEAREST_MIPMAP_LINEAR,
    [gn]: s.LINEAR,
    [lp]: s.LINEAR_MIPMAP_NEAREST,
    [_s]: s.LINEAR_MIPMAP_LINEAR
  }, J = {
    [hE]: s.NEVER,
    [_E]: s.ALWAYS,
    [fE]: s.LESS,
    [O0]: s.LEQUAL,
    [dE]: s.EQUAL,
    [gE]: s.GEQUAL,
    [pE]: s.GREATER,
    [mE]: s.NOTEQUAL
  };
  function K(O, L, $) {
    if ($ ? (s.texParameteri(O, s.TEXTURE_WRAP_S, I[L.wrapS]), s.texParameteri(O, s.TEXTURE_WRAP_T, I[L.wrapT]), (O === s.TEXTURE_3D || O === s.TEXTURE_2D_ARRAY) && s.texParameteri(O, s.TEXTURE_WRAP_R, I[L.wrapR]), s.texParameteri(O, s.TEXTURE_MAG_FILTER, D[L.magFilter]), s.texParameteri(O, s.TEXTURE_MIN_FILTER, D[L.minFilter])) : (s.texParameteri(O, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(O, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), (O === s.TEXTURE_3D || O === s.TEXTURE_2D_ARRAY) && s.texParameteri(O, s.TEXTURE_WRAP_R, s.CLAMP_TO_EDGE), (L.wrapS !== ri || L.wrapT !== ri) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), s.texParameteri(O, s.TEXTURE_MAG_FILTER, b(L.magFilter)), s.texParameteri(O, s.TEXTURE_MIN_FILTER, b(L.minFilter)), L.minFilter !== Sn && L.minFilter !== gn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), L.compareFunction && (s.texParameteri(O, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(O, s.TEXTURE_COMPARE_FUNC, J[L.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      const xe = e.get("EXT_texture_filter_anisotropic");
      if (L.magFilter === Sn || L.minFilter !== Jl && L.minFilter !== _s || L.type === Jr && e.has("OES_texture_float_linear") === !1 || a === !1 && L.type === ic && e.has("OES_texture_half_float_linear") === !1) return;
      (L.anisotropy > 1 || n.get(L).__currentAnisotropy) && (s.texParameterf(O, xe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(L.anisotropy, i.getMaxAnisotropy())), n.get(L).__currentAnisotropy = L.anisotropy);
    }
  }
  function ie(O, L) {
    let $ = !1;
    O.__webglInit === void 0 && (O.__webglInit = !0, L.addEventListener("dispose", R));
    const xe = L.source;
    let Ae = p.get(xe);
    Ae === void 0 && (Ae = {}, p.set(xe, Ae));
    const _e = q(L);
    if (_e !== O.__cacheKey) {
      Ae[_e] === void 0 && (Ae[_e] = {
        texture: s.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, $ = !0), Ae[_e].usedTimes++;
      const Ue = Ae[O.__cacheKey];
      Ue !== void 0 && (Ae[O.__cacheKey].usedTimes--, Ue.usedTimes === 0 && B(L)), O.__cacheKey = _e, O.__webglTexture = Ae[_e].texture;
    }
    return $;
  }
  function he(O, L, $) {
    let xe = s.TEXTURE_2D;
    (L.isDataArrayTexture || L.isCompressedArrayTexture) && (xe = s.TEXTURE_2D_ARRAY), L.isData3DTexture && (xe = s.TEXTURE_3D);
    const Ae = ie(O, L), _e = L.source;
    t.bindTexture(xe, O.__webglTexture, s.TEXTURE0 + $);
    const Ue = n.get(_e);
    if (_e.version !== Ue.__version || Ae === !0) {
      t.activeTexture(s.TEXTURE0 + $);
      const Le = Qt.getPrimaries(Qt.workingColorSpace), Te = L.colorSpace === ar ? null : Qt.getPrimaries(L.colorSpace), Ze = L.colorSpace === ar || Le === Te ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, L.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, L.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ze);
      const ct = v(L) && y(L.image) === !1;
      let ye = x(L.image, ct, !1, i.maxTextureSize);
      ye = Ie(L, ye);
      const bt = y(ye) || a, et = r.convert(L.format, L.colorSpace);
      let mt = r.convert(L.type), je = T(L.internalFormat, et, mt, L.colorSpace, L.isVideoTexture);
      K(xe, L, bt);
      let Ve;
      const gt = L.mipmaps, St = a && L.isVideoTexture !== !0 && je !== L0, Wt = Ue.__version === void 0 || Ae === !0, Oe = P(L, ye, bt);
      if (L.isDepthTexture)
        je = s.DEPTH_COMPONENT, a ? L.type === Jr ? je = s.DEPTH_COMPONENT32F : L.type === Ns ? je = s.DEPTH_COMPONENT24 : L.type === Mo ? je = s.DEPTH24_STENCIL8 : je = s.DEPTH_COMPONENT16 : L.type === Jr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), L.format === So && je === s.DEPTH_COMPONENT && L.type !== cp && L.type !== Ns && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), L.type = Ns, mt = r.convert(L.type)), L.format === Da && je === s.DEPTH_COMPONENT && (je = s.DEPTH_STENCIL, L.type !== Mo && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), L.type = Mo, mt = r.convert(L.type))), Wt && (St ? t.texStorage2D(s.TEXTURE_2D, 1, je, ye.width, ye.height) : t.texImage2D(s.TEXTURE_2D, 0, je, ye.width, ye.height, 0, et, mt, null));
      else if (L.isDataTexture)
        if (gt.length > 0 && bt) {
          St && Wt && t.texStorage2D(s.TEXTURE_2D, Oe, je, gt[0].width, gt[0].height);
          for (let Ee = 0, Y = gt.length; Ee < Y; Ee++)
            Ve = gt[Ee], St ? t.texSubImage2D(s.TEXTURE_2D, Ee, 0, 0, Ve.width, Ve.height, et, mt, Ve.data) : t.texImage2D(s.TEXTURE_2D, Ee, je, Ve.width, Ve.height, 0, et, mt, Ve.data);
          L.generateMipmaps = !1;
        } else
          St ? (Wt && t.texStorage2D(s.TEXTURE_2D, Oe, je, ye.width, ye.height), t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, ye.width, ye.height, et, mt, ye.data)) : t.texImage2D(s.TEXTURE_2D, 0, je, ye.width, ye.height, 0, et, mt, ye.data);
      else if (L.isCompressedTexture)
        if (L.isCompressedArrayTexture) {
          St && Wt && t.texStorage3D(s.TEXTURE_2D_ARRAY, Oe, je, gt[0].width, gt[0].height, ye.depth);
          for (let Ee = 0, Y = gt.length; Ee < Y; Ee++)
            Ve = gt[Ee], L.format !== Di ? et !== null ? St ? t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, Ee, 0, 0, 0, Ve.width, Ve.height, ye.depth, et, Ve.data, 0, 0) : t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, Ee, je, Ve.width, Ve.height, ye.depth, 0, Ve.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : St ? t.texSubImage3D(s.TEXTURE_2D_ARRAY, Ee, 0, 0, 0, Ve.width, Ve.height, ye.depth, et, mt, Ve.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, Ee, je, Ve.width, Ve.height, ye.depth, 0, et, mt, Ve.data);
        } else {
          St && Wt && t.texStorage2D(s.TEXTURE_2D, Oe, je, gt[0].width, gt[0].height);
          for (let Ee = 0, Y = gt.length; Ee < Y; Ee++)
            Ve = gt[Ee], L.format !== Di ? et !== null ? St ? t.compressedTexSubImage2D(s.TEXTURE_2D, Ee, 0, 0, Ve.width, Ve.height, et, Ve.data) : t.compressedTexImage2D(s.TEXTURE_2D, Ee, je, Ve.width, Ve.height, 0, Ve.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : St ? t.texSubImage2D(s.TEXTURE_2D, Ee, 0, 0, Ve.width, Ve.height, et, mt, Ve.data) : t.texImage2D(s.TEXTURE_2D, Ee, je, Ve.width, Ve.height, 0, et, mt, Ve.data);
        }
      else if (L.isDataArrayTexture)
        St ? (Wt && t.texStorage3D(s.TEXTURE_2D_ARRAY, Oe, je, ye.width, ye.height, ye.depth), t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ye.width, ye.height, ye.depth, et, mt, ye.data)) : t.texImage3D(s.TEXTURE_2D_ARRAY, 0, je, ye.width, ye.height, ye.depth, 0, et, mt, ye.data);
      else if (L.isData3DTexture)
        St ? (Wt && t.texStorage3D(s.TEXTURE_3D, Oe, je, ye.width, ye.height, ye.depth), t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, ye.width, ye.height, ye.depth, et, mt, ye.data)) : t.texImage3D(s.TEXTURE_3D, 0, je, ye.width, ye.height, ye.depth, 0, et, mt, ye.data);
      else if (L.isFramebufferTexture) {
        if (Wt)
          if (St)
            t.texStorage2D(s.TEXTURE_2D, Oe, je, ye.width, ye.height);
          else {
            let Ee = ye.width, Y = ye.height;
            for (let Ce = 0; Ce < Oe; Ce++)
              t.texImage2D(s.TEXTURE_2D, Ce, je, Ee, Y, 0, et, mt, null), Ee >>= 1, Y >>= 1;
          }
      } else if (gt.length > 0 && bt) {
        St && Wt && t.texStorage2D(s.TEXTURE_2D, Oe, je, gt[0].width, gt[0].height);
        for (let Ee = 0, Y = gt.length; Ee < Y; Ee++)
          Ve = gt[Ee], St ? t.texSubImage2D(s.TEXTURE_2D, Ee, 0, 0, et, mt, Ve) : t.texImage2D(s.TEXTURE_2D, Ee, je, et, mt, Ve);
        L.generateMipmaps = !1;
      } else
        St ? (Wt && t.texStorage2D(s.TEXTURE_2D, Oe, je, ye.width, ye.height), t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, et, mt, ye)) : t.texImage2D(s.TEXTURE_2D, 0, je, et, mt, ye);
      S(L, bt) && M(xe), Ue.__version = _e.version, L.onUpdate && L.onUpdate(L);
    }
    O.__version = L.version;
  }
  function ge(O, L, $) {
    if (L.image.length !== 6) return;
    const xe = ie(O, L), Ae = L.source;
    t.bindTexture(s.TEXTURE_CUBE_MAP, O.__webglTexture, s.TEXTURE0 + $);
    const _e = n.get(Ae);
    if (Ae.version !== _e.__version || xe === !0) {
      t.activeTexture(s.TEXTURE0 + $);
      const Ue = Qt.getPrimaries(Qt.workingColorSpace), Le = L.colorSpace === ar ? null : Qt.getPrimaries(L.colorSpace), Te = L.colorSpace === ar || Ue === Le ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, L.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, L.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, L.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Te);
      const Ze = L.isCompressedTexture || L.image[0].isCompressedTexture, ct = L.image[0] && L.image[0].isDataTexture, ye = [];
      for (let Ee = 0; Ee < 6; Ee++)
        !Ze && !ct ? ye[Ee] = x(L.image[Ee], !1, !0, i.maxCubemapSize) : ye[Ee] = ct ? L.image[Ee].image : L.image[Ee], ye[Ee] = Ie(L, ye[Ee]);
      const bt = ye[0], et = y(bt) || a, mt = r.convert(L.format, L.colorSpace), je = r.convert(L.type), Ve = T(L.internalFormat, mt, je, L.colorSpace), gt = a && L.isVideoTexture !== !0, St = _e.__version === void 0 || xe === !0;
      let Wt = P(L, bt, et);
      K(s.TEXTURE_CUBE_MAP, L, et);
      let Oe;
      if (Ze) {
        gt && St && t.texStorage2D(s.TEXTURE_CUBE_MAP, Wt, Ve, bt.width, bt.height);
        for (let Ee = 0; Ee < 6; Ee++) {
          Oe = ye[Ee].mipmaps;
          for (let Y = 0; Y < Oe.length; Y++) {
            const Ce = Oe[Y];
            L.format !== Di ? mt !== null ? gt ? t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Y, 0, 0, Ce.width, Ce.height, mt, Ce.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Y, Ve, Ce.width, Ce.height, 0, Ce.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : gt ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Y, 0, 0, Ce.width, Ce.height, mt, je, Ce.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Y, Ve, Ce.width, Ce.height, 0, mt, je, Ce.data);
          }
        }
      } else {
        Oe = L.mipmaps, gt && St && (Oe.length > 0 && Wt++, t.texStorage2D(s.TEXTURE_CUBE_MAP, Wt, Ve, ye[0].width, ye[0].height));
        for (let Ee = 0; Ee < 6; Ee++)
          if (ct) {
            gt ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, 0, 0, ye[Ee].width, ye[Ee].height, mt, je, ye[Ee].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, Ve, ye[Ee].width, ye[Ee].height, 0, mt, je, ye[Ee].data);
            for (let Y = 0; Y < Oe.length; Y++) {
              const be = Oe[Y].image[Ee].image;
              gt ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Y + 1, 0, 0, be.width, be.height, mt, je, be.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Y + 1, Ve, be.width, be.height, 0, mt, je, be.data);
            }
          } else {
            gt ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, 0, 0, mt, je, ye[Ee]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0, Ve, mt, je, ye[Ee]);
            for (let Y = 0; Y < Oe.length; Y++) {
              const Ce = Oe[Y];
              gt ? t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Y + 1, 0, 0, mt, je, Ce.image[Ee]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Y + 1, Ve, mt, je, Ce.image[Ee]);
            }
          }
      }
      S(L, et) && M(s.TEXTURE_CUBE_MAP), _e.__version = Ae.version, L.onUpdate && L.onUpdate(L);
    }
    O.__version = L.version;
  }
  function me(O, L, $, xe, Ae, _e) {
    const Ue = r.convert($.format, $.colorSpace), Le = r.convert($.type), Te = T($.internalFormat, Ue, Le, $.colorSpace);
    if (!n.get(L).__hasExternalTextures) {
      const ct = Math.max(1, L.width >> _e), ye = Math.max(1, L.height >> _e);
      Ae === s.TEXTURE_3D || Ae === s.TEXTURE_2D_ARRAY ? t.texImage3D(Ae, _e, Te, ct, ye, L.depth, 0, Ue, Le, null) : t.texImage2D(Ae, _e, Te, ct, ye, 0, Ue, Le, null);
    }
    t.bindFramebuffer(s.FRAMEBUFFER, O), fe(L) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, xe, Ae, n.get($).__webglTexture, 0, Me(L)) : (Ae === s.TEXTURE_2D || Ae >= s.TEXTURE_CUBE_MAP_POSITIVE_X && Ae <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, xe, Ae, n.get($).__webglTexture, _e), t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function Be(O, L, $) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, O), L.depthBuffer && !L.stencilBuffer) {
      let xe = a === !0 ? s.DEPTH_COMPONENT24 : s.DEPTH_COMPONENT16;
      if ($ || fe(L)) {
        const Ae = L.depthTexture;
        Ae && Ae.isDepthTexture && (Ae.type === Jr ? xe = s.DEPTH_COMPONENT32F : Ae.type === Ns && (xe = s.DEPTH_COMPONENT24));
        const _e = Me(L);
        fe(L) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, _e, xe, L.width, L.height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, _e, xe, L.width, L.height);
      } else
        s.renderbufferStorage(s.RENDERBUFFER, xe, L.width, L.height);
      s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, O);
    } else if (L.depthBuffer && L.stencilBuffer) {
      const xe = Me(L);
      $ && fe(L) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, xe, s.DEPTH24_STENCIL8, L.width, L.height) : fe(L) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, xe, s.DEPTH24_STENCIL8, L.width, L.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, L.width, L.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, O);
    } else {
      const xe = L.isWebGLMultipleRenderTargets === !0 ? L.texture : [L.texture];
      for (let Ae = 0; Ae < xe.length; Ae++) {
        const _e = xe[Ae], Ue = r.convert(_e.format, _e.colorSpace), Le = r.convert(_e.type), Te = T(_e.internalFormat, Ue, Le, _e.colorSpace), Ze = Me(L);
        $ && fe(L) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Ze, Te, L.width, L.height) : fe(L) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Ze, Te, L.width, L.height) : s.renderbufferStorage(s.RENDERBUFFER, Te, L.width, L.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function Pe(O, L) {
    if (L && L.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(s.FRAMEBUFFER, O), !(L.depthTexture && L.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!n.get(L.depthTexture).__webglTexture || L.depthTexture.image.width !== L.width || L.depthTexture.image.height !== L.height) && (L.depthTexture.image.width = L.width, L.depthTexture.image.height = L.height, L.depthTexture.needsUpdate = !0), j(L.depthTexture, 0);
    const xe = n.get(L.depthTexture).__webglTexture, Ae = Me(L);
    if (L.depthTexture.format === So)
      fe(L) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, xe, 0, Ae) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, xe, 0);
    else if (L.depthTexture.format === Da)
      fe(L) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, xe, 0, Ae) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, xe, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function De(O) {
    const L = n.get(O), $ = O.isWebGLCubeRenderTarget === !0;
    if (O.depthTexture && !L.__autoAllocateDepthBuffer) {
      if ($) throw new Error("target.depthTexture not supported in Cube render targets");
      Pe(L.__webglFramebuffer, O);
    } else if ($) {
      L.__webglDepthbuffer = [];
      for (let xe = 0; xe < 6; xe++)
        t.bindFramebuffer(s.FRAMEBUFFER, L.__webglFramebuffer[xe]), L.__webglDepthbuffer[xe] = s.createRenderbuffer(), Be(L.__webglDepthbuffer[xe], O, !1);
    } else
      t.bindFramebuffer(s.FRAMEBUFFER, L.__webglFramebuffer), L.__webglDepthbuffer = s.createRenderbuffer(), Be(L.__webglDepthbuffer, O, !1);
    t.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function ze(O, L, $) {
    const xe = n.get(O);
    L !== void 0 && me(xe.__webglFramebuffer, O, O.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), $ !== void 0 && De(O);
  }
  function X(O) {
    const L = O.texture, $ = n.get(O), xe = n.get(L);
    O.addEventListener("dispose", U), O.isWebGLMultipleRenderTargets !== !0 && (xe.__webglTexture === void 0 && (xe.__webglTexture = s.createTexture()), xe.__version = L.version, o.memory.textures++);
    const Ae = O.isWebGLCubeRenderTarget === !0, _e = O.isWebGLMultipleRenderTargets === !0, Ue = y(O) || a;
    if (Ae) {
      $.__webglFramebuffer = [];
      for (let Le = 0; Le < 6; Le++)
        if (a && L.mipmaps && L.mipmaps.length > 0) {
          $.__webglFramebuffer[Le] = [];
          for (let Te = 0; Te < L.mipmaps.length; Te++)
            $.__webglFramebuffer[Le][Te] = s.createFramebuffer();
        } else
          $.__webglFramebuffer[Le] = s.createFramebuffer();
    } else {
      if (a && L.mipmaps && L.mipmaps.length > 0) {
        $.__webglFramebuffer = [];
        for (let Le = 0; Le < L.mipmaps.length; Le++)
          $.__webglFramebuffer[Le] = s.createFramebuffer();
      } else
        $.__webglFramebuffer = s.createFramebuffer();
      if (_e)
        if (i.drawBuffers) {
          const Le = O.texture;
          for (let Te = 0, Ze = Le.length; Te < Ze; Te++) {
            const ct = n.get(Le[Te]);
            ct.__webglTexture === void 0 && (ct.__webglTexture = s.createTexture(), o.memory.textures++);
          }
        } else
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (a && O.samples > 0 && fe(O) === !1) {
        const Le = _e ? L : [L];
        $.__webglMultisampledFramebuffer = s.createFramebuffer(), $.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, $.__webglMultisampledFramebuffer);
        for (let Te = 0; Te < Le.length; Te++) {
          const Ze = Le[Te];
          $.__webglColorRenderbuffer[Te] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, $.__webglColorRenderbuffer[Te]);
          const ct = r.convert(Ze.format, Ze.colorSpace), ye = r.convert(Ze.type), bt = T(Ze.internalFormat, ct, ye, Ze.colorSpace, O.isXRRenderTarget === !0), et = Me(O);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, et, bt, O.width, O.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Te, s.RENDERBUFFER, $.__webglColorRenderbuffer[Te]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), O.depthBuffer && ($.__webglDepthRenderbuffer = s.createRenderbuffer(), Be($.__webglDepthRenderbuffer, O, !0)), t.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (Ae) {
      t.bindTexture(s.TEXTURE_CUBE_MAP, xe.__webglTexture), K(s.TEXTURE_CUBE_MAP, L, Ue);
      for (let Le = 0; Le < 6; Le++)
        if (a && L.mipmaps && L.mipmaps.length > 0)
          for (let Te = 0; Te < L.mipmaps.length; Te++)
            me($.__webglFramebuffer[Le][Te], O, L, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Le, Te);
        else
          me($.__webglFramebuffer[Le], O, L, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Le, 0);
      S(L, Ue) && M(s.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (_e) {
      const Le = O.texture;
      for (let Te = 0, Ze = Le.length; Te < Ze; Te++) {
        const ct = Le[Te], ye = n.get(ct);
        t.bindTexture(s.TEXTURE_2D, ye.__webglTexture), K(s.TEXTURE_2D, ct, Ue), me($.__webglFramebuffer, O, ct, s.COLOR_ATTACHMENT0 + Te, s.TEXTURE_2D, 0), S(ct, Ue) && M(s.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Le = s.TEXTURE_2D;
      if ((O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) && (a ? Le = O.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Le, xe.__webglTexture), K(Le, L, Ue), a && L.mipmaps && L.mipmaps.length > 0)
        for (let Te = 0; Te < L.mipmaps.length; Te++)
          me($.__webglFramebuffer[Te], O, L, s.COLOR_ATTACHMENT0, Le, Te);
      else
        me($.__webglFramebuffer, O, L, s.COLOR_ATTACHMENT0, Le, 0);
      S(L, Ue) && M(Le), t.unbindTexture();
    }
    O.depthBuffer && De(O);
  }
  function pe(O) {
    const L = y(O) || a, $ = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture];
    for (let xe = 0, Ae = $.length; xe < Ae; xe++) {
      const _e = $[xe];
      if (S(_e, L)) {
        const Ue = O.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D, Le = n.get(_e).__webglTexture;
        t.bindTexture(Ue, Le), M(Ue), t.unbindTexture();
      }
    }
  }
  function ce(O) {
    if (a && O.samples > 0 && fe(O) === !1) {
      const L = O.isWebGLMultipleRenderTargets ? O.texture : [O.texture], $ = O.width, xe = O.height;
      let Ae = s.COLOR_BUFFER_BIT;
      const _e = [], Ue = O.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Le = n.get(O), Te = O.isWebGLMultipleRenderTargets === !0;
      if (Te)
        for (let Ze = 0; Ze < L.length; Ze++)
          t.bindFramebuffer(s.FRAMEBUFFER, Le.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ze, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, Le.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ze, s.TEXTURE_2D, null, 0);
      t.bindFramebuffer(s.READ_FRAMEBUFFER, Le.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Le.__webglFramebuffer);
      for (let Ze = 0; Ze < L.length; Ze++) {
        _e.push(s.COLOR_ATTACHMENT0 + Ze), O.depthBuffer && _e.push(Ue);
        const ct = Le.__ignoreDepthValues !== void 0 ? Le.__ignoreDepthValues : !1;
        if (ct === !1 && (O.depthBuffer && (Ae |= s.DEPTH_BUFFER_BIT), O.stencilBuffer && (Ae |= s.STENCIL_BUFFER_BIT)), Te && s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Le.__webglColorRenderbuffer[Ze]), ct === !0 && (s.invalidateFramebuffer(s.READ_FRAMEBUFFER, [Ue]), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [Ue])), Te) {
          const ye = n.get(L[Ze]).__webglTexture;
          s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, ye, 0);
        }
        s.blitFramebuffer(0, 0, $, xe, 0, 0, $, xe, Ae, s.NEAREST), h && s.invalidateFramebuffer(s.READ_FRAMEBUFFER, _e);
      }
      if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), Te)
        for (let Ze = 0; Ze < L.length; Ze++) {
          t.bindFramebuffer(s.FRAMEBUFFER, Le.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ze, s.RENDERBUFFER, Le.__webglColorRenderbuffer[Ze]);
          const ct = n.get(L[Ze]).__webglTexture;
          t.bindFramebuffer(s.FRAMEBUFFER, Le.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ze, s.TEXTURE_2D, ct, 0);
        }
      t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Le.__webglMultisampledFramebuffer);
    }
  }
  function Me(O) {
    return Math.min(i.maxSamples, O.samples);
  }
  function fe(O) {
    const L = n.get(O);
    return a && O.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && L.__useRenderToTexture !== !1;
  }
  function Q(O) {
    const L = o.render.frame;
    f.get(O) !== L && (f.set(O, L), O.update());
  }
  function Ie(O, L) {
    const $ = O.colorSpace, xe = O.format, Ae = O.type;
    return O.isCompressedTexture === !0 || O.isVideoTexture === !0 || O.format === Vd || $ !== vs && $ !== ar && (Qt.getTransfer($) === on ? a === !1 ? e.has("EXT_sRGB") === !0 && xe === Di ? (O.format = Vd, O.minFilter = gn, O.generateMipmaps = !1) : L = k0.sRGBToLinear(L) : (xe !== Di || Ae !== ds) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", $)), L;
  }
  this.allocateTextureUnit = z, this.resetTextureUnits = se, this.setTexture2D = j, this.setTexture2DArray = ee, this.setTexture3D = N, this.setTextureCube = V, this.rebindTextures = ze, this.setupRenderTarget = X, this.updateRenderTargetMipmap = pe, this.updateMultisampleRenderTarget = ce, this.setupDepthRenderbuffer = De, this.setupFrameBufferTexture = me, this.useMultisampledRTT = fe;
}
function IE(s, e, t) {
  const n = t.isWebGL2;
  function i(r, o = ar) {
    let a;
    const l = Qt.getTransfer(o);
    if (r === ds) return s.UNSIGNED_BYTE;
    if (r === b0) return s.UNSIGNED_SHORT_4_4_4_4;
    if (r === R0) return s.UNSIGNED_SHORT_5_5_5_1;
    if (r === QS) return s.BYTE;
    if (r === ZS) return s.SHORT;
    if (r === cp) return s.UNSIGNED_SHORT;
    if (r === C0) return s.INT;
    if (r === Ns) return s.UNSIGNED_INT;
    if (r === Jr) return s.FLOAT;
    if (r === ic)
      return n ? s.HALF_FLOAT : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
    if (r === jS) return s.ALPHA;
    if (r === Di) return s.RGBA;
    if (r === $S) return s.LUMINANCE;
    if (r === eE) return s.LUMINANCE_ALPHA;
    if (r === So) return s.DEPTH_COMPONENT;
    if (r === Da) return s.DEPTH_STENCIL;
    if (r === Vd)
      return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (r === tE) return s.RED;
    if (r === B0) return s.RED_INTEGER;
    if (r === nE) return s.RG;
    if (r === P0) return s.RG_INTEGER;
    if (r === I0) return s.RGBA_INTEGER;
    if (r === Sd || r === Ed || r === Td || r === wd)
      if (l === on)
        if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (r === Sd) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === Ed) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === Td) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === wd) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (r === Sd) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === Ed) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === Td) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === wd) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (r === m_ || r === g_ || r === __ || r === v_)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (r === m_) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === g_) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === __) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === v_) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (r === L0)
      return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (r === y_ || r === x_)
      if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (r === y_) return l === on ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (r === x_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (r === A_ || r === M_ || r === S_ || r === E_ || r === T_ || r === w_ || r === C_ || r === b_ || r === R_ || r === B_ || r === P_ || r === I_ || r === L_ || r === D_)
      if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (r === A_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === M_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === S_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === E_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === T_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === w_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === C_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === b_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === R_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === B_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === P_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === I_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === L_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === D_) return l === on ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (r === Cd || r === F_ || r === U_)
      if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (r === Cd) return l === on ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === F_) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === U_) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (r === iE || r === O_ || r === N_ || r === k_)
      if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
        if (r === Cd) return a.COMPRESSED_RED_RGTC1_EXT;
        if (r === O_) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === N_) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === k_) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return r === Mo ? n ? s.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : s[r] !== void 0 ? s[r] : null;
  }
  return { convert: i };
}
class LE extends Wn {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class ks extends zt {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const rL = { type: "move" };
class fg {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new ks(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new ks(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new k(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new k()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new ks(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new k(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new k()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, t, n) {
    let i = null, r = null, o = null;
    const a = this._targetRay, l = this._grip, h = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (h && e.hand) {
        o = !0;
        for (const x of e.hand.values()) {
          const y = t.getJointPose(x, n), v = this._getHandJoint(h, x);
          y !== null && (v.matrix.fromArray(y.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.matrixWorldNeedsUpdate = !0, v.jointRadius = y.radius), v.visible = y !== null;
        }
        const f = h.joints["index-finger-tip"], d = h.joints["thumb-tip"], p = f.position.distanceTo(d.position), m = 0.02, _ = 5e-3;
        h.inputState.pinching && p > m + _ ? (h.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !h.inputState.pinching && p <= m - _ && (h.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
      a !== null && (i = t.getPose(e.targetRaySpace, n), i === null && r !== null && (i = r), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(rL)));
    }
    return a !== null && (a.visible = i !== null), l !== null && (l.visible = r !== null), h !== null && (h.visible = o !== null), this;
  }
  // private method
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new ks();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class sL extends qs {
  constructor(e, t) {
    super();
    const n = this;
    let i = null, r = 1, o = null, a = "local-floor", l = 1, h = null, f = null, d = null, p = null, m = null, _ = null;
    const x = t.getContextAttributes();
    let y = null, v = null;
    const S = [], M = [], T = new ve();
    let P = null;
    const b = new Wn();
    b.layers.enable(1), b.viewport = new Zt();
    const R = new Wn();
    R.layers.enable(2), R.viewport = new Zt();
    const U = [b, R], C = new LE();
    C.layers.enable(1), C.layers.enable(2);
    let B = null, G = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(K) {
      let ie = S[K];
      return ie === void 0 && (ie = new fg(), S[K] = ie), ie.getTargetRaySpace();
    }, this.getControllerGrip = function(K) {
      let ie = S[K];
      return ie === void 0 && (ie = new fg(), S[K] = ie), ie.getGripSpace();
    }, this.getHand = function(K) {
      let ie = S[K];
      return ie === void 0 && (ie = new fg(), S[K] = ie), ie.getHandSpace();
    };
    function W(K) {
      const ie = M.indexOf(K.inputSource);
      if (ie === -1)
        return;
      const he = S[ie];
      he !== void 0 && (he.update(K.inputSource, K.frame, h || o), he.dispatchEvent({ type: K.type, data: K.inputSource }));
    }
    function se() {
      i.removeEventListener("select", W), i.removeEventListener("selectstart", W), i.removeEventListener("selectend", W), i.removeEventListener("squeeze", W), i.removeEventListener("squeezestart", W), i.removeEventListener("squeezeend", W), i.removeEventListener("end", se), i.removeEventListener("inputsourceschange", z);
      for (let K = 0; K < S.length; K++) {
        const ie = M[K];
        ie !== null && (M[K] = null, S[K].disconnect(ie));
      }
      B = null, G = null, e.setRenderTarget(y), m = null, p = null, d = null, i = null, v = null, J.stop(), n.isPresenting = !1, e.setPixelRatio(P), e.setSize(T.width, T.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(K) {
      r = K, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(K) {
      a = K, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return h || o;
    }, this.setReferenceSpace = function(K) {
      h = K;
    }, this.getBaseLayer = function() {
      return p !== null ? p : m;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return _;
    }, this.getSession = function() {
      return i;
    }, this.setSession = async function(K) {
      if (i = K, i !== null) {
        if (y = e.getRenderTarget(), i.addEventListener("select", W), i.addEventListener("selectstart", W), i.addEventListener("selectend", W), i.addEventListener("squeeze", W), i.addEventListener("squeezestart", W), i.addEventListener("squeezeend", W), i.addEventListener("end", se), i.addEventListener("inputsourceschange", z), x.xrCompatible !== !0 && await t.makeXRCompatible(), P = e.getPixelRatio(), e.getSize(T), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
          const ie = {
            antialias: i.renderState.layers === void 0 ? x.antialias : !0,
            alpha: !0,
            depth: x.depth,
            stencil: x.stencil,
            framebufferScaleFactor: r
          };
          m = new XRWebGLLayer(i, t, ie), i.updateRenderState({ baseLayer: m }), e.setPixelRatio(1), e.setSize(m.framebufferWidth, m.framebufferHeight, !1), v = new Kr(
            m.framebufferWidth,
            m.framebufferHeight,
            {
              format: Di,
              type: ds,
              colorSpace: e.outputColorSpace,
              stencilBuffer: x.stencil
            }
          );
        } else {
          let ie = null, he = null, ge = null;
          x.depth && (ge = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, ie = x.stencil ? Da : So, he = x.stencil ? Mo : Ns);
          const me = {
            colorFormat: t.RGBA8,
            depthFormat: ge,
            scaleFactor: r
          };
          d = new XRWebGLBinding(i, t), p = d.createProjectionLayer(me), i.updateRenderState({ layers: [p] }), e.setPixelRatio(1), e.setSize(p.textureWidth, p.textureHeight, !1), v = new Kr(
            p.textureWidth,
            p.textureHeight,
            {
              format: Di,
              type: ds,
              depthTexture: new W0(p.textureWidth, p.textureHeight, he, void 0, void 0, void 0, void 0, void 0, void 0, ie),
              stencilBuffer: x.stencil,
              colorSpace: e.outputColorSpace,
              samples: x.antialias ? 4 : 0
            }
          );
          const Be = e.properties.get(v);
          Be.__ignoreDepthValues = p.ignoreDepthValues;
        }
        v.isXRRenderTarget = !0, this.setFoveation(l), h = null, o = await i.requestReferenceSpace(a), J.setContext(i), J.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (i !== null)
        return i.environmentBlendMode;
    };
    function z(K) {
      for (let ie = 0; ie < K.removed.length; ie++) {
        const he = K.removed[ie], ge = M.indexOf(he);
        ge >= 0 && (M[ge] = null, S[ge].disconnect(he));
      }
      for (let ie = 0; ie < K.added.length; ie++) {
        const he = K.added[ie];
        let ge = M.indexOf(he);
        if (ge === -1) {
          for (let Be = 0; Be < S.length; Be++)
            if (Be >= M.length) {
              M.push(he), ge = Be;
              break;
            } else if (M[Be] === null) {
              M[Be] = he, ge = Be;
              break;
            }
          if (ge === -1) break;
        }
        const me = S[ge];
        me && me.connect(he);
      }
    }
    const q = new k(), j = new k();
    function ee(K, ie, he) {
      q.setFromMatrixPosition(ie.matrixWorld), j.setFromMatrixPosition(he.matrixWorld);
      const ge = q.distanceTo(j), me = ie.projectionMatrix.elements, Be = he.projectionMatrix.elements, Pe = me[14] / (me[10] - 1), De = me[14] / (me[10] + 1), ze = (me[9] + 1) / me[5], X = (me[9] - 1) / me[5], pe = (me[8] - 1) / me[0], ce = (Be[8] + 1) / Be[0], Me = Pe * pe, fe = Pe * ce, Q = ge / (-pe + ce), Ie = Q * -pe;
      ie.matrixWorld.decompose(K.position, K.quaternion, K.scale), K.translateX(Ie), K.translateZ(Q), K.matrixWorld.compose(K.position, K.quaternion, K.scale), K.matrixWorldInverse.copy(K.matrixWorld).invert();
      const O = Pe + Q, L = De + Q, $ = Me - Ie, xe = fe + (ge - Ie), Ae = ze * De / L * O, _e = X * De / L * O;
      K.projectionMatrix.makePerspective($, xe, Ae, _e, O, L), K.projectionMatrixInverse.copy(K.projectionMatrix).invert();
    }
    function N(K, ie) {
      ie === null ? K.matrixWorld.copy(K.matrix) : K.matrixWorld.multiplyMatrices(ie.matrixWorld, K.matrix), K.matrixWorldInverse.copy(K.matrixWorld).invert();
    }
    this.updateCamera = function(K) {
      if (i === null) return;
      C.near = R.near = b.near = K.near, C.far = R.far = b.far = K.far, (B !== C.near || G !== C.far) && (i.updateRenderState({
        depthNear: C.near,
        depthFar: C.far
      }), B = C.near, G = C.far);
      const ie = K.parent, he = C.cameras;
      N(C, ie);
      for (let ge = 0; ge < he.length; ge++)
        N(he[ge], ie);
      he.length === 2 ? ee(C, b, R) : C.projectionMatrix.copy(b.projectionMatrix), V(K, C, ie);
    };
    function V(K, ie, he) {
      he === null ? K.matrix.copy(ie.matrixWorld) : (K.matrix.copy(he.matrixWorld), K.matrix.invert(), K.matrix.multiply(ie.matrixWorld)), K.matrix.decompose(K.position, K.quaternion, K.scale), K.updateMatrixWorld(!0), K.projectionMatrix.copy(ie.projectionMatrix), K.projectionMatrixInverse.copy(ie.projectionMatrixInverse), K.isPerspectiveCamera && (K.fov = oc * 2 * Math.atan(1 / K.projectionMatrix.elements[5]), K.zoom = 1);
    }
    this.getCamera = function() {
      return C;
    }, this.getFoveation = function() {
      if (!(p === null && m === null))
        return l;
    }, this.setFoveation = function(K) {
      l = K, p !== null && (p.fixedFoveation = K), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = K);
    };
    let I = null;
    function D(K, ie) {
      if (f = ie.getViewerPose(h || o), _ = ie, f !== null) {
        const he = f.views;
        m !== null && (e.setRenderTargetFramebuffer(v, m.framebuffer), e.setRenderTarget(v));
        let ge = !1;
        he.length !== C.cameras.length && (C.cameras.length = 0, ge = !0);
        for (let me = 0; me < he.length; me++) {
          const Be = he[me];
          let Pe = null;
          if (m !== null)
            Pe = m.getViewport(Be);
          else {
            const ze = d.getViewSubImage(p, Be);
            Pe = ze.viewport, me === 0 && (e.setRenderTargetTextures(
              v,
              ze.colorTexture,
              p.ignoreDepthValues ? void 0 : ze.depthStencilTexture
            ), e.setRenderTarget(v));
          }
          let De = U[me];
          De === void 0 && (De = new Wn(), De.layers.enable(me), De.viewport = new Zt(), U[me] = De), De.matrix.fromArray(Be.transform.matrix), De.matrix.decompose(De.position, De.quaternion, De.scale), De.projectionMatrix.fromArray(Be.projectionMatrix), De.projectionMatrixInverse.copy(De.projectionMatrix).invert(), De.viewport.set(Pe.x, Pe.y, Pe.width, Pe.height), me === 0 && (C.matrix.copy(De.matrix), C.matrix.decompose(C.position, C.quaternion, C.scale)), ge === !0 && C.cameras.push(De);
        }
      }
      for (let he = 0; he < S.length; he++) {
        const ge = M[he], me = S[he];
        ge !== null && me !== void 0 && me.update(ge, ie, h || o);
      }
      I && I(K, ie), ie.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: ie }), _ = null;
    }
    const J = new wE();
    J.setAnimationLoop(D), this.setAnimationLoop = function(K) {
      I = K;
    }, this.dispose = function() {
    };
  }
}
function oL(s, e) {
  function t(y, v) {
    y.matrixAutoUpdate === !0 && y.updateMatrix(), v.value.copy(y.matrix);
  }
  function n(y, v) {
    v.color.getRGB(y.fogColor.value, ME(s)), v.isFog ? (y.fogNear.value = v.near, y.fogFar.value = v.far) : v.isFogExp2 && (y.fogDensity.value = v.density);
  }
  function i(y, v, S, M, T) {
    v.isMeshBasicMaterial || v.isMeshLambertMaterial ? r(y, v) : v.isMeshToonMaterial ? (r(y, v), d(y, v)) : v.isMeshPhongMaterial ? (r(y, v), f(y, v)) : v.isMeshStandardMaterial ? (r(y, v), p(y, v), v.isMeshPhysicalMaterial && m(y, v, T)) : v.isMeshMatcapMaterial ? (r(y, v), _(y, v)) : v.isMeshDepthMaterial ? r(y, v) : v.isMeshDistanceMaterial ? (r(y, v), x(y, v)) : v.isMeshNormalMaterial ? r(y, v) : v.isLineBasicMaterial ? (o(y, v), v.isLineDashedMaterial && a(y, v)) : v.isPointsMaterial ? l(y, v, S, M) : v.isSpriteMaterial ? h(y, v) : v.isShadowMaterial ? (y.color.value.copy(v.color), y.opacity.value = v.opacity) : v.isShaderMaterial && (v.uniformsNeedUpdate = !1);
  }
  function r(y, v) {
    y.opacity.value = v.opacity, v.color && y.diffuse.value.copy(v.color), v.emissive && y.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity), v.map && (y.map.value = v.map, t(v.map, y.mapTransform)), v.alphaMap && (y.alphaMap.value = v.alphaMap, t(v.alphaMap, y.alphaMapTransform)), v.bumpMap && (y.bumpMap.value = v.bumpMap, t(v.bumpMap, y.bumpMapTransform), y.bumpScale.value = v.bumpScale, v.side === Oi && (y.bumpScale.value *= -1)), v.normalMap && (y.normalMap.value = v.normalMap, t(v.normalMap, y.normalMapTransform), y.normalScale.value.copy(v.normalScale), v.side === Oi && y.normalScale.value.negate()), v.displacementMap && (y.displacementMap.value = v.displacementMap, t(v.displacementMap, y.displacementMapTransform), y.displacementScale.value = v.displacementScale, y.displacementBias.value = v.displacementBias), v.emissiveMap && (y.emissiveMap.value = v.emissiveMap, t(v.emissiveMap, y.emissiveMapTransform)), v.specularMap && (y.specularMap.value = v.specularMap, t(v.specularMap, y.specularMapTransform)), v.alphaTest > 0 && (y.alphaTest.value = v.alphaTest);
    const S = e.get(v).envMap;
    if (S && (y.envMap.value = S, y.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, y.reflectivity.value = v.reflectivity, y.ior.value = v.ior, y.refractionRatio.value = v.refractionRatio), v.lightMap) {
      y.lightMap.value = v.lightMap;
      const M = s._useLegacyLights === !0 ? Math.PI : 1;
      y.lightMapIntensity.value = v.lightMapIntensity * M, t(v.lightMap, y.lightMapTransform);
    }
    v.aoMap && (y.aoMap.value = v.aoMap, y.aoMapIntensity.value = v.aoMapIntensity, t(v.aoMap, y.aoMapTransform));
  }
  function o(y, v) {
    y.diffuse.value.copy(v.color), y.opacity.value = v.opacity, v.map && (y.map.value = v.map, t(v.map, y.mapTransform));
  }
  function a(y, v) {
    y.dashSize.value = v.dashSize, y.totalSize.value = v.dashSize + v.gapSize, y.scale.value = v.scale;
  }
  function l(y, v, S, M) {
    y.diffuse.value.copy(v.color), y.opacity.value = v.opacity, y.size.value = v.size * S, y.scale.value = M * 0.5, v.map && (y.map.value = v.map, t(v.map, y.uvTransform)), v.alphaMap && (y.alphaMap.value = v.alphaMap, t(v.alphaMap, y.alphaMapTransform)), v.alphaTest > 0 && (y.alphaTest.value = v.alphaTest);
  }
  function h(y, v) {
    y.diffuse.value.copy(v.color), y.opacity.value = v.opacity, y.rotation.value = v.rotation, v.map && (y.map.value = v.map, t(v.map, y.mapTransform)), v.alphaMap && (y.alphaMap.value = v.alphaMap, t(v.alphaMap, y.alphaMapTransform)), v.alphaTest > 0 && (y.alphaTest.value = v.alphaTest);
  }
  function f(y, v) {
    y.specular.value.copy(v.specular), y.shininess.value = Math.max(v.shininess, 1e-4);
  }
  function d(y, v) {
    v.gradientMap && (y.gradientMap.value = v.gradientMap);
  }
  function p(y, v) {
    y.metalness.value = v.metalness, v.metalnessMap && (y.metalnessMap.value = v.metalnessMap, t(v.metalnessMap, y.metalnessMapTransform)), y.roughness.value = v.roughness, v.roughnessMap && (y.roughnessMap.value = v.roughnessMap, t(v.roughnessMap, y.roughnessMapTransform)), e.get(v).envMap && (y.envMapIntensity.value = v.envMapIntensity);
  }
  function m(y, v, S) {
    y.ior.value = v.ior, v.sheen > 0 && (y.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen), y.sheenRoughness.value = v.sheenRoughness, v.sheenColorMap && (y.sheenColorMap.value = v.sheenColorMap, t(v.sheenColorMap, y.sheenColorMapTransform)), v.sheenRoughnessMap && (y.sheenRoughnessMap.value = v.sheenRoughnessMap, t(v.sheenRoughnessMap, y.sheenRoughnessMapTransform))), v.clearcoat > 0 && (y.clearcoat.value = v.clearcoat, y.clearcoatRoughness.value = v.clearcoatRoughness, v.clearcoatMap && (y.clearcoatMap.value = v.clearcoatMap, t(v.clearcoatMap, y.clearcoatMapTransform)), v.clearcoatRoughnessMap && (y.clearcoatRoughnessMap.value = v.clearcoatRoughnessMap, t(v.clearcoatRoughnessMap, y.clearcoatRoughnessMapTransform)), v.clearcoatNormalMap && (y.clearcoatNormalMap.value = v.clearcoatNormalMap, t(v.clearcoatNormalMap, y.clearcoatNormalMapTransform), y.clearcoatNormalScale.value.copy(v.clearcoatNormalScale), v.side === Oi && y.clearcoatNormalScale.value.negate())), v.iridescence > 0 && (y.iridescence.value = v.iridescence, y.iridescenceIOR.value = v.iridescenceIOR, y.iridescenceThicknessMinimum.value = v.iridescenceThicknessRange[0], y.iridescenceThicknessMaximum.value = v.iridescenceThicknessRange[1], v.iridescenceMap && (y.iridescenceMap.value = v.iridescenceMap, t(v.iridescenceMap, y.iridescenceMapTransform)), v.iridescenceThicknessMap && (y.iridescenceThicknessMap.value = v.iridescenceThicknessMap, t(v.iridescenceThicknessMap, y.iridescenceThicknessMapTransform))), v.transmission > 0 && (y.transmission.value = v.transmission, y.transmissionSamplerMap.value = S.texture, y.transmissionSamplerSize.value.set(S.width, S.height), v.transmissionMap && (y.transmissionMap.value = v.transmissionMap, t(v.transmissionMap, y.transmissionMapTransform)), y.thickness.value = v.thickness, v.thicknessMap && (y.thicknessMap.value = v.thicknessMap, t(v.thicknessMap, y.thicknessMapTransform)), y.attenuationDistance.value = v.attenuationDistance, y.attenuationColor.value.copy(v.attenuationColor)), v.anisotropy > 0 && (y.anisotropyVector.value.set(v.anisotropy * Math.cos(v.anisotropyRotation), v.anisotropy * Math.sin(v.anisotropyRotation)), v.anisotropyMap && (y.anisotropyMap.value = v.anisotropyMap, t(v.anisotropyMap, y.anisotropyMapTransform))), y.specularIntensity.value = v.specularIntensity, y.specularColor.value.copy(v.specularColor), v.specularColorMap && (y.specularColorMap.value = v.specularColorMap, t(v.specularColorMap, y.specularColorMapTransform)), v.specularIntensityMap && (y.specularIntensityMap.value = v.specularIntensityMap, t(v.specularIntensityMap, y.specularIntensityMapTransform));
  }
  function _(y, v) {
    v.matcap && (y.matcap.value = v.matcap);
  }
  function x(y, v) {
    const S = e.get(v).light;
    y.referencePosition.value.setFromMatrixPosition(S.matrixWorld), y.nearDistance.value = S.shadow.camera.near, y.farDistance.value = S.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: i
  };
}
function aL(s, e, t, n) {
  let i = {}, r = {}, o = [];
  const a = t.isWebGL2 ? s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(S, M) {
    const T = M.program;
    n.uniformBlockBinding(S, T);
  }
  function h(S, M) {
    let T = i[S.id];
    T === void 0 && (_(S), T = f(S), i[S.id] = T, S.addEventListener("dispose", y));
    const P = M.program;
    n.updateUBOMapping(S, P);
    const b = e.render.frame;
    r[S.id] !== b && (p(S), r[S.id] = b);
  }
  function f(S) {
    const M = d();
    S.__bindingPointIndex = M;
    const T = s.createBuffer(), P = S.__size, b = S.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, T), s.bufferData(s.UNIFORM_BUFFER, P, b), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, M, T), T;
  }
  function d() {
    for (let S = 0; S < a; S++)
      if (o.indexOf(S) === -1)
        return o.push(S), S;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function p(S) {
    const M = i[S.id], T = S.uniforms, P = S.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, M);
    for (let b = 0, R = T.length; b < R; b++) {
      const U = Array.isArray(T[b]) ? T[b] : [T[b]];
      for (let C = 0, B = U.length; C < B; C++) {
        const G = U[C];
        if (m(G, b, C, P) === !0) {
          const W = G.__offset, se = Array.isArray(G.value) ? G.value : [G.value];
          let z = 0;
          for (let q = 0; q < se.length; q++) {
            const j = se[q], ee = x(j);
            typeof j == "number" || typeof j == "boolean" ? (G.__data[0] = j, s.bufferSubData(s.UNIFORM_BUFFER, W + z, G.__data)) : j.isMatrix3 ? (G.__data[0] = j.elements[0], G.__data[1] = j.elements[1], G.__data[2] = j.elements[2], G.__data[3] = 0, G.__data[4] = j.elements[3], G.__data[5] = j.elements[4], G.__data[6] = j.elements[5], G.__data[7] = 0, G.__data[8] = j.elements[6], G.__data[9] = j.elements[7], G.__data[10] = j.elements[8], G.__data[11] = 0) : (j.toArray(G.__data, z), z += ee.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          s.bufferSubData(s.UNIFORM_BUFFER, W, G.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function m(S, M, T, P) {
    const b = S.value, R = M + "_" + T;
    if (P[R] === void 0)
      return typeof b == "number" || typeof b == "boolean" ? P[R] = b : P[R] = b.clone(), !0;
    {
      const U = P[R];
      if (typeof b == "number" || typeof b == "boolean") {
        if (U !== b)
          return P[R] = b, !0;
      } else if (U.equals(b) === !1)
        return U.copy(b), !0;
    }
    return !1;
  }
  function _(S) {
    const M = S.uniforms;
    let T = 0;
    const P = 16;
    for (let R = 0, U = M.length; R < U; R++) {
      const C = Array.isArray(M[R]) ? M[R] : [M[R]];
      for (let B = 0, G = C.length; B < G; B++) {
        const W = C[B], se = Array.isArray(W.value) ? W.value : [W.value];
        for (let z = 0, q = se.length; z < q; z++) {
          const j = se[z], ee = x(j), N = T % P;
          N !== 0 && P - N < ee.boundary && (T += P - N), W.__data = new Float32Array(ee.storage / Float32Array.BYTES_PER_ELEMENT), W.__offset = T, T += ee.storage;
        }
      }
    }
    const b = T % P;
    return b > 0 && (T += P - b), S.__size = T, S.__cache = {}, this;
  }
  function x(S) {
    const M = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof S == "number" || typeof S == "boolean" ? (M.boundary = 4, M.storage = 4) : S.isVector2 ? (M.boundary = 8, M.storage = 8) : S.isVector3 || S.isColor ? (M.boundary = 16, M.storage = 12) : S.isVector4 ? (M.boundary = 16, M.storage = 16) : S.isMatrix3 ? (M.boundary = 48, M.storage = 48) : S.isMatrix4 ? (M.boundary = 64, M.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S), M;
  }
  function y(S) {
    const M = S.target;
    M.removeEventListener("dispose", y);
    const T = o.indexOf(M.__bindingPointIndex);
    o.splice(T, 1), s.deleteBuffer(i[M.id]), delete i[M.id], delete r[M.id];
  }
  function v() {
    for (const S in i)
      s.deleteBuffer(i[S]);
    o = [], i = {}, r = {};
  }
  return {
    bind: l,
    update: h,
    dispose: v
  };
}
class Y0 {
  constructor(e = {}) {
    const {
      canvas: t = yE(),
      context: n = null,
      depth: i = !0,
      stencil: r = !0,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: h = !1,
      powerPreference: f = "default",
      failIfMajorPerformanceCaveat: d = !1
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    n !== null ? p = n.getContextAttributes().alpha : p = o;
    const m = new Uint32Array(4), _ = new Int32Array(4);
    let x = null, y = null;
    const v = [], S = [];
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Vn, this._useLegacyLights = !1, this.toneMapping = fs, this.toneMappingExposure = 1;
    const M = this;
    let T = !1, P = 0, b = 0, R = null, U = -1, C = null;
    const B = new Zt(), G = new Zt();
    let W = null;
    const se = new Ne(0);
    let z = 0, q = t.width, j = t.height, ee = 1, N = null, V = null;
    const I = new Zt(0, 0, q, j), D = new Zt(0, 0, q, j);
    let J = !1;
    const K = new ch();
    let ie = !1, he = !1, ge = null;
    const me = new pt(), Be = new ve(), Pe = new k(), De = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    function ze() {
      return R === null ? ee : 1;
    }
    let X = n;
    function pe(F, te) {
      for (let ae = 0; ae < F.length; ae++) {
        const oe = F[ae], re = t.getContext(oe, te);
        if (re !== null) return re;
      }
      return null;
    }
    try {
      const F = {
        alpha: !0,
        depth: i,
        stencil: r,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: h,
        powerPreference: f,
        failIfMajorPerformanceCaveat: d
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${rh}`), t.addEventListener("webglcontextlost", Ee, !1), t.addEventListener("webglcontextrestored", Y, !1), t.addEventListener("webglcontextcreationerror", Ce, !1), X === null) {
        const te = ["webgl2", "webgl", "experimental-webgl"];
        if (M.isWebGL1Renderer === !0 && te.shift(), X = pe(te, F), X === null)
          throw pe(te) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && X instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), X.getShaderPrecisionFormat === void 0 && (X.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (F) {
      throw console.error("THREE.WebGLRenderer: " + F.message), F;
    }
    let ce, Me, fe, Q, Ie, O, L, $, xe, Ae, _e, Ue, Le, Te, Ze, ct, ye, bt, et, mt, je, Ve, gt, St;
    function Wt() {
      ce = new AP(X), Me = new mP(X, ce, e), ce.init(Me), Ve = new IE(X, ce, Me), fe = new nL(X, ce, Me), Q = new EP(X), Ie = new WI(), O = new iL(X, ce, fe, Ie, Me, Ve, Q), L = new _P(M), $ = new xP(M), xe = new Ib(X, Me), gt = new dP(X, ce, xe, Me), Ae = new MP(X, xe, Q, gt), _e = new bP(X, Ae, xe, Q), et = new CP(X, Me, O), ct = new gP(Ie), Ue = new VI(M, L, $, ce, Me, gt, ct), Le = new oL(M, Ie), Te = new JI(), Ze = new jI(ce, Me), bt = new fP(M, L, $, fe, _e, p, l), ye = new tL(M, _e, Me), St = new aL(X, Q, Me, fe), mt = new pP(X, ce, Q, Me), je = new SP(X, ce, Q, Me), Q.programs = Ue.programs, M.capabilities = Me, M.extensions = ce, M.properties = Ie, M.renderLists = Te, M.shadowMap = ye, M.state = fe, M.info = Q;
    }
    Wt();
    const Oe = new sL(M, X);
    this.xr = Oe, this.getContext = function() {
      return X;
    }, this.getContextAttributes = function() {
      return X.getContextAttributes();
    }, this.forceContextLoss = function() {
      const F = ce.get("WEBGL_lose_context");
      F && F.loseContext();
    }, this.forceContextRestore = function() {
      const F = ce.get("WEBGL_lose_context");
      F && F.restoreContext();
    }, this.getPixelRatio = function() {
      return ee;
    }, this.setPixelRatio = function(F) {
      F !== void 0 && (ee = F, this.setSize(q, j, !1));
    }, this.getSize = function(F) {
      return F.set(q, j);
    }, this.setSize = function(F, te, ae = !0) {
      if (Oe.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      q = F, j = te, t.width = Math.floor(F * ee), t.height = Math.floor(te * ee), ae === !0 && (t.style.width = F + "px", t.style.height = te + "px"), this.setViewport(0, 0, F, te);
    }, this.getDrawingBufferSize = function(F) {
      return F.set(q * ee, j * ee).floor();
    }, this.setDrawingBufferSize = function(F, te, ae) {
      q = F, j = te, ee = ae, t.width = Math.floor(F * ae), t.height = Math.floor(te * ae), this.setViewport(0, 0, F, te);
    }, this.getCurrentViewport = function(F) {
      return F.copy(B);
    }, this.getViewport = function(F) {
      return F.copy(I);
    }, this.setViewport = function(F, te, ae, oe) {
      F.isVector4 ? I.set(F.x, F.y, F.z, F.w) : I.set(F, te, ae, oe), fe.viewport(B.copy(I).multiplyScalar(ee).floor());
    }, this.getScissor = function(F) {
      return F.copy(D);
    }, this.setScissor = function(F, te, ae, oe) {
      F.isVector4 ? D.set(F.x, F.y, F.z, F.w) : D.set(F, te, ae, oe), fe.scissor(G.copy(D).multiplyScalar(ee).floor());
    }, this.getScissorTest = function() {
      return J;
    }, this.setScissorTest = function(F) {
      fe.setScissorTest(J = F);
    }, this.setOpaqueSort = function(F) {
      N = F;
    }, this.setTransparentSort = function(F) {
      V = F;
    }, this.getClearColor = function(F) {
      return F.copy(bt.getClearColor());
    }, this.setClearColor = function() {
      bt.setClearColor.apply(bt, arguments);
    }, this.getClearAlpha = function() {
      return bt.getClearAlpha();
    }, this.setClearAlpha = function() {
      bt.setClearAlpha.apply(bt, arguments);
    }, this.clear = function(F = !0, te = !0, ae = !0) {
      let oe = 0;
      if (F) {
        let re = !1;
        if (R !== null) {
          const Re = R.texture.format;
          re = Re === I0 || Re === P0 || Re === B0;
        }
        if (re) {
          const Re = R.texture.type, Je = Re === ds || Re === Ns || Re === cp || Re === Mo || Re === b0 || Re === R0, ht = bt.getClearColor(), Xe = bt.getClearAlpha(), Ye = ht.r, at = ht.g, vt = ht.b;
          Je ? (m[0] = Ye, m[1] = at, m[2] = vt, m[3] = Xe, X.clearBufferuiv(X.COLOR, 0, m)) : (_[0] = Ye, _[1] = at, _[2] = vt, _[3] = Xe, X.clearBufferiv(X.COLOR, 0, _));
        } else
          oe |= X.COLOR_BUFFER_BIT;
      }
      te && (oe |= X.DEPTH_BUFFER_BIT), ae && (oe |= X.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), X.clear(oe);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Ee, !1), t.removeEventListener("webglcontextrestored", Y, !1), t.removeEventListener("webglcontextcreationerror", Ce, !1), Te.dispose(), Ze.dispose(), Ie.dispose(), L.dispose(), $.dispose(), _e.dispose(), gt.dispose(), St.dispose(), Ue.dispose(), Oe.dispose(), Oe.removeEventListener("sessionstart", We), Oe.removeEventListener("sessionend", tt), ge && (ge.dispose(), ge = null), Se.stop();
    };
    function Ee(F) {
      F.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), T = !0;
    }
    function Y() {
      console.log("THREE.WebGLRenderer: Context Restored."), T = !1;
      const F = Q.autoReset, te = ye.enabled, ae = ye.autoUpdate, oe = ye.needsUpdate, re = ye.type;
      Wt(), Q.autoReset = F, ye.enabled = te, ye.autoUpdate = ae, ye.needsUpdate = oe, ye.type = re;
    }
    function Ce(F) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", F.statusMessage);
    }
    function be(F) {
      const te = F.target;
      te.removeEventListener("dispose", be), ot(te);
    }
    function ot(F) {
      it(F), Ie.remove(F);
    }
    function it(F) {
      const te = Ie.get(F).programs;
      te !== void 0 && (te.forEach(function(ae) {
        Ue.releaseProgram(ae);
      }), F.isShaderMaterial && Ue.releaseShaderCache(F));
    }
    this.renderBufferDirect = function(F, te, ae, oe, re, Re) {
      te === null && (te = De);
      const Je = re.isMesh && re.matrixWorld.determinant() < 0, ht = $t(F, te, ae, oe, re);
      fe.setMaterial(oe, Je);
      let Xe = ae.index, Ye = 1;
      if (oe.wireframe === !0) {
        if (Xe = Ae.getWireframeAttribute(ae), Xe === void 0) return;
        Ye = 2;
      }
      const at = ae.drawRange, vt = ae.attributes.position;
      let sn = at.start * Ye, dn = (at.start + at.count) * Ye;
      Re !== null && (sn = Math.max(sn, Re.start * Ye), dn = Math.min(dn, (Re.start + Re.count) * Ye)), Xe !== null ? (sn = Math.max(sn, 0), dn = Math.min(dn, Xe.count)) : vt != null && (sn = Math.max(sn, 0), dn = Math.min(dn, vt.count));
      const Nt = dn - sn;
      if (Nt < 0 || Nt === 1 / 0) return;
      gt.setup(re, oe, ht, ae, Xe);
      let un, ft = mt;
      if (Xe !== null && (un = xe.get(Xe), ft = je, ft.setIndex(un)), re.isMesh)
        oe.wireframe === !0 ? (fe.setLineWidth(oe.wireframeLinewidth * ze()), ft.setMode(X.LINES)) : ft.setMode(X.TRIANGLES);
      else if (re.isLine) {
        let ke = oe.linewidth;
        ke === void 0 && (ke = 1), fe.setLineWidth(ke * ze()), re.isLineSegments ? ft.setMode(X.LINES) : re.isLineLoop ? ft.setMode(X.LINE_LOOP) : ft.setMode(X.LINE_STRIP);
      } else re.isPoints ? ft.setMode(X.POINTS) : re.isSprite && ft.setMode(X.TRIANGLES);
      if (re.isBatchedMesh)
        ft.renderMultiDraw(re._multiDrawStarts, re._multiDrawCounts, re._multiDrawCount);
      else if (re.isInstancedMesh)
        ft.renderInstances(sn, Nt, re.count);
      else if (ae.isInstancedBufferGeometry) {
        const ke = ae._maxInstanceCount !== void 0 ? ae._maxInstanceCount : 1 / 0, _r = Math.min(ae.instanceCount, ke);
        ft.renderInstances(sn, Nt, _r);
      } else
        ft.render(sn, Nt);
    };
    function It(F, te, ae) {
      F.transparent === !0 && F.side === Xr && F.forceSinglePass === !1 ? (F.side = Oi, F.needsUpdate = !0, jt(F, te, ae), F.side = gs, F.needsUpdate = !0, jt(F, te, ae), F.side = Xr) : jt(F, te, ae);
    }
    this.compile = function(F, te, ae = null) {
      ae === null && (ae = F), y = Ze.get(ae), y.init(), S.push(y), ae.traverseVisible(function(re) {
        re.isLight && re.layers.test(te.layers) && (y.pushLight(re), re.castShadow && y.pushShadow(re));
      }), F !== ae && F.traverseVisible(function(re) {
        re.isLight && re.layers.test(te.layers) && (y.pushLight(re), re.castShadow && y.pushShadow(re));
      }), y.setupLights(M._useLegacyLights);
      const oe = /* @__PURE__ */ new Set();
      return F.traverse(function(re) {
        const Re = re.material;
        if (Re)
          if (Array.isArray(Re))
            for (let Je = 0; Je < Re.length; Je++) {
              const ht = Re[Je];
              It(ht, ae, re), oe.add(ht);
            }
          else
            It(Re, ae, re), oe.add(Re);
      }), S.pop(), y = null, oe;
    }, this.compileAsync = function(F, te, ae = null) {
      const oe = this.compile(F, te, ae);
      return new Promise((re) => {
        function Re() {
          if (oe.forEach(function(Je) {
            Ie.get(Je).currentProgram.isReady() && oe.delete(Je);
          }), oe.size === 0) {
            re(F);
            return;
          }
          setTimeout(Re, 10);
        }
        ce.get("KHR_parallel_shader_compile") !== null ? Re() : setTimeout(Re, 10);
      });
    };
    let kt = null;
    function Qe(F) {
      kt && kt(F);
    }
    function We() {
      Se.stop();
    }
    function tt() {
      Se.start();
    }
    const Se = new wE();
    Se.setAnimationLoop(Qe), typeof self < "u" && Se.setContext(self), this.setAnimationLoop = function(F) {
      kt = F, Oe.setAnimationLoop(F), F === null ? Se.stop() : Se.start();
    }, Oe.addEventListener("sessionstart", We), Oe.addEventListener("sessionend", tt), this.render = function(F, te) {
      if (te !== void 0 && te.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (T === !0) return;
      F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(), te.parent === null && te.matrixWorldAutoUpdate === !0 && te.updateMatrixWorld(), Oe.enabled === !0 && Oe.isPresenting === !0 && (Oe.cameraAutoUpdate === !0 && Oe.updateCamera(te), te = Oe.getCamera()), F.isScene === !0 && F.onBeforeRender(M, F, te, R), y = Ze.get(F, S.length), y.init(), S.push(y), me.multiplyMatrices(te.projectionMatrix, te.matrixWorldInverse), K.setFromProjectionMatrix(me), he = this.localClippingEnabled, ie = ct.init(this.clippingPlanes, he), x = Te.get(F, v.length), x.init(), v.push(x), ut(F, te, 0, M.sortObjects), x.finish(), M.sortObjects === !0 && x.sort(N, V), this.info.render.frame++, ie === !0 && ct.beginShadows();
      const ae = y.state.shadowsArray;
      if (ye.render(ae, F, te), ie === !0 && ct.endShadows(), this.info.autoReset === !0 && this.info.reset(), bt.render(x, F), y.setupLights(M._useLegacyLights), te.isArrayCamera) {
        const oe = te.cameras;
        for (let re = 0, Re = oe.length; re < Re; re++) {
          const Je = oe[re];
          rt(x, F, Je, Je.viewport);
        }
      } else
        rt(x, F, te);
      R !== null && (O.updateMultisampleRenderTarget(R), O.updateRenderTargetMipmap(R)), F.isScene === !0 && F.onAfterRender(M, F, te), gt.resetDefaultState(), U = -1, C = null, S.pop(), S.length > 0 ? y = S[S.length - 1] : y = null, v.pop(), v.length > 0 ? x = v[v.length - 1] : x = null;
    };
    function ut(F, te, ae, oe) {
      if (F.visible === !1) return;
      if (F.layers.test(te.layers)) {
        if (F.isGroup)
          ae = F.renderOrder;
        else if (F.isLOD)
          F.autoUpdate === !0 && F.update(te);
        else if (F.isLight)
          y.pushLight(F), F.castShadow && y.pushShadow(F);
        else if (F.isSprite) {
          if (!F.frustumCulled || K.intersectsSprite(F)) {
            oe && Pe.setFromMatrixPosition(F.matrixWorld).applyMatrix4(me);
            const Je = _e.update(F), ht = F.material;
            ht.visible && x.push(F, Je, ht, ae, Pe.z, null);
          }
        } else if ((F.isMesh || F.isLine || F.isPoints) && (!F.frustumCulled || K.intersectsObject(F))) {
          const Je = _e.update(F), ht = F.material;
          if (oe && (F.boundingSphere !== void 0 ? (F.boundingSphere === null && F.computeBoundingSphere(), Pe.copy(F.boundingSphere.center)) : (Je.boundingSphere === null && Je.computeBoundingSphere(), Pe.copy(Je.boundingSphere.center)), Pe.applyMatrix4(F.matrixWorld).applyMatrix4(me)), Array.isArray(ht)) {
            const Xe = Je.groups;
            for (let Ye = 0, at = Xe.length; Ye < at; Ye++) {
              const vt = Xe[Ye], sn = ht[vt.materialIndex];
              sn && sn.visible && x.push(F, Je, sn, ae, Pe.z, vt);
            }
          } else ht.visible && x.push(F, Je, ht, ae, Pe.z, null);
        }
      }
      const Re = F.children;
      for (let Je = 0, ht = Re.length; Je < ht; Je++)
        ut(Re[Je], te, ae, oe);
    }
    function rt(F, te, ae, oe) {
      const re = F.opaque, Re = F.transmissive, Je = F.transparent;
      y.setupLightsView(ae), ie === !0 && ct.setGlobalState(M.clippingPlanes, ae), Re.length > 0 && _t(re, Re, te, ae), oe && fe.viewport(B.copy(oe)), re.length > 0 && cn(re, te, ae), Re.length > 0 && cn(Re, te, ae), Je.length > 0 && cn(Je, te, ae), fe.buffers.depth.setTest(!0), fe.buffers.depth.setMask(!0), fe.buffers.color.setMask(!0), fe.setPolygonOffset(!1);
    }
    function _t(F, te, ae, oe) {
      if ((ae.isScene === !0 ? ae.overrideMaterial : null) !== null)
        return;
      const Re = Me.isWebGL2;
      ge === null && (ge = new Kr(1, 1, {
        generateMipmaps: !0,
        type: ce.has("EXT_color_buffer_half_float") ? ic : ds,
        minFilter: _s,
        samples: Re ? 4 : 0
      })), M.getDrawingBufferSize(Be), Re ? ge.setSize(Be.x, Be.y) : ge.setSize(Wd(Be.x), Wd(Be.y));
      const Je = M.getRenderTarget();
      M.setRenderTarget(ge), M.getClearColor(se), z = M.getClearAlpha(), z < 1 && M.setClearColor(16777215, 0.5), M.clear();
      const ht = M.toneMapping;
      M.toneMapping = fs, cn(F, ae, oe), O.updateMultisampleRenderTarget(ge), O.updateRenderTargetMipmap(ge);
      let Xe = !1;
      for (let Ye = 0, at = te.length; Ye < at; Ye++) {
        const vt = te[Ye], sn = vt.object, dn = vt.geometry, Nt = vt.material, un = vt.group;
        if (Nt.side === Xr && sn.layers.test(oe.layers)) {
          const ft = Nt.side;
          Nt.side = Oi, Nt.needsUpdate = !0, yt(sn, ae, oe, dn, Nt, un), Nt.side = ft, Nt.needsUpdate = !0, Xe = !0;
        }
      }
      Xe === !0 && (O.updateMultisampleRenderTarget(ge), O.updateRenderTargetMipmap(ge)), M.setRenderTarget(Je), M.setClearColor(se, z), M.toneMapping = ht;
    }
    function cn(F, te, ae) {
      const oe = te.isScene === !0 ? te.overrideMaterial : null;
      for (let re = 0, Re = F.length; re < Re; re++) {
        const Je = F[re], ht = Je.object, Xe = Je.geometry, Ye = oe === null ? Je.material : oe, at = Je.group;
        ht.layers.test(ae.layers) && yt(ht, te, ae, Xe, Ye, at);
      }
    }
    function yt(F, te, ae, oe, re, Re) {
      F.onBeforeRender(M, te, ae, oe, re, Re), F.modelViewMatrix.multiplyMatrices(ae.matrixWorldInverse, F.matrixWorld), F.normalMatrix.getNormalMatrix(F.modelViewMatrix), re.onBeforeRender(M, te, ae, oe, F, Re), re.transparent === !0 && re.side === Xr && re.forceSinglePass === !1 ? (re.side = Oi, re.needsUpdate = !0, M.renderBufferDirect(ae, te, oe, re, F, Re), re.side = gs, re.needsUpdate = !0, M.renderBufferDirect(ae, te, oe, re, F, Re), re.side = Xr) : M.renderBufferDirect(ae, te, oe, re, F, Re), F.onAfterRender(M, te, ae, oe, re, Re);
    }
    function jt(F, te, ae) {
      te.isScene !== !0 && (te = De);
      const oe = Ie.get(F), re = y.state.lights, Re = y.state.shadowsArray, Je = re.state.version, ht = Ue.getParameters(F, re.state, Re, te, ae), Xe = Ue.getProgramCacheKey(ht);
      let Ye = oe.programs;
      oe.environment = F.isMeshStandardMaterial ? te.environment : null, oe.fog = te.fog, oe.envMap = (F.isMeshStandardMaterial ? $ : L).get(F.envMap || oe.environment), Ye === void 0 && (F.addEventListener("dispose", be), Ye = /* @__PURE__ */ new Map(), oe.programs = Ye);
      let at = Ye.get(Xe);
      if (at !== void 0) {
        if (oe.currentProgram === at && oe.lightsStateVersion === Je)
          return en(F, ht), at;
      } else
        ht.uniforms = Ue.getUniforms(F), F.onBuild(ae, ht, M), F.onBeforeCompile(ht, M), at = Ue.acquireProgram(ht, Xe), Ye.set(Xe, at), oe.uniforms = ht.uniforms;
      const vt = oe.uniforms;
      return (!F.isShaderMaterial && !F.isRawShaderMaterial || F.clipping === !0) && (vt.clippingPlanes = ct.uniform), en(F, ht), oe.needsLights = Ei(F), oe.lightsStateVersion = Je, oe.needsLights && (vt.ambientLightColor.value = re.state.ambient, vt.lightProbe.value = re.state.probe, vt.directionalLights.value = re.state.directional, vt.directionalLightShadows.value = re.state.directionalShadow, vt.spotLights.value = re.state.spot, vt.spotLightShadows.value = re.state.spotShadow, vt.rectAreaLights.value = re.state.rectArea, vt.ltc_1.value = re.state.rectAreaLTC1, vt.ltc_2.value = re.state.rectAreaLTC2, vt.pointLights.value = re.state.point, vt.pointLightShadows.value = re.state.pointShadow, vt.hemisphereLights.value = re.state.hemi, vt.directionalShadowMap.value = re.state.directionalShadowMap, vt.directionalShadowMatrix.value = re.state.directionalShadowMatrix, vt.spotShadowMap.value = re.state.spotShadowMap, vt.spotLightMatrix.value = re.state.spotLightMatrix, vt.spotLightMap.value = re.state.spotLightMap, vt.pointShadowMap.value = re.state.pointShadowMap, vt.pointShadowMatrix.value = re.state.pointShadowMatrix), oe.currentProgram = at, oe.uniformsList = null, at;
    }
    function wn(F) {
      if (F.uniformsList === null) {
        const te = F.currentProgram.getUniforms();
        F.uniformsList = Rd.seqWithValue(te.seq, F.uniforms);
      }
      return F.uniformsList;
    }
    function en(F, te) {
      const ae = Ie.get(F);
      ae.outputColorSpace = te.outputColorSpace, ae.batching = te.batching, ae.instancing = te.instancing, ae.instancingColor = te.instancingColor, ae.skinning = te.skinning, ae.morphTargets = te.morphTargets, ae.morphNormals = te.morphNormals, ae.morphColors = te.morphColors, ae.morphTargetsCount = te.morphTargetsCount, ae.numClippingPlanes = te.numClippingPlanes, ae.numIntersection = te.numClipIntersection, ae.vertexAlphas = te.vertexAlphas, ae.vertexTangents = te.vertexTangents, ae.toneMapping = te.toneMapping;
    }
    function $t(F, te, ae, oe, re) {
      te.isScene !== !0 && (te = De), O.resetTextureUnits();
      const Re = te.fog, Je = oe.isMeshStandardMaterial ? te.environment : null, ht = R === null ? M.outputColorSpace : R.isXRRenderTarget === !0 ? R.texture.colorSpace : vs, Xe = (oe.isMeshStandardMaterial ? $ : L).get(oe.envMap || Je), Ye = oe.vertexColors === !0 && !!ae.attributes.color && ae.attributes.color.itemSize === 4, at = !!ae.attributes.tangent && (!!oe.normalMap || oe.anisotropy > 0), vt = !!ae.morphAttributes.position, sn = !!ae.morphAttributes.normal, dn = !!ae.morphAttributes.color;
      let Nt = fs;
      oe.toneMapped && (R === null || R.isXRRenderTarget === !0) && (Nt = M.toneMapping);
      const un = ae.morphAttributes.position || ae.morphAttributes.normal || ae.morphAttributes.color, ft = un !== void 0 ? un.length : 0, ke = Ie.get(oe), _r = y.state.lights;
      if (ie === !0 && (he === !0 || F !== C)) {
        const ni = F === C && oe.id === U;
        ct.setState(oe, F, ni);
      }
      let Rt = !1;
      oe.version === ke.__version ? (ke.needsLights && ke.lightsStateVersion !== _r.state.version || ke.outputColorSpace !== ht || re.isBatchedMesh && ke.batching === !1 || !re.isBatchedMesh && ke.batching === !0 || re.isInstancedMesh && ke.instancing === !1 || !re.isInstancedMesh && ke.instancing === !0 || re.isSkinnedMesh && ke.skinning === !1 || !re.isSkinnedMesh && ke.skinning === !0 || re.isInstancedMesh && ke.instancingColor === !0 && re.instanceColor === null || re.isInstancedMesh && ke.instancingColor === !1 && re.instanceColor !== null || ke.envMap !== Xe || oe.fog === !0 && ke.fog !== Re || ke.numClippingPlanes !== void 0 && (ke.numClippingPlanes !== ct.numPlanes || ke.numIntersection !== ct.numIntersection) || ke.vertexAlphas !== Ye || ke.vertexTangents !== at || ke.morphTargets !== vt || ke.morphNormals !== sn || ke.morphColors !== dn || ke.toneMapping !== Nt || Me.isWebGL2 === !0 && ke.morphTargetsCount !== ft) && (Rt = !0) : (Rt = !0, ke.__version = oe.version);
      let xn = ke.currentProgram;
      Rt === !0 && (xn = jt(oe, te, re));
      let jr = !1, vr = !1, Kn = !1;
      const Cn = xn.getUniforms(), $r = ke.uniforms;
      if (fe.useProgram(xn.program) && (jr = !0, vr = !0, Kn = !0), oe.id !== U && (U = oe.id, vr = !0), jr || C !== F) {
        Cn.setValue(X, "projectionMatrix", F.projectionMatrix), Cn.setValue(X, "viewMatrix", F.matrixWorldInverse);
        const ni = Cn.map.cameraPosition;
        ni !== void 0 && ni.setValue(X, Pe.setFromMatrixPosition(F.matrixWorld)), Me.logarithmicDepthBuffer && Cn.setValue(
          X,
          "logDepthBufFC",
          2 / (Math.log(F.far + 1) / Math.LN2)
        ), (oe.isMeshPhongMaterial || oe.isMeshToonMaterial || oe.isMeshLambertMaterial || oe.isMeshBasicMaterial || oe.isMeshStandardMaterial || oe.isShaderMaterial) && Cn.setValue(X, "isOrthographic", F.isOrthographicCamera === !0), C !== F && (C = F, vr = !0, Kn = !0);
      }
      if (re.isSkinnedMesh) {
        Cn.setOptional(X, re, "bindMatrix"), Cn.setOptional(X, re, "bindMatrixInverse");
        const ni = re.skeleton;
        ni && (Me.floatVertexTextures ? (ni.boneTexture === null && ni.computeBoneTexture(), Cn.setValue(X, "boneTexture", ni.boneTexture, O)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      re.isBatchedMesh && (Cn.setOptional(X, re, "batchingTexture"), Cn.setValue(X, "batchingTexture", re._matricesTexture, O));
      const Ka = ae.morphAttributes;
      if ((Ka.position !== void 0 || Ka.normal !== void 0 || Ka.color !== void 0 && Me.isWebGL2 === !0) && et.update(re, ae, xn), (vr || ke.receiveShadow !== re.receiveShadow) && (ke.receiveShadow = re.receiveShadow, Cn.setValue(X, "receiveShadow", re.receiveShadow)), oe.isMeshGouraudMaterial && oe.envMap !== null && ($r.envMap.value = Xe, $r.flipEnvMap.value = Xe.isCubeTexture && Xe.isRenderTargetTexture === !1 ? -1 : 1), vr && (Cn.setValue(X, "toneMappingExposure", M.toneMappingExposure), ke.needsLights && Kt($r, Kn), Re && oe.fog === !0 && Le.refreshFogUniforms($r, Re), Le.refreshMaterialUniforms($r, oe, ee, j, ge), Rd.upload(X, wn(ke), $r, O)), oe.isShaderMaterial && oe.uniformsNeedUpdate === !0 && (Rd.upload(X, wn(ke), $r, O), oe.uniformsNeedUpdate = !1), oe.isSpriteMaterial && Cn.setValue(X, "center", re.center), Cn.setValue(X, "modelViewMatrix", re.modelViewMatrix), Cn.setValue(X, "normalMatrix", re.normalMatrix), Cn.setValue(X, "modelMatrix", re.matrixWorld), oe.isShaderMaterial || oe.isRawShaderMaterial) {
        const ni = oe.uniformsGroups;
        for (let qa = 0, Qi = ni.length; qa < Qi; qa++)
          if (Me.isWebGL2) {
            const xh = ni[qa];
            St.update(xh, xn), St.bind(xh, xn);
          } else
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return xn;
    }
    function Kt(F, te) {
      F.ambientLightColor.needsUpdate = te, F.lightProbe.needsUpdate = te, F.directionalLights.needsUpdate = te, F.directionalLightShadows.needsUpdate = te, F.pointLights.needsUpdate = te, F.pointLightShadows.needsUpdate = te, F.spotLights.needsUpdate = te, F.spotLightShadows.needsUpdate = te, F.rectAreaLights.needsUpdate = te, F.hemisphereLights.needsUpdate = te;
    }
    function Ei(F) {
      return F.isMeshLambertMaterial || F.isMeshToonMaterial || F.isMeshPhongMaterial || F.isMeshStandardMaterial || F.isShadowMaterial || F.isShaderMaterial && F.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return P;
    }, this.getActiveMipmapLevel = function() {
      return b;
    }, this.getRenderTarget = function() {
      return R;
    }, this.setRenderTargetTextures = function(F, te, ae) {
      Ie.get(F.texture).__webglTexture = te, Ie.get(F.depthTexture).__webglTexture = ae;
      const oe = Ie.get(F);
      oe.__hasExternalTextures = !0, oe.__hasExternalTextures && (oe.__autoAllocateDepthBuffer = ae === void 0, oe.__autoAllocateDepthBuffer || ce.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), oe.__useRenderToTexture = !1));
    }, this.setRenderTargetFramebuffer = function(F, te) {
      const ae = Ie.get(F);
      ae.__webglFramebuffer = te, ae.__useDefaultFramebuffer = te === void 0;
    }, this.setRenderTarget = function(F, te = 0, ae = 0) {
      R = F, P = te, b = ae;
      let oe = !0, re = null, Re = !1, Je = !1;
      if (F) {
        const Xe = Ie.get(F);
        Xe.__useDefaultFramebuffer !== void 0 ? (fe.bindFramebuffer(X.FRAMEBUFFER, null), oe = !1) : Xe.__webglFramebuffer === void 0 ? O.setupRenderTarget(F) : Xe.__hasExternalTextures && O.rebindTextures(F, Ie.get(F.texture).__webglTexture, Ie.get(F.depthTexture).__webglTexture);
        const Ye = F.texture;
        (Ye.isData3DTexture || Ye.isDataArrayTexture || Ye.isCompressedArrayTexture) && (Je = !0);
        const at = Ie.get(F).__webglFramebuffer;
        F.isWebGLCubeRenderTarget ? (Array.isArray(at[te]) ? re = at[te][ae] : re = at[te], Re = !0) : Me.isWebGL2 && F.samples > 0 && O.useMultisampledRTT(F) === !1 ? re = Ie.get(F).__webglMultisampledFramebuffer : Array.isArray(at) ? re = at[ae] : re = at, B.copy(F.viewport), G.copy(F.scissor), W = F.scissorTest;
      } else
        B.copy(I).multiplyScalar(ee).floor(), G.copy(D).multiplyScalar(ee).floor(), W = J;
      if (fe.bindFramebuffer(X.FRAMEBUFFER, re) && Me.drawBuffers && oe && fe.drawBuffers(F, re), fe.viewport(B), fe.scissor(G), fe.setScissorTest(W), Re) {
        const Xe = Ie.get(F.texture);
        X.framebufferTexture2D(X.FRAMEBUFFER, X.COLOR_ATTACHMENT0, X.TEXTURE_CUBE_MAP_POSITIVE_X + te, Xe.__webglTexture, ae);
      } else if (Je) {
        const Xe = Ie.get(F.texture), Ye = te || 0;
        X.framebufferTextureLayer(X.FRAMEBUFFER, X.COLOR_ATTACHMENT0, Xe.__webglTexture, ae || 0, Ye);
      }
      U = -1;
    }, this.readRenderTargetPixels = function(F, te, ae, oe, re, Re, Je) {
      if (!(F && F.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let ht = Ie.get(F).__webglFramebuffer;
      if (F.isWebGLCubeRenderTarget && Je !== void 0 && (ht = ht[Je]), ht) {
        fe.bindFramebuffer(X.FRAMEBUFFER, ht);
        try {
          const Xe = F.texture, Ye = Xe.format, at = Xe.type;
          if (Ye !== Di && Ve.convert(Ye) !== X.getParameter(X.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const vt = at === ic && (ce.has("EXT_color_buffer_half_float") || Me.isWebGL2 && ce.has("EXT_color_buffer_float"));
          if (at !== ds && Ve.convert(at) !== X.getParameter(X.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(at === Jr && (Me.isWebGL2 || ce.has("OES_texture_float") || ce.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !vt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          te >= 0 && te <= F.width - oe && ae >= 0 && ae <= F.height - re && X.readPixels(te, ae, oe, re, Ve.convert(Ye), Ve.convert(at), Re);
        } finally {
          const Xe = R !== null ? Ie.get(R).__webglFramebuffer : null;
          fe.bindFramebuffer(X.FRAMEBUFFER, Xe);
        }
      }
    }, this.copyFramebufferToTexture = function(F, te, ae = 0) {
      const oe = Math.pow(2, -ae), re = Math.floor(te.image.width * oe), Re = Math.floor(te.image.height * oe);
      O.setTexture2D(te, 0), X.copyTexSubImage2D(X.TEXTURE_2D, ae, 0, 0, F.x, F.y, re, Re), fe.unbindTexture();
    }, this.copyTextureToTexture = function(F, te, ae, oe = 0) {
      const re = te.image.width, Re = te.image.height, Je = Ve.convert(ae.format), ht = Ve.convert(ae.type);
      O.setTexture2D(ae, 0), X.pixelStorei(X.UNPACK_FLIP_Y_WEBGL, ae.flipY), X.pixelStorei(X.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ae.premultiplyAlpha), X.pixelStorei(X.UNPACK_ALIGNMENT, ae.unpackAlignment), te.isDataTexture ? X.texSubImage2D(X.TEXTURE_2D, oe, F.x, F.y, re, Re, Je, ht, te.image.data) : te.isCompressedTexture ? X.compressedTexSubImage2D(X.TEXTURE_2D, oe, F.x, F.y, te.mipmaps[0].width, te.mipmaps[0].height, Je, te.mipmaps[0].data) : X.texSubImage2D(X.TEXTURE_2D, oe, F.x, F.y, Je, ht, te.image), oe === 0 && ae.generateMipmaps && X.generateMipmap(X.TEXTURE_2D), fe.unbindTexture();
    }, this.copyTextureToTexture3D = function(F, te, ae, oe, re = 0) {
      if (M.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const Re = F.max.x - F.min.x + 1, Je = F.max.y - F.min.y + 1, ht = F.max.z - F.min.z + 1, Xe = Ve.convert(oe.format), Ye = Ve.convert(oe.type);
      let at;
      if (oe.isData3DTexture)
        O.setTexture3D(oe, 0), at = X.TEXTURE_3D;
      else if (oe.isDataArrayTexture || oe.isCompressedArrayTexture)
        O.setTexture2DArray(oe, 0), at = X.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      X.pixelStorei(X.UNPACK_FLIP_Y_WEBGL, oe.flipY), X.pixelStorei(X.UNPACK_PREMULTIPLY_ALPHA_WEBGL, oe.premultiplyAlpha), X.pixelStorei(X.UNPACK_ALIGNMENT, oe.unpackAlignment);
      const vt = X.getParameter(X.UNPACK_ROW_LENGTH), sn = X.getParameter(X.UNPACK_IMAGE_HEIGHT), dn = X.getParameter(X.UNPACK_SKIP_PIXELS), Nt = X.getParameter(X.UNPACK_SKIP_ROWS), un = X.getParameter(X.UNPACK_SKIP_IMAGES), ft = ae.isCompressedTexture ? ae.mipmaps[re] : ae.image;
      X.pixelStorei(X.UNPACK_ROW_LENGTH, ft.width), X.pixelStorei(X.UNPACK_IMAGE_HEIGHT, ft.height), X.pixelStorei(X.UNPACK_SKIP_PIXELS, F.min.x), X.pixelStorei(X.UNPACK_SKIP_ROWS, F.min.y), X.pixelStorei(X.UNPACK_SKIP_IMAGES, F.min.z), ae.isDataTexture || ae.isData3DTexture ? X.texSubImage3D(at, re, te.x, te.y, te.z, Re, Je, ht, Xe, Ye, ft.data) : ae.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), X.compressedTexSubImage3D(at, re, te.x, te.y, te.z, Re, Je, ht, Xe, ft.data)) : X.texSubImage3D(at, re, te.x, te.y, te.z, Re, Je, ht, Xe, Ye, ft), X.pixelStorei(X.UNPACK_ROW_LENGTH, vt), X.pixelStorei(X.UNPACK_IMAGE_HEIGHT, sn), X.pixelStorei(X.UNPACK_SKIP_PIXELS, dn), X.pixelStorei(X.UNPACK_SKIP_ROWS, Nt), X.pixelStorei(X.UNPACK_SKIP_IMAGES, un), re === 0 && oe.generateMipmaps && X.generateMipmap(at), fe.unbindTexture();
    }, this.initTexture = function(F) {
      F.isCubeTexture ? O.setTextureCube(F, 0) : F.isData3DTexture ? O.setTexture3D(F, 0) : F.isDataArrayTexture || F.isCompressedArrayTexture ? O.setTexture2DArray(F, 0) : O.setTexture2D(F, 0), fe.unbindTexture();
    }, this.resetState = function() {
      P = 0, b = 0, R = null, fe.reset(), gt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Yr;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === hp ? "display-p3" : "srgb", t.unpackColorSpace = Qt.workingColorSpace === oh ? "display-p3" : "srgb";
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === Vn ? Eo : U0;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === Eo ? Vn : vs;
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(e) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
  }
}
class DE extends Y0 {
}
DE.prototype.isWebGL1Renderer = !0;
class pp {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new Ne(e), this.density = t;
  }
  clone() {
    return new pp(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class mp {
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new Ne(e), this.near = t, this.far = n;
  }
  clone() {
    return new mp(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class K0 extends zt {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
}
class hh {
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Hu, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = fr();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return console.warn("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let i = 0, r = this.stride; i < r; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Ci = /* @__PURE__ */ new k();
class Po {
  constructor(e, t, n, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Ci.fromBufferAttribute(this, t), Ci.applyMatrix4(e), this.setXYZ(t, Ci.x, Ci.y, Ci.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ci.fromBufferAttribute(this, t), Ci.applyNormalMatrix(e), this.setXYZ(t, Ci.x, Ci.y, Ci.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ci.fromBufferAttribute(this, t), Ci.transformDirection(e), this.setXYZ(t, Ci.x, Ci.y, Ci.z);
    return this;
  }
  setX(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = Tt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Wi(t, this.array)), t;
  }
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Tt(t, this.array), n = Tt(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  setXYZ(e, t, n, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Tt(t, this.array), n = Tt(n, this.array), i = Tt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
  }
  setXYZW(e, t, n, i, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = Tt(t, this.array), n = Tt(n, this.array), i = Tt(i, this.array), r = Tt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[i + r]);
      }
      return new Vt(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Po(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let r = 0; r < this.itemSize; r++)
          t.push(this.data.array[i + r]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class q0 extends Xn {
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new Ne(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let Sl;
const Kc = /* @__PURE__ */ new k(), El = /* @__PURE__ */ new k(), Tl = /* @__PURE__ */ new k(), wl = /* @__PURE__ */ new ve(), qc = /* @__PURE__ */ new ve(), FE = /* @__PURE__ */ new pt(), Uf = /* @__PURE__ */ new k(), Qc = /* @__PURE__ */ new k(), Of = /* @__PURE__ */ new k(), dA = /* @__PURE__ */ new ve(), dg = /* @__PURE__ */ new ve(), pA = /* @__PURE__ */ new ve();
class UE extends zt {
  constructor(e = new q0()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", Sl === void 0) {
      Sl = new Mt();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new hh(t, 5);
      Sl.setIndex([0, 1, 2, 0, 2, 3]), Sl.setAttribute("position", new Po(n, 3, 0, !1)), Sl.setAttribute("uv", new Po(n, 2, 3, !1));
    }
    this.geometry = Sl, this.material = e, this.center = new ve(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), El.setFromMatrixScale(this.matrixWorld), FE.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Tl.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && El.multiplyScalar(-Tl.z);
    const n = this.material.rotation;
    let i, r;
    n !== 0 && (r = Math.cos(n), i = Math.sin(n));
    const o = this.center;
    Nf(Uf.set(-0.5, -0.5, 0), Tl, o, El, i, r), Nf(Qc.set(0.5, -0.5, 0), Tl, o, El, i, r), Nf(Of.set(0.5, 0.5, 0), Tl, o, El, i, r), dA.set(0, 0), dg.set(1, 0), pA.set(1, 1);
    let a = e.ray.intersectTriangle(Uf, Qc, Of, !1, Kc);
    if (a === null && (Nf(Qc.set(-0.5, 0.5, 0), Tl, o, El, i, r), dg.set(0, 1), a = e.ray.intersectTriangle(Uf, Of, Qc, !1, Kc), a === null))
      return;
    const l = e.ray.origin.distanceTo(Kc);
    l < e.near || l > e.far || t.push({
      distance: l,
      point: Kc.clone(),
      uv: Vi.getInterpolation(Kc, Uf, Qc, Of, dA, dg, pA, new ve()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Nf(s, e, t, n, i, r) {
  wl.subVectors(s, t).addScalar(0.5).multiply(n), i !== void 0 ? (qc.x = r * wl.x - i * wl.y, qc.y = i * wl.x + r * wl.y) : qc.copy(wl), s.copy(e), s.x += qc.x, s.y += qc.y, s.applyMatrix4(FE);
}
const kf = /* @__PURE__ */ new k(), mA = /* @__PURE__ */ new k();
class OE extends zt {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      levels: {
        enumerable: !0,
        value: []
      },
      isLOD: {
        value: !0
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      this.addLevel(r.object.clone(), r.distance, r.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let r;
    for (r = 0; r < i.length && !(t < i[r].distance); r++)
      ;
    return i.splice(r, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, i;
      for (n = 1, i = t.length; n < i; n++) {
        let r = t[n].distance;
        if (t[n].object.visible && (r -= r * t[n].hysteresis), e < r)
          break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      kf.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(kf);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      kf.setFromMatrixPosition(e.matrixWorld), mA.setFromMatrixPosition(this.matrixWorld);
      const n = kf.distanceTo(mA) / e.zoom;
      t[0].object.visible = !0;
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let o = t[i].distance;
        if (t[i].object.visible && (o -= o * t[i].hysteresis), n >= o)
          t[i - 1].object.visible = !1, t[i].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = i - 1; i < r; i++)
        t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let i = 0, r = n.length; i < r; i++) {
      const o = n[i];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis
      });
    }
    return t;
  }
}
const gA = /* @__PURE__ */ new k(), _A = /* @__PURE__ */ new Zt(), vA = /* @__PURE__ */ new Zt(), lL = /* @__PURE__ */ new k(), yA = /* @__PURE__ */ new pt(), Gf = /* @__PURE__ */ new k(), pg = /* @__PURE__ */ new oi(), xA = /* @__PURE__ */ new pt(), mg = /* @__PURE__ */ new vc();
class Q0 extends kn {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = p_, this.bindMatrix = new pt(), this.bindMatrixInverse = new pt(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new xi()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Gf), this.boundingBox.expandByPoint(Gf);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new oi()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Gf), this.boundingSphere.expandByPoint(Gf);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, i = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), pg.copy(this.boundingSphere), pg.applyMatrix4(i), e.ray.intersectsSphere(pg) !== !1 && (xA.copy(i).invert(), mg.copy(e.ray).applyMatrix4(xA), !(this.boundingBox !== null && mg.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, mg)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Zt(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const r = 1 / e.manhattanLength();
      r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === p_ ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === qS ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton, i = this.geometry;
    _A.fromBufferAttribute(i.attributes.skinIndex, e), vA.fromBufferAttribute(i.attributes.skinWeight, e), gA.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let r = 0; r < 4; r++) {
      const o = vA.getComponent(r);
      if (o !== 0) {
        const a = _A.getComponent(r);
        yA.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(lL.copy(gA).applyMatrix4(yA), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t);
  }
}
class gp extends zt {
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class Ta extends yn {
  constructor(e = null, t = 1, n = 1, i, r, o, a, l, h = Sn, f = Sn, d, p) {
    super(null, o, a, l, h, f, i, r, d, p), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const AA = /* @__PURE__ */ new pt(), cL = /* @__PURE__ */ new pt();
class fh {
  constructor(e = [], t = []) {
    this.uuid = fr(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new pt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new pt();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, i = this.boneTexture;
    for (let r = 0, o = e.length; r < o; r++) {
      const a = e[r] ? e[r].matrixWorld : cL;
      AA.multiplyMatrices(a, t[r]), AA.toArray(n, r * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new fh(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Ta(t, e, e, Di, Jr);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e)
        return i;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const r = e.bones[n];
      let o = t[r];
      o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), o = new gp()), this.bones.push(o), this.boneInverses.push(new pt().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i];
      e.bones.push(o.uuid);
      const a = n[i];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Ua extends Vt {
  constructor(e, t, n, i = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const Cl = /* @__PURE__ */ new pt(), MA = /* @__PURE__ */ new pt(), Hf = [], SA = /* @__PURE__ */ new xi(), uL = /* @__PURE__ */ new pt(), Zc = /* @__PURE__ */ new kn(), jc = /* @__PURE__ */ new oi();
class Z0 extends kn {
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new Ua(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let i = 0; i < n; i++)
      this.setMatrixAt(i, uL);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new xi()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Cl), SA.copy(e.boundingBox).applyMatrix4(Cl), this.boundingBox.union(SA);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new oi()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Cl), jc.copy(e.boundingSphere).applyMatrix4(Cl), this.boundingSphere.union(jc);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld, i = this.count;
    if (Zc.geometry = this.geometry, Zc.material = this.material, Zc.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), jc.copy(this.boundingSphere), jc.applyMatrix4(n), e.ray.intersectsSphere(jc) !== !1))
      for (let r = 0; r < i; r++) {
        this.getMatrixAt(r, Cl), MA.multiplyMatrices(n, Cl), Zc.matrixWorld = MA, Zc.raycast(e, Hf);
        for (let o = 0, a = Hf.length; o < a; o++) {
          const l = Hf[o];
          l.instanceId = r, l.object = this, t.push(l);
        }
        Hf.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new Ua(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function hL(s, e) {
  return s.z - e.z;
}
function fL(s, e) {
  return e.z - s.z;
}
class dL {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t) {
    const n = this.pool, i = this.list;
    this.index >= n.length && n.push({
      start: -1,
      count: -1,
      z: -1
    });
    const r = n[this.index];
    i.push(r), this.index++, r.start = e.start, r.count = e.count, r.z = t;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const bl = "batchId", co = /* @__PURE__ */ new pt(), EA = /* @__PURE__ */ new pt(), pL = /* @__PURE__ */ new pt(), TA = /* @__PURE__ */ new pt(), gg = /* @__PURE__ */ new ch(), zf = /* @__PURE__ */ new xi(), $o = /* @__PURE__ */ new oi(), $c = /* @__PURE__ */ new k(), _g = /* @__PURE__ */ new dL(), pi = /* @__PURE__ */ new kn(), Vf = [];
function mL(s, e, t = 0) {
  const n = e.itemSize;
  if (s.isInterleavedBufferAttribute || s.array.constructor !== e.array.constructor) {
    const i = s.count;
    for (let r = 0; r < i; r++)
      for (let o = 0; o < n; o++)
        e.setComponent(r + t, o, s.getComponent(r, o));
  } else
    e.array.set(s.array, t * n);
  e.needsUpdate = !0;
}
class NE extends kn {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, n = t * 2, i) {
    super(new Mt(), i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._geometryInitialized = !1, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._visibilityChanged = !0, this._matricesTexture = null, this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), n = new Ta(t, e, e, Di, Jr);
    this._matricesTexture = n;
  }
  _initializeGeometry(e) {
    const t = this.geometry, n = this._maxVertexCount, i = this._maxGeometryCount, r = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const a in e.attributes) {
        const l = e.getAttribute(a), { array: h, itemSize: f, normalized: d } = l, p = new h.constructor(n * f), m = new l.constructor(p, f, d);
        m.setUsage(l.usage), t.setAttribute(a, m);
      }
      if (e.getIndex() !== null) {
        const a = n > 65536 ? new Uint32Array(r) : new Uint16Array(r);
        t.setIndex(new Vt(a, 1));
      }
      const o = i > 65536 ? new Uint32Array(n) : new Uint16Array(n);
      t.setAttribute(bl, new Vt(o, 1)), this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry atributes
  _validateGeometry(e) {
    if (e.getAttribute(bl))
      throw new Error(`BatchedMesh: Geometry cannot use attribute "${bl}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const n in t.attributes) {
      if (n === bl)
        continue;
      if (!e.hasAttribute(n))
        throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
      const i = e.getAttribute(n), r = t.getAttribute(n);
      if (i.itemSize !== r.itemSize || i.normalized !== r.normalized)
        throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new xi());
    const e = this._geometryCount, t = this.boundingBox, n = this._active;
    t.makeEmpty();
    for (let i = 0; i < e; i++)
      n[i] !== !1 && (this.getMatrixAt(i, co), this.getBoundingBoxAt(i, zf).applyMatrix4(co), t.union(zf));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new oi());
    const e = this._geometryCount, t = this.boundingSphere, n = this._active;
    t.makeEmpty();
    for (let i = 0; i < e; i++)
      n[i] !== !1 && (this.getMatrixAt(i, co), this.getBoundingSphereAt(i, $o).applyMatrix4(co), t.union($o));
  }
  addGeometry(e, t = -1, n = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    const i = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1
    };
    let r = null;
    const o = this._reservedRanges, a = this._drawRanges, l = this._bounds;
    this._geometryCount !== 0 && (r = o[o.length - 1]), t === -1 ? i.vertexCount = e.getAttribute("position").count : i.vertexCount = t, r === null ? i.vertexStart = 0 : i.vertexStart = r.vertexStart + r.vertexCount;
    const h = e.getIndex(), f = h !== null;
    if (f && (n === -1 ? i.indexCount = h.count : i.indexCount = n, r === null ? i.indexStart = 0 : i.indexStart = r.indexStart + r.indexCount), i.indexStart !== -1 && i.indexStart + i.indexCount > this._maxIndexCount || i.vertexStart + i.vertexCount > this._maxVertexCount)
      throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const d = this._visibility, p = this._active, m = this._matricesTexture, _ = this._matricesTexture.image.data;
    d.push(!0), p.push(!0);
    const x = this._geometryCount;
    this._geometryCount++, pL.toArray(_, x * 16), m.needsUpdate = !0, o.push(i), a.push({
      start: f ? i.indexStart : i.vertexStart,
      count: -1
    }), l.push({
      boxInitialized: !1,
      box: new xi(),
      sphereInitialized: !1,
      sphere: new oi()
    });
    const y = this.geometry.getAttribute(bl);
    for (let v = 0; v < i.vertexCount; v++)
      y.setX(i.vertexStart + v, x);
    return y.needsUpdate = !0, this.setGeometryAt(x, e), x;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry, i = n.getIndex() !== null, r = n.getIndex(), o = t.getIndex(), a = this._reservedRanges[e];
    if (i && o.count > a.indexCount || t.attributes.position.count > a.vertexCount)
      throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const l = a.vertexStart, h = a.vertexCount;
    for (const m in n.attributes) {
      if (m === bl)
        continue;
      const _ = t.getAttribute(m), x = n.getAttribute(m);
      mL(_, x, l);
      const y = _.itemSize;
      for (let v = _.count, S = h; v < S; v++) {
        const M = l + v;
        for (let T = 0; T < y; T++)
          x.setComponent(M, T, 0);
      }
      x.needsUpdate = !0;
    }
    if (i) {
      const m = a.indexStart;
      for (let _ = 0; _ < o.count; _++)
        r.setX(m + _, l + o.getX(_));
      for (let _ = o.count, x = a.indexCount; _ < x; _++)
        r.setX(m + _, l);
      r.needsUpdate = !0;
    }
    const f = this._bounds[e];
    t.boundingBox !== null ? (f.box.copy(t.boundingBox), f.boxInitialized = !0) : f.boxInitialized = !1, t.boundingSphere !== null ? (f.sphere.copy(t.boundingSphere), f.sphereInitialized = !0) : f.sphereInitialized = !1;
    const d = this._drawRanges[e], p = t.getAttribute("position");
    return d.count = i ? o.count : p.count, this._visibilityChanged = !0, e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === !1 ? this : (t[e] = !1, this._visibilityChanged = !0, this);
  }
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(e, t) {
    if (this._active[e] === !1)
      return this;
    const i = this._bounds[e], r = i.box, o = this.geometry;
    if (i.boxInitialized === !1) {
      r.makeEmpty();
      const a = o.index, l = o.attributes.position, h = this._drawRanges[e];
      for (let f = h.start, d = h.start + h.count; f < d; f++) {
        let p = f;
        a && (p = a.getX(p)), r.expandByPoint($c.fromBufferAttribute(l, p));
      }
      i.boxInitialized = !0;
    }
    return t.copy(r), t;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(e, t) {
    if (this._active[e] === !1)
      return this;
    const i = this._bounds[e], r = i.sphere, o = this.geometry;
    if (i.sphereInitialized === !1) {
      r.makeEmpty(), this.getBoundingBoxAt(e, zf), zf.getCenter(r.center);
      const a = o.index, l = o.attributes.position, h = this._drawRanges[e];
      let f = 0;
      for (let d = h.start, p = h.start + h.count; d < p; d++) {
        let m = d;
        a && (m = a.getX(m)), $c.fromBufferAttribute(l, m), f = Math.max(f, r.center.distanceToSquared($c));
      }
      r.radius = Math.sqrt(f), i.sphereInitialized = !0;
    }
    return t.copy(r), t;
  }
  setMatrixAt(e, t) {
    const n = this._active, i = this._matricesTexture, r = this._matricesTexture.image.data, o = this._geometryCount;
    return e >= o || n[e] === !1 ? this : (t.toArray(r, e * 16), i.needsUpdate = !0, this);
  }
  getMatrixAt(e, t) {
    const n = this._active, i = this._matricesTexture.image.data, r = this._geometryCount;
    return e >= r || n[e] === !1 ? null : t.fromArray(i, e * 16);
  }
  setVisibleAt(e, t) {
    const n = this._visibility, i = this._active, r = this._geometryCount;
    return e >= r || i[e] === !1 || n[e] === t ? this : (n[e] = t, this._visibilityChanged = !0, this);
  }
  getVisibleAt(e) {
    const t = this._visibility, n = this._active, i = this._geometryCount;
    return e >= i || n[e] === !1 ? !1 : t[e];
  }
  raycast(e, t) {
    const n = this._visibility, i = this._active, r = this._drawRanges, o = this._geometryCount, a = this.matrixWorld, l = this.geometry;
    pi.material = this.material, pi.geometry.index = l.index, pi.geometry.attributes = l.attributes, pi.geometry.boundingBox === null && (pi.geometry.boundingBox = new xi()), pi.geometry.boundingSphere === null && (pi.geometry.boundingSphere = new oi());
    for (let h = 0; h < o; h++) {
      if (!n[h] || !i[h])
        continue;
      const f = r[h];
      pi.geometry.setDrawRange(f.start, f.count), this.getMatrixAt(h, pi.matrixWorld).premultiply(a), this.getBoundingBoxAt(h, pi.geometry.boundingBox), this.getBoundingSphereAt(h, pi.geometry.boundingSphere), pi.raycast(e, Vf);
      for (let d = 0, p = Vf.length; d < p; d++) {
        const m = Vf[d];
        m.object = this, m.batchId = h, t.push(m);
      }
      Vf.length = 0;
    }
    pi.material = null, pi.geometry.index = null, pi.geometry.attributes = {}, pi.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((t) => ({
      boxInitialized: t.boxInitialized,
      box: t.box.clone(),
      sphereInitialized: t.sphereInitialized,
      sphere: t.sphere.clone()
    })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
  }
  onBeforeRender(e, t, n, i, r) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const o = i.getIndex(), a = o === null ? 1 : o.array.BYTES_PER_ELEMENT, l = this._visibility, h = this._multiDrawStarts, f = this._multiDrawCounts, d = this._drawRanges, p = this.perObjectFrustumCulled;
    p && (TA.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), gg.setFromProjectionMatrix(
      TA,
      e.isWebGPURenderer ? sc : Yr
    ));
    let m = 0;
    if (this.sortObjects) {
      EA.copy(this.matrixWorld).invert(), $c.setFromMatrixPosition(n.matrixWorld).applyMatrix4(EA);
      for (let y = 0, v = l.length; y < v; y++)
        if (l[y]) {
          this.getMatrixAt(y, co), this.getBoundingSphereAt(y, $o).applyMatrix4(co);
          let S = !1;
          if (p && (S = !gg.intersectsSphere($o)), !S) {
            const M = $c.distanceTo($o.center);
            _g.push(d[y], M);
          }
        }
      const _ = _g.list, x = this.customSort;
      x === null ? _.sort(r.transparent ? fL : hL) : x.call(this, _, n);
      for (let y = 0, v = _.length; y < v; y++) {
        const S = _[y];
        h[m] = S.start * a, f[m] = S.count, m++;
      }
      _g.reset();
    } else
      for (let _ = 0, x = l.length; _ < x; _++)
        if (l[_]) {
          let y = !1;
          if (p && (this.getMatrixAt(_, co), this.getBoundingSphereAt(_, $o).applyMatrix4(co), y = !gg.intersectsSphere($o)), !y) {
            const v = d[_];
            h[m] = v.start * a, f[m] = v.count, m++;
          }
        }
    this._multiDrawCount = m, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, n, i, r, o) {
    this.onBeforeRender(e, null, i, r, o);
  }
}
class Mi extends Xn {
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Ne(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const wA = /* @__PURE__ */ new k(), CA = /* @__PURE__ */ new k(), bA = /* @__PURE__ */ new pt(), vg = /* @__PURE__ */ new vc(), Wf = /* @__PURE__ */ new oi();
class Js extends zt {
  constructor(e = new Mt(), t = new Mi()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let i = 1, r = t.count; i < r; i++)
        wA.fromBufferAttribute(t, i - 1), CA.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += wA.distanceTo(CA);
      e.setAttribute("lineDistance", new $e(n, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, r = e.params.Line.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Wf.copy(n.boundingSphere), Wf.applyMatrix4(i), Wf.radius += r, e.ray.intersectsSphere(Wf) === !1) return;
    bA.copy(i).invert(), vg.copy(e.ray).applyMatrix4(bA);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, h = new k(), f = new k(), d = new k(), p = new k(), m = this.isLineSegments ? 2 : 1, _ = n.index, y = n.attributes.position;
    if (_ !== null) {
      const v = Math.max(0, o.start), S = Math.min(_.count, o.start + o.count);
      for (let M = v, T = S - 1; M < T; M += m) {
        const P = _.getX(M), b = _.getX(M + 1);
        if (h.fromBufferAttribute(y, P), f.fromBufferAttribute(y, b), vg.distanceSqToSegment(h, f, p, d) > l) continue;
        p.applyMatrix4(this.matrixWorld);
        const U = e.ray.origin.distanceTo(p);
        U < e.near || U > e.far || t.push({
          distance: U,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: d.clone().applyMatrix4(this.matrixWorld),
          index: M,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const v = Math.max(0, o.start), S = Math.min(y.count, o.start + o.count);
      for (let M = v, T = S - 1; M < T; M += m) {
        if (h.fromBufferAttribute(y, M), f.fromBufferAttribute(y, M + 1), vg.distanceSqToSegment(h, f, p, d) > l) continue;
        p.applyMatrix4(this.matrixWorld);
        const b = e.ray.origin.distanceTo(p);
        b < e.near || b > e.far || t.push({
          distance: b,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: d.clone().applyMatrix4(this.matrixWorld),
          index: M,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = i.length; r < o; r++) {
          const a = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
const RA = /* @__PURE__ */ new k(), BA = /* @__PURE__ */ new k();
class qr extends Js {
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let i = 0, r = t.count; i < r; i += 2)
        RA.fromBufferAttribute(t, i), BA.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + RA.distanceTo(BA);
      e.setAttribute("lineDistance", new $e(n, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class j0 extends Js {
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class _p extends Xn {
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new Ne(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const PA = /* @__PURE__ */ new pt(), X_ = /* @__PURE__ */ new vc(), Xf = /* @__PURE__ */ new oi(), Jf = /* @__PURE__ */ new k();
class $0 extends zt {
  constructor(e = new Mt(), t = new _p()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const n = this.geometry, i = this.matrixWorld, r = e.params.Points.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Xf.copy(n.boundingSphere), Xf.applyMatrix4(i), Xf.radius += r, e.ray.intersectsSphere(Xf) === !1) return;
    PA.copy(i).invert(), X_.copy(e.ray).applyMatrix4(PA);
    const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, h = n.index, d = n.attributes.position;
    if (h !== null) {
      const p = Math.max(0, o.start), m = Math.min(h.count, o.start + o.count);
      for (let _ = p, x = m; _ < x; _++) {
        const y = h.getX(_);
        Jf.fromBufferAttribute(d, y), IA(Jf, y, l, i, e, t, this);
      }
    } else {
      const p = Math.max(0, o.start), m = Math.min(d.count, o.start + o.count);
      for (let _ = p, x = m; _ < x; _++)
        Jf.fromBufferAttribute(d, _), IA(Jf, _, l, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let r = 0, o = i.length; r < o; r++) {
          const a = i[r].name || String(r);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
        }
      }
    }
  }
}
function IA(s, e, t, n, i, r, o) {
  const a = X_.distanceSqToPoint(s);
  if (a < t) {
    const l = new k();
    X_.closestPointToPoint(s, l), l.applyMatrix4(n);
    const h = i.ray.origin.distanceTo(l);
    if (h < i.near || h > i.far) return;
    r.push({
      distance: h,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: o
    });
  }
}
class gL extends yn {
  constructor(e, t, n, i, r, o, a, l, h) {
    super(e, t, n, i, r, o, a, l, h), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : gn, this.magFilter = r !== void 0 ? r : gn, this.generateMipmaps = !1;
    const f = this;
    function d() {
      f.needsUpdate = !0, e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class _L extends yn {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = Sn, this.minFilter = Sn, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class vp extends yn {
  constructor(e, t, n, i, r, o, a, l, h, f, d, p) {
    super(null, o, a, l, h, f, i, r, d, p), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class vL extends vp {
  constructor(e, t, n, i, r, o) {
    super(e, t, n, r, o), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = ri;
  }
}
class yL extends vp {
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, Xs), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class xL extends yn {
  constructor(e, t, n, i, r, o, a, l, h) {
    super(e, t, n, i, r, o, a, l, h), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Qr {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, i = this.getPoint(0), r = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      n = this.getPoint(o / e), r += n.distanceTo(i), t.push(r), i = n;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, t) {
    const n = this.getLengths();
    let i = 0;
    const r = n.length;
    let o;
    t ? o = t : o = e * n[r - 1];
    let a = 0, l = r - 1, h;
    for (; a <= l; )
      if (i = Math.floor(a + (l - a) / 2), h = n[i] - o, h < 0)
        a = i + 1;
      else if (h > 0)
        l = i - 1;
      else {
        l = i;
        break;
      }
    if (i = l, n[i] === o)
      return i / (r - 1);
    const f = n[i], p = n[i + 1] - f, m = (o - f) / p;
    return (i + m) / (r - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, t) {
    let i = e - 1e-4, r = e + 1e-4;
    i < 0 && (i = 0), r > 1 && (r = 1);
    const o = this.getPoint(i), a = this.getPoint(r), l = t || (o.isVector2 ? new ve() : new k());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  computeFrenetFrames(e, t) {
    const n = new k(), i = [], r = [], o = [], a = new k(), l = new pt();
    for (let m = 0; m <= e; m++) {
      const _ = m / e;
      i[m] = this.getTangentAt(_, new k());
    }
    r[0] = new k(), o[0] = new k();
    let h = Number.MAX_VALUE;
    const f = Math.abs(i[0].x), d = Math.abs(i[0].y), p = Math.abs(i[0].z);
    f <= h && (h = f, n.set(1, 0, 0)), d <= h && (h = d, n.set(0, 1, 0)), p <= h && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], a), o[0].crossVectors(i[0], r[0]);
    for (let m = 1; m <= e; m++) {
      if (r[m] = r[m - 1].clone(), o[m] = o[m - 1].clone(), a.crossVectors(i[m - 1], i[m]), a.length() > Number.EPSILON) {
        a.normalize();
        const _ = Math.acos(En(i[m - 1].dot(i[m]), -1, 1));
        r[m].applyMatrix4(l.makeRotationAxis(a, _));
      }
      o[m].crossVectors(i[m], r[m]);
    }
    if (t === !0) {
      let m = Math.acos(En(r[0].dot(r[e]), -1, 1));
      m /= e, i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (m = -m);
      for (let _ = 1; _ <= e; _++)
        r[_].applyMatrix4(l.makeRotationAxis(i[_], m * _)), o[_].crossVectors(i[_], r[_]);
    }
    return {
      tangents: i,
      normals: r,
      binormals: o
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class yp extends Qr {
  constructor(e = 0, t = 0, n = 1, i = 1, r = 0, o = Math.PI * 2, a = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l;
  }
  getPoint(e, t) {
    const n = t || new ve(), i = Math.PI * 2;
    let r = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(r) < Number.EPSILON;
    for (; r < 0; ) r += i;
    for (; r > i; ) r -= i;
    r < Number.EPSILON && (o ? r = 0 : r = i), this.aClockwise === !0 && !o && (r === i ? r = -i : r = r - i);
    const a = this.aStartAngle + e * r;
    let l = this.aX + this.xRadius * Math.cos(a), h = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const f = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = l - this.aX, m = h - this.aY;
      l = p * f - m * d + this.aX, h = p * d + m * f + this.aY;
    }
    return n.set(l, h);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class kE extends yp {
  constructor(e, t, n, i, r, o) {
    super(e, t, n, n, i, r, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function ev() {
  let s = 0, e = 0, t = 0, n = 0;
  function i(r, o, a, l) {
    s = r, e = a, t = -3 * r + 3 * o - 2 * a - l, n = 2 * r - 2 * o + a + l;
  }
  return {
    initCatmullRom: function(r, o, a, l, h) {
      i(o, a, h * (a - r), h * (l - o));
    },
    initNonuniformCatmullRom: function(r, o, a, l, h, f, d) {
      let p = (o - r) / h - (a - r) / (h + f) + (a - o) / f, m = (a - o) / f - (l - o) / (f + d) + (l - a) / d;
      p *= f, m *= f, i(o, a, p, m);
    },
    calc: function(r) {
      const o = r * r, a = o * r;
      return s + e * r + t * o + n * a;
    }
  };
}
const Yf = /* @__PURE__ */ new k(), yg = /* @__PURE__ */ new ev(), xg = /* @__PURE__ */ new ev(), Ag = /* @__PURE__ */ new ev();
class GE extends Qr {
  constructor(e = [], t = !1, n = "centripetal", i = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i;
  }
  getPoint(e, t = new k()) {
    const n = t, i = this.points, r = i.length, o = (r - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o), l = o - a;
    this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : l === 0 && a === r - 1 && (a = r - 2, l = 1);
    let h, f;
    this.closed || a > 0 ? h = i[(a - 1) % r] : (Yf.subVectors(i[0], i[1]).add(i[0]), h = Yf);
    const d = i[a % r], p = i[(a + 1) % r];
    if (this.closed || a + 2 < r ? f = i[(a + 2) % r] : (Yf.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), f = Yf), this.curveType === "centripetal" || this.curveType === "chordal") {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let _ = Math.pow(h.distanceToSquared(d), m), x = Math.pow(d.distanceToSquared(p), m), y = Math.pow(p.distanceToSquared(f), m);
      x < 1e-4 && (x = 1), _ < 1e-4 && (_ = x), y < 1e-4 && (y = x), yg.initNonuniformCatmullRom(h.x, d.x, p.x, f.x, _, x, y), xg.initNonuniformCatmullRom(h.y, d.y, p.y, f.y, _, x, y), Ag.initNonuniformCatmullRom(h.z, d.z, p.z, f.z, _, x, y);
    } else this.curveType === "catmullrom" && (yg.initCatmullRom(h.x, d.x, p.x, f.x, this.tension), xg.initCatmullRom(h.y, d.y, p.y, f.y, this.tension), Ag.initCatmullRom(h.z, d.z, p.z, f.z, this.tension));
    return n.set(
      yg.calc(l),
      xg.calc(l),
      Ag.calc(l)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new k().fromArray(i));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function LA(s, e, t, n, i) {
  const r = (n - e) * 0.5, o = (i - t) * 0.5, a = s * s, l = s * a;
  return (2 * t - 2 * n + r + o) * l + (-3 * t + 3 * n - 2 * r - o) * a + r * s + t;
}
function AL(s, e) {
  const t = 1 - s;
  return t * t * e;
}
function ML(s, e) {
  return 2 * (1 - s) * s * e;
}
function SL(s, e) {
  return s * s * e;
}
function yu(s, e, t, n) {
  return AL(s, e) + ML(s, t) + SL(s, n);
}
function EL(s, e) {
  const t = 1 - s;
  return t * t * t * e;
}
function TL(s, e) {
  const t = 1 - s;
  return 3 * t * t * s * e;
}
function wL(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function CL(s, e) {
  return s * s * s * e;
}
function xu(s, e, t, n, i) {
  return EL(s, e) + TL(s, t) + wL(s, n) + CL(s, i);
}
class tv extends Qr {
  constructor(e = new ve(), t = new ve(), n = new ve(), i = new ve()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new ve()) {
    const n = t, i = this.v0, r = this.v1, o = this.v2, a = this.v3;
    return n.set(
      xu(e, i.x, r.x, o.x, a.x),
      xu(e, i.y, r.y, o.y, a.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class HE extends Qr {
  constructor(e = new k(), t = new k(), n = new k(), i = new k()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i;
  }
  getPoint(e, t = new k()) {
    const n = t, i = this.v0, r = this.v1, o = this.v2, a = this.v3;
    return n.set(
      xu(e, i.x, r.x, o.x, a.x),
      xu(e, i.y, r.y, o.y, a.y),
      xu(e, i.z, r.z, o.z, a.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class nv extends Qr {
  constructor(e = new ve(), t = new ve()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new ve()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new ve()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class zE extends Qr {
  constructor(e = new k(), t = new k()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new k()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new k()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class iv extends Qr {
  constructor(e = new ve(), t = new ve(), n = new ve()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new ve()) {
    const n = t, i = this.v0, r = this.v1, o = this.v2;
    return n.set(
      yu(e, i.x, r.x, o.x),
      yu(e, i.y, r.y, o.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class rv extends Qr {
  constructor(e = new k(), t = new k(), n = new k()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  getPoint(e, t = new k()) {
    const n = t, i = this.v0, r = this.v1, o = this.v2;
    return n.set(
      yu(e, i.x, r.x, o.x),
      yu(e, i.y, r.y, o.y),
      yu(e, i.z, r.z, o.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class sv extends Qr {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new ve()) {
    const n = t, i = this.points, r = (i.length - 1) * e, o = Math.floor(r), a = r - o, l = i[o === 0 ? o : o - 1], h = i[o], f = i[o > i.length - 2 ? i.length - 1 : o + 1], d = i[o > i.length - 3 ? i.length - 1 : o + 2];
    return n.set(
      LA(a, l.x, h.x, f.x, d.x),
      LA(a, l.y, h.y, f.y, d.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const i = e.points[t];
      this.points.push(new ve().fromArray(i));
    }
    return this;
  }
}
var Xd = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: kE,
  CatmullRomCurve3: GE,
  CubicBezierCurve: tv,
  CubicBezierCurve3: HE,
  EllipseCurve: yp,
  LineCurve: nv,
  LineCurve3: zE,
  QuadraticBezierCurve: iv,
  QuadraticBezierCurve3: rv,
  SplineCurve: sv
});
class VE extends Qr {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Xd[n](t, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, t) {
    const n = e * this.getLength(), i = this.getCurveLengths();
    let r = 0;
    for (; r < i.length; ) {
      if (i[r] >= n) {
        const o = i[r] - n, a = this.curves[r], l = a.getLength(), h = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(h, t);
      }
      r++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, i = this.curves.length; n < i; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let i = 0, r = this.curves; i < r.length; i++) {
      const o = r[i], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a);
      for (let h = 0; h < l.length; h++) {
        const f = l[h];
        n && n.equals(f) || (t.push(f), n = f);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const i = e.curves[t];
      this.curves.push(new Xd[i.type]().fromJSON(i));
    }
    return this;
  }
}
class Vu extends VE {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new ve(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const n = new nv(this.currentPoint.clone(), new ve(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    const r = new iv(
      this.currentPoint.clone(),
      new ve(e, t),
      new ve(n, i)
    );
    return this.curves.push(r), this.currentPoint.set(n, i), this;
  }
  bezierCurveTo(e, t, n, i, r, o) {
    const a = new tv(
      this.currentPoint.clone(),
      new ve(e, t),
      new ve(n, i),
      new ve(r, o)
    );
    return this.curves.push(a), this.currentPoint.set(r, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new sv(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, n, i, r, o) {
    const a = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      e + a,
      t + l,
      n,
      i,
      r,
      o
    ), this;
  }
  absarc(e, t, n, i, r, o) {
    return this.absellipse(e, t, n, n, i, r, o), this;
  }
  ellipse(e, t, n, i, r, o, a, l) {
    const h = this.currentPoint.x, f = this.currentPoint.y;
    return this.absellipse(e + h, t + f, n, i, r, o, a, l), this;
  }
  absellipse(e, t, n, i, r, o, a, l) {
    const h = new yp(e, t, n, i, r, o, a, l);
    if (this.curves.length > 0) {
      const d = h.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(h);
    const f = h.getPoint(1);
    return this.currentPoint.copy(f), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class dh extends Mt {
  constructor(e = [new ve(0, -0.5), new ve(0.5, 0), new ve(0, 0.5)], t = 12, n = 0, i = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: i
    }, t = Math.floor(t), i = En(i, 0, Math.PI * 2);
    const r = [], o = [], a = [], l = [], h = [], f = 1 / t, d = new k(), p = new ve(), m = new k(), _ = new k(), x = new k();
    let y = 0, v = 0;
    for (let S = 0; S <= e.length - 1; S++)
      switch (S) {
        case 0:
          y = e[S + 1].x - e[S].x, v = e[S + 1].y - e[S].y, m.x = v * 1, m.y = -y, m.z = v * 0, x.copy(m), m.normalize(), l.push(m.x, m.y, m.z);
          break;
        case e.length - 1:
          l.push(x.x, x.y, x.z);
          break;
        default:
          y = e[S + 1].x - e[S].x, v = e[S + 1].y - e[S].y, m.x = v * 1, m.y = -y, m.z = v * 0, _.copy(m), m.x += x.x, m.y += x.y, m.z += x.z, m.normalize(), l.push(m.x, m.y, m.z), x.copy(_);
      }
    for (let S = 0; S <= t; S++) {
      const M = n + S * f * i, T = Math.sin(M), P = Math.cos(M);
      for (let b = 0; b <= e.length - 1; b++) {
        d.x = e[b].x * T, d.y = e[b].y, d.z = e[b].x * P, o.push(d.x, d.y, d.z), p.x = S / t, p.y = b / (e.length - 1), a.push(p.x, p.y);
        const R = l[3 * b + 0] * T, U = l[3 * b + 1], C = l[3 * b + 0] * P;
        h.push(R, U, C);
      }
    }
    for (let S = 0; S < t; S++)
      for (let M = 0; M < e.length - 1; M++) {
        const T = M + S * e.length, P = T, b = T + e.length, R = T + e.length + 1, U = T + 1;
        r.push(P, b, U), r.push(R, U, b);
      }
    this.setIndex(r), this.setAttribute("position", new $e(o, 3)), this.setAttribute("uv", new $e(a, 2)), this.setAttribute("normal", new $e(h, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new dh(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class xp extends dh {
  constructor(e = 1, t = 1, n = 4, i = 8) {
    const r = new Vu();
    r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(r.getPoints(n), i), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      length: t,
      capSegments: n,
      radialSegments: i
    };
  }
  static fromJSON(e) {
    return new xp(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Ap extends Mt {
  constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: i
    }, t = Math.max(3, t);
    const r = [], o = [], a = [], l = [], h = new k(), f = new ve();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= t; d++, p += 3) {
      const m = n + d / t * i;
      h.x = e * Math.cos(m), h.y = e * Math.sin(m), o.push(h.x, h.y, h.z), a.push(0, 0, 1), f.x = (o[p] / e + 1) / 2, f.y = (o[p + 1] / e + 1) / 2, l.push(f.x, f.y);
    }
    for (let d = 1; d <= t; d++)
      r.push(d, d + 1, 0);
    this.setIndex(r), this.setAttribute("position", new $e(o, 3)), this.setAttribute("normal", new $e(a, 3)), this.setAttribute("uv", new $e(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ap(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Mc extends Mt {
  constructor(e = 1, t = 1, n = 1, i = 32, r = 1, o = !1, a = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: i,
      heightSegments: r,
      openEnded: o,
      thetaStart: a,
      thetaLength: l
    };
    const h = this;
    i = Math.floor(i), r = Math.floor(r);
    const f = [], d = [], p = [], m = [];
    let _ = 0;
    const x = [], y = n / 2;
    let v = 0;
    S(), o === !1 && (e > 0 && M(!0), t > 0 && M(!1)), this.setIndex(f), this.setAttribute("position", new $e(d, 3)), this.setAttribute("normal", new $e(p, 3)), this.setAttribute("uv", new $e(m, 2));
    function S() {
      const T = new k(), P = new k();
      let b = 0;
      const R = (t - e) / n;
      for (let U = 0; U <= r; U++) {
        const C = [], B = U / r, G = B * (t - e) + e;
        for (let W = 0; W <= i; W++) {
          const se = W / i, z = se * l + a, q = Math.sin(z), j = Math.cos(z);
          P.x = G * q, P.y = -B * n + y, P.z = G * j, d.push(P.x, P.y, P.z), T.set(q, R, j).normalize(), p.push(T.x, T.y, T.z), m.push(se, 1 - B), C.push(_++);
        }
        x.push(C);
      }
      for (let U = 0; U < i; U++)
        for (let C = 0; C < r; C++) {
          const B = x[C][U], G = x[C + 1][U], W = x[C + 1][U + 1], se = x[C][U + 1];
          f.push(B, G, se), f.push(G, W, se), b += 6;
        }
      h.addGroup(v, b, 0), v += b;
    }
    function M(T) {
      const P = _, b = new ve(), R = new k();
      let U = 0;
      const C = T === !0 ? e : t, B = T === !0 ? 1 : -1;
      for (let W = 1; W <= i; W++)
        d.push(0, y * B, 0), p.push(0, B, 0), m.push(0.5, 0.5), _++;
      const G = _;
      for (let W = 0; W <= i; W++) {
        const z = W / i * l + a, q = Math.cos(z), j = Math.sin(z);
        R.x = C * j, R.y = y * B, R.z = C * q, d.push(R.x, R.y, R.z), p.push(0, B, 0), b.x = q * 0.5 + 0.5, b.y = j * 0.5 * B + 0.5, m.push(b.x, b.y), _++;
      }
      for (let W = 0; W < i; W++) {
        const se = P + W, z = G + W;
        T === !0 ? f.push(z, z + 1, se) : f.push(z + 1, z, se), U += 3;
      }
      h.addGroup(v, U, T === !0 ? 1 : 2), v += U;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Mc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Mp extends Mc {
  constructor(e = 1, t = 1, n = 32, i = 1, r = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, n, i, r, o, a), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: n,
      heightSegments: i,
      openEnded: r,
      thetaStart: o,
      thetaLength: a
    };
  }
  static fromJSON(e) {
    return new Mp(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Oo extends Mt {
  constructor(e = [], t = [], n = 1, i = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: i
    };
    const r = [], o = [];
    a(i), h(n), f(), this.setAttribute("position", new $e(r, 3)), this.setAttribute("normal", new $e(r.slice(), 3)), this.setAttribute("uv", new $e(o, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(S) {
      const M = new k(), T = new k(), P = new k();
      for (let b = 0; b < t.length; b += 3)
        m(t[b + 0], M), m(t[b + 1], T), m(t[b + 2], P), l(M, T, P, S);
    }
    function l(S, M, T, P) {
      const b = P + 1, R = [];
      for (let U = 0; U <= b; U++) {
        R[U] = [];
        const C = S.clone().lerp(T, U / b), B = M.clone().lerp(T, U / b), G = b - U;
        for (let W = 0; W <= G; W++)
          W === 0 && U === b ? R[U][W] = C : R[U][W] = C.clone().lerp(B, W / G);
      }
      for (let U = 0; U < b; U++)
        for (let C = 0; C < 2 * (b - U) - 1; C++) {
          const B = Math.floor(C / 2);
          C % 2 === 0 ? (p(R[U][B + 1]), p(R[U + 1][B]), p(R[U][B])) : (p(R[U][B + 1]), p(R[U + 1][B + 1]), p(R[U + 1][B]));
        }
    }
    function h(S) {
      const M = new k();
      for (let T = 0; T < r.length; T += 3)
        M.x = r[T + 0], M.y = r[T + 1], M.z = r[T + 2], M.normalize().multiplyScalar(S), r[T + 0] = M.x, r[T + 1] = M.y, r[T + 2] = M.z;
    }
    function f() {
      const S = new k();
      for (let M = 0; M < r.length; M += 3) {
        S.x = r[M + 0], S.y = r[M + 1], S.z = r[M + 2];
        const T = y(S) / 2 / Math.PI + 0.5, P = v(S) / Math.PI + 0.5;
        o.push(T, 1 - P);
      }
      _(), d();
    }
    function d() {
      for (let S = 0; S < o.length; S += 6) {
        const M = o[S + 0], T = o[S + 2], P = o[S + 4], b = Math.max(M, T, P), R = Math.min(M, T, P);
        b > 0.9 && R < 0.1 && (M < 0.2 && (o[S + 0] += 1), T < 0.2 && (o[S + 2] += 1), P < 0.2 && (o[S + 4] += 1));
      }
    }
    function p(S) {
      r.push(S.x, S.y, S.z);
    }
    function m(S, M) {
      const T = S * 3;
      M.x = e[T + 0], M.y = e[T + 1], M.z = e[T + 2];
    }
    function _() {
      const S = new k(), M = new k(), T = new k(), P = new k(), b = new ve(), R = new ve(), U = new ve();
      for (let C = 0, B = 0; C < r.length; C += 9, B += 6) {
        S.set(r[C + 0], r[C + 1], r[C + 2]), M.set(r[C + 3], r[C + 4], r[C + 5]), T.set(r[C + 6], r[C + 7], r[C + 8]), b.set(o[B + 0], o[B + 1]), R.set(o[B + 2], o[B + 3]), U.set(o[B + 4], o[B + 5]), P.copy(S).add(M).add(T).divideScalar(3);
        const G = y(P);
        x(b, B + 0, S, G), x(R, B + 2, M, G), x(U, B + 4, T, G);
      }
    }
    function x(S, M, T, P) {
      P < 0 && S.x === 1 && (o[M] = S.x - 1), T.x === 0 && T.z === 0 && (o[M] = P / 2 / Math.PI + 0.5);
    }
    function y(S) {
      return Math.atan2(S.z, -S.x);
    }
    function v(S) {
      return Math.atan2(-S.y, Math.sqrt(S.x * S.x + S.z * S.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Oo(e.vertices, e.indices, e.radius, e.details);
  }
}
class Sp extends Oo {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = 1 / n, r = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      // (±1/φ, ±φ, 0)
      -i,
      -n,
      0,
      -i,
      n,
      0,
      i,
      -n,
      0,
      i,
      n,
      0,
      // (±φ, 0, ±1/φ)
      -n,
      0,
      -i,
      n,
      0,
      -i,
      -n,
      0,
      i,
      n,
      0,
      i
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(r, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Sp(e.radius, e.detail);
  }
}
const Kf = /* @__PURE__ */ new k(), qf = /* @__PURE__ */ new k(), Mg = /* @__PURE__ */ new k(), Qf = /* @__PURE__ */ new Vi();
class WE extends Mt {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const i = Math.pow(10, 4), r = Math.cos(Sa * t), o = e.getIndex(), a = e.getAttribute("position"), l = o ? o.count : a.count, h = [0, 0, 0], f = ["a", "b", "c"], d = new Array(3), p = {}, m = [];
      for (let _ = 0; _ < l; _ += 3) {
        o ? (h[0] = o.getX(_), h[1] = o.getX(_ + 1), h[2] = o.getX(_ + 2)) : (h[0] = _, h[1] = _ + 1, h[2] = _ + 2);
        const { a: x, b: y, c: v } = Qf;
        if (x.fromBufferAttribute(a, h[0]), y.fromBufferAttribute(a, h[1]), v.fromBufferAttribute(a, h[2]), Qf.getNormal(Mg), d[0] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(x.z * i)}`, d[1] = `${Math.round(y.x * i)},${Math.round(y.y * i)},${Math.round(y.z * i)}`, d[2] = `${Math.round(v.x * i)},${Math.round(v.y * i)},${Math.round(v.z * i)}`, !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
          for (let S = 0; S < 3; S++) {
            const M = (S + 1) % 3, T = d[S], P = d[M], b = Qf[f[S]], R = Qf[f[M]], U = `${T}_${P}`, C = `${P}_${T}`;
            C in p && p[C] ? (Mg.dot(p[C].normal) <= r && (m.push(b.x, b.y, b.z), m.push(R.x, R.y, R.z)), p[C] = null) : U in p || (p[U] = {
              index0: h[S],
              index1: h[M],
              normal: Mg.clone()
            });
          }
      }
      for (const _ in p)
        if (p[_]) {
          const { index0: x, index1: y } = p[_];
          Kf.fromBufferAttribute(a, x), qf.fromBufferAttribute(a, y), m.push(Kf.x, Kf.y, Kf.z), m.push(qf.x, qf.y, qf.z);
        }
      this.setAttribute("position", new $e(m, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class wa extends Vu {
  constructor(e) {
    super(e), this.uuid = fr(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, i = this.holes.length; n < i; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const i = e.holes[t];
      this.holes.push(new Vu().fromJSON(i));
    }
    return this;
  }
}
const bL = {
  triangulate: function(s, e, t = 2) {
    const n = e && e.length, i = n ? e[0] * t : s.length;
    let r = XE(s, 0, i, t, !0);
    const o = [];
    if (!r || r.next === r.prev) return o;
    let a, l, h, f, d, p, m;
    if (n && (r = LL(s, e, r, t)), s.length > 80 * t) {
      a = h = s[0], l = f = s[1];
      for (let _ = t; _ < i; _ += t)
        d = s[_], p = s[_ + 1], d < a && (a = d), p < l && (l = p), d > h && (h = d), p > f && (f = p);
      m = Math.max(h - a, f - l), m = m !== 0 ? 32767 / m : 0;
    }
    return Wu(r, o, t, a, l, m, 0), o;
  }
};
function XE(s, e, t, n, i) {
  let r, o;
  if (i === WL(s, e, t, n) > 0)
    for (r = e; r < t; r += n) o = DA(r, s[r], s[r + 1], o);
  else
    for (r = t - n; r >= e; r -= n) o = DA(r, s[r], s[r + 1], o);
  return o && Ep(o, o.next) && (Ju(o), o = o.next), o;
}
function Oa(s, e) {
  if (!s) return s;
  e || (e = s);
  let t = s, n;
  do
    if (n = !1, !t.steiner && (Ep(t, t.next) || _n(t.prev, t, t.next) === 0)) {
      if (Ju(t), t = e = t.prev, t === t.next) break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function Wu(s, e, t, n, i, r, o) {
  if (!s) return;
  !o && r && NL(s, n, i, r);
  let a = s, l, h;
  for (; s.prev !== s.next; ) {
    if (l = s.prev, h = s.next, r ? BL(s, n, i, r) : RL(s)) {
      e.push(l.i / t | 0), e.push(s.i / t | 0), e.push(h.i / t | 0), Ju(s), s = h.next, a = h.next;
      continue;
    }
    if (s = h, s === a) {
      o ? o === 1 ? (s = PL(Oa(s), e, t), Wu(s, e, t, n, i, r, 2)) : o === 2 && IL(s, e, t, n, i, r) : Wu(Oa(s), e, t, n, i, r, 1);
      break;
    }
  }
}
function RL(s) {
  const e = s.prev, t = s, n = s.next;
  if (_n(e, t, n) >= 0) return !1;
  const i = e.x, r = t.x, o = n.x, a = e.y, l = t.y, h = n.y, f = i < r ? i < o ? i : o : r < o ? r : o, d = a < l ? a < h ? a : h : l < h ? l : h, p = i > r ? i > o ? i : o : r > o ? r : o, m = a > l ? a > h ? a : h : l > h ? l : h;
  let _ = n.next;
  for (; _ !== e; ) {
    if (_.x >= f && _.x <= p && _.y >= d && _.y <= m && Hl(i, a, r, l, o, h, _.x, _.y) && _n(_.prev, _, _.next) >= 0) return !1;
    _ = _.next;
  }
  return !0;
}
function BL(s, e, t, n) {
  const i = s.prev, r = s, o = s.next;
  if (_n(i, r, o) >= 0) return !1;
  const a = i.x, l = r.x, h = o.x, f = i.y, d = r.y, p = o.y, m = a < l ? a < h ? a : h : l < h ? l : h, _ = f < d ? f < p ? f : p : d < p ? d : p, x = a > l ? a > h ? a : h : l > h ? l : h, y = f > d ? f > p ? f : p : d > p ? d : p, v = J_(m, _, e, t, n), S = J_(x, y, e, t, n);
  let M = s.prevZ, T = s.nextZ;
  for (; M && M.z >= v && T && T.z <= S; ) {
    if (M.x >= m && M.x <= x && M.y >= _ && M.y <= y && M !== i && M !== o && Hl(a, f, l, d, h, p, M.x, M.y) && _n(M.prev, M, M.next) >= 0 || (M = M.prevZ, T.x >= m && T.x <= x && T.y >= _ && T.y <= y && T !== i && T !== o && Hl(a, f, l, d, h, p, T.x, T.y) && _n(T.prev, T, T.next) >= 0)) return !1;
    T = T.nextZ;
  }
  for (; M && M.z >= v; ) {
    if (M.x >= m && M.x <= x && M.y >= _ && M.y <= y && M !== i && M !== o && Hl(a, f, l, d, h, p, M.x, M.y) && _n(M.prev, M, M.next) >= 0) return !1;
    M = M.prevZ;
  }
  for (; T && T.z <= S; ) {
    if (T.x >= m && T.x <= x && T.y >= _ && T.y <= y && T !== i && T !== o && Hl(a, f, l, d, h, p, T.x, T.y) && _n(T.prev, T, T.next) >= 0) return !1;
    T = T.nextZ;
  }
  return !0;
}
function PL(s, e, t) {
  let n = s;
  do {
    const i = n.prev, r = n.next.next;
    !Ep(i, r) && JE(i, n, n.next, r) && Xu(i, r) && Xu(r, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(r.i / t | 0), Ju(n), Ju(n.next), n = s = r), n = n.next;
  } while (n !== s);
  return Oa(n);
}
function IL(s, e, t, n, i, r) {
  let o = s;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && HL(o, a)) {
        let l = YE(o, a);
        o = Oa(o, o.next), l = Oa(l, l.next), Wu(o, e, t, n, i, r, 0), Wu(l, e, t, n, i, r, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== s);
}
function LL(s, e, t, n) {
  const i = [];
  let r, o, a, l, h;
  for (r = 0, o = e.length; r < o; r++)
    a = e[r] * n, l = r < o - 1 ? e[r + 1] * n : s.length, h = XE(s, a, l, n, !1), h === h.next && (h.steiner = !0), i.push(GL(h));
  for (i.sort(DL), r = 0; r < i.length; r++)
    t = FL(i[r], t);
  return t;
}
function DL(s, e) {
  return s.x - e.x;
}
function FL(s, e) {
  const t = UL(s, e);
  if (!t)
    return e;
  const n = YE(t, s);
  return Oa(n, n.next), Oa(t, t.next);
}
function UL(s, e) {
  let t = e, n = -1 / 0, i;
  const r = s.x, o = s.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (p <= r && p > n && (n = p, i = t.x < t.next.x ? t : t.next, p === r))
        return i;
    }
    t = t.next;
  } while (t !== e);
  if (!i) return null;
  const a = i, l = i.x, h = i.y;
  let f = 1 / 0, d;
  t = i;
  do
    r >= t.x && t.x >= l && r !== t.x && Hl(o < h ? r : n, o, l, h, o < h ? n : r, o, t.x, t.y) && (d = Math.abs(o - t.y) / (r - t.x), Xu(t, s) && (d < f || d === f && (t.x > i.x || t.x === i.x && OL(i, t))) && (i = t, f = d)), t = t.next;
  while (t !== a);
  return i;
}
function OL(s, e) {
  return _n(s.prev, s, e.prev) < 0 && _n(e.next, s, s.next) < 0;
}
function NL(s, e, t, n) {
  let i = s;
  do
    i.z === 0 && (i.z = J_(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;
  while (i !== s);
  i.prevZ.nextZ = null, i.prevZ = null, kL(i);
}
function kL(s) {
  let e, t, n, i, r, o, a, l, h = 1;
  do {
    for (t = s, s = null, r = null, o = 0; t; ) {
      for (o++, n = t, a = 0, e = 0; e < h && (a++, n = n.nextZ, !!n); e++)
        ;
      for (l = h; a > 0 || l > 0 && n; )
        a !== 0 && (l === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, a--) : (i = n, n = n.nextZ, l--), r ? r.nextZ = i : s = i, i.prevZ = r, r = i;
      t = n;
    }
    r.nextZ = null, h *= 2;
  } while (o > 1);
  return s;
}
function J_(s, e, t, n, i) {
  return s = (s - t) * i | 0, e = (e - n) * i | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function GL(s) {
  let e = s, t = s;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== s);
  return t;
}
function Hl(s, e, t, n, i, r, o, a) {
  return (i - o) * (e - a) >= (s - o) * (r - a) && (s - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (i - o) * (n - a);
}
function HL(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !zL(s, e) && // dones't intersect other edges
  (Xu(s, e) && Xu(e, s) && VL(s, e) && // locally visible
  (_n(s.prev, s, e.prev) || _n(s, e.prev, e)) || // does not create opposite-facing sectors
  Ep(s, e) && _n(s.prev, s, s.next) > 0 && _n(e.prev, e, e.next) > 0);
}
function _n(s, e, t) {
  return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y);
}
function Ep(s, e) {
  return s.x === e.x && s.y === e.y;
}
function JE(s, e, t, n) {
  const i = jf(_n(s, e, t)), r = jf(_n(s, e, n)), o = jf(_n(t, n, s)), a = jf(_n(t, n, e));
  return !!(i !== r && o !== a || i === 0 && Zf(s, t, e) || r === 0 && Zf(s, n, e) || o === 0 && Zf(t, s, n) || a === 0 && Zf(t, e, n));
}
function Zf(s, e, t) {
  return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y);
}
function jf(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function zL(s, e) {
  let t = s;
  do {
    if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && JE(t, t.next, s, e)) return !0;
    t = t.next;
  } while (t !== s);
  return !1;
}
function Xu(s, e) {
  return _n(s.prev, s, s.next) < 0 ? _n(s, e, s.next) >= 0 && _n(s, s.prev, e) >= 0 : _n(s, e, s.prev) < 0 || _n(s, s.next, e) < 0;
}
function VL(s, e) {
  let t = s, n = !1;
  const i = (s.x + e.x) / 2, r = (s.y + e.y) / 2;
  do
    t.y > r != t.next.y > r && t.next.y !== t.y && i < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== s);
  return n;
}
function YE(s, e) {
  const t = new Y_(s.i, s.x, s.y), n = new Y_(e.i, e.x, e.y), i = s.next, r = e.prev;
  return s.next = e, e.prev = s, t.next = i, i.prev = t, n.next = t, t.prev = n, r.next = n, n.prev = r, n;
}
function DA(s, e, t, n) {
  const i = new Y_(s, e, t);
  return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;
}
function Ju(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function Y_(s, e, t) {
  this.i = s, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function WL(s, e, t, n) {
  let i = 0;
  for (let r = e, o = t - n; r < t; r += n)
    i += (s[o] - s[r]) * (s[r + 1] + s[o + 1]), o = r;
  return i;
}
class ps {
  // calculate area of the contour polygon
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let i = t - 1, r = 0; r < t; i = r++)
      n += e[i].x * e[r].y - e[r].x * e[i].y;
    return n * 0.5;
  }
  static isClockWise(e) {
    return ps.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const n = [], i = [], r = [];
    FA(e), UA(n, e);
    let o = e.length;
    t.forEach(FA);
    for (let l = 0; l < t.length; l++)
      i.push(o), o += t[l].length, UA(n, t[l]);
    const a = bL.triangulate(n, i);
    for (let l = 0; l < a.length; l += 3)
      r.push(a.slice(l, l + 3));
    return r;
  }
}
function FA(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function UA(s, e) {
  for (let t = 0; t < e.length; t++)
    s.push(e[t].x), s.push(e[t].y);
}
class Tp extends Mt {
  constructor(e = new wa([new ve(0.5, 0.5), new ve(-0.5, 0.5), new ve(-0.5, -0.5), new ve(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const n = this, i = [], r = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const h = e[a];
      o(h);
    }
    this.setAttribute("position", new $e(i, 3)), this.setAttribute("uv", new $e(r, 2)), this.computeVertexNormals();
    function o(a) {
      const l = [], h = t.curveSegments !== void 0 ? t.curveSegments : 12, f = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 1;
      let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, m = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, _ = t.bevelSize !== void 0 ? t.bevelSize : m - 0.1, x = t.bevelOffset !== void 0 ? t.bevelOffset : 0, y = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const v = t.extrudePath, S = t.UVGenerator !== void 0 ? t.UVGenerator : XL;
      let M, T = !1, P, b, R, U;
      v && (M = v.getSpacedPoints(f), T = !0, p = !1, P = v.computeFrenetFrames(f, !1), b = new k(), R = new k(), U = new k()), p || (y = 0, m = 0, _ = 0, x = 0);
      const C = a.extractPoints(h);
      let B = C.shape;
      const G = C.holes;
      if (!ps.isClockWise(B)) {
        B = B.reverse();
        for (let X = 0, pe = G.length; X < pe; X++) {
          const ce = G[X];
          ps.isClockWise(ce) && (G[X] = ce.reverse());
        }
      }
      const se = ps.triangulateShape(B, G), z = B;
      for (let X = 0, pe = G.length; X < pe; X++) {
        const ce = G[X];
        B = B.concat(ce);
      }
      function q(X, pe, ce) {
        return pe || console.error("THREE.ExtrudeGeometry: vec does not exist"), X.clone().addScaledVector(pe, ce);
      }
      const j = B.length, ee = se.length;
      function N(X, pe, ce) {
        let Me, fe, Q;
        const Ie = X.x - pe.x, O = X.y - pe.y, L = ce.x - X.x, $ = ce.y - X.y, xe = Ie * Ie + O * O, Ae = Ie * $ - O * L;
        if (Math.abs(Ae) > Number.EPSILON) {
          const _e = Math.sqrt(xe), Ue = Math.sqrt(L * L + $ * $), Le = pe.x - O / _e, Te = pe.y + Ie / _e, Ze = ce.x - $ / Ue, ct = ce.y + L / Ue, ye = ((Ze - Le) * $ - (ct - Te) * L) / (Ie * $ - O * L);
          Me = Le + Ie * ye - X.x, fe = Te + O * ye - X.y;
          const bt = Me * Me + fe * fe;
          if (bt <= 2)
            return new ve(Me, fe);
          Q = Math.sqrt(bt / 2);
        } else {
          let _e = !1;
          Ie > Number.EPSILON ? L > Number.EPSILON && (_e = !0) : Ie < -Number.EPSILON ? L < -Number.EPSILON && (_e = !0) : Math.sign(O) === Math.sign($) && (_e = !0), _e ? (Me = -O, fe = Ie, Q = Math.sqrt(xe)) : (Me = Ie, fe = O, Q = Math.sqrt(xe / 2));
        }
        return new ve(Me / Q, fe / Q);
      }
      const V = [];
      for (let X = 0, pe = z.length, ce = pe - 1, Me = X + 1; X < pe; X++, ce++, Me++)
        ce === pe && (ce = 0), Me === pe && (Me = 0), V[X] = N(z[X], z[ce], z[Me]);
      const I = [];
      let D, J = V.concat();
      for (let X = 0, pe = G.length; X < pe; X++) {
        const ce = G[X];
        D = [];
        for (let Me = 0, fe = ce.length, Q = fe - 1, Ie = Me + 1; Me < fe; Me++, Q++, Ie++)
          Q === fe && (Q = 0), Ie === fe && (Ie = 0), D[Me] = N(ce[Me], ce[Q], ce[Ie]);
        I.push(D), J = J.concat(D);
      }
      for (let X = 0; X < y; X++) {
        const pe = X / y, ce = m * Math.cos(pe * Math.PI / 2), Me = _ * Math.sin(pe * Math.PI / 2) + x;
        for (let fe = 0, Q = z.length; fe < Q; fe++) {
          const Ie = q(z[fe], V[fe], Me);
          me(Ie.x, Ie.y, -ce);
        }
        for (let fe = 0, Q = G.length; fe < Q; fe++) {
          const Ie = G[fe];
          D = I[fe];
          for (let O = 0, L = Ie.length; O < L; O++) {
            const $ = q(Ie[O], D[O], Me);
            me($.x, $.y, -ce);
          }
        }
      }
      const K = _ + x;
      for (let X = 0; X < j; X++) {
        const pe = p ? q(B[X], J[X], K) : B[X];
        T ? (R.copy(P.normals[0]).multiplyScalar(pe.x), b.copy(P.binormals[0]).multiplyScalar(pe.y), U.copy(M[0]).add(R).add(b), me(U.x, U.y, U.z)) : me(pe.x, pe.y, 0);
      }
      for (let X = 1; X <= f; X++)
        for (let pe = 0; pe < j; pe++) {
          const ce = p ? q(B[pe], J[pe], K) : B[pe];
          T ? (R.copy(P.normals[X]).multiplyScalar(ce.x), b.copy(P.binormals[X]).multiplyScalar(ce.y), U.copy(M[X]).add(R).add(b), me(U.x, U.y, U.z)) : me(ce.x, ce.y, d / f * X);
        }
      for (let X = y - 1; X >= 0; X--) {
        const pe = X / y, ce = m * Math.cos(pe * Math.PI / 2), Me = _ * Math.sin(pe * Math.PI / 2) + x;
        for (let fe = 0, Q = z.length; fe < Q; fe++) {
          const Ie = q(z[fe], V[fe], Me);
          me(Ie.x, Ie.y, d + ce);
        }
        for (let fe = 0, Q = G.length; fe < Q; fe++) {
          const Ie = G[fe];
          D = I[fe];
          for (let O = 0, L = Ie.length; O < L; O++) {
            const $ = q(Ie[O], D[O], Me);
            T ? me($.x, $.y + M[f - 1].y, M[f - 1].x + ce) : me($.x, $.y, d + ce);
          }
        }
      }
      ie(), he();
      function ie() {
        const X = i.length / 3;
        if (p) {
          let pe = 0, ce = j * pe;
          for (let Me = 0; Me < ee; Me++) {
            const fe = se[Me];
            Be(fe[2] + ce, fe[1] + ce, fe[0] + ce);
          }
          pe = f + y * 2, ce = j * pe;
          for (let Me = 0; Me < ee; Me++) {
            const fe = se[Me];
            Be(fe[0] + ce, fe[1] + ce, fe[2] + ce);
          }
        } else {
          for (let pe = 0; pe < ee; pe++) {
            const ce = se[pe];
            Be(ce[2], ce[1], ce[0]);
          }
          for (let pe = 0; pe < ee; pe++) {
            const ce = se[pe];
            Be(ce[0] + j * f, ce[1] + j * f, ce[2] + j * f);
          }
        }
        n.addGroup(X, i.length / 3 - X, 0);
      }
      function he() {
        const X = i.length / 3;
        let pe = 0;
        ge(z, pe), pe += z.length;
        for (let ce = 0, Me = G.length; ce < Me; ce++) {
          const fe = G[ce];
          ge(fe, pe), pe += fe.length;
        }
        n.addGroup(X, i.length / 3 - X, 1);
      }
      function ge(X, pe) {
        let ce = X.length;
        for (; --ce >= 0; ) {
          const Me = ce;
          let fe = ce - 1;
          fe < 0 && (fe = X.length - 1);
          for (let Q = 0, Ie = f + y * 2; Q < Ie; Q++) {
            const O = j * Q, L = j * (Q + 1), $ = pe + Me + O, xe = pe + fe + O, Ae = pe + fe + L, _e = pe + Me + L;
            Pe($, xe, Ae, _e);
          }
        }
      }
      function me(X, pe, ce) {
        l.push(X), l.push(pe), l.push(ce);
      }
      function Be(X, pe, ce) {
        De(X), De(pe), De(ce);
        const Me = i.length / 3, fe = S.generateTopUV(n, i, Me - 3, Me - 2, Me - 1);
        ze(fe[0]), ze(fe[1]), ze(fe[2]);
      }
      function Pe(X, pe, ce, Me) {
        De(X), De(pe), De(Me), De(pe), De(ce), De(Me);
        const fe = i.length / 3, Q = S.generateSideWallUV(n, i, fe - 6, fe - 3, fe - 2, fe - 1);
        ze(Q[0]), ze(Q[1]), ze(Q[3]), ze(Q[1]), ze(Q[2]), ze(Q[3]);
      }
      function De(X) {
        i.push(l[X * 3 + 0]), i.push(l[X * 3 + 1]), i.push(l[X * 3 + 2]);
      }
      function ze(X) {
        r.push(X.x), r.push(X.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
    return JL(t, n, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, o = e.shapes.length; r < o; r++) {
      const a = t[e.shapes[r]];
      n.push(a);
    }
    const i = e.options.extrudePath;
    return i !== void 0 && (e.options.extrudePath = new Xd[i.type]().fromJSON(i)), new Tp(n, e.options);
  }
}
const XL = {
  generateTopUV: function(s, e, t, n, i) {
    const r = e[t * 3], o = e[t * 3 + 1], a = e[n * 3], l = e[n * 3 + 1], h = e[i * 3], f = e[i * 3 + 1];
    return [
      new ve(r, o),
      new ve(a, l),
      new ve(h, f)
    ];
  },
  generateSideWallUV: function(s, e, t, n, i, r) {
    const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], h = e[n * 3], f = e[n * 3 + 1], d = e[n * 3 + 2], p = e[i * 3], m = e[i * 3 + 1], _ = e[i * 3 + 2], x = e[r * 3], y = e[r * 3 + 1], v = e[r * 3 + 2];
    return Math.abs(a - f) < Math.abs(o - h) ? [
      new ve(o, 1 - l),
      new ve(h, 1 - d),
      new ve(p, 1 - _),
      new ve(x, 1 - v)
    ] : [
      new ve(a, 1 - l),
      new ve(f, 1 - d),
      new ve(m, 1 - _),
      new ve(y, 1 - v)
    ];
  }
};
function JL(s, e, t) {
  if (t.shapes = [], Array.isArray(s))
    for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      t.shapes.push(r.uuid);
    }
  else
    t.shapes.push(s.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class wp extends Oo {
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, i = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], r = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(i, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new wp(e.radius, e.detail);
  }
}
class ph extends Oo {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], i = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new ph(e.radius, e.detail);
  }
}
class Cp extends Mt {
  constructor(e = 0.5, t = 1, n = 32, i = 1, r = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: i,
      thetaStart: r,
      thetaLength: o
    }, n = Math.max(3, n), i = Math.max(1, i);
    const a = [], l = [], h = [], f = [];
    let d = e;
    const p = (t - e) / i, m = new k(), _ = new ve();
    for (let x = 0; x <= i; x++) {
      for (let y = 0; y <= n; y++) {
        const v = r + y / n * o;
        m.x = d * Math.cos(v), m.y = d * Math.sin(v), l.push(m.x, m.y, m.z), h.push(0, 0, 1), _.x = (m.x / t + 1) / 2, _.y = (m.y / t + 1) / 2, f.push(_.x, _.y);
      }
      d += p;
    }
    for (let x = 0; x < i; x++) {
      const y = x * (n + 1);
      for (let v = 0; v < n; v++) {
        const S = v + y, M = S, T = S + n + 1, P = S + n + 2, b = S + 1;
        a.push(M, T, b), a.push(T, P, b);
      }
    }
    this.setIndex(a), this.setAttribute("position", new $e(l, 3)), this.setAttribute("normal", new $e(h, 3)), this.setAttribute("uv", new $e(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Cp(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class bp extends Mt {
  constructor(e = new wa([new ve(0, 0.5), new ve(-0.5, -0.5), new ve(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const n = [], i = [], r = [], o = [];
    let a = 0, l = 0;
    if (Array.isArray(e) === !1)
      h(e);
    else
      for (let f = 0; f < e.length; f++)
        h(e[f]), this.addGroup(a, l, f), a += l, l = 0;
    this.setIndex(n), this.setAttribute("position", new $e(i, 3)), this.setAttribute("normal", new $e(r, 3)), this.setAttribute("uv", new $e(o, 2));
    function h(f) {
      const d = i.length / 3, p = f.extractPoints(t);
      let m = p.shape;
      const _ = p.holes;
      ps.isClockWise(m) === !1 && (m = m.reverse());
      for (let y = 0, v = _.length; y < v; y++) {
        const S = _[y];
        ps.isClockWise(S) === !0 && (_[y] = S.reverse());
      }
      const x = ps.triangulateShape(m, _);
      for (let y = 0, v = _.length; y < v; y++) {
        const S = _[y];
        m = m.concat(S);
      }
      for (let y = 0, v = m.length; y < v; y++) {
        const S = m[y];
        i.push(S.x, S.y, 0), r.push(0, 0, 1), o.push(S.x, S.y);
      }
      for (let y = 0, v = x.length; y < v; y++) {
        const S = x[y], M = S[0] + d, T = S[1] + d, P = S[2] + d;
        n.push(M, T, P), l += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return YL(t, e);
  }
  static fromJSON(e, t) {
    const n = [];
    for (let i = 0, r = e.shapes.length; i < r; i++) {
      const o = t[e.shapes[i]];
      n.push(o);
    }
    return new bp(n, e.curveSegments);
  }
}
function YL(s, e) {
  if (e.shapes = [], Array.isArray(s))
    for (let t = 0, n = s.length; t < n; t++) {
      const i = s[t];
      e.shapes.push(i.uuid);
    }
  else
    e.shapes.push(s.uuid);
  return e;
}
class mh extends Mt {
  constructor(e = 1, t = 32, n = 16, i = 0, r = Math.PI * 2, o = 0, a = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: i,
      phiLength: r,
      thetaStart: o,
      thetaLength: a
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const l = Math.min(o + a, Math.PI);
    let h = 0;
    const f = [], d = new k(), p = new k(), m = [], _ = [], x = [], y = [];
    for (let v = 0; v <= n; v++) {
      const S = [], M = v / n;
      let T = 0;
      v === 0 && o === 0 ? T = 0.5 / t : v === n && l === Math.PI && (T = -0.5 / t);
      for (let P = 0; P <= t; P++) {
        const b = P / t;
        d.x = -e * Math.cos(i + b * r) * Math.sin(o + M * a), d.y = e * Math.cos(o + M * a), d.z = e * Math.sin(i + b * r) * Math.sin(o + M * a), _.push(d.x, d.y, d.z), p.copy(d).normalize(), x.push(p.x, p.y, p.z), y.push(b + T, 1 - M), S.push(h++);
      }
      f.push(S);
    }
    for (let v = 0; v < n; v++)
      for (let S = 0; S < t; S++) {
        const M = f[v][S + 1], T = f[v][S], P = f[v + 1][S], b = f[v + 1][S + 1];
        (v !== 0 || o > 0) && m.push(M, T, b), (v !== n - 1 || l < Math.PI) && m.push(T, P, b);
      }
    this.setIndex(m), this.setAttribute("position", new $e(_, 3)), this.setAttribute("normal", new $e(x, 3)), this.setAttribute("uv", new $e(y, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new mh(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Rp extends Oo {
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], i = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  static fromJSON(e) {
    return new Rp(e.radius, e.detail);
  }
}
class Bp extends Mt {
  constructor(e = 1, t = 0.4, n = 12, i = 48, r = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: i,
      arc: r
    }, n = Math.floor(n), i = Math.floor(i);
    const o = [], a = [], l = [], h = [], f = new k(), d = new k(), p = new k();
    for (let m = 0; m <= n; m++)
      for (let _ = 0; _ <= i; _++) {
        const x = _ / i * r, y = m / n * Math.PI * 2;
        d.x = (e + t * Math.cos(y)) * Math.cos(x), d.y = (e + t * Math.cos(y)) * Math.sin(x), d.z = t * Math.sin(y), a.push(d.x, d.y, d.z), f.x = e * Math.cos(x), f.y = e * Math.sin(x), p.subVectors(d, f).normalize(), l.push(p.x, p.y, p.z), h.push(_ / i), h.push(m / n);
      }
    for (let m = 1; m <= n; m++)
      for (let _ = 1; _ <= i; _++) {
        const x = (i + 1) * m + _ - 1, y = (i + 1) * (m - 1) + _ - 1, v = (i + 1) * (m - 1) + _, S = (i + 1) * m + _;
        o.push(x, y, S), o.push(y, v, S);
      }
    this.setIndex(o), this.setAttribute("position", new $e(a, 3)), this.setAttribute("normal", new $e(l, 3)), this.setAttribute("uv", new $e(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Bp(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Pp extends Mt {
  constructor(e = 1, t = 0.4, n = 64, i = 8, r = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: i,
      p: r,
      q: o
    }, n = Math.floor(n), i = Math.floor(i);
    const a = [], l = [], h = [], f = [], d = new k(), p = new k(), m = new k(), _ = new k(), x = new k(), y = new k(), v = new k();
    for (let M = 0; M <= n; ++M) {
      const T = M / n * r * Math.PI * 2;
      S(T, r, o, e, m), S(T + 0.01, r, o, e, _), y.subVectors(_, m), v.addVectors(_, m), x.crossVectors(y, v), v.crossVectors(x, y), x.normalize(), v.normalize();
      for (let P = 0; P <= i; ++P) {
        const b = P / i * Math.PI * 2, R = -t * Math.cos(b), U = t * Math.sin(b);
        d.x = m.x + (R * v.x + U * x.x), d.y = m.y + (R * v.y + U * x.y), d.z = m.z + (R * v.z + U * x.z), l.push(d.x, d.y, d.z), p.subVectors(d, m).normalize(), h.push(p.x, p.y, p.z), f.push(M / n), f.push(P / i);
      }
    }
    for (let M = 1; M <= n; M++)
      for (let T = 1; T <= i; T++) {
        const P = (i + 1) * (M - 1) + (T - 1), b = (i + 1) * M + (T - 1), R = (i + 1) * M + T, U = (i + 1) * (M - 1) + T;
        a.push(P, b, U), a.push(b, R, U);
      }
    this.setIndex(a), this.setAttribute("position", new $e(l, 3)), this.setAttribute("normal", new $e(h, 3)), this.setAttribute("uv", new $e(f, 2));
    function S(M, T, P, b, R) {
      const U = Math.cos(M), C = Math.sin(M), B = P / T * M, G = Math.cos(B);
      R.x = b * (2 + G) * 0.5 * U, R.y = b * (2 + G) * C * 0.5, R.z = b * Math.sin(B) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Pp(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class Ip extends Mt {
  constructor(e = new rv(new k(-1, -1, 0), new k(-1, 1, 0), new k(1, 1, 0)), t = 64, n = 1, i = 8, r = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: n,
      radialSegments: i,
      closed: r
    };
    const o = e.computeFrenetFrames(t, r);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const a = new k(), l = new k(), h = new ve();
    let f = new k();
    const d = [], p = [], m = [], _ = [];
    x(), this.setIndex(_), this.setAttribute("position", new $e(d, 3)), this.setAttribute("normal", new $e(p, 3)), this.setAttribute("uv", new $e(m, 2));
    function x() {
      for (let M = 0; M < t; M++)
        y(M);
      y(r === !1 ? t : 0), S(), v();
    }
    function y(M) {
      f = e.getPointAt(M / t, f);
      const T = o.normals[M], P = o.binormals[M];
      for (let b = 0; b <= i; b++) {
        const R = b / i * Math.PI * 2, U = Math.sin(R), C = -Math.cos(R);
        l.x = C * T.x + U * P.x, l.y = C * T.y + U * P.y, l.z = C * T.z + U * P.z, l.normalize(), p.push(l.x, l.y, l.z), a.x = f.x + n * l.x, a.y = f.y + n * l.y, a.z = f.z + n * l.z, d.push(a.x, a.y, a.z);
      }
    }
    function v() {
      for (let M = 1; M <= t; M++)
        for (let T = 1; T <= i; T++) {
          const P = (i + 1) * (M - 1) + (T - 1), b = (i + 1) * M + (T - 1), R = (i + 1) * M + T, U = (i + 1) * (M - 1) + T;
          _.push(P, b, U), _.push(b, R, U);
        }
    }
    function S() {
      for (let M = 0; M <= t; M++)
        for (let T = 0; T <= i; T++)
          h.x = M / t, h.y = T / i, m.push(h.x, h.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new Ip(
      new Xd[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class KE extends Mt {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), i = new k(), r = new k();
      if (e.index !== null) {
        const o = e.attributes.position, a = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let h = 0, f = l.length; h < f; ++h) {
          const d = l[h], p = d.start, m = d.count;
          for (let _ = p, x = p + m; _ < x; _ += 3)
            for (let y = 0; y < 3; y++) {
              const v = a.getX(_ + y), S = a.getX(_ + (y + 1) % 3);
              i.fromBufferAttribute(o, v), r.fromBufferAttribute(o, S), OA(i, r, n) === !0 && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let h = 0; h < 3; h++) {
            const f = 3 * a + h, d = 3 * a + (h + 1) % 3;
            i.fromBufferAttribute(o, f), r.fromBufferAttribute(o, d), OA(i, r, n) === !0 && (t.push(i.x, i.y, i.z), t.push(r.x, r.y, r.z));
          }
      }
      this.setAttribute("position", new $e(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function OA(s, e, t) {
  const n = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`, i = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`;
  return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0);
}
var NA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: Wa,
  CapsuleGeometry: xp,
  CircleGeometry: Ap,
  ConeGeometry: Mp,
  CylinderGeometry: Mc,
  DodecahedronGeometry: Sp,
  EdgesGeometry: WE,
  ExtrudeGeometry: Tp,
  IcosahedronGeometry: wp,
  LatheGeometry: dh,
  OctahedronGeometry: ph,
  PlaneGeometry: uh,
  PolyhedronGeometry: Oo,
  RingGeometry: Cp,
  ShapeGeometry: bp,
  SphereGeometry: mh,
  TetrahedronGeometry: Rp,
  TorusGeometry: Bp,
  TorusKnotGeometry: Pp,
  TubeGeometry: Ip,
  WireframeGeometry: KE
});
class qE extends Xn {
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new Ne(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class QE extends ys {
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class gh extends Xn {
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Ne(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Uo, this.normalScale = new ve(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Ur extends gh {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ve(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return En(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Ne(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ne(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ne(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class ZE extends Xn {
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new Ne(16777215), this.specular = new Ne(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Uo, this.normalScale = new ve(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = sh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class jE extends Xn {
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Ne(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Uo, this.normalScale = new ve(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class $E extends Xn {
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Uo, this.normalScale = new ve(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class e1 extends Xn {
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new Ne(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ne(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Uo, this.normalScale = new ve(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = sh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class t1 extends Xn {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Ne(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Uo, this.normalScale = new ve(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class n1 extends Mi {
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function _a(s, e, t) {
  return !s || // let 'undefined' and 'null' pass
  !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s);
}
function i1(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView);
}
function r1(s) {
  function e(i, r) {
    return s[i] - s[r];
  }
  const t = s.length, n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function K_(s, e, t) {
  const n = s.length, i = new s.constructor(n);
  for (let r = 0, o = 0; o !== n; ++r) {
    const a = t[r] * e;
    for (let l = 0; l !== e; ++l)
      i[o++] = s[a + l];
  }
  return i;
}
function ov(s, e, t, n) {
  let i = 1, r = s[0];
  for (; r !== void 0 && r[n] === void 0; )
    r = s[i++];
  if (r === void 0) return;
  let o = r[n];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        o = r[n], o !== void 0 && (e.push(r.time), t.push.apply(t, o)), r = s[i++];
      while (r !== void 0);
    else if (o.toArray !== void 0)
      do
        o = r[n], o !== void 0 && (e.push(r.time), o.toArray(t, t.length)), r = s[i++];
      while (r !== void 0);
    else
      do
        o = r[n], o !== void 0 && (e.push(r.time), t.push(o)), r = s[i++];
      while (r !== void 0);
}
function KL(s, e, t, n, i = 30) {
  const r = s.clone();
  r.name = e;
  const o = [];
  for (let l = 0; l < r.tracks.length; ++l) {
    const h = r.tracks[l], f = h.getValueSize(), d = [], p = [];
    for (let m = 0; m < h.times.length; ++m) {
      const _ = h.times[m] * i;
      if (!(_ < t || _ >= n)) {
        d.push(h.times[m]);
        for (let x = 0; x < f; ++x)
          p.push(h.values[m * f + x]);
      }
    }
    d.length !== 0 && (h.times = _a(d, h.times.constructor), h.values = _a(p, h.values.constructor), o.push(h));
  }
  r.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < r.tracks.length; ++l)
    a > r.tracks[l].times[0] && (a = r.tracks[l].times[0]);
  for (let l = 0; l < r.tracks.length; ++l)
    r.tracks[l].shift(-1 * a);
  return r.resetDuration(), r;
}
function qL(s, e = 0, t = s, n = 30) {
  n <= 0 && (n = 30);
  const i = t.tracks.length, r = e / n;
  for (let o = 0; o < i; ++o) {
    const a = t.tracks[o], l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const h = s.tracks.find(function(v) {
      return v.name === a.name && v.ValueTypeName === l;
    });
    if (h === void 0) continue;
    let f = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (f = d / 3);
    let p = 0;
    const m = h.getValueSize();
    h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = m / 3);
    const _ = a.times.length - 1;
    let x;
    if (r <= a.times[0]) {
      const v = f, S = d - f;
      x = a.values.slice(v, S);
    } else if (r >= a.times[_]) {
      const v = _ * d + f, S = v + d - f;
      x = a.values.slice(v, S);
    } else {
      const v = a.createInterpolant(), S = f, M = d - f;
      v.evaluate(r), x = v.resultBuffer.slice(S, M);
    }
    l === "quaternion" && new yi().fromArray(x).normalize().conjugate().toArray(x);
    const y = h.times.length;
    for (let v = 0; v < y; ++v) {
      const S = v * m + p;
      if (l === "quaternion")
        yi.multiplyQuaternionsFlat(
          h.values,
          S,
          x,
          0,
          h.values,
          S
        );
      else {
        const M = m - p * 2;
        for (let T = 0; T < M; ++T)
          h.values[S + T] -= x[T];
      }
    }
  }
  return s.blendMode = D0, s;
}
const QL = {
  convertArray: _a,
  isTypedArray: i1,
  getKeyframeOrder: r1,
  sortedArray: K_,
  flattenJSON: ov,
  subclip: KL,
  makeClipAdditive: qL
};
class Sc {
  constructor(e, t, n, i) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, i = t[n], r = t[n - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < i)) {
            for (let a = n + 2; ; ) {
              if (i === void 0) {
                if (e < r) break i;
                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
              }
              if (n === a) break;
              if (r = i, i = t[++n], e < i)
                break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= r)) {
            const a = t[1];
            e < a && (n = 2, r = a);
            for (let l = n - 2; ; ) {
              if (r === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === l) break;
              if (i = r, r = t[--n - 1], e >= r)
                break t;
            }
            o = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < o; ) {
          const a = n + o >>> 1;
          e < t[a] ? o = a : n = a + 1;
        }
        if (i = t[n], r = t[n - 1], r === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (i === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, r, i);
    }
    return this.interpolate_(n, r, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i;
    for (let o = 0; o !== i; ++o)
      t[o] = n[r + o];
    return t;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class s1 extends Sc {
  constructor(e, t, n, i) {
    super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: pa,
      endingEnd: pa
    };
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let r = e - 2, o = e + 1, a = i[r], l = i[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case ma:
          r = e, a = 2 * t - n;
          break;
        case Ou:
          r = i.length - 2, a = t + i[r] - i[r + 1];
          break;
        default:
          r = e, a = n;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case ma:
          o = e, l = 2 * n - t;
          break;
        case Ou:
          o = 1, l = n + i[1] - i[0];
          break;
        default:
          o = e - 1, l = t;
      }
    const h = (n - t) * 0.5, f = this.valueSize;
    this._weightPrev = h / (t - a), this._weightNext = h / (l - n), this._offsetPrev = r * f, this._offsetNext = o * f;
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, h = l - a, f = this._offsetPrev, d = this._offsetNext, p = this._weightPrev, m = this._weightNext, _ = (n - t) / (i - t), x = _ * _, y = x * _, v = -p * y + 2 * p * x - p * _, S = (1 + p) * y + (-1.5 - 2 * p) * x + (-0.5 + p) * _ + 1, M = (-1 - m) * y + (1.5 + m) * x + 0.5 * _, T = m * y - m * x;
    for (let P = 0; P !== a; ++P)
      r[P] = v * o[f + P] + S * o[h + P] + M * o[l + P] + T * o[d + P];
    return r;
  }
}
class av extends Sc {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, h = l - a, f = (n - t) / (i - t), d = 1 - f;
    for (let p = 0; p !== a; ++p)
      r[p] = o[h + p] * d + o[l + p] * f;
    return r;
  }
}
class o1 extends Sc {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Zr {
  constructor(e, t, n, i) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = _a(t, this.TimeBufferType), this.values = _a(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: _a(e.times, Array),
        values: _a(e.values, Array)
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return n.type = e.ValueTypeName, n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new o1(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new av(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new s1(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case rc:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Fa:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case bd:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return rc;
      case this.InterpolantFactoryMethodLinear:
        return Fa;
      case this.InterpolantFactoryMethodSmooth:
        return bd;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] += e;
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n)
        t[n] *= e;
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(e, t) {
    const n = this.times, i = n.length;
    let r = 0, o = i - 1;
    for (; r !== i && n[r] < e; )
      ++r;
    for (; o !== -1 && n[o] > t; )
      --o;
    if (++o, r !== 0 || o !== i) {
      r >= o && (o = Math.max(o, 1), r = o - 1);
      const a = this.getValueSize();
      this.times = n.slice(r, o), this.values = this.values.slice(r * a, o * a);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, i = this.values, r = n.length;
    r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
    let o = null;
    for (let a = 0; a !== r; a++) {
      const l = n[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
        break;
      }
      o = l;
    }
    if (i !== void 0 && i1(i))
      for (let a = 0, l = i.length; a !== l; ++a) {
        const h = i[a];
        if (isNaN(h)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, h), e = !1;
          break;
        }
      }
    return e;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), i = this.getInterpolation() === bd, r = e.length - 1;
    let o = 1;
    for (let a = 1; a < r; ++a) {
      let l = !1;
      const h = e[a], f = e[a + 1];
      if (h !== f && (a !== 1 || h !== e[0]))
        if (i)
          l = !0;
        else {
          const d = a * n, p = d - n, m = d + n;
          for (let _ = 0; _ !== n; ++_) {
            const x = t[d + _];
            if (x !== t[p + _] || x !== t[m + _]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const d = a * n, p = o * n;
          for (let m = 0; m !== n; ++m)
            t[p + m] = t[d + m];
        }
        ++o;
      }
    }
    if (r > 0) {
      e[o] = e[r];
      for (let a = r * n, l = o * n, h = 0; h !== n; ++h)
        t[l + h] = t[a + h];
      ++o;
    }
    return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * n)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = this.constructor, i = new n(this.name, e, t);
    return i.createInterpolant = this.createInterpolant, i;
  }
}
Zr.prototype.TimeBufferType = Float32Array;
Zr.prototype.ValueBufferType = Float32Array;
Zr.prototype.DefaultInterpolation = Fa;
class Xa extends Zr {
}
Xa.prototype.ValueTypeName = "bool";
Xa.prototype.ValueBufferType = Array;
Xa.prototype.DefaultInterpolation = rc;
Xa.prototype.InterpolantFactoryMethodLinear = void 0;
Xa.prototype.InterpolantFactoryMethodSmooth = void 0;
class lv extends Zr {
}
lv.prototype.ValueTypeName = "color";
class Na extends Zr {
}
Na.prototype.ValueTypeName = "number";
class a1 extends Sc {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (n - t) / (i - t);
    let h = e * a;
    for (let f = h + a; h !== f; h += 4)
      yi.slerpFlat(r, 0, o, h - a, o, h, l);
    return r;
  }
}
class Io extends Zr {
  InterpolantFactoryMethodLinear(e) {
    return new a1(this.times, this.values, this.getValueSize(), e);
  }
}
Io.prototype.ValueTypeName = "quaternion";
Io.prototype.DefaultInterpolation = Fa;
Io.prototype.InterpolantFactoryMethodSmooth = void 0;
class Ja extends Zr {
}
Ja.prototype.ValueTypeName = "string";
Ja.prototype.ValueBufferType = Array;
Ja.prototype.DefaultInterpolation = rc;
Ja.prototype.InterpolantFactoryMethodLinear = void 0;
Ja.prototype.InterpolantFactoryMethodSmooth = void 0;
class ka extends Zr {
}
ka.prototype.ValueTypeName = "vector";
class lc {
  constructor(e, t = -1, n, i = up) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = fr(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], n = e.tracks, i = 1 / (e.fps || 1);
    for (let o = 0, a = n.length; o !== a; ++o)
      t.push(jL(n[o]).scale(i));
    const r = new this(e.name, e.duration, t, e.blendMode);
    return r.uuid = e.uuid, r;
  }
  static toJSON(e) {
    const t = [], n = e.tracks, i = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode
    };
    for (let r = 0, o = n.length; r !== o; ++r)
      t.push(Zr.toJSON(n[r]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const r = t.length, o = [];
    for (let a = 0; a < r; a++) {
      let l = [], h = [];
      l.push(
        (a + r - 1) % r,
        a,
        (a + 1) % r
      ), h.push(0, 1, 0);
      const f = r1(l);
      l = K_(l, 1, f), h = K_(h, 1, f), !i && l[0] === 0 && (l.push(r), h.push(h[0])), o.push(
        new Na(
          ".morphTargetInfluences[" + t[a].name + "]",
          l,
          h
        ).scale(1 / n)
      );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = i.geometry && i.geometry.animations || i.animations;
    }
    for (let i = 0; i < n.length; i++)
      if (n[i].name === t)
        return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {}, r = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const h = e[a], f = h.name.match(r);
      if (f && f.length > 1) {
        const d = f[1];
        let p = i[d];
        p || (i[d] = p = []), p.push(h);
      }
    }
    const o = [];
    for (const a in i)
      o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
    return o;
  }
  // parse the animation.hierarchy format
  static parseAnimation(e, t) {
    if (!e)
      return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const n = function(d, p, m, _, x) {
      if (m.length !== 0) {
        const y = [], v = [];
        ov(m, y, v, _), y.length !== 0 && x.push(new d(p, y, v));
      }
    }, i = [], r = e.name || "default", o = e.fps || 30, a = e.blendMode;
    let l = e.length || -1;
    const h = e.hierarchy || [];
    for (let d = 0; d < h.length; d++) {
      const p = h[d].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const m = {};
          let _;
          for (_ = 0; _ < p.length; _++)
            if (p[_].morphTargets)
              for (let x = 0; x < p[_].morphTargets.length; x++)
                m[p[_].morphTargets[x]] = -1;
          for (const x in m) {
            const y = [], v = [];
            for (let S = 0; S !== p[_].morphTargets.length; ++S) {
              const M = p[_];
              y.push(M.time), v.push(M.morphTarget === x ? 1 : 0);
            }
            i.push(new Na(".morphTargetInfluence[" + x + "]", y, v));
          }
          l = m.length * o;
        } else {
          const m = ".bones[" + t[d].name + "]";
          n(
            ka,
            m + ".position",
            p,
            "pos",
            i
          ), n(
            Io,
            m + ".quaternion",
            p,
            "rot",
            i
          ), n(
            ka,
            m + ".scale",
            p,
            "scl",
            i
          );
        }
    }
    return i.length === 0 ? null : new this(r, l, i, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const r = this.tracks[n];
      t = Math.max(t, r.times[r.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++)
      e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function ZL(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Na;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return ka;
    case "color":
      return lv;
    case "quaternion":
      return Io;
    case "bool":
    case "boolean":
      return Xa;
    case "string":
      return Ja;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s);
}
function jL(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = ZL(s.type);
  if (s.times === void 0) {
    const t = [], n = [];
    ov(s.keys, t, n, "value"), s.times = t, s.values = n;
  }
  return e.parse !== void 0 ? e.parse(s) : new e(s.name, s.times, s.values, s.interpolation);
}
const Gs = {
  enabled: !1,
  files: {},
  add: function(s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function(s) {
    if (this.enabled !== !1)
      return this.files[s];
  },
  remove: function(s) {
    delete this.files[s];
  },
  clear: function() {
    this.files = {};
  }
};
class cv {
  constructor(e, t, n) {
    const i = this;
    let r = !1, o = 0, a = 0, l;
    const h = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(f) {
      a++, r === !1 && i.onStart !== void 0 && i.onStart(f, o, a), r = !0;
    }, this.itemEnd = function(f) {
      o++, i.onProgress !== void 0 && i.onProgress(f, o, a), o === a && (r = !1, i.onLoad !== void 0 && i.onLoad());
    }, this.itemError = function(f) {
      i.onError !== void 0 && i.onError(f);
    }, this.resolveURL = function(f) {
      return l ? l(f) : f;
    }, this.setURLModifier = function(f) {
      return l = f, this;
    }, this.addHandler = function(f, d) {
      return h.push(f, d), this;
    }, this.removeHandler = function(f) {
      const d = h.indexOf(f);
      return d !== -1 && h.splice(d, 2), this;
    }, this.getHandler = function(f) {
      for (let d = 0, p = h.length; d < p; d += 2) {
        const m = h[d], _ = h[d + 1];
        if (m.global && (m.lastIndex = 0), m.test(f))
          return _;
      }
      return null;
    };
  }
}
const l1 = /* @__PURE__ */ new cv();
class Si {
  constructor(e) {
    this.manager = e !== void 0 ? e : l1, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(i, r) {
      n.load(e, i, t, r);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Si.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Is = {};
class $L extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class pr extends Si {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = Gs.get(e);
    if (r !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(r), this.manager.itemEnd(e);
      }, 0), r;
    if (Is[e] !== void 0) {
      Is[e].push({
        onLoad: t,
        onProgress: n,
        onError: i
      });
      return;
    }
    Is[e] = [], Is[e].push({
      onLoad: t,
      onProgress: n,
      onError: i
    });
    const o = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), a = this.mimeType, l = this.responseType;
    fetch(o).then((h) => {
      if (h.status === 200 || h.status === 0) {
        if (h.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || h.body === void 0 || h.body.getReader === void 0)
          return h;
        const f = Is[e], d = h.body.getReader(), p = h.headers.get("Content-Length") || h.headers.get("X-File-Size"), m = p ? parseInt(p) : 0, _ = m !== 0;
        let x = 0;
        const y = new ReadableStream({
          start(v) {
            S();
            function S() {
              d.read().then(({ done: M, value: T }) => {
                if (M)
                  v.close();
                else {
                  x += T.byteLength;
                  const P = new ProgressEvent("progress", { lengthComputable: _, loaded: x, total: m });
                  for (let b = 0, R = f.length; b < R; b++) {
                    const U = f[b];
                    U.onProgress && U.onProgress(P);
                  }
                  v.enqueue(T), S();
                }
              });
            }
          }
        });
        return new Response(y);
      } else
        throw new $L(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`, h);
    }).then((h) => {
      switch (l) {
        case "arraybuffer":
          return h.arrayBuffer();
        case "blob":
          return h.blob();
        case "document":
          return h.text().then((f) => new DOMParser().parseFromString(f, a));
        case "json":
          return h.json();
        default:
          if (a === void 0)
            return h.text();
          {
            const d = /charset="?([^;"\s]*)"?/i.exec(a), p = d && d[1] ? d[1].toLowerCase() : void 0, m = new TextDecoder(p);
            return h.arrayBuffer().then((_) => m.decode(_));
          }
      }
    }).then((h) => {
      Gs.add(e, h);
      const f = Is[e];
      delete Is[e];
      for (let d = 0, p = f.length; d < p; d++) {
        const m = f[d];
        m.onLoad && m.onLoad(h);
      }
    }).catch((h) => {
      const f = Is[e];
      if (f === void 0)
        throw this.manager.itemError(e), h;
      delete Is[e];
      for (let d = 0, p = f.length; d < p; d++) {
        const m = f[d];
        m.onError && m.onError(h);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class eD extends Si {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = new pr(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
      try {
        t(r.parse(JSON.parse(a)));
      } catch (l) {
        i ? i(l) : console.error(l), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const i = lc.parse(e[n]);
      t.push(i);
    }
    return t;
  }
}
class tD extends Si {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = [], a = new vp(), l = new pr(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(r.withCredentials);
    let h = 0;
    function f(d) {
      l.load(e[d], function(p) {
        const m = r.parse(p, !0);
        o[d] = {
          width: m.width,
          height: m.height,
          format: m.format,
          mipmaps: m.mipmaps
        }, h += 1, h === 6 && (m.mipmapCount === 1 && (a.minFilter = gn), a.image = o, a.format = m.format, a.needsUpdate = !0, t && t(a));
      }, n, i);
    }
    if (Array.isArray(e))
      for (let d = 0, p = e.length; d < p; ++d)
        f(d);
    else
      l.load(e, function(d) {
        const p = r.parse(d, !0);
        if (p.isCubemap) {
          const m = p.mipmaps.length / p.mipmapCount;
          for (let _ = 0; _ < m; _++) {
            o[_] = { mipmaps: [] };
            for (let x = 0; x < p.mipmapCount; x++)
              o[_].mipmaps.push(p.mipmaps[_ * p.mipmapCount + x]), o[_].format = p.format, o[_].width = p.width, o[_].height = p.height;
          }
          a.image = o;
        } else
          a.image.width = p.width, a.image.height = p.height, a.mipmaps = p.mipmaps;
        p.mipmapCount === 1 && (a.minFilter = gn), a.format = p.format, a.needsUpdate = !0, t && t(a);
      }, n, i);
    return a;
  }
}
class Yu extends Si {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, o = Gs.get(e);
    if (o !== void 0)
      return r.manager.itemStart(e), setTimeout(function() {
        t && t(o), r.manager.itemEnd(e);
      }, 0), o;
    const a = zu("img");
    function l() {
      f(), Gs.add(e, this), t && t(this), r.manager.itemEnd(e);
    }
    function h(d) {
      f(), i && i(d), r.manager.itemError(e), r.manager.itemEnd(e);
    }
    function f() {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", h, !1);
    }
    return a.addEventListener("load", l, !1), a.addEventListener("error", h, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), r.manager.itemStart(e), a.src = e, a;
  }
}
class nD extends Si {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new lh();
    r.colorSpace = Vn;
    const o = new Yu(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(h) {
      o.load(e[h], function(f) {
        r.images[h] = f, a++, a === 6 && (r.needsUpdate = !0, t && t(r));
      }, void 0, i);
    }
    for (let h = 0; h < e.length; ++h)
      l(h);
    return r;
  }
}
class iD extends Si {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = new Ta(), a = new pr(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(r.withCredentials), a.load(e, function(l) {
      let h;
      try {
        h = r.parse(l);
      } catch (f) {
        if (i !== void 0)
          i(f);
        else {
          console.error(f);
          return;
        }
      }
      h.image !== void 0 ? o.image = h.image : h.data !== void 0 && (o.image.width = h.width, o.image.height = h.height, o.image.data = h.data), o.wrapS = h.wrapS !== void 0 ? h.wrapS : ri, o.wrapT = h.wrapT !== void 0 ? h.wrapT : ri, o.magFilter = h.magFilter !== void 0 ? h.magFilter : gn, o.minFilter = h.minFilter !== void 0 ? h.minFilter : gn, o.anisotropy = h.anisotropy !== void 0 ? h.anisotropy : 1, h.colorSpace !== void 0 ? o.colorSpace = h.colorSpace : h.encoding !== void 0 && (o.encoding = h.encoding), h.flipY !== void 0 && (o.flipY = h.flipY), h.format !== void 0 && (o.format = h.format), h.type !== void 0 && (o.type = h.type), h.mipmaps !== void 0 && (o.mipmaps = h.mipmaps, o.minFilter = _s), h.mipmapCount === 1 && (o.minFilter = gn), h.generateMipmaps !== void 0 && (o.generateMipmaps = h.generateMipmaps), o.needsUpdate = !0, t && t(o, h);
    }, n, i), o;
  }
}
class c1 extends Si {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = new yn(), o = new Yu(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
      r.image = a, r.needsUpdate = !0, t !== void 0 && t(r);
    }, n, i), r;
  }
}
class No extends zt {
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Ne(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class u1 extends No {
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(zt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Ne(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const Sg = /* @__PURE__ */ new pt(), kA = /* @__PURE__ */ new k(), GA = /* @__PURE__ */ new k();
class uv {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ve(512, 512), this.map = null, this.mapPass = null, this.matrix = new pt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new ch(), this._frameExtents = new ve(1, 1), this._viewportCount = 1, this._viewports = [
      new Zt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    kA.setFromMatrixPosition(e.matrixWorld), t.position.copy(kA), GA.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(GA), t.updateMatrixWorld(), Sg.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Sg), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(Sg);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class rD extends uv {
  constructor() {
    super(new Wn(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = oc * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height, r = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || r !== t.far) && (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class hv extends No {
  constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(zt.DEFAULT_UP), this.updateMatrix(), this.target = new zt(), this.distance = n, this.angle = i, this.penumbra = r, this.decay = o, this.map = null, this.shadow = new rD();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const HA = /* @__PURE__ */ new pt(), eu = /* @__PURE__ */ new k(), Eg = /* @__PURE__ */ new k();
class sD extends uv {
  constructor() {
    super(new Wn(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new ve(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Zt(2, 1, 1, 1),
      // negative X
      new Zt(0, 1, 1, 1),
      // positive Z
      new Zt(3, 1, 1, 1),
      // negative Z
      new Zt(1, 1, 1, 1),
      // positive Y
      new Zt(3, 0, 1, 1),
      // negative Y
      new Zt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new k(1, 0, 0),
      new k(-1, 0, 0),
      new k(0, 0, 1),
      new k(0, 0, -1),
      new k(0, 1, 0),
      new k(0, -1, 0)
    ], this._cubeUps = [
      new k(0, 1, 0),
      new k(0, 1, 0),
      new k(0, 1, 0),
      new k(0, 1, 0),
      new k(0, 0, 1),
      new k(0, 0, -1)
    ];
  }
  updateMatrices(e, t = 0) {
    const n = this.camera, i = this.matrix, r = e.distance || n.far;
    r !== n.far && (n.far = r, n.updateProjectionMatrix()), eu.setFromMatrixPosition(e.matrixWorld), n.position.copy(eu), Eg.copy(n.position), Eg.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Eg), n.updateMatrixWorld(), i.makeTranslation(-eu.x, -eu.y, -eu.z), HA.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(HA);
  }
}
class fv extends No {
  constructor(e, t, n = 0, i = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new sD();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class oD extends uv {
  constructor() {
    super(new xc(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class dv extends No {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(zt.DEFAULT_UP), this.updateMatrix(), this.target = new zt(), this.shadow = new oD();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class h1 extends No {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class f1 extends No {
  constructor(e, t, n = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = i;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class d1 {
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new k());
  }
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(e, t) {
    const n = e.x, i = e.y, r = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * i), t.addScaledVector(o[2], 0.488603 * r), t.addScaledVector(o[3], 0.488603 * n), t.addScaledVector(o[4], 1.092548 * (n * i)), t.addScaledVector(o[5], 1.092548 * (i * r)), t.addScaledVector(o[6], 0.315392 * (3 * r * r - 1)), t.addScaledVector(o[7], 1.092548 * (n * r)), t.addScaledVector(o[8], 0.546274 * (n * n - i * i)), t;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(e, t) {
    const n = e.x, i = e.y, r = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 2 * 0.511664 * i), t.addScaledVector(o[2], 2 * 0.511664 * r), t.addScaledVector(o[3], 2 * 0.511664 * n), t.addScaledVector(o[4], 2 * 0.429043 * n * i), t.addScaledVector(o[5], 2 * 0.429043 * i * r), t.addScaledVector(o[6], 0.743125 * r * r - 0.247708), t.addScaledVector(o[7], 2 * 0.429043 * n * r), t.addScaledVector(o[8], 0.429043 * (n * n - i * i)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].toArray(e, t + i * 3);
    return e;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(e, t) {
    const n = e.x, i = e.y, r = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * r, t[3] = 0.488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * r, t[6] = 0.315392 * (3 * r * r - 1), t[7] = 1.092548 * n * r, t[8] = 0.546274 * (n * n - i * i);
  }
}
class p1 extends No {
  constructor(e = new d1(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class Lp extends Si {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, n, i) {
    const r = this, o = new pr(r.manager);
    o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(a) {
      try {
        t(r.parse(JSON.parse(a)));
      } catch (l) {
        i ? i(l) : console.error(l), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = this.textures;
    function n(r) {
      return t[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), t[r];
    }
    const i = Lp.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new Ne().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const r in e.uniforms) {
        const o = e.uniforms[r];
        switch (i.uniforms[r] = {}, o.type) {
          case "t":
            i.uniforms[r].value = n(o.value);
            break;
          case "c":
            i.uniforms[r].value = new Ne().setHex(o.value);
            break;
          case "v2":
            i.uniforms[r].value = new ve().fromArray(o.value);
            break;
          case "v3":
            i.uniforms[r].value = new k().fromArray(o.value);
            break;
          case "v4":
            i.uniforms[r].value = new Zt().fromArray(o.value);
            break;
          case "m3":
            i.uniforms[r].value = new Ct().fromArray(o.value);
            break;
          case "m4":
            i.uniforms[r].value = new pt().fromArray(o.value);
            break;
          default:
            i.uniforms[r].value = o.value;
        }
      }
    if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const r in e.extensions)
        i.extensions[r] = e.extensions[r];
    if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let r = e.normalScale;
      Array.isArray(r) === !1 && (r = [r, r]), i.normalScale = new ve().fromArray(r);
    }
    return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new ve().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: qE,
      SpriteMaterial: q0,
      RawShaderMaterial: QE,
      ShaderMaterial: ys,
      PointsMaterial: _p,
      MeshPhysicalMaterial: Ur,
      MeshStandardMaterial: gh,
      MeshPhongMaterial: ZE,
      MeshToonMaterial: jE,
      MeshNormalMaterial: $E,
      MeshLambertMaterial: e1,
      MeshDepthMaterial: X0,
      MeshDistanceMaterial: J0,
      MeshBasicMaterial: ur,
      MeshMatcapMaterial: t1,
      LineDashedMaterial: n1,
      LineBasicMaterial: Mi,
      Material: Xn
    };
    return new t[e]();
  }
}
class To {
  static decodeText(e) {
    if (typeof TextDecoder < "u")
      return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++)
      t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class m1 extends Mt {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class g1 extends Si {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = new pr(r.manager);
    o.setPath(r.path), o.setRequestHeader(r.requestHeader), o.setWithCredentials(r.withCredentials), o.load(e, function(a) {
      try {
        t(r.parse(JSON.parse(a)));
      } catch (l) {
        i ? i(l) : console.error(l), r.manager.itemError(e);
      }
    }, n, i);
  }
  parse(e) {
    const t = {}, n = {};
    function i(m, _) {
      if (t[_] !== void 0) return t[_];
      const y = m.interleavedBuffers[_], v = r(m, y.buffer), S = Nl(y.type, v), M = new hh(S, y.stride);
      return M.uuid = y.uuid, t[_] = M, M;
    }
    function r(m, _) {
      if (n[_] !== void 0) return n[_];
      const y = m.arrayBuffers[_], v = new Uint32Array(y).buffer;
      return n[_] = v, v;
    }
    const o = e.isInstancedBufferGeometry ? new m1() : new Mt(), a = e.data.index;
    if (a !== void 0) {
      const m = Nl(a.type, a.array);
      o.setIndex(new Vt(m, 1));
    }
    const l = e.data.attributes;
    for (const m in l) {
      const _ = l[m];
      let x;
      if (_.isInterleavedBufferAttribute) {
        const y = i(e.data, _.data);
        x = new Po(y, _.itemSize, _.offset, _.normalized);
      } else {
        const y = Nl(_.type, _.array), v = _.isInstancedBufferAttribute ? Ua : Vt;
        x = new v(y, _.itemSize, _.normalized);
      }
      _.name !== void 0 && (x.name = _.name), _.usage !== void 0 && x.setUsage(_.usage), o.setAttribute(m, x);
    }
    const h = e.data.morphAttributes;
    if (h)
      for (const m in h) {
        const _ = h[m], x = [];
        for (let y = 0, v = _.length; y < v; y++) {
          const S = _[y];
          let M;
          if (S.isInterleavedBufferAttribute) {
            const T = i(e.data, S.data);
            M = new Po(T, S.itemSize, S.offset, S.normalized);
          } else {
            const T = Nl(S.type, S.array);
            M = new Vt(T, S.itemSize, S.normalized);
          }
          S.name !== void 0 && (M.name = S.name), x.push(M);
        }
        o.morphAttributes[m] = x;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let m = 0, _ = d.length; m !== _; ++m) {
        const x = d[m];
        o.addGroup(x.start, x.count, x.materialIndex);
      }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const m = new k();
      p.center !== void 0 && m.fromArray(p.center), o.boundingSphere = new oi(m, p.radius);
    }
    return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
  }
}
class aD extends Si {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = this.path === "" ? To.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new pr(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      let h = null;
      try {
        h = JSON.parse(l);
      } catch (d) {
        i !== void 0 && i(d), console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message);
        return;
      }
      const f = h.metadata;
      if (f === void 0 || f.type === void 0 || f.type.toLowerCase() === "geometry") {
        i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      r.parse(h, t);
    }, n, i);
  }
  async loadAsync(e, t) {
    const n = this, i = this.path === "" ? To.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const r = new pr(this.manager);
    r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
    const o = await r.loadAsync(e, t), a = JSON.parse(o), l = a.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(a);
  }
  parse(e, t) {
    const n = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), o = this.parseImages(e.images, function() {
      t !== void 0 && t(h);
    }), a = this.parseTextures(e.textures, o), l = this.parseMaterials(e.materials, a), h = this.parseObject(e.object, r, l, a, n), f = this.parseSkeletons(e.skeletons, h);
    if (this.bindSkeletons(h, f), t !== void 0) {
      let d = !1;
      for (const p in o)
        if (o[p].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && t(h);
    }
    return h;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), i = this.parseGeometries(e.geometries, n), r = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, r), a = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, i, a, o, t), h = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, h), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, i = e.length; n < i; n++) {
        const r = new wa().fromJSON(e[n]);
        t[r.uuid] = r;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {}, i = {};
    if (t.traverse(function(r) {
      r.isBone && (i[r.uuid] = r);
    }), e !== void 0)
      for (let r = 0, o = e.length; r < o; r++) {
        const a = new fh().fromJSON(e[r], i);
        n[a.uuid] = a;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const i = new g1();
      for (let r = 0, o = e.length; r < o; r++) {
        let a;
        const l = e[r];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = i.parse(l);
            break;
          default:
            l.type in NA ? a = NA[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a;
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {}, i = {};
    if (e !== void 0) {
      const r = new Lp();
      r.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        n[l.uuid] === void 0 && (n[l.uuid] = r.parse(l)), i[l.uuid] = n[l.uuid];
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const i = e[n], r = lc.parse(i);
        t[r.uuid] = r;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this, i = {};
    let r;
    function o(l) {
      return n.manager.itemStart(l), r.load(l, function() {
        n.manager.itemEnd(l);
      }, void 0, function() {
        n.manager.itemError(l), n.manager.itemEnd(l);
      });
    }
    function a(l) {
      if (typeof l == "string") {
        const h = l, f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h) ? h : n.resourcePath + h;
        return o(f);
      } else
        return l.data ? {
          data: Nl(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new cv(t);
      r = new Yu(l), r.setCrossOrigin(this.crossOrigin);
      for (let h = 0, f = e.length; h < f; h++) {
        const d = e[h], p = d.url;
        if (Array.isArray(p)) {
          const m = [];
          for (let _ = 0, x = p.length; _ < x; _++) {
            const y = p[_], v = a(y);
            v !== null && (v instanceof HTMLImageElement ? m.push(v) : m.push(new Ta(v.data, v.width, v.height)));
          }
          i[d.uuid] = new ga(m);
        } else {
          const m = a(d.url);
          i[d.uuid] = new ga(m);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this, n = {};
    let i;
    async function r(o) {
      if (typeof o == "string") {
        const a = o, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await i.loadAsync(l);
      } else
        return o.data ? {
          data: Nl(o.type, o.data),
          width: o.width,
          height: o.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      i = new Yu(this.manager), i.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o], h = l.url;
        if (Array.isArray(h)) {
          const f = [];
          for (let d = 0, p = h.length; d < p; d++) {
            const m = h[d], _ = await r(m);
            _ !== null && (_ instanceof HTMLImageElement ? f.push(_) : f.push(new Ta(_.data, _.width, _.height)));
          }
          n[l.uuid] = new ga(f);
        } else {
          const f = await r(l.url);
          n[l.uuid] = new ga(f);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(r, o) {
      return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), o[r]);
    }
    const i = {};
    if (e !== void 0)
      for (let r = 0, o = e.length; r < o; r++) {
        const a = e[r];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = t[a.image], h = l.data;
        let f;
        Array.isArray(h) ? (f = new lh(), h.length === 6 && (f.needsUpdate = !0)) : (h && h.data ? f = new Ta() : f = new yn(), h && (f.needsUpdate = !0)), f.source = l, f.uuid = a.uuid, a.name !== void 0 && (f.name = a.name), a.mapping !== void 0 && (f.mapping = n(a.mapping, lD)), a.channel !== void 0 && (f.channel = a.channel), a.offset !== void 0 && f.offset.fromArray(a.offset), a.repeat !== void 0 && f.repeat.fromArray(a.repeat), a.center !== void 0 && f.center.fromArray(a.center), a.rotation !== void 0 && (f.rotation = a.rotation), a.wrap !== void 0 && (f.wrapS = n(a.wrap[0], zA), f.wrapT = n(a.wrap[1], zA)), a.format !== void 0 && (f.format = a.format), a.internalFormat !== void 0 && (f.internalFormat = a.internalFormat), a.type !== void 0 && (f.type = a.type), a.colorSpace !== void 0 && (f.colorSpace = a.colorSpace), a.encoding !== void 0 && (f.encoding = a.encoding), a.minFilter !== void 0 && (f.minFilter = n(a.minFilter, VA)), a.magFilter !== void 0 && (f.magFilter = n(a.magFilter, VA)), a.anisotropy !== void 0 && (f.anisotropy = a.anisotropy), a.flipY !== void 0 && (f.flipY = a.flipY), a.generateMipmaps !== void 0 && (f.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (f.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (f.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (f.compareFunction = a.compareFunction), a.userData !== void 0 && (f.userData = a.userData), i[a.uuid] = f;
      }
    return i;
  }
  parseObject(e, t, n, i, r) {
    let o;
    function a(p) {
      return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p];
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const m = [];
          for (let _ = 0, x = p.length; _ < x; _++) {
            const y = p[_];
            n[y] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", y), m.push(n[y]);
          }
          return m;
        }
        return n[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), n[p];
      }
    }
    function h(p) {
      return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), i[p];
    }
    let f, d;
    switch (e.type) {
      case "Scene":
        o = new K0(), e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Ne(e.background) : o.background = h(e.background)), e.environment !== void 0 && (o.environment = h(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new mp(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new pp(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        o = new Wn(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        o = new xc(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new h1(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new dv(e.color, e.intensity);
        break;
      case "PointLight":
        o = new fv(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new f1(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new hv(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        o = new u1(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new p1().fromJSON(e);
        break;
      case "SkinnedMesh":
        f = a(e.geometry), d = l(e.material), o = new Q0(f, d), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        f = a(e.geometry), d = l(e.material), o = new kn(f, d);
        break;
      case "InstancedMesh":
        f = a(e.geometry), d = l(e.material);
        const p = e.count, m = e.instanceMatrix, _ = e.instanceColor;
        o = new Z0(f, d, p), o.instanceMatrix = new Ua(new Float32Array(m.array), 16), _ !== void 0 && (o.instanceColor = new Ua(new Float32Array(_.array), _.itemSize));
        break;
      case "BatchedMesh":
        f = a(e.geometry), d = l(e.material), o = new NE(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, d), o.geometry = f, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map((x) => {
          const y = new xi();
          y.min.fromArray(x.boxMin), y.max.fromArray(x.boxMax);
          const v = new oi();
          return v.radius = x.sphereRadius, v.center.fromArray(x.sphereCenter), {
            boxInitialized: x.boxInitialized,
            box: y,
            sphereInitialized: x.sphereInitialized,
            sphere: v
          };
        }), o._maxGeometryCount = e.maxGeometryCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = h(e.matricesTexture.uuid);
        break;
      case "LOD":
        o = new OE();
        break;
      case "Line":
        o = new Js(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new j0(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new qr(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new $0(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new UE(l(e.material));
        break;
      case "Group":
        o = new ks();
        break;
      case "Bone":
        o = new gp();
        break;
      default:
        o = new zt();
    }
    if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
      const p = e.children;
      for (let m = 0; m < p.length; m++)
        o.add(this.parseObject(p[m], t, n, i, r));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let m = 0; m < p.length; m++) {
        const _ = p[m];
        o.animations.push(r[_]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let m = 0; m < p.length; m++) {
        const _ = p[m], x = o.getObjectByProperty("uuid", _.object);
        x !== void 0 && o.addLevel(x, _.distance, _.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const i = t[n.skeleton];
        i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix);
      }
    });
  }
}
const lD = {
  UVMapping: ap,
  CubeReflectionMapping: Xs,
  CubeRefractionMapping: Ro,
  EquirectangularReflectionMapping: Du,
  EquirectangularRefractionMapping: Fu,
  CubeUVReflectionMapping: _c
}, zA = {
  RepeatWrapping: Bo,
  ClampToEdgeWrapping: ri,
  MirroredRepeatWrapping: nc
}, VA = {
  NearestFilter: Sn,
  NearestMipmapNearestFilter: Uu,
  NearestMipmapLinearFilter: Jl,
  LinearFilter: gn,
  LinearMipmapNearestFilter: lp,
  LinearMipmapLinearFilter: _s
};
class _1 extends Si {
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const r = this, o = Gs.get(e);
    if (o !== void 0) {
      if (r.manager.itemStart(e), o.then) {
        o.then((h) => {
          t && t(h), r.manager.itemEnd(e);
        }).catch((h) => {
          i && i(h);
        });
        return;
      }
      return setTimeout(function() {
        t && t(o), r.manager.itemEnd(e);
      }, 0), o;
    }
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader;
    const l = fetch(e, a).then(function(h) {
      return h.blob();
    }).then(function(h) {
      return createImageBitmap(h, Object.assign(r.options, { colorSpaceConversion: "none" }));
    }).then(function(h) {
      return Gs.add(e, h), t && t(h), r.manager.itemEnd(e), h;
    }).catch(function(h) {
      i && i(h), Gs.remove(e), r.manager.itemError(e), r.manager.itemEnd(e);
    });
    Gs.add(e, l), r.manager.itemStart(e);
  }
}
let $f;
class pv {
  static getContext() {
    return $f === void 0 && ($f = new (window.AudioContext || window.webkitAudioContext)()), $f;
  }
  static setContext(e) {
    $f = e;
  }
}
class cD extends Si {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const r = this, o = new pr(this.manager);
    o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      try {
        const h = l.slice(0);
        pv.getContext().decodeAudioData(h, function(d) {
          t(d);
        }).catch(a);
      } catch (h) {
        a(h);
      }
    }, n, i);
    function a(l) {
      i ? i(l) : console.error(l), r.manager.itemError(e);
    }
  }
}
const WA = /* @__PURE__ */ new pt(), XA = /* @__PURE__ */ new pt(), ea = /* @__PURE__ */ new pt();
class uD {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Wn(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Wn(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, ea.copy(e.projectionMatrix);
      const i = t.eyeSep / 2, r = i * t.near / t.focus, o = t.near * Math.tan(Sa * t.fov * 0.5) / t.zoom;
      let a, l;
      XA.elements[12] = -i, WA.elements[12] = i, a = -o * t.aspect + r, l = o * t.aspect + r, ea.elements[0] = 2 * t.near / (l - a), ea.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(ea), a = -o * t.aspect - r, l = o * t.aspect - r, ea.elements[0] = 2 * t.near / (l - a), ea.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(ea);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(XA), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(WA);
  }
}
class mv {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = JA(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = JA();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function JA() {
  return (typeof performance > "u" ? Date : performance).now();
}
const ta = /* @__PURE__ */ new k(), YA = /* @__PURE__ */ new yi(), hD = /* @__PURE__ */ new k(), na = /* @__PURE__ */ new k();
class fD extends zt {
  constructor() {
    super(), this.type = "AudioListener", this.context = pv.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new mv();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, n = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ta, YA, hD), na.set(0, 0, -1).applyQuaternion(YA), t.positionX) {
      const i = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(ta.x, i), t.positionY.linearRampToValueAtTime(ta.y, i), t.positionZ.linearRampToValueAtTime(ta.z, i), t.forwardX.linearRampToValueAtTime(na.x, i), t.forwardY.linearRampToValueAtTime(na.y, i), t.forwardZ.linearRampToValueAtTime(na.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i);
    } else
      t.setPosition(ta.x, ta.y, ta.z), t.setOrientation(na.x, na.y, na.z, n.x, n.y, n.z);
  }
}
class v1 extends zt {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = !1, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    if (this.detune = e, this.source.detune !== void 0)
      return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const ia = /* @__PURE__ */ new k(), KA = /* @__PURE__ */ new yi(), dD = /* @__PURE__ */ new k(), ra = /* @__PURE__ */ new k();
class pD extends v1 {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(ia, KA, dD), ra.set(0, 0, 1).applyQuaternion(KA);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(ia.x, n), t.positionY.linearRampToValueAtTime(ia.y, n), t.positionZ.linearRampToValueAtTime(ia.z, n), t.orientationX.linearRampToValueAtTime(ra.x, n), t.orientationY.linearRampToValueAtTime(ra.y, n), t.orientationZ.linearRampToValueAtTime(ra.z, n);
    } else
      t.setPosition(ia.x, ia.y, ia.z), t.setOrientation(ra.x, ra.y, ra.z);
  }
}
class mD {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++)
      e += t[n];
    return e / t.length;
  }
}
class y1 {
  constructor(e, t, n) {
    this.binding = e, this.valueSize = n;
    let i, r, o;
    switch (t) {
      case "quaternion":
        i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
        break;
      default:
        i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
    }
    this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(e, t) {
    const n = this.buffer, i = this.valueSize, r = e * i + i;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== i; ++a)
        n[r + a] = n[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(n, r, 0, a, i);
    }
    this.cumulativeWeight = o;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, i = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(e) {
    const t = this.valueSize, n = this.buffer, i = e * t + t, r = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(
        n,
        i,
        l,
        1 - r,
        t
      );
    }
    o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
    for (let l = t, h = t + t; l !== h; ++l)
      if (n[l] !== n[l + t]) {
        a.setValue(n, i);
        break;
      }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, i = n * this._origIndex;
    e.getValue(t, i);
    for (let r = n, o = i; r !== o; ++r)
      t[r] = t[i + r % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  // mix functions
  _select(e, t, n, i, r) {
    if (i >= 0.5)
      for (let o = 0; o !== r; ++o)
        e[t + o] = e[n + o];
  }
  _slerp(e, t, n, i) {
    yi.slerpFlat(e, t, e, t, e, n, i);
  }
  _slerpAdditive(e, t, n, i, r) {
    const o = this._workIndex * r;
    yi.multiplyQuaternionsFlat(e, o, e, t, e, n), yi.slerpFlat(e, t, e, t, e, o, i);
  }
  _lerp(e, t, n, i, r) {
    const o = 1 - i;
    for (let a = 0; a !== r; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[n + a] * i;
    }
  }
  _lerpAdditive(e, t, n, i, r) {
    for (let o = 0; o !== r; ++o) {
      const a = t + o;
      e[a] = e[a] + e[n + o] * i;
    }
  }
}
const gv = "\\[\\]\\.:\\/", gD = new RegExp("[" + gv + "]", "g"), _v = "[^" + gv + "]", _D = "[^" + gv.replace("\\.", "") + "]", vD = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _v), yD = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _D), xD = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _v), AD = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _v), MD = new RegExp(
  "^" + vD + yD + xD + AD + "$"
), SD = ["material", "materials", "bones", "map"];
class ED {
  constructor(e, t, n) {
    const i = n || Ht.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, i);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Ht {
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || Ht.parseTrackName(t), this.node = Ht.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new Ht.Composite(e, t, n) : new Ht(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(gD, "");
  }
  static parseTrackName(e) {
    const t = MD.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const r = n.nodeName.substring(i + 1);
      SD.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(r) {
        for (let o = 0; o < r.length; o++) {
          const a = r[o];
          if (a.name === t || a.uuid === t)
            return a;
          const l = n(a.children);
          if (l) return l;
        }
        return null;
      }, i = n(e.children);
      if (i)
        return i;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, r = n.length; i !== r; ++i)
      n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, i = t.propertyName;
    let r = t.propertyIndex;
    if (e || (e = Ht.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let h = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let f = 0; f < e.length; f++)
            if (e[f].name === h) {
              h = f;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (h !== void 0) {
        if (e[h] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[h];
      }
    }
    const o = e[i];
    if (o === void 0) {
      const h = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + i + " but it wasn't found.", e);
      return;
    }
    let a = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (r !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Ht.Composite = ED;
Ht.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Ht.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Ht.prototype.GetterByBindingType = [
  Ht.prototype._getValue_direct,
  Ht.prototype._getValue_array,
  Ht.prototype._getValue_arrayElement,
  Ht.prototype._getValue_toArray
];
Ht.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Ht.prototype._setValue_direct,
    Ht.prototype._setValue_direct_setNeedsUpdate,
    Ht.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Ht.prototype._setValue_array,
    Ht.prototype._setValue_array_setNeedsUpdate,
    Ht.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Ht.prototype._setValue_arrayElement,
    Ht.prototype._setValue_arrayElement_setNeedsUpdate,
    Ht.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Ht.prototype._setValue_fromArray,
    Ht.prototype._setValue_fromArray_setNeedsUpdate,
    Ht.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class TD {
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = fr(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, i = arguments.length; n !== i; ++n)
      e[arguments[n].uuid] = n;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, i = this._parsedPaths, r = this._bindings, o = r.length;
    let a, l = e.length, h = this.nCachedObjects_;
    for (let f = 0, d = arguments.length; f !== d; ++f) {
      const p = arguments[f], m = p.uuid;
      let _ = t[m];
      if (_ === void 0) {
        _ = l++, t[m] = _, e.push(p);
        for (let x = 0, y = o; x !== y; ++x)
          r[x].push(new Ht(p, n[x], i[x]));
      } else if (_ < h) {
        a = e[_];
        const x = --h, y = e[x];
        t[y.uuid] = _, e[_] = y, t[m] = x, e[x] = p;
        for (let v = 0, S = o; v !== S; ++v) {
          const M = r[v], T = M[x];
          let P = M[_];
          M[_] = T, P === void 0 && (P = new Ht(p, n[v], i[v])), M[x] = P;
        }
      } else e[_] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = h;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let r = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o], h = l.uuid, f = t[h];
      if (f !== void 0 && f >= r) {
        const d = r++, p = e[d];
        t[p.uuid] = f, e[f] = p, t[h] = d, e[d] = l;
        for (let m = 0, _ = i; m !== _; ++m) {
          const x = n[m], y = x[d], v = x[f];
          x[f] = y, x[d] = v;
        }
      }
    }
    this.nCachedObjects_ = r;
  }
  // remove & forget
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, i = n.length;
    let r = this.nCachedObjects_, o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const h = arguments[a], f = h.uuid, d = t[f];
      if (d !== void 0)
        if (delete t[f], d < r) {
          const p = --r, m = e[p], _ = --o, x = e[_];
          t[m.uuid] = d, e[d] = m, t[x.uuid] = p, e[p] = x, e.pop();
          for (let y = 0, v = i; y !== v; ++y) {
            const S = n[y], M = S[p], T = S[_];
            S[d] = M, S[p] = T, S.pop();
          }
        } else {
          const p = --o, m = e[p];
          p > 0 && (t[m.uuid] = d), e[d] = m, e.pop();
          for (let _ = 0, x = i; _ !== x; ++_) {
            const y = n[_];
            y[d] = y[p], y.pop();
          }
        }
    }
    this.nCachedObjects_ = r;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let i = n[e];
    const r = this._bindings;
    if (i !== void 0) return r[i];
    const o = this._paths, a = this._parsedPaths, l = this._objects, h = l.length, f = this.nCachedObjects_, d = new Array(h);
    i = r.length, n[e] = i, o.push(e), a.push(t), r.push(d);
    for (let p = f, m = l.length; p !== m; ++p) {
      const _ = l[p];
      d[p] = new Ht(_, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (n !== void 0) {
      const i = this._paths, r = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], h = e[a];
      t[h] = n, o[n] = l, o.pop(), r[n] = r[a], r.pop(), i[n] = i[a], i.pop();
    }
  }
}
class x1 {
  constructor(e, t, n = null, i = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
    const r = t.tracks, o = r.length, a = new Array(o), l = {
      endingStart: pa,
      endingEnd: pa
    };
    for (let h = 0; h !== o; ++h) {
      const f = r[h].createInterpolant(null);
      a[h] = f, f.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = sE, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  // State & Scheduling
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, n) {
    if (e.fadeOut(t), this.fadeIn(t), n) {
      const i = this._clip.duration, r = e._clip.duration, o = r / i, a = i / r;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, n) {
    return e.crossFadeFrom(this, t, n);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, n) {
    const i = this._mixer, r = i.time, o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
    const l = a.parameterPositions, h = a.sampleValues;
    return l[0] = r, l[1] = r + n, h[0] = e / o, h[1] = t / o, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, n, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const r = this._startTime;
    if (r !== null) {
      const l = (e - r) * n;
      l < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * l);
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t), a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants, h = this._propertyBindings;
      switch (this.blendMode) {
        case D0:
          for (let f = 0, d = l.length; f !== d; ++f)
            l[f].evaluate(o), h[f].accumulateAdditive(a);
          break;
        case up:
        default:
          for (let f = 0, d = l.length; f !== d; ++f)
            l[f].evaluate(o), h[f].accumulate(i, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const i = n.evaluate(e)[0];
        t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let i = this.time + e, r = this._loopCount;
    const o = n === oE;
    if (e === 0)
      return r === -1 ? i : o && (r & 1) === 1 ? t - i : i;
    if (n === rE) {
      r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (i >= t)
          i = t;
        else if (i < 0)
          i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = i, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), i >= t || i < 0) {
        const a = Math.floor(i / t);
        i -= t * a, r += Math.abs(a);
        const l = this.repetitions - r;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (l === 1) {
            const h = e < 0;
            this._setEndings(h, !h, o);
          } else
            this._setEndings(!1, !1, o);
          this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: a
          });
        }
      } else
        this.time = i;
      if (o && (r & 1) === 1)
        return t - i;
    }
    return i;
  }
  _setEndings(e, t, n) {
    const i = this._interpolantSettings;
    n ? (i.endingStart = ma, i.endingEnd = ma) : (e ? i.endingStart = this.zeroSlopeAtStart ? ma : pa : i.endingStart = Ou, t ? i.endingEnd = this.zeroSlopeAtEnd ? ma : pa : i.endingEnd = Ou);
  }
  _scheduleFading(e, t, n) {
    const i = this._mixer, r = i.time;
    let o = this._weightInterpolant;
    o === null && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
    const a = o.parameterPositions, l = o.sampleValues;
    return a[0] = r, l[0] = t, a[1] = r + e, l[1] = n, this;
  }
}
const wD = new Float32Array(1);
class CD extends qs {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, i = e._clip.tracks, r = i.length, o = e._propertyBindings, a = e._interpolants, l = n.uuid, h = this._bindingsByRootAndName;
    let f = h[l];
    f === void 0 && (f = {}, h[l] = f);
    for (let d = 0; d !== r; ++d) {
      const p = i[d], m = p.name;
      let _ = f[m];
      if (_ !== void 0)
        ++_.referenceCount, o[d] = _;
      else {
        if (_ = o[d], _ !== void 0) {
          _._cacheIndex === null && (++_.referenceCount, this._addInactiveBinding(_, l, m));
          continue;
        }
        const x = t && t._propertyBindings[d].binding.parsedPath;
        _ = new y1(
          Ht.create(n, m, x),
          p.ValueTypeName,
          p.getValueSize()
        ), ++_.referenceCount, this._addInactiveBinding(_, l, m), o[d] = _;
      }
      a[d].resultBuffer = _.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid, i = e._clip.uuid, r = this._actionsByClip[i];
        this._bindAction(
          e,
          r && r.knownActions[0]
        ), this._addInactiveAction(e, i, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, i = t.length; n !== i; ++n) {
        const r = t[n];
        --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const i = this._actions, r = this._actionsByClip;
    let o = r[t];
    if (o === void 0)
      o = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = o;
    else {
      const a = o.knownActions;
      e._byClipCacheIndex = a.length, a.push(e);
    }
    e._cacheIndex = i.length, i.push(e), o.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], i = e._cacheIndex;
    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
    const r = e._clip.uuid, o = this._actionsByClip, a = o[r], l = a.knownActions, h = l[l.length - 1], f = e._byClipCacheIndex;
    h._byClipCacheIndex = f, l[f] = h, l.pop(), e._byClipCacheIndex = null;
    const d = a.actionByRoot, p = (e._localRoot || this._root).uuid;
    delete d[p], l.length === 0 && delete o[r], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, i = t.length; n !== i; ++n) {
      const r = t[n];
      --r.referenceCount === 0 && this._removeInactiveBinding(r);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, i = this._nActiveActions++, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, i = --this._nActiveActions, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, n) {
    const i = this._bindingsByRootAndName, r = this._bindings;
    let o = i[t];
    o === void 0 && (o = {}, i[t] = o), o[n] = e, e._cacheIndex = r.length, r.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, i = n.rootNode.uuid, r = n.path, o = this._bindingsByRootAndName, a = o[i], l = t[t.length - 1], h = e._cacheIndex;
    l._cacheIndex = h, t[h] = l, t.pop(), delete a[r], Object.keys(a).length === 0 && delete o[i];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = this._nActiveBindings++, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, i = --this._nActiveBindings, r = t[i];
    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return n === void 0 && (n = new av(
      new Float32Array(2),
      new Float32Array(2),
      1,
      wD
    ), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, i = --this._nActiveControlInterpolants, r = t[i];
    e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(e, t, n) {
    const i = t || this._root, r = i.uuid;
    let o = typeof e == "string" ? lc.findByName(i, e) : e;
    const a = o !== null ? o.uuid : e, l = this._actionsByClip[a];
    let h = null;
    if (n === void 0 && (o !== null ? n = o.blendMode : n = up), l !== void 0) {
      const d = l.actionByRoot[r];
      if (d !== void 0 && d.blendMode === n)
        return d;
      h = l.knownActions[0], o === null && (o = h._clip);
    }
    if (o === null) return null;
    const f = new x1(this, o, t, n);
    return this._bindAction(f, h), this._addInactiveAction(f, a, r), f;
  }
  // get an existing action
  existingAction(e, t) {
    const n = t || this._root, i = n.uuid, r = typeof e == "string" ? lc.findByName(n, e) : e, o = r ? r.uuid : e, a = this._actionsByClip[o];
    return a !== void 0 && a.actionByRoot[i] || null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n)
      e[n].stop();
    return this;
  }
  // advance the time and update apply the animation
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), o = this._accuIndex ^= 1;
    for (let h = 0; h !== n; ++h)
      t[h]._update(i, e, r, o);
    const a = this._bindings, l = this._nActiveBindings;
    for (let h = 0; h !== l; ++h)
      a[h].apply(o);
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, i = this._actionsByClip, r = i[n];
    if (r !== void 0) {
      const o = r.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const h = o[a];
        this._deactivateAction(h);
        const f = h._cacheIndex, d = t[t.length - 1];
        h._cacheIndex = null, h._byClipCacheIndex = null, d._cacheIndex = f, t[f] = d, t.pop(), this._removeInactiveBindingsForAction(h);
      }
      delete i[n];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const o in n) {
      const a = n[o].actionByRoot, l = a[t];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const i = this._bindingsByRootAndName, r = i[t];
    if (r !== void 0)
      for (const o in r) {
        const a = r[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  // remove a targeted clip from the cache
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class vv {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new vv(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let bD = 0;
class RD extends qs {
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: bD++ }), this.name = "", this.usage = Hu, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, i = t.length; n < i; n++) {
      const r = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let o = 0; o < r.length; o++)
        this.uniforms.push(r[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class BD extends hh {
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class PD {
  constructor(e, t, n, i, r) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class A1 {
  constructor(e, t, n = 0, i = 1 / 0) {
    this.ray = new vc(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new Ea(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, n = []) {
    return q_(e, this, n, t), n.sort(qA), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, r = e.length; i < r; i++)
      q_(e[i], this, n, t);
    return n.sort(qA), n;
  }
}
function qA(s, e) {
  return s.distance - e.distance;
}
function q_(s, e, t, n) {
  if (s.layers.test(e.layers) && s.raycast(e, t), n === !0) {
    const i = s.children;
    for (let r = 0, o = i.length; r < o; r++)
      q_(i[r], e, t, !0);
  }
}
class ID {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(En(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class LD {
  constructor(e = 1, t = 0, n = 0) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const QA = /* @__PURE__ */ new ve();
class DD {
  constructor(e = new ve(1 / 0, 1 / 0), t = new ve(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = QA.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, QA).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const ZA = /* @__PURE__ */ new k(), ed = /* @__PURE__ */ new k();
class FD {
  constructor(e = new k(), t = new k()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    ZA.subVectors(e, this.start), ed.subVectors(this.end, this.start);
    const n = ed.dot(ed);
    let r = ed.dot(ZA) / n;
    return t && (r = En(r, 0, 1)), r;
  }
  closestPointToPoint(e, t, n) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(i).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const jA = /* @__PURE__ */ new k();
class UD extends zt {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const n = new Mt(), i = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const h = o / l * Math.PI * 2, f = a / l * Math.PI * 2;
      i.push(
        Math.cos(h),
        Math.sin(h),
        1,
        Math.cos(f),
        Math.sin(f),
        1
      );
    }
    n.setAttribute("position", new $e(i, 3));
    const r = new Mi({ fog: !1, toneMapped: !1 });
    this.cone = new qr(n, r), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), jA.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(jA), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const uo = /* @__PURE__ */ new k(), td = /* @__PURE__ */ new pt(), Tg = /* @__PURE__ */ new pt();
class OD extends qr {
  constructor(e) {
    const t = M1(e), n = new Mt(), i = [], r = [], o = new Ne(0, 0, 1), a = new Ne(0, 1, 0);
    for (let h = 0; h < t.length; h++) {
      const f = t[h];
      f.parent && f.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b));
    }
    n.setAttribute("position", new $e(i, 3)), n.setAttribute("color", new $e(r, 3));
    const l = new Mi({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(n, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
  }
  updateMatrixWorld(e) {
    const t = this.bones, n = this.geometry, i = n.getAttribute("position");
    Tg.copy(this.root.matrixWorld).invert();
    for (let r = 0, o = 0; r < t.length; r++) {
      const a = t[r];
      a.parent && a.parent.isBone && (td.multiplyMatrices(Tg, a.matrixWorld), uo.setFromMatrixPosition(td), i.setXYZ(o, uo.x, uo.y, uo.z), td.multiplyMatrices(Tg, a.parent.matrixWorld), uo.setFromMatrixPosition(td), i.setXYZ(o + 1, uo.x, uo.y, uo.z), o += 2);
    }
    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function M1(s) {
  const e = [];
  s.isBone === !0 && e.push(s);
  for (let t = 0; t < s.children.length; t++)
    e.push.apply(e, M1(s.children[t]));
  return e;
}
class ND extends kn {
  constructor(e, t, n) {
    const i = new mh(t, 4, 2), r = new ur({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, r), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const kD = /* @__PURE__ */ new k(), $A = /* @__PURE__ */ new Ne(), eM = /* @__PURE__ */ new Ne();
class GD extends zt {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
    const i = new ph(t);
    i.rotateY(Math.PI * 0.5), this.material = new ur({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const r = i.getAttribute("position"), o = new Float32Array(r.count * 3);
    i.setAttribute("color", new Vt(o, 3)), this.add(new kn(i, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      $A.copy(this.light.color), eM.copy(this.light.groundColor);
      for (let n = 0, i = t.count; n < i; n++) {
        const r = n < i / 2 ? $A : eM;
        t.setXYZ(n, r.r, r.g, r.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(kD.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class HD extends qr {
  constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
    n = new Ne(n), i = new Ne(i);
    const r = t / 2, o = e / t, a = e / 2, l = [], h = [];
    for (let p = 0, m = 0, _ = -a; p <= t; p++, _ += o) {
      l.push(-a, 0, _, a, 0, _), l.push(_, 0, -a, _, 0, a);
      const x = p === r ? n : i;
      x.toArray(h, m), m += 3, x.toArray(h, m), m += 3, x.toArray(h, m), m += 3, x.toArray(h, m), m += 3;
    }
    const f = new Mt();
    f.setAttribute("position", new $e(l, 3)), f.setAttribute("color", new $e(h, 3));
    const d = new Mi({ vertexColors: !0, toneMapped: !1 });
    super(f, d), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class zD extends qr {
  constructor(e = 10, t = 16, n = 8, i = 64, r = 4473924, o = 8947848) {
    r = new Ne(r), o = new Ne(o);
    const a = [], l = [];
    if (t > 1)
      for (let d = 0; d < t; d++) {
        const p = d / t * (Math.PI * 2), m = Math.sin(p) * e, _ = Math.cos(p) * e;
        a.push(0, 0, 0), a.push(m, 0, _);
        const x = d & 1 ? r : o;
        l.push(x.r, x.g, x.b), l.push(x.r, x.g, x.b);
      }
    for (let d = 0; d < n; d++) {
      const p = d & 1 ? r : o, m = e - e / n * d;
      for (let _ = 0; _ < i; _++) {
        let x = _ / i * (Math.PI * 2), y = Math.sin(x) * m, v = Math.cos(x) * m;
        a.push(y, 0, v), l.push(p.r, p.g, p.b), x = (_ + 1) / i * (Math.PI * 2), y = Math.sin(x) * m, v = Math.cos(x) * m, a.push(y, 0, v), l.push(p.r, p.g, p.b);
      }
    }
    const h = new Mt();
    h.setAttribute("position", new $e(a, 3)), h.setAttribute("color", new $e(l, 3));
    const f = new Mi({ vertexColors: !0, toneMapped: !1 });
    super(h, f), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const tM = /* @__PURE__ */ new k(), nd = /* @__PURE__ */ new k(), nM = /* @__PURE__ */ new k();
class VD extends zt {
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let i = new Mt();
    i.setAttribute("position", new $e([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const r = new Mi({ fog: !1, toneMapped: !1 });
    this.lightPlane = new Js(i, r), this.add(this.lightPlane), i = new Mt(), i.setAttribute("position", new $e([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Js(i, r), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), tM.setFromMatrixPosition(this.light.matrixWorld), nd.setFromMatrixPosition(this.light.target.matrixWorld), nM.subVectors(nd, tM), this.lightPlane.lookAt(nd), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(nd), this.targetLine.scale.z = nM.length();
  }
}
const id = /* @__PURE__ */ new k(), Mn = /* @__PURE__ */ new ah();
class WD extends qr {
  constructor(e) {
    const t = new Mt(), n = new Mi({ color: 16777215, vertexColors: !0, toneMapped: !1 }), i = [], r = [], o = {};
    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");
    function a(_, x) {
      l(_), l(x);
    }
    function l(_) {
      i.push(0, 0, 0), r.push(0, 0, 0), o[_] === void 0 && (o[_] = []), o[_].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new $e(i, 3)), t.setAttribute("color", new $e(r, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
    const h = new Ne(16755200), f = new Ne(16711680), d = new Ne(43775), p = new Ne(16777215), m = new Ne(3355443);
    this.setColors(h, f, d, p, m);
  }
  setColors(e, t, n, i, r) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, i.r, i.g, i.b), a.setXYZ(39, i.r, i.g, i.b), a.setXYZ(40, r.r, r.g, r.b), a.setXYZ(41, r.r, r.g, r.b), a.setXYZ(42, r.r, r.g, r.b), a.setXYZ(43, r.r, r.g, r.b), a.setXYZ(44, r.r, r.g, r.b), a.setXYZ(45, r.r, r.g, r.b), a.setXYZ(46, r.r, r.g, r.b), a.setXYZ(47, r.r, r.g, r.b), a.setXYZ(48, r.r, r.g, r.b), a.setXYZ(49, r.r, r.g, r.b), a.needsUpdate = !0;
  }
  update() {
    const e = this.geometry, t = this.pointMap, n = 1, i = 1;
    Mn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Rn("c", t, e, Mn, 0, 0, -1), Rn("t", t, e, Mn, 0, 0, 1), Rn("n1", t, e, Mn, -n, -i, -1), Rn("n2", t, e, Mn, n, -i, -1), Rn("n3", t, e, Mn, -n, i, -1), Rn("n4", t, e, Mn, n, i, -1), Rn("f1", t, e, Mn, -n, -i, 1), Rn("f2", t, e, Mn, n, -i, 1), Rn("f3", t, e, Mn, -n, i, 1), Rn("f4", t, e, Mn, n, i, 1), Rn("u1", t, e, Mn, n * 0.7, i * 1.1, -1), Rn("u2", t, e, Mn, -n * 0.7, i * 1.1, -1), Rn("u3", t, e, Mn, 0, i * 2, -1), Rn("cf1", t, e, Mn, -n, 0, 1), Rn("cf2", t, e, Mn, n, 0, 1), Rn("cf3", t, e, Mn, 0, -i, 1), Rn("cf4", t, e, Mn, 0, i, 1), Rn("cn1", t, e, Mn, -n, 0, -1), Rn("cn2", t, e, Mn, n, 0, -1), Rn("cn3", t, e, Mn, 0, -i, -1), Rn("cn4", t, e, Mn, 0, i, -1), e.getAttribute("position").needsUpdate = !0;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Rn(s, e, t, n, i, r, o) {
  id.set(i, r, o).unproject(n);
  const a = e[s];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let h = 0, f = a.length; h < f; h++)
      l.setXYZ(a[h], id.x, id.y, id.z);
  }
}
const rd = /* @__PURE__ */ new xi();
class XD extends qr {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = new Float32Array(24), r = new Mt();
    r.setIndex(new Vt(n, 1)), r.setAttribute("position", new Vt(i, 3)), super(r, new Mi({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && rd.setFromObject(this.object), rd.isEmpty()) return;
    const t = rd.min, n = rd.max, i = this.geometry.attributes.position, r = i.array;
    r[0] = n.x, r[1] = n.y, r[2] = n.z, r[3] = t.x, r[4] = n.y, r[5] = n.z, r[6] = t.x, r[7] = t.y, r[8] = n.z, r[9] = n.x, r[10] = t.y, r[11] = n.z, r[12] = n.x, r[13] = n.y, r[14] = t.z, r[15] = t.x, r[16] = n.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = n.x, r[22] = t.y, r[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class JD extends qr {
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], r = new Mt();
    r.setIndex(new Vt(n, 1)), r.setAttribute("position", new $e(i, 3)), super(r, new Mi({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class YD extends Js {
  constructor(e, t = 1, n = 16776960) {
    const i = n, r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new Mt();
    o.setAttribute("position", new $e(r, 3)), o.computeBoundingSphere(), super(o, new Mi({ color: i, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new Mt();
    l.setAttribute("position", new $e(a, 3)), l.computeBoundingSphere(), this.add(new kn(l, new ur({ color: i, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const iM = /* @__PURE__ */ new k();
let sd, wg;
class KD extends zt {
  // dir is assumed to be normalized
  constructor(e = new k(0, 0, 1), t = new k(0, 0, 0), n = 1, i = 16776960, r = n * 0.2, o = r * 0.2) {
    super(), this.type = "ArrowHelper", sd === void 0 && (sd = new Mt(), sd.setAttribute("position", new $e([0, 0, 0, 0, 1, 0], 3)), wg = new Mc(0, 0.5, 1, 5, 1), wg.translate(0, -0.5, 0)), this.position.copy(t), this.line = new Js(sd, new Mi({ color: i, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new kn(wg, new ur({ color: i, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, o);
  }
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      iM.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(iM, t);
    }
  }
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class qD extends qr {
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], i = new Mt();
    i.setAttribute("position", new $e(t, 3)), i.setAttribute("color", new $e(n, 3));
    const r = new Mi({ vertexColors: !0, toneMapped: !1 });
    super(i, r), this.type = "AxesHelper";
  }
  setColors(e, t, n) {
    const i = new Ne(), r = this.geometry.attributes.color.array;
    return i.set(e), i.toArray(r, 0), i.toArray(r, 3), i.set(t), i.toArray(r, 6), i.toArray(r, 9), i.set(n), i.toArray(r, 12), i.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class QD {
  constructor() {
    this.type = "ShapePath", this.color = new Ne(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new Vu(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, n, i) {
    return this.currentPath.quadraticCurveTo(e, t, n, i), this;
  }
  bezierCurveTo(e, t, n, i, r, o) {
    return this.currentPath.bezierCurveTo(e, t, n, i, r, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(v) {
      const S = [];
      for (let M = 0, T = v.length; M < T; M++) {
        const P = v[M], b = new wa();
        b.curves = P.curves, S.push(b);
      }
      return S;
    }
    function n(v, S) {
      const M = S.length;
      let T = !1;
      for (let P = M - 1, b = 0; b < M; P = b++) {
        let R = S[P], U = S[b], C = U.x - R.x, B = U.y - R.y;
        if (Math.abs(B) > Number.EPSILON) {
          if (B < 0 && (R = S[b], C = -C, U = S[P], B = -B), v.y < R.y || v.y > U.y) continue;
          if (v.y === R.y) {
            if (v.x === R.x) return !0;
          } else {
            const G = B * (v.x - R.x) - C * (v.y - R.y);
            if (G === 0) return !0;
            if (G < 0) continue;
            T = !T;
          }
        } else {
          if (v.y !== R.y) continue;
          if (U.x <= v.x && v.x <= R.x || R.x <= v.x && v.x <= U.x) return !0;
        }
      }
      return T;
    }
    const i = ps.isClockWise, r = this.subPaths;
    if (r.length === 0) return [];
    let o, a, l;
    const h = [];
    if (r.length === 1)
      return a = r[0], l = new wa(), l.curves = a.curves, h.push(l), h;
    let f = !i(r[0].getPoints());
    f = e ? !f : f;
    const d = [], p = [];
    let m = [], _ = 0, x;
    p[_] = void 0, m[_] = [];
    for (let v = 0, S = r.length; v < S; v++)
      a = r[v], x = a.getPoints(), o = i(x), o = e ? !o : o, o ? (!f && p[_] && _++, p[_] = { s: new wa(), p: x }, p[_].s.curves = a.curves, f && _++, m[_] = []) : m[_].push({ h: a, p: x[0] });
    if (!p[0]) return t(r);
    if (p.length > 1) {
      let v = !1, S = 0;
      for (let M = 0, T = p.length; M < T; M++)
        d[M] = [];
      for (let M = 0, T = p.length; M < T; M++) {
        const P = m[M];
        for (let b = 0; b < P.length; b++) {
          const R = P[b];
          let U = !0;
          for (let C = 0; C < p.length; C++)
            n(R.p, p[C].p) && (M !== C && S++, U ? (U = !1, d[C].push(R)) : v = !0);
          U && d[M].push(R);
        }
      }
      S > 0 && v === !1 && (m = d);
    }
    let y;
    for (let v = 0, S = p.length; v < S; v++) {
      l = p[v].s, h.push(l), y = m[v];
      for (let M = 0, T = y.length; M < T; M++)
        l.holes.push(y[M].h);
    }
    return h;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: rh
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = rh);
const ZD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: w0,
  AddEquation: go,
  AddOperation: VS,
  AdditiveAnimationBlendMode: D0,
  AdditiveBlending: c_,
  AgXToneMapping: KS,
  AlphaFormat: jS,
  AlwaysCompare: _E,
  AlwaysDepth: US,
  AlwaysStencilFunc: G_,
  AmbientLight: h1,
  AnimationAction: x1,
  AnimationClip: lc,
  AnimationLoader: eD,
  AnimationMixer: CD,
  AnimationObjectGroup: TD,
  AnimationUtils: QL,
  ArcCurve: kE,
  ArrayCamera: LE,
  ArrowHelper: KD,
  AttachedBindMode: p_,
  Audio: v1,
  AudioAnalyser: mD,
  AudioContext: pv,
  AudioListener: fD,
  AudioLoader: cD,
  AxesHelper: qD,
  BackSide: Oi,
  BasicDepthPacking: lE,
  BasicShadowMap: vS,
  BatchedMesh: NE,
  Bone: gp,
  BooleanKeyframeTrack: Xa,
  Box2: DD,
  Box3: xi,
  Box3Helper: JD,
  BoxGeometry: Wa,
  BoxHelper: XD,
  BufferAttribute: Vt,
  BufferGeometry: Mt,
  BufferGeometryLoader: g1,
  ByteType: QS,
  Cache: Gs,
  Camera: ah,
  CameraHelper: WD,
  CanvasTexture: xL,
  CapsuleGeometry: xp,
  CatmullRomCurve3: GE,
  CineonToneMapping: JS,
  CircleGeometry: Ap,
  ClampToEdgeWrapping: ri,
  Clock: mv,
  Color: Ne,
  ColorKeyframeTrack: lv,
  ColorManagement: Qt,
  CompressedArrayTexture: vL,
  CompressedCubeTexture: yL,
  CompressedTexture: vp,
  CompressedTextureLoader: tD,
  ConeGeometry: Mp,
  ConstantAlphaFactor: LS,
  ConstantColorFactor: PS,
  CubeCamera: EE,
  CubeReflectionMapping: Xs,
  CubeRefractionMapping: Ro,
  CubeTexture: lh,
  CubeTextureLoader: nD,
  CubeUVReflectionMapping: _c,
  CubicBezierCurve: tv,
  CubicBezierCurve3: HE,
  CubicInterpolant: s1,
  CullFaceBack: l_,
  CullFaceFront: _S,
  CullFaceFrontBack: hC,
  CullFaceNone: gS,
  Curve: Qr,
  CurvePath: VE,
  CustomBlending: yS,
  CustomToneMapping: YS,
  CylinderGeometry: Mc,
  Cylindrical: LD,
  Data3DTexture: G0,
  DataArrayTexture: fp,
  DataTexture: Ta,
  DataTextureLoader: iD,
  DataUtils: _b,
  DecrementStencilOp: xC,
  DecrementWrapStencilOp: MC,
  DefaultLoadingManager: l1,
  DepthFormat: So,
  DepthStencilFormat: Da,
  DepthTexture: W0,
  DetachedBindMode: qS,
  DirectionalLight: dv,
  DirectionalLightHelper: VD,
  DiscreteInterpolant: o1,
  DisplayP3ColorSpace: hp,
  DodecahedronGeometry: Sp,
  DoubleSide: Xr,
  DstAlphaFactor: wS,
  DstColorFactor: bS,
  DynamicCopyUsage: OC,
  DynamicDrawUsage: PC,
  DynamicReadUsage: DC,
  EdgesGeometry: WE,
  EllipseCurve: yp,
  EqualCompare: dE,
  EqualDepth: NS,
  EqualStencilFunc: wC,
  EquirectangularReflectionMapping: Du,
  EquirectangularRefractionMapping: Fu,
  Euler: yc,
  EventDispatcher: qs,
  ExtrudeGeometry: Tp,
  FileLoader: pr,
  Float16BufferAttribute: Sb,
  Float32BufferAttribute: $e,
  Float64BufferAttribute: Eb,
  FloatType: Jr,
  Fog: mp,
  FogExp2: pp,
  FramebufferTexture: _L,
  FrontSide: gs,
  Frustum: ch,
  GLBufferAttribute: PD,
  GLSL1: kC,
  GLSL3: H_,
  GreaterCompare: pE,
  GreaterDepth: GS,
  GreaterEqualCompare: gE,
  GreaterEqualDepth: kS,
  GreaterEqualStencilFunc: BC,
  GreaterStencilFunc: bC,
  GridHelper: HD,
  Group: ks,
  HalfFloatType: ic,
  HemisphereLight: u1,
  HemisphereLightHelper: GD,
  IcosahedronGeometry: wp,
  ImageBitmapLoader: _1,
  ImageLoader: Yu,
  ImageUtils: k0,
  IncrementStencilOp: yC,
  IncrementWrapStencilOp: AC,
  InstancedBufferAttribute: Ua,
  InstancedBufferGeometry: m1,
  InstancedInterleavedBuffer: BD,
  InstancedMesh: Z0,
  Int16BufferAttribute: Ab,
  Int32BufferAttribute: Mb,
  Int8BufferAttribute: vb,
  IntType: C0,
  InterleavedBuffer: hh,
  InterleavedBufferAttribute: Po,
  Interpolant: Sc,
  InterpolateDiscrete: rc,
  InterpolateLinear: Fa,
  InterpolateSmooth: bd,
  InvertStencilOp: SC,
  KeepStencilOp: la,
  KeyframeTrack: Zr,
  LOD: OE,
  LatheGeometry: dh,
  Layers: Ea,
  LessCompare: fE,
  LessDepth: OS,
  LessEqualCompare: O0,
  LessEqualDepth: Lu,
  LessEqualStencilFunc: CC,
  LessStencilFunc: TC,
  Light: No,
  LightProbe: p1,
  Line: Js,
  Line3: FD,
  LineBasicMaterial: Mi,
  LineCurve: nv,
  LineCurve3: zE,
  LineDashedMaterial: n1,
  LineLoop: j0,
  LineSegments: qr,
  LinearDisplayP3ColorSpace: oh,
  LinearEncoding: U0,
  LinearFilter: gn,
  LinearInterpolant: av,
  LinearMipMapLinearFilter: gC,
  LinearMipMapNearestFilter: mC,
  LinearMipmapLinearFilter: _s,
  LinearMipmapNearestFilter: lp,
  LinearSRGBColorSpace: vs,
  LinearToneMapping: WS,
  LinearTransfer: Nu,
  Loader: Si,
  LoaderUtils: To,
  LoadingManager: cv,
  LoopOnce: rE,
  LoopPingPong: oE,
  LoopRepeat: sE,
  LuminanceAlphaFormat: eE,
  LuminanceFormat: $S,
  MOUSE: cC,
  Material: Xn,
  MaterialLoader: Lp,
  MathUtils: _u,
  Matrix3: Ct,
  Matrix4: pt,
  MaxEquation: d_,
  Mesh: kn,
  MeshBasicMaterial: ur,
  MeshDepthMaterial: X0,
  MeshDistanceMaterial: J0,
  MeshLambertMaterial: e1,
  MeshMatcapMaterial: t1,
  MeshNormalMaterial: $E,
  MeshPhongMaterial: ZE,
  MeshPhysicalMaterial: Ur,
  MeshStandardMaterial: gh,
  MeshToonMaterial: jE,
  MinEquation: f_,
  MirroredRepeatWrapping: nc,
  MixOperation: zS,
  MultiplyBlending: h_,
  MultiplyOperation: sh,
  NearestFilter: Sn,
  NearestMipMapLinearFilter: pC,
  NearestMipMapNearestFilter: dC,
  NearestMipmapLinearFilter: Jl,
  NearestMipmapNearestFilter: Uu,
  NeverCompare: hE,
  NeverDepth: FS,
  NeverStencilFunc: EC,
  NoBlending: zs,
  NoColorSpace: ar,
  NoToneMapping: fs,
  NormalAnimationBlendMode: up,
  NormalBlending: Ma,
  NotEqualCompare: mE,
  NotEqualDepth: HS,
  NotEqualStencilFunc: RC,
  NumberKeyframeTrack: Na,
  Object3D: zt,
  ObjectLoader: aD,
  ObjectSpaceNormalMap: uE,
  OctahedronGeometry: ph,
  OneFactor: SS,
  OneMinusConstantAlphaFactor: DS,
  OneMinusConstantColorFactor: IS,
  OneMinusDstAlphaFactor: CS,
  OneMinusDstColorFactor: RS,
  OneMinusSrcAlphaFactor: Hd,
  OneMinusSrcColorFactor: TS,
  OrthographicCamera: xc,
  P3Primaries: Gu,
  PCFShadowMap: op,
  PCFSoftShadowMap: mu,
  PMREMGenerator: V_,
  Path: Vu,
  PerspectiveCamera: Wn,
  Plane: mo,
  PlaneGeometry: uh,
  PlaneHelper: YD,
  PointLight: fv,
  PointLightHelper: ND,
  Points: $0,
  PointsMaterial: _p,
  PolarGridHelper: zD,
  PolyhedronGeometry: Oo,
  PositionalAudio: pD,
  PropertyBinding: Ht,
  PropertyMixer: y1,
  QuadraticBezierCurve: iv,
  QuadraticBezierCurve3: rv,
  Quaternion: yi,
  QuaternionKeyframeTrack: Io,
  QuaternionLinearInterpolant: a1,
  RED_GREEN_RGTC2_Format: N_,
  RED_RGTC1_Format: iE,
  REVISION: rh,
  RGBADepthPacking: cE,
  RGBAFormat: Di,
  RGBAIntegerFormat: I0,
  RGBA_ASTC_10x10_Format: I_,
  RGBA_ASTC_10x5_Format: R_,
  RGBA_ASTC_10x6_Format: B_,
  RGBA_ASTC_10x8_Format: P_,
  RGBA_ASTC_12x10_Format: L_,
  RGBA_ASTC_12x12_Format: D_,
  RGBA_ASTC_4x4_Format: A_,
  RGBA_ASTC_5x4_Format: M_,
  RGBA_ASTC_5x5_Format: S_,
  RGBA_ASTC_6x5_Format: E_,
  RGBA_ASTC_6x6_Format: T_,
  RGBA_ASTC_8x5_Format: w_,
  RGBA_ASTC_8x6_Format: C_,
  RGBA_ASTC_8x8_Format: b_,
  RGBA_BPTC_Format: Cd,
  RGBA_ETC2_EAC_Format: x_,
  RGBA_PVRTC_2BPPV1_Format: v_,
  RGBA_PVRTC_4BPPV1_Format: __,
  RGBA_S3TC_DXT1_Format: Ed,
  RGBA_S3TC_DXT3_Format: Td,
  RGBA_S3TC_DXT5_Format: wd,
  RGB_BPTC_SIGNED_Format: F_,
  RGB_BPTC_UNSIGNED_Format: U_,
  RGB_ETC1_Format: L0,
  RGB_ETC2_Format: y_,
  RGB_PVRTC_2BPPV1_Format: g_,
  RGB_PVRTC_4BPPV1_Format: m_,
  RGB_S3TC_DXT1_Format: Sd,
  RGFormat: nE,
  RGIntegerFormat: P0,
  RawShaderMaterial: QE,
  Ray: vc,
  Raycaster: A1,
  Rec709Primaries: ku,
  RectAreaLight: f1,
  RedFormat: tE,
  RedIntegerFormat: B0,
  ReinhardToneMapping: XS,
  RenderTarget: xE,
  RepeatWrapping: Bo,
  ReplaceStencilOp: vC,
  ReverseSubtractEquation: AS,
  RingGeometry: Cp,
  SIGNED_RED_GREEN_RGTC2_Format: k_,
  SIGNED_RED_RGTC1_Format: O_,
  SRGBColorSpace: Vn,
  SRGBTransfer: on,
  Scene: K0,
  ShaderChunk: Et,
  ShaderLib: Wr,
  ShaderMaterial: ys,
  ShadowMaterial: qE,
  Shape: wa,
  ShapeGeometry: bp,
  ShapePath: QD,
  ShapeUtils: ps,
  ShortType: ZS,
  Skeleton: fh,
  SkeletonHelper: OD,
  SkinnedMesh: Q0,
  Source: ga,
  Sphere: oi,
  SphereGeometry: mh,
  Spherical: ID,
  SphericalHarmonics3: d1,
  SplineCurve: sv,
  SpotLight: hv,
  SpotLightHelper: UD,
  Sprite: UE,
  SpriteMaterial: q0,
  SrcAlphaFactor: Gd,
  SrcAlphaSaturateFactor: BS,
  SrcColorFactor: ES,
  StaticCopyUsage: UC,
  StaticDrawUsage: Hu,
  StaticReadUsage: LC,
  StereoCamera: uD,
  StreamCopyUsage: NC,
  StreamDrawUsage: IC,
  StreamReadUsage: FC,
  StringKeyframeTrack: Ja,
  SubtractEquation: xS,
  SubtractiveBlending: u_,
  TOUCH: uC,
  TangentSpaceNormalMap: Uo,
  TetrahedronGeometry: Rp,
  Texture: yn,
  TextureLoader: c1,
  TorusGeometry: Bp,
  TorusKnotGeometry: Pp,
  Triangle: Vi,
  TriangleFanDrawMode: zd,
  TriangleStripDrawMode: F0,
  TrianglesDrawMode: aE,
  TubeGeometry: Ip,
  TwoPassDoubleSide: fC,
  UVMapping: ap,
  Uint16BufferAttribute: H0,
  Uint32BufferAttribute: z0,
  Uint8BufferAttribute: yb,
  Uint8ClampedBufferAttribute: xb,
  Uniform: vv,
  UniformsGroup: RD,
  UniformsLib: Fe,
  UniformsUtils: SE,
  UnsignedByteType: ds,
  UnsignedInt248Type: Mo,
  UnsignedIntType: Ns,
  UnsignedShort4444Type: b0,
  UnsignedShort5551Type: R0,
  UnsignedShortType: cp,
  VSMShadowMap: Vr,
  Vector2: ve,
  Vector3: k,
  Vector4: Zt,
  VectorKeyframeTrack: ka,
  VideoTexture: gL,
  WebGL1Renderer: DE,
  WebGL3DRenderTarget: sb,
  WebGLArrayRenderTarget: rb,
  WebGLCoordinateSystem: Yr,
  WebGLCubeRenderTarget: TE,
  WebGLMultipleRenderTargets: ob,
  WebGLRenderTarget: Kr,
  WebGLRenderer: Y0,
  WebGLUtils: IE,
  WebGPUCoordinateSystem: sc,
  WireframeGeometry: KE,
  WrapAroundEnding: Ou,
  ZeroCurvatureEnding: pa,
  ZeroFactor: MS,
  ZeroSlopeEnding: ma,
  ZeroStencilOp: _C,
  _SRGBAFormat: Vd,
  createCanvasElement: yE,
  sRGBEncoding: Eo
}, Symbol.toStringTag, { value: "Module" }));
var Cg = { exports: {} }, ho = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rM;
function jD() {
  return rM || (rM = 1, ho.ConcurrentRoot = 1, ho.ContinuousEventPriority = 4, ho.DefaultEventPriority = 16, ho.DiscreteEventPriority = 1, ho.IdleEventPriority = 536870912, ho.LegacyRoot = 0), ho;
}
var sM;
function $D() {
  return sM || (sM = 1, Cg.exports = jD()), Cg.exports;
}
var zl = $D();
function e2(s) {
  let e;
  const t = /* @__PURE__ */ new Set(), n = (h, f) => {
    const d = typeof h == "function" ? h(e) : h;
    if (d !== e) {
      const p = e;
      e = f ? d : Object.assign({}, e, d), t.forEach((m) => m(e, p));
    }
  }, i = () => e, r = (h, f = i, d = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let p = f(e);
    function m() {
      const _ = f(e);
      if (!d(p, _)) {
        const x = p;
        h(p = _, x);
      }
    }
    return t.add(m), () => t.delete(m);
  }, l = { setState: n, getState: i, subscribe: (h, f, d) => f || d ? r(h, f, d) : (t.add(h), () => t.delete(h)), destroy: () => t.clear() };
  return e = s(n, i, l), l;
}
const t2 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), oM = t2 ? nt.useEffect : nt.useLayoutEffect;
function n2(s) {
  const e = typeof s == "function" ? e2(s) : s, t = (n = e.getState, i = Object.is) => {
    const [, r] = nt.useReducer((y) => y + 1, 0), o = e.getState(), a = nt.useRef(o), l = nt.useRef(n), h = nt.useRef(i), f = nt.useRef(!1), d = nt.useRef();
    d.current === void 0 && (d.current = n(o));
    let p, m = !1;
    (a.current !== o || l.current !== n || h.current !== i || f.current) && (p = n(o), m = !i(d.current, p)), oM(() => {
      m && (d.current = p), a.current = o, l.current = n, h.current = i, f.current = !1;
    });
    const _ = nt.useRef(o);
    oM(() => {
      const y = () => {
        try {
          const S = e.getState(), M = l.current(S);
          h.current(d.current, M) || (a.current = S, d.current = M, r());
        } catch {
          f.current = !0, r();
        }
      }, v = e.subscribe(y);
      return e.getState() !== _.current && y(), v;
    }, []);
    const x = m ? p : d.current;
    return nt.useDebugValue(x), x;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const n = [t, e];
    return {
      next() {
        const i = n.length <= 0;
        return { value: n.shift(), done: i };
      }
    };
  }, t;
}
const i2 = (s) => typeof s == "object" && typeof s.then == "function", va = [];
function S1(s, e, t = (n, i) => n === i) {
  if (s === e) return !0;
  if (!s || !e) return !1;
  const n = s.length;
  if (e.length !== n) return !1;
  for (let i = 0; i < n; i++) if (!t(s[i], e[i])) return !1;
  return !0;
}
function E1(s, e = null, t = !1, n = {}) {
  e === null && (e = [s]);
  for (const r of va)
    if (S1(e, r.keys, r.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(r, "error")) throw r.error;
      if (Object.prototype.hasOwnProperty.call(r, "response"))
        return n.lifespan && n.lifespan > 0 && (r.timeout && clearTimeout(r.timeout), r.timeout = setTimeout(r.remove, n.lifespan)), r.response;
      if (!t) throw r.promise;
    }
  const i = {
    keys: e,
    equal: n.equal,
    remove: () => {
      const r = va.indexOf(i);
      r !== -1 && va.splice(r, 1);
    },
    promise: (
      // Execute the promise
      (i2(s) ? s : s(...e)).then((r) => {
        i.response = r, n.lifespan && n.lifespan > 0 && (i.timeout = setTimeout(i.remove, n.lifespan));
      }).catch((r) => i.error = r)
    )
  };
  if (va.push(i), !t) throw i.promise;
}
const r2 = (s, e, t) => E1(s, e, !1, t), s2 = (s, e, t) => void E1(s, e, !0, t), o2 = (s) => {
  if (s === void 0 || s.length === 0) va.splice(0, va.length);
  else {
    const e = va.find((t) => S1(s, t.keys, t.equal));
    e && e.remove();
  }
};
var bg = { exports: {} }, Rg = { exports: {} }, Bg = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aM;
function a2() {
  return aM || (aM = 1, function(s) {
    function e(N, V) {
      var I = N.length;
      N.push(V);
      e: for (; 0 < I; ) {
        var D = I - 1 >>> 1, J = N[D];
        if (0 < i(J, V)) N[D] = V, N[I] = J, I = D;
        else break e;
      }
    }
    function t(N) {
      return N.length === 0 ? null : N[0];
    }
    function n(N) {
      if (N.length === 0) return null;
      var V = N[0], I = N.pop();
      if (I !== V) {
        N[0] = I;
        e: for (var D = 0, J = N.length, K = J >>> 1; D < K; ) {
          var ie = 2 * (D + 1) - 1, he = N[ie], ge = ie + 1, me = N[ge];
          if (0 > i(he, I)) ge < J && 0 > i(me, he) ? (N[D] = me, N[ge] = I, D = ge) : (N[D] = he, N[ie] = I, D = ie);
          else if (ge < J && 0 > i(me, I)) N[D] = me, N[ge] = I, D = ge;
          else break e;
        }
      }
      return V;
    }
    function i(N, V) {
      var I = N.sortIndex - V.sortIndex;
      return I !== 0 ? I : N.id - V.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var r = performance;
      s.unstable_now = function() {
        return r.now();
      };
    } else {
      var o = Date, a = o.now();
      s.unstable_now = function() {
        return o.now() - a;
      };
    }
    var l = [], h = [], f = 1, d = null, p = 3, m = !1, _ = !1, x = !1, y = typeof setTimeout == "function" ? setTimeout : null, v = typeof clearTimeout == "function" ? clearTimeout : null, S = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function M(N) {
      for (var V = t(h); V !== null; ) {
        if (V.callback === null) n(h);
        else if (V.startTime <= N) n(h), V.sortIndex = V.expirationTime, e(l, V);
        else break;
        V = t(h);
      }
    }
    function T(N) {
      if (x = !1, M(N), !_) if (t(l) !== null) _ = !0, j(P);
      else {
        var V = t(h);
        V !== null && ee(T, V.startTime - N);
      }
    }
    function P(N, V) {
      _ = !1, x && (x = !1, v(U), U = -1), m = !0;
      var I = p;
      try {
        for (M(V), d = t(l); d !== null && (!(d.expirationTime > V) || N && !G()); ) {
          var D = d.callback;
          if (typeof D == "function") {
            d.callback = null, p = d.priorityLevel;
            var J = D(d.expirationTime <= V);
            V = s.unstable_now(), typeof J == "function" ? d.callback = J : d === t(l) && n(l), M(V);
          } else n(l);
          d = t(l);
        }
        if (d !== null) var K = !0;
        else {
          var ie = t(h);
          ie !== null && ee(T, ie.startTime - V), K = !1;
        }
        return K;
      } finally {
        d = null, p = I, m = !1;
      }
    }
    var b = !1, R = null, U = -1, C = 5, B = -1;
    function G() {
      return !(s.unstable_now() - B < C);
    }
    function W() {
      if (R !== null) {
        var N = s.unstable_now();
        B = N;
        var V = !0;
        try {
          V = R(!0, N);
        } finally {
          V ? se() : (b = !1, R = null);
        }
      } else b = !1;
    }
    var se;
    if (typeof S == "function") se = function() {
      S(W);
    };
    else if (typeof MessageChannel < "u") {
      var z = new MessageChannel(), q = z.port2;
      z.port1.onmessage = W, se = function() {
        q.postMessage(null);
      };
    } else se = function() {
      y(W, 0);
    };
    function j(N) {
      R = N, b || (b = !0, se());
    }
    function ee(N, V) {
      U = y(function() {
        N(s.unstable_now());
      }, V);
    }
    s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(N) {
      N.callback = null;
    }, s.unstable_continueExecution = function() {
      _ || m || (_ = !0, j(P));
    }, s.unstable_forceFrameRate = function(N) {
      0 > N || 125 < N ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < N ? Math.floor(1e3 / N) : 5;
    }, s.unstable_getCurrentPriorityLevel = function() {
      return p;
    }, s.unstable_getFirstCallbackNode = function() {
      return t(l);
    }, s.unstable_next = function(N) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var V = 3;
          break;
        default:
          V = p;
      }
      var I = p;
      p = V;
      try {
        return N();
      } finally {
        p = I;
      }
    }, s.unstable_pauseExecution = function() {
    }, s.unstable_requestPaint = function() {
    }, s.unstable_runWithPriority = function(N, V) {
      switch (N) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          N = 3;
      }
      var I = p;
      p = N;
      try {
        return V();
      } finally {
        p = I;
      }
    }, s.unstable_scheduleCallback = function(N, V, I) {
      var D = s.unstable_now();
      switch (typeof I == "object" && I !== null ? (I = I.delay, I = typeof I == "number" && 0 < I ? D + I : D) : I = D, N) {
        case 1:
          var J = -1;
          break;
        case 2:
          J = 250;
          break;
        case 5:
          J = 1073741823;
          break;
        case 4:
          J = 1e4;
          break;
        default:
          J = 5e3;
      }
      return J = I + J, N = { id: f++, callback: V, priorityLevel: N, startTime: I, expirationTime: J, sortIndex: -1 }, I > D ? (N.sortIndex = I, e(h, N), t(l) === null && N === t(h) && (x ? (v(U), U = -1) : x = !0, ee(T, I - D))) : (N.sortIndex = J, e(l, N), _ || m || (_ = !0, j(P))), N;
    }, s.unstable_shouldYield = G, s.unstable_wrapCallback = function(N) {
      var V = p;
      return function() {
        var I = p;
        p = V;
        try {
          return N.apply(this, arguments);
        } finally {
          p = I;
        }
      };
    };
  }(Bg)), Bg;
}
var lM;
function l2() {
  return lM || (lM = 1, Rg.exports = a2()), Rg.exports;
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Pg, cM;
function c2() {
  return cM || (cM = 1, Pg = function(e) {
    var t = {}, n = T0(), i = l2(), r = Object.assign;
    function o(c) {
      for (var u = "https://reactjs.org/docs/error-decoder.html?invariant=" + c, g = 1; g < arguments.length; g++) u += "&args[]=" + encodeURIComponent(arguments[g]);
      return "Minified React error #" + c + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var a = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = Symbol.for("react.element"), h = Symbol.for("react.portal"), f = Symbol.for("react.fragment"), d = Symbol.for("react.strict_mode"), p = Symbol.for("react.profiler"), m = Symbol.for("react.provider"), _ = Symbol.for("react.context"), x = Symbol.for("react.forward_ref"), y = Symbol.for("react.suspense"), v = Symbol.for("react.suspense_list"), S = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), T = Symbol.for("react.offscreen"), P = Symbol.iterator;
    function b(c) {
      return c === null || typeof c != "object" ? null : (c = P && c[P] || c["@@iterator"], typeof c == "function" ? c : null);
    }
    function R(c) {
      if (c == null) return null;
      if (typeof c == "function") return c.displayName || c.name || null;
      if (typeof c == "string") return c;
      switch (c) {
        case f:
          return "Fragment";
        case h:
          return "Portal";
        case p:
          return "Profiler";
        case d:
          return "StrictMode";
        case y:
          return "Suspense";
        case v:
          return "SuspenseList";
      }
      if (typeof c == "object") switch (c.$$typeof) {
        case _:
          return (c.displayName || "Context") + ".Consumer";
        case m:
          return (c._context.displayName || "Context") + ".Provider";
        case x:
          var u = c.render;
          return c = c.displayName, c || (c = u.displayName || u.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c;
        case S:
          return u = c.displayName || null, u !== null ? u : R(c.type) || "Memo";
        case M:
          u = c._payload, c = c._init;
          try {
            return R(c(u));
          } catch {
          }
      }
      return null;
    }
    function U(c) {
      var u = c.type;
      switch (c.tag) {
        case 24:
          return "Cache";
        case 9:
          return (u.displayName || "Context") + ".Consumer";
        case 10:
          return (u._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return c = u.render, c = c.displayName || c.name || "", u.displayName || (c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return u;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return R(u);
        case 8:
          return u === d ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if (typeof u == "function") return u.displayName || u.name || null;
          if (typeof u == "string") return u;
      }
      return null;
    }
    function C(c) {
      var u = c, g = c;
      if (c.alternate) for (; u.return; ) u = u.return;
      else {
        c = u;
        do
          u = c, (u.flags & 4098) !== 0 && (g = u.return), c = u.return;
        while (c);
      }
      return u.tag === 3 ? g : null;
    }
    function B(c) {
      if (C(c) !== c) throw Error(o(188));
    }
    function G(c) {
      var u = c.alternate;
      if (!u) {
        if (u = C(c), u === null) throw Error(o(188));
        return u !== c ? null : c;
      }
      for (var g = c, A = u; ; ) {
        var E = g.return;
        if (E === null) break;
        var w = E.alternate;
        if (w === null) {
          if (A = E.return, A !== null) {
            g = A;
            continue;
          }
          break;
        }
        if (E.child === w.child) {
          for (w = E.child; w; ) {
            if (w === g) return B(E), c;
            if (w === A) return B(E), u;
            w = w.sibling;
          }
          throw Error(o(188));
        }
        if (g.return !== A.return) g = E, A = w;
        else {
          for (var H = !1, Z = E.child; Z; ) {
            if (Z === g) {
              H = !0, g = E, A = w;
              break;
            }
            if (Z === A) {
              H = !0, A = E, g = w;
              break;
            }
            Z = Z.sibling;
          }
          if (!H) {
            for (Z = w.child; Z; ) {
              if (Z === g) {
                H = !0, g = w, A = E;
                break;
              }
              if (Z === A) {
                H = !0, A = w, g = E;
                break;
              }
              Z = Z.sibling;
            }
            if (!H) throw Error(o(189));
          }
        }
        if (g.alternate !== A) throw Error(o(190));
      }
      if (g.tag !== 3) throw Error(o(188));
      return g.stateNode.current === g ? c : u;
    }
    function W(c) {
      return c = G(c), c !== null ? se(c) : null;
    }
    function se(c) {
      if (c.tag === 5 || c.tag === 6) return c;
      for (c = c.child; c !== null; ) {
        var u = se(c);
        if (u !== null) return u;
        c = c.sibling;
      }
      return null;
    }
    function z(c) {
      if (c.tag === 5 || c.tag === 6) return c;
      for (c = c.child; c !== null; ) {
        if (c.tag !== 4) {
          var u = z(c);
          if (u !== null) return u;
        }
        c = c.sibling;
      }
      return null;
    }
    var q = Array.isArray, j = e.getPublicInstance, ee = e.getRootHostContext, N = e.getChildHostContext, V = e.prepareForCommit, I = e.resetAfterCommit, D = e.createInstance, J = e.appendInitialChild, K = e.finalizeInitialChildren, ie = e.prepareUpdate, he = e.shouldSetTextContent, ge = e.createTextInstance, me = e.scheduleTimeout, Be = e.cancelTimeout, Pe = e.noTimeout, De = e.isPrimaryRenderer, ze = e.supportsMutation, X = e.supportsPersistence, pe = e.supportsHydration, ce = e.getInstanceFromNode, Me = e.preparePortalMount, fe = e.getCurrentEventPriority, Q = e.detachDeletedInstance, Ie = e.supportsMicrotasks, O = e.scheduleMicrotask, L = e.supportsTestSelectors, $ = e.findFiberRoot, xe = e.getBoundingRect, Ae = e.getTextContent, _e = e.isHiddenSubtree, Ue = e.matchAccessibilityRole, Le = e.setFocusIfFocusable, Te = e.setupIntersectionObserver, Ze = e.appendChild, ct = e.appendChildToContainer, ye = e.commitTextUpdate, bt = e.commitMount, et = e.commitUpdate, mt = e.insertBefore, je = e.insertInContainerBefore, Ve = e.removeChild, gt = e.removeChildFromContainer, St = e.resetTextContent, Wt = e.hideInstance, Oe = e.hideTextInstance, Ee = e.unhideInstance, Y = e.unhideTextInstance, Ce = e.clearContainer, be = e.cloneInstance, ot = e.createContainerChildSet, it = e.appendChildToContainerChildSet, It = e.finalizeContainerChildren, kt = e.replaceContainerChildren, Qe = e.cloneHiddenInstance, We = e.cloneHiddenTextInstance, tt = e.canHydrateInstance, Se = e.canHydrateTextInstance, ut = e.canHydrateSuspenseInstance, rt = e.isSuspenseInstancePending, _t = e.isSuspenseInstanceFallback, cn = e.registerSuspenseInstanceRetry, yt = e.getNextHydratableSibling, jt = e.getFirstHydratableChild, wn = e.getFirstHydratableChildWithinContainer, en = e.getFirstHydratableChildWithinSuspenseInstance, $t = e.hydrateInstance, Kt = e.hydrateTextInstance, Ei = e.hydrateSuspenseInstance, F = e.getNextHydratableInstanceAfterSuspenseInstance, te = e.commitHydratedContainer, ae = e.commitHydratedSuspenseInstance, oe = e.clearSuspenseBoundary, re = e.clearSuspenseBoundaryFromContainer, Re = e.shouldDeleteUnhydratedTailInstances, Je = e.didNotMatchHydratedContainerTextInstance, ht = e.didNotMatchHydratedTextInstance, Xe;
    function Ye(c) {
      if (Xe === void 0) try {
        throw Error();
      } catch (g) {
        var u = g.stack.trim().match(/\n( *(at )?)/);
        Xe = u && u[1] || "";
      }
      return `
` + Xe + c;
    }
    var at = !1;
    function vt(c, u) {
      if (!c || at) return "";
      at = !0;
      var g = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (u) if (u = function() {
          throw Error();
        }, Object.defineProperty(u.prototype, "props", { set: function() {
          throw Error();
        } }), typeof Reflect == "object" && Reflect.construct) {
          try {
            Reflect.construct(u, []);
          } catch (we) {
            var A = we;
          }
          Reflect.construct(c, [], u);
        } else {
          try {
            u.call();
          } catch (we) {
            A = we;
          }
          c.call(u.prototype);
        }
        else {
          try {
            throw Error();
          } catch (we) {
            A = we;
          }
          c();
        }
      } catch (we) {
        if (we && A && typeof we.stack == "string") {
          for (var E = we.stack.split(`
`), w = A.stack.split(`
`), H = E.length - 1, Z = w.length - 1; 1 <= H && 0 <= Z && E[H] !== w[Z]; ) Z--;
          for (; 1 <= H && 0 <= Z; H--, Z--) if (E[H] !== w[Z]) {
            if (H !== 1 || Z !== 1)
              do
                if (H--, Z--, 0 > Z || E[H] !== w[Z]) {
                  var de = `
` + E[H].replace(" at new ", " at ");
                  return c.displayName && de.includes("<anonymous>") && (de = de.replace("<anonymous>", c.displayName)), de;
                }
              while (1 <= H && 0 <= Z);
            break;
          }
        }
      } finally {
        at = !1, Error.prepareStackTrace = g;
      }
      return (c = c ? c.displayName || c.name : "") ? Ye(c) : "";
    }
    var sn = Object.prototype.hasOwnProperty, dn = [], Nt = -1;
    function un(c) {
      return { current: c };
    }
    function ft(c) {
      0 > Nt || (c.current = dn[Nt], dn[Nt] = null, Nt--);
    }
    function ke(c, u) {
      Nt++, dn[Nt] = c.current, c.current = u;
    }
    var _r = {}, Rt = un(_r), xn = un(!1), jr = _r;
    function vr(c, u) {
      var g = c.type.contextTypes;
      if (!g) return _r;
      var A = c.stateNode;
      if (A && A.__reactInternalMemoizedUnmaskedChildContext === u) return A.__reactInternalMemoizedMaskedChildContext;
      var E = {}, w;
      for (w in g) E[w] = u[w];
      return A && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = u, c.__reactInternalMemoizedMaskedChildContext = E), E;
    }
    function Kn(c) {
      return c = c.childContextTypes, c != null;
    }
    function Cn() {
      ft(xn), ft(Rt);
    }
    function $r(c, u, g) {
      if (Rt.current !== _r) throw Error(o(168));
      ke(Rt, u), ke(xn, g);
    }
    function Ka(c, u, g) {
      var A = c.stateNode;
      if (u = u.childContextTypes, typeof A.getChildContext != "function") return g;
      A = A.getChildContext();
      for (var E in A) if (!(E in u)) throw Error(o(108, U(c) || "Unknown", E));
      return r({}, g, A);
    }
    function ni(c) {
      return c = (c = c.stateNode) && c.__reactInternalMemoizedMergedChildContext || _r, jr = Rt.current, ke(Rt, c), ke(xn, xn.current), !0;
    }
    function qa(c, u, g) {
      var A = c.stateNode;
      if (!A) throw Error(o(169));
      g ? (c = Ka(c, u, jr), A.__reactInternalMemoizedMergedChildContext = c, ft(xn), ft(Rt), ke(Rt, c)) : ft(xn), ke(xn, g);
    }
    var Qi = Math.clz32 ? Math.clz32 : gw, xh = Math.log, mw = Math.LN2;
    function gw(c) {
      return c >>>= 0, c === 0 ? 32 : 31 - (xh(c) / mw | 0) | 0;
    }
    var Ah = 64, Mh = 4194304;
    function Ec(c) {
      switch (c & -c) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return c & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return c & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return c;
      }
    }
    function Sh(c, u) {
      var g = c.pendingLanes;
      if (g === 0) return 0;
      var A = 0, E = c.suspendedLanes, w = c.pingedLanes, H = g & 268435455;
      if (H !== 0) {
        var Z = H & ~E;
        Z !== 0 ? A = Ec(Z) : (w &= H, w !== 0 && (A = Ec(w)));
      } else H = g & ~E, H !== 0 ? A = Ec(H) : w !== 0 && (A = Ec(w));
      if (A === 0) return 0;
      if (u !== 0 && u !== A && (u & E) === 0 && (E = A & -A, w = u & -u, E >= w || E === 16 && (w & 4194240) !== 0)) return u;
      if ((A & 4) !== 0 && (A |= g & 16), u = c.entangledLanes, u !== 0) for (c = c.entanglements, u &= A; 0 < u; ) g = 31 - Qi(u), E = 1 << g, A |= c[g], u &= ~E;
      return A;
    }
    function _w(c, u) {
      switch (c) {
        case 1:
        case 2:
        case 4:
          return u + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return u + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function vw(c, u) {
      for (var g = c.suspendedLanes, A = c.pingedLanes, E = c.expirationTimes, w = c.pendingLanes; 0 < w; ) {
        var H = 31 - Qi(w), Z = 1 << H, de = E[H];
        de === -1 ? ((Z & g) === 0 || (Z & A) !== 0) && (E[H] = _w(Z, u)) : de <= u && (c.expiredLanes |= Z), w &= ~Z;
      }
    }
    function Np(c) {
      return c = c.pendingLanes & -1073741825, c !== 0 ? c : c & 1073741824 ? 1073741824 : 0;
    }
    function kp(c) {
      for (var u = [], g = 0; 31 > g; g++) u.push(c);
      return u;
    }
    function Tc(c, u, g) {
      c.pendingLanes |= u, u !== 536870912 && (c.suspendedLanes = 0, c.pingedLanes = 0), c = c.eventTimes, u = 31 - Qi(u), c[u] = g;
    }
    function yw(c, u) {
      var g = c.pendingLanes & ~u;
      c.pendingLanes = u, c.suspendedLanes = 0, c.pingedLanes = 0, c.expiredLanes &= u, c.mutableReadLanes &= u, c.entangledLanes &= u, u = c.entanglements;
      var A = c.eventTimes;
      for (c = c.expirationTimes; 0 < g; ) {
        var E = 31 - Qi(g), w = 1 << E;
        u[E] = 0, A[E] = -1, c[E] = -1, g &= ~w;
      }
    }
    function Gp(c, u) {
      var g = c.entangledLanes |= u;
      for (c = c.entanglements; g; ) {
        var A = 31 - Qi(g), E = 1 << A;
        E & u | c[A] & u && (c[A] |= u), g &= ~E;
      }
    }
    var Xt = 0;
    function Kv(c) {
      return c &= -c, 1 < c ? 4 < c ? (c & 268435455) !== 0 ? 16 : 536870912 : 4 : 1;
    }
    var Hp = i.unstable_scheduleCallback, qv = i.unstable_cancelCallback, xw = i.unstable_shouldYield, Aw = i.unstable_requestPaint, qn = i.unstable_now, zp = i.unstable_ImmediatePriority, Mw = i.unstable_UserBlockingPriority, Vp = i.unstable_NormalPriority, Sw = i.unstable_IdlePriority, Eh = null, es = null;
    function Ew(c) {
      if (es && typeof es.onCommitFiberRoot == "function") try {
        es.onCommitFiberRoot(Eh, c, void 0, (c.current.flags & 128) === 128);
      } catch {
      }
    }
    function Tw(c, u) {
      return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
    }
    var ts = typeof Object.is == "function" ? Object.is : Tw, As = null, Th = !1, Wp = !1;
    function Qv(c) {
      As === null ? As = [c] : As.push(c);
    }
    function ww(c) {
      Th = !0, Qv(c);
    }
    function ns() {
      if (!Wp && As !== null) {
        Wp = !0;
        var c = 0, u = Xt;
        try {
          var g = As;
          for (Xt = 1; c < g.length; c++) {
            var A = g[c];
            do
              A = A(!0);
            while (A !== null);
          }
          As = null, Th = !1;
        } catch (E) {
          throw As !== null && (As = As.slice(c + 1)), Hp(zp, ns), E;
        } finally {
          Xt = u, Wp = !1;
        }
      }
      return null;
    }
    var Cw = a.ReactCurrentBatchConfig;
    function wh(c, u) {
      if (ts(c, u)) return !0;
      if (typeof c != "object" || c === null || typeof u != "object" || u === null) return !1;
      var g = Object.keys(c), A = Object.keys(u);
      if (g.length !== A.length) return !1;
      for (A = 0; A < g.length; A++) {
        var E = g[A];
        if (!sn.call(u, E) || !ts(c[E], u[E])) return !1;
      }
      return !0;
    }
    function bw(c) {
      switch (c.tag) {
        case 5:
          return Ye(c.type);
        case 16:
          return Ye("Lazy");
        case 13:
          return Ye("Suspense");
        case 19:
          return Ye("SuspenseList");
        case 0:
        case 2:
        case 15:
          return c = vt(c.type, !1), c;
        case 11:
          return c = vt(c.type.render, !1), c;
        case 1:
          return c = vt(c.type, !0), c;
        default:
          return "";
      }
    }
    function Or(c, u) {
      if (c && c.defaultProps) {
        u = r({}, u), c = c.defaultProps;
        for (var g in c) u[g] === void 0 && (u[g] = c[g]);
        return u;
      }
      return u;
    }
    var Ch = un(null), bh = null, Qa = null, Xp = null;
    function Jp() {
      Xp = Qa = bh = null;
    }
    function Zv(c, u, g) {
      De ? (ke(Ch, u._currentValue), u._currentValue = g) : (ke(Ch, u._currentValue2), u._currentValue2 = g);
    }
    function Yp(c) {
      var u = Ch.current;
      ft(Ch), De ? c._currentValue = u : c._currentValue2 = u;
    }
    function Kp(c, u, g) {
      for (; c !== null; ) {
        var A = c.alternate;
        if ((c.childLanes & u) !== u ? (c.childLanes |= u, A !== null && (A.childLanes |= u)) : A !== null && (A.childLanes & u) !== u && (A.childLanes |= u), c === g) break;
        c = c.return;
      }
    }
    function Za(c, u) {
      bh = c, Xp = Qa = null, c = c.dependencies, c !== null && c.firstContext !== null && ((c.lanes & u) !== 0 && ($i = !0), c.firstContext = null);
    }
    function yr(c) {
      var u = De ? c._currentValue : c._currentValue2;
      if (Xp !== c) if (c = { context: c, memoizedValue: u, next: null }, Qa === null) {
        if (bh === null) throw Error(o(308));
        Qa = c, bh.dependencies = { lanes: 0, firstContext: c };
      } else Qa = Qa.next = c;
      return u;
    }
    var is = null, Qs = !1;
    function qp(c) {
      c.updateQueue = { baseState: c.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function jv(c, u) {
      c = c.updateQueue, u.updateQueue === c && (u.updateQueue = { baseState: c.baseState, firstBaseUpdate: c.firstBaseUpdate, lastBaseUpdate: c.lastBaseUpdate, shared: c.shared, effects: c.effects });
    }
    function Ms(c, u) {
      return { eventTime: c, lane: u, tag: 0, payload: null, callback: null, next: null };
    }
    function Zs(c, u) {
      var g = c.updateQueue;
      g !== null && (g = g.shared, Ln !== null && (c.mode & 1) !== 0 && (Bt & 2) === 0 ? (c = g.interleaved, c === null ? (u.next = u, is === null ? is = [g] : is.push(g)) : (u.next = c.next, c.next = u), g.interleaved = u) : (c = g.pending, c === null ? u.next = u : (u.next = c.next, c.next = u), g.pending = u));
    }
    function Rh(c, u, g) {
      if (u = u.updateQueue, u !== null && (u = u.shared, (g & 4194240) !== 0)) {
        var A = u.lanes;
        A &= c.pendingLanes, g |= A, u.lanes = g, Gp(c, g);
      }
    }
    function $v(c, u) {
      var g = c.updateQueue, A = c.alternate;
      if (A !== null && (A = A.updateQueue, g === A)) {
        var E = null, w = null;
        if (g = g.firstBaseUpdate, g !== null) {
          do {
            var H = { eventTime: g.eventTime, lane: g.lane, tag: g.tag, payload: g.payload, callback: g.callback, next: null };
            w === null ? E = w = H : w = w.next = H, g = g.next;
          } while (g !== null);
          w === null ? E = w = u : w = w.next = u;
        } else E = w = u;
        g = { baseState: A.baseState, firstBaseUpdate: E, lastBaseUpdate: w, shared: A.shared, effects: A.effects }, c.updateQueue = g;
        return;
      }
      c = g.lastBaseUpdate, c === null ? g.firstBaseUpdate = u : c.next = u, g.lastBaseUpdate = u;
    }
    function Bh(c, u, g, A) {
      var E = c.updateQueue;
      Qs = !1;
      var w = E.firstBaseUpdate, H = E.lastBaseUpdate, Z = E.shared.pending;
      if (Z !== null) {
        E.shared.pending = null;
        var de = Z, we = de.next;
        de.next = null, H === null ? w = we : H.next = we, H = de;
        var Ke = c.alternate;
        Ke !== null && (Ke = Ke.updateQueue, Z = Ke.lastBaseUpdate, Z !== H && (Z === null ? Ke.firstBaseUpdate = we : Z.next = we, Ke.lastBaseUpdate = de));
      }
      if (w !== null) {
        var xt = E.baseState;
        H = 0, Ke = we = de = null, Z = w;
        do {
          var dt = Z.lane, tn = Z.eventTime;
          if ((A & dt) === dt) {
            Ke !== null && (Ke = Ke.next = {
              eventTime: tn,
              lane: 0,
              tag: Z.tag,
              payload: Z.payload,
              callback: Z.callback,
              next: null
            });
            e: {
              var lt = c, hi = Z;
              switch (dt = u, tn = g, hi.tag) {
                case 1:
                  if (lt = hi.payload, typeof lt == "function") {
                    xt = lt.call(tn, xt, dt);
                    break e;
                  }
                  xt = lt;
                  break e;
                case 3:
                  lt.flags = lt.flags & -65537 | 128;
                case 0:
                  if (lt = hi.payload, dt = typeof lt == "function" ? lt.call(tn, xt, dt) : lt, dt == null) break e;
                  xt = r({}, xt, dt);
                  break e;
                case 2:
                  Qs = !0;
              }
            }
            Z.callback !== null && Z.lane !== 0 && (c.flags |= 64, dt = E.effects, dt === null ? E.effects = [Z] : dt.push(Z));
          } else tn = { eventTime: tn, lane: dt, tag: Z.tag, payload: Z.payload, callback: Z.callback, next: null }, Ke === null ? (we = Ke = tn, de = xt) : Ke = Ke.next = tn, H |= dt;
          if (Z = Z.next, Z === null) {
            if (Z = E.shared.pending, Z === null) break;
            dt = Z, Z = dt.next, dt.next = null, E.lastBaseUpdate = dt, E.shared.pending = null;
          }
        } while (!0);
        if (Ke === null && (de = xt), E.baseState = de, E.firstBaseUpdate = we, E.lastBaseUpdate = Ke, u = E.shared.interleaved, u !== null) {
          E = u;
          do
            H |= E.lane, E = E.next;
          while (E !== u);
        } else w === null && (E.shared.lanes = 0);
        ol |= H, c.lanes = H, c.memoizedState = xt;
      }
    }
    function ey(c, u, g) {
      if (c = u.effects, u.effects = null, c !== null) for (u = 0; u < c.length; u++) {
        var A = c[u], E = A.callback;
        if (E !== null) {
          if (A.callback = null, A = g, typeof E != "function") throw Error(o(191, E));
          E.call(A);
        }
      }
    }
    var ty = new n.Component().refs;
    function Qp(c, u, g, A) {
      u = c.memoizedState, g = g(A, u), g = g == null ? u : r({}, u, g), c.memoizedState = g, c.lanes === 0 && (c.updateQueue.baseState = g);
    }
    var Ph = { isMounted: function(c) {
      return (c = c._reactInternals) ? C(c) === c : !1;
    }, enqueueSetState: function(c, u, g) {
      c = c._reactInternals;
      var A = wi(), E = eo(c), w = Ms(A, E);
      w.payload = u, g != null && (w.callback = g), Zs(c, w), u = Er(c, E, A), u !== null && Rh(u, c, E);
    }, enqueueReplaceState: function(c, u, g) {
      c = c._reactInternals;
      var A = wi(), E = eo(c), w = Ms(A, E);
      w.tag = 1, w.payload = u, g != null && (w.callback = g), Zs(c, w), u = Er(c, E, A), u !== null && Rh(u, c, E);
    }, enqueueForceUpdate: function(c, u) {
      c = c._reactInternals;
      var g = wi(), A = eo(c), E = Ms(
        g,
        A
      );
      E.tag = 2, u != null && (E.callback = u), Zs(c, E), u = Er(c, A, g), u !== null && Rh(u, c, A);
    } };
    function ny(c, u, g, A, E, w, H) {
      return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(A, w, H) : u.prototype && u.prototype.isPureReactComponent ? !wh(g, A) || !wh(E, w) : !0;
    }
    function iy(c, u, g) {
      var A = !1, E = _r, w = u.contextType;
      return typeof w == "object" && w !== null ? w = yr(w) : (E = Kn(u) ? jr : Rt.current, A = u.contextTypes, w = (A = A != null) ? vr(c, E) : _r), u = new u(g, w), c.memoizedState = u.state !== null && u.state !== void 0 ? u.state : null, u.updater = Ph, c.stateNode = u, u._reactInternals = c, A && (c = c.stateNode, c.__reactInternalMemoizedUnmaskedChildContext = E, c.__reactInternalMemoizedMaskedChildContext = w), u;
    }
    function ry(c, u, g, A) {
      c = u.state, typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(g, A), typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(g, A), u.state !== c && Ph.enqueueReplaceState(u, u.state, null);
    }
    function Zp(c, u, g, A) {
      var E = c.stateNode;
      E.props = g, E.state = c.memoizedState, E.refs = ty, qp(c);
      var w = u.contextType;
      typeof w == "object" && w !== null ? E.context = yr(w) : (w = Kn(u) ? jr : Rt.current, E.context = vr(c, w)), E.state = c.memoizedState, w = u.getDerivedStateFromProps, typeof w == "function" && (Qp(c, u, w, g), E.state = c.memoizedState), typeof u.getDerivedStateFromProps == "function" || typeof E.getSnapshotBeforeUpdate == "function" || typeof E.UNSAFE_componentWillMount != "function" && typeof E.componentWillMount != "function" || (u = E.state, typeof E.componentWillMount == "function" && E.componentWillMount(), typeof E.UNSAFE_componentWillMount == "function" && E.UNSAFE_componentWillMount(), u !== E.state && Ph.enqueueReplaceState(E, E.state, null), Bh(c, g, E, A), E.state = c.memoizedState), typeof E.componentDidMount == "function" && (c.flags |= 4194308);
    }
    var ja = [], $a = 0, Ih = null, Lh = 0, xr = [], Ar = 0, Go = null, Ss = 1, Es = "";
    function Ho(c, u) {
      ja[$a++] = Lh, ja[$a++] = Ih, Ih = c, Lh = u;
    }
    function sy(c, u, g) {
      xr[Ar++] = Ss, xr[Ar++] = Es, xr[Ar++] = Go, Go = c;
      var A = Ss;
      c = Es;
      var E = 32 - Qi(A) - 1;
      A &= ~(1 << E), g += 1;
      var w = 32 - Qi(u) + E;
      if (30 < w) {
        var H = E - E % 5;
        w = (A & (1 << H) - 1).toString(32), A >>= H, E -= H, Ss = 1 << 32 - Qi(u) + E | g << E | A, Es = w + c;
      } else Ss = 1 << w | g << E | A, Es = c;
    }
    function jp(c) {
      c.return !== null && (Ho(c, 1), sy(c, 1, 0));
    }
    function $p(c) {
      for (; c === Ih; ) Ih = ja[--$a], ja[$a] = null, Lh = ja[--$a], ja[$a] = null;
      for (; c === Go; ) Go = xr[--Ar], xr[Ar] = null, Es = xr[--Ar], xr[Ar] = null, Ss = xr[--Ar], xr[Ar] = null;
    }
    var Zi = null, ji = null, hn = !1, wc = !1, Nr = null;
    function oy(c, u) {
      var g = Tr(5, null, null, 0);
      g.elementType = "DELETED", g.stateNode = u, g.return = c, u = c.deletions, u === null ? (c.deletions = [g], c.flags |= 16) : u.push(g);
    }
    function ay(c, u) {
      switch (c.tag) {
        case 5:
          return u = tt(u, c.type, c.pendingProps), u !== null ? (c.stateNode = u, Zi = c, ji = jt(u), !0) : !1;
        case 6:
          return u = Se(u, c.pendingProps), u !== null ? (c.stateNode = u, Zi = c, ji = null, !0) : !1;
        case 13:
          if (u = ut(u), u !== null) {
            var g = Go !== null ? { id: Ss, overflow: Es } : null;
            return c.memoizedState = { dehydrated: u, treeContext: g, retryLane: 1073741824 }, g = Tr(18, null, null, 0), g.stateNode = u, g.return = c, c.child = g, Zi = c, ji = null, !0;
          }
          return !1;
        default:
          return !1;
      }
    }
    function em(c) {
      return (c.mode & 1) !== 0 && (c.flags & 128) === 0;
    }
    function tm(c) {
      if (hn) {
        var u = ji;
        if (u) {
          var g = u;
          if (!ay(c, u)) {
            if (em(c)) throw Error(o(418));
            u = yt(g);
            var A = Zi;
            u && ay(c, u) ? oy(A, g) : (c.flags = c.flags & -4097 | 2, hn = !1, Zi = c);
          }
        } else {
          if (em(c)) throw Error(o(418));
          c.flags = c.flags & -4097 | 2, hn = !1, Zi = c;
        }
      }
    }
    function ly(c) {
      for (c = c.return; c !== null && c.tag !== 5 && c.tag !== 3 && c.tag !== 13; ) c = c.return;
      Zi = c;
    }
    function Cc(c) {
      if (!pe || c !== Zi) return !1;
      if (!hn) return ly(c), hn = !0, !1;
      if (c.tag !== 3 && (c.tag !== 5 || Re(c.type) && !he(c.type, c.memoizedProps))) {
        var u = ji;
        if (u) {
          if (em(c)) {
            for (c = ji; c; ) c = yt(c);
            throw Error(o(418));
          }
          for (; u; ) oy(c, u), u = yt(u);
        }
      }
      if (ly(c), c.tag === 13) {
        if (!pe) throw Error(o(316));
        if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(o(317));
        ji = F(c);
      } else ji = Zi ? yt(c.stateNode) : null;
      return !0;
    }
    function el() {
      pe && (ji = Zi = null, wc = hn = !1);
    }
    function nm(c) {
      Nr === null ? Nr = [c] : Nr.push(c);
    }
    function bc(c, u, g) {
      if (c = g.ref, c !== null && typeof c != "function" && typeof c != "object") {
        if (g._owner) {
          if (g = g._owner, g) {
            if (g.tag !== 1) throw Error(o(309));
            var A = g.stateNode;
          }
          if (!A) throw Error(o(147, c));
          var E = A, w = "" + c;
          return u !== null && u.ref !== null && typeof u.ref == "function" && u.ref._stringRef === w ? u.ref : (u = function(H) {
            var Z = E.refs;
            Z === ty && (Z = E.refs = {}), H === null ? delete Z[w] : Z[w] = H;
          }, u._stringRef = w, u);
        }
        if (typeof c != "string") throw Error(o(284));
        if (!g._owner) throw Error(o(290, c));
      }
      return c;
    }
    function Dh(c, u) {
      throw c = Object.prototype.toString.call(u), Error(o(31, c === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : c));
    }
    function cy(c) {
      var u = c._init;
      return u(c._payload);
    }
    function uy(c) {
      function u(le, ne) {
        if (c) {
          var ue = le.deletions;
          ue === null ? (le.deletions = [ne], le.flags |= 16) : ue.push(ne);
        }
      }
      function g(le, ne) {
        if (!c) return null;
        for (; ne !== null; ) u(le, ne), ne = ne.sibling;
        return null;
      }
      function A(le, ne) {
        for (le = /* @__PURE__ */ new Map(); ne !== null; ) ne.key !== null ? le.set(ne.key, ne) : le.set(ne.index, ne), ne = ne.sibling;
        return le;
      }
      function E(le, ne) {
        return le = no(le, ne), le.index = 0, le.sibling = null, le;
      }
      function w(le, ne, ue) {
        return le.index = ue, c ? (ue = le.alternate, ue !== null ? (ue = ue.index, ue < ne ? (le.flags |= 2, ne) : ue) : (le.flags |= 2, ne)) : (le.flags |= 1048576, ne);
      }
      function H(le) {
        return c && le.alternate === null && (le.flags |= 2), le;
      }
      function Z(le, ne, ue, He) {
        return ne === null || ne.tag !== 6 ? (ne = km(ue, le.mode, He), ne.return = le, ne) : (ne = E(ne, ue), ne.return = le, ne);
      }
      function de(le, ne, ue, He) {
        var st = ue.type;
        return st === f ? Ke(le, ne, ue.props.children, He, ue.key) : ne !== null && (ne.elementType === st || typeof st == "object" && st !== null && st.$$typeof === M && cy(st) === ne.type) ? (He = E(ne, ue.props), He.ref = bc(le, ne, ue), He.return = le, He) : (He = ff(ue.type, ue.key, ue.props, null, le.mode, He), He.ref = bc(le, ne, ue), He.return = le, He);
      }
      function we(le, ne, ue, He) {
        return ne === null || ne.tag !== 4 || ne.stateNode.containerInfo !== ue.containerInfo || ne.stateNode.implementation !== ue.implementation ? (ne = Gm(ue, le.mode, He), ne.return = le, ne) : (ne = E(ne, ue.children || []), ne.return = le, ne);
      }
      function Ke(le, ne, ue, He, st) {
        return ne === null || ne.tag !== 7 ? (ne = Ko(ue, le.mode, He, st), ne.return = le, ne) : (ne = E(ne, ue), ne.return = le, ne);
      }
      function xt(le, ne, ue) {
        if (typeof ne == "string" && ne !== "" || typeof ne == "number") return ne = km("" + ne, le.mode, ue), ne.return = le, ne;
        if (typeof ne == "object" && ne !== null) {
          switch (ne.$$typeof) {
            case l:
              return ue = ff(ne.type, ne.key, ne.props, null, le.mode, ue), ue.ref = bc(le, null, ne), ue.return = le, ue;
            case h:
              return ne = Gm(ne, le.mode, ue), ne.return = le, ne;
            case M:
              var He = ne._init;
              return xt(le, He(ne._payload), ue);
          }
          if (q(ne) || b(ne)) return ne = Ko(ne, le.mode, ue, null), ne.return = le, ne;
          Dh(le, ne);
        }
        return null;
      }
      function dt(le, ne, ue, He) {
        var st = ne !== null ? ne.key : null;
        if (typeof ue == "string" && ue !== "" || typeof ue == "number") return st !== null ? null : Z(le, ne, "" + ue, He);
        if (typeof ue == "object" && ue !== null) {
          switch (ue.$$typeof) {
            case l:
              return ue.key === st ? de(le, ne, ue, He) : null;
            case h:
              return ue.key === st ? we(le, ne, ue, He) : null;
            case M:
              return st = ue._init, dt(
                le,
                ne,
                st(ue._payload),
                He
              );
          }
          if (q(ue) || b(ue)) return st !== null ? null : Ke(le, ne, ue, He, null);
          Dh(le, ue);
        }
        return null;
      }
      function tn(le, ne, ue, He, st) {
        if (typeof He == "string" && He !== "" || typeof He == "number") return le = le.get(ue) || null, Z(ne, le, "" + He, st);
        if (typeof He == "object" && He !== null) {
          switch (He.$$typeof) {
            case l:
              return le = le.get(He.key === null ? ue : He.key) || null, de(ne, le, He, st);
            case h:
              return le = le.get(He.key === null ? ue : He.key) || null, we(ne, le, He, st);
            case M:
              var wt = He._init;
              return tn(le, ne, ue, wt(He._payload), st);
          }
          if (q(He) || b(He)) return le = le.get(ue) || null, Ke(ne, le, He, st, null);
          Dh(ne, He);
        }
        return null;
      }
      function lt(le, ne, ue, He) {
        for (var st = null, wt = null, At = ne, Jt = ne = 0, Zn = null; At !== null && Jt < ue.length; Jt++) {
          At.index > Jt ? (Zn = At, At = null) : Zn = At.sibling;
          var Yt = dt(le, At, ue[Jt], He);
          if (Yt === null) {
            At === null && (At = Zn);
            break;
          }
          c && At && Yt.alternate === null && u(le, At), ne = w(Yt, ne, Jt), wt === null ? st = Yt : wt.sibling = Yt, wt = Yt, At = Zn;
        }
        if (Jt === ue.length) return g(le, At), hn && Ho(le, Jt), st;
        if (At === null) {
          for (; Jt < ue.length; Jt++) At = xt(le, ue[Jt], He), At !== null && (ne = w(At, ne, Jt), wt === null ? st = At : wt.sibling = At, wt = At);
          return hn && Ho(le, Jt), st;
        }
        for (At = A(le, At); Jt < ue.length; Jt++) Zn = tn(At, le, Jt, ue[Jt], He), Zn !== null && (c && Zn.alternate !== null && At.delete(Zn.key === null ? Jt : Zn.key), ne = w(Zn, ne, Jt), wt === null ? st = Zn : wt.sibling = Zn, wt = Zn);
        return c && At.forEach(function(io) {
          return u(le, io);
        }), hn && Ho(le, Jt), st;
      }
      function hi(le, ne, ue, He) {
        var st = b(ue);
        if (typeof st != "function") throw Error(o(150));
        if (ue = st.call(ue), ue == null) throw Error(o(151));
        for (var wt = st = null, At = ne, Jt = ne = 0, Zn = null, Yt = ue.next(); At !== null && !Yt.done; Jt++, Yt = ue.next()) {
          At.index > Jt ? (Zn = At, At = null) : Zn = At.sibling;
          var io = dt(le, At, Yt.value, He);
          if (io === null) {
            At === null && (At = Zn);
            break;
          }
          c && At && io.alternate === null && u(le, At), ne = w(io, ne, Jt), wt === null ? st = io : wt.sibling = io, wt = io, At = Zn;
        }
        if (Yt.done) return g(
          le,
          At
        ), hn && Ho(le, Jt), st;
        if (At === null) {
          for (; !Yt.done; Jt++, Yt = ue.next()) Yt = xt(le, Yt.value, He), Yt !== null && (ne = w(Yt, ne, Jt), wt === null ? st = Yt : wt.sibling = Yt, wt = Yt);
          return hn && Ho(le, Jt), st;
        }
        for (At = A(le, At); !Yt.done; Jt++, Yt = ue.next()) Yt = tn(At, le, Jt, Yt.value, He), Yt !== null && (c && Yt.alternate !== null && At.delete(Yt.key === null ? Jt : Yt.key), ne = w(Yt, ne, Jt), wt === null ? st = Yt : wt.sibling = Yt, wt = Yt);
        return c && At.forEach(function(rC) {
          return u(le, rC);
        }), hn && Ho(le, Jt), st;
      }
      function wr(le, ne, ue, He) {
        if (typeof ue == "object" && ue !== null && ue.type === f && ue.key === null && (ue = ue.props.children), typeof ue == "object" && ue !== null) {
          switch (ue.$$typeof) {
            case l:
              e: {
                for (var st = ue.key, wt = ne; wt !== null; ) {
                  if (wt.key === st) {
                    if (st = ue.type, st === f) {
                      if (wt.tag === 7) {
                        g(le, wt.sibling), ne = E(wt, ue.props.children), ne.return = le, le = ne;
                        break e;
                      }
                    } else if (wt.elementType === st || typeof st == "object" && st !== null && st.$$typeof === M && cy(st) === wt.type) {
                      g(le, wt.sibling), ne = E(wt, ue.props), ne.ref = bc(le, wt, ue), ne.return = le, le = ne;
                      break e;
                    }
                    g(le, wt);
                    break;
                  } else u(le, wt);
                  wt = wt.sibling;
                }
                ue.type === f ? (ne = Ko(ue.props.children, le.mode, He, ue.key), ne.return = le, le = ne) : (He = ff(ue.type, ue.key, ue.props, null, le.mode, He), He.ref = bc(le, ne, ue), He.return = le, le = He);
              }
              return H(le);
            case h:
              e: {
                for (wt = ue.key; ne !== null; ) {
                  if (ne.key === wt) if (ne.tag === 4 && ne.stateNode.containerInfo === ue.containerInfo && ne.stateNode.implementation === ue.implementation) {
                    g(le, ne.sibling), ne = E(ne, ue.children || []), ne.return = le, le = ne;
                    break e;
                  } else {
                    g(le, ne);
                    break;
                  }
                  else u(le, ne);
                  ne = ne.sibling;
                }
                ne = Gm(ue, le.mode, He), ne.return = le, le = ne;
              }
              return H(le);
            case M:
              return wt = ue._init, wr(le, ne, wt(ue._payload), He);
          }
          if (q(ue)) return lt(le, ne, ue, He);
          if (b(ue)) return hi(le, ne, ue, He);
          Dh(le, ue);
        }
        return typeof ue == "string" && ue !== "" || typeof ue == "number" ? (ue = "" + ue, ne !== null && ne.tag === 6 ? (g(le, ne.sibling), ne = E(ne, ue), ne.return = le, le = ne) : (g(le, ne), ne = km(ue, le.mode, He), ne.return = le, le = ne), H(le)) : g(le, ne);
      }
      return wr;
    }
    var tl = uy(!0), hy = uy(!1), Rc = {}, Mr = un(Rc), Bc = un(Rc), nl = un(Rc);
    function rs(c) {
      if (c === Rc) throw Error(o(174));
      return c;
    }
    function im(c, u) {
      ke(nl, u), ke(Bc, c), ke(Mr, Rc), c = ee(u), ft(Mr), ke(Mr, c);
    }
    function il() {
      ft(Mr), ft(Bc), ft(nl);
    }
    function fy(c) {
      var u = rs(nl.current), g = rs(Mr.current);
      u = N(g, c.type, u), g !== u && (ke(Bc, c), ke(Mr, u));
    }
    function rm(c) {
      Bc.current === c && (ft(Mr), ft(Bc));
    }
    var pn = un(0);
    function Fh(c) {
      for (var u = c; u !== null; ) {
        if (u.tag === 13) {
          var g = u.memoizedState;
          if (g !== null && (g = g.dehydrated, g === null || rt(g) || _t(g))) return u;
        } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
          if ((u.flags & 128) !== 0) return u;
        } else if (u.child !== null) {
          u.child.return = u, u = u.child;
          continue;
        }
        if (u === c) break;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === c) return null;
          u = u.return;
        }
        u.sibling.return = u.return, u = u.sibling;
      }
      return null;
    }
    var sm = [];
    function om() {
      for (var c = 0; c < sm.length; c++) {
        var u = sm[c];
        De ? u._workInProgressVersionPrimary = null : u._workInProgressVersionSecondary = null;
      }
      sm.length = 0;
    }
    var Uh = a.ReactCurrentDispatcher, Sr = a.ReactCurrentBatchConfig, rl = 0, An = null, li = null, Qn = null, Oh = !1, Pc = !1, Ic = 0, Rw = 0;
    function ci() {
      throw Error(o(321));
    }
    function am(c, u) {
      if (u === null) return !1;
      for (var g = 0; g < u.length && g < c.length; g++) if (!ts(c[g], u[g])) return !1;
      return !0;
    }
    function lm(c, u, g, A, E, w) {
      if (rl = w, An = u, u.memoizedState = null, u.updateQueue = null, u.lanes = 0, Uh.current = c === null || c.memoizedState === null ? Lw : Dw, c = g(A, E), Pc) {
        w = 0;
        do {
          if (Pc = !1, Ic = 0, 25 <= w) throw Error(o(301));
          w += 1, Qn = li = null, u.updateQueue = null, Uh.current = Fw, c = g(A, E);
        } while (Pc);
      }
      if (Uh.current = zh, u = li !== null && li.next !== null, rl = 0, Qn = li = An = null, Oh = !1, u) throw Error(o(300));
      return c;
    }
    function cm() {
      var c = Ic !== 0;
      return Ic = 0, c;
    }
    function Ts() {
      var c = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      return Qn === null ? An.memoizedState = Qn = c : Qn = Qn.next = c, Qn;
    }
    function ss() {
      if (li === null) {
        var c = An.alternate;
        c = c !== null ? c.memoizedState : null;
      } else c = li.next;
      var u = Qn === null ? An.memoizedState : Qn.next;
      if (u !== null) Qn = u, li = c;
      else {
        if (c === null) throw Error(o(310));
        li = c, c = { memoizedState: li.memoizedState, baseState: li.baseState, baseQueue: li.baseQueue, queue: li.queue, next: null }, Qn === null ? An.memoizedState = Qn = c : Qn = Qn.next = c;
      }
      return Qn;
    }
    function zo(c, u) {
      return typeof u == "function" ? u(c) : u;
    }
    function Nh(c) {
      var u = ss(), g = u.queue;
      if (g === null) throw Error(o(311));
      g.lastRenderedReducer = c;
      var A = li, E = A.baseQueue, w = g.pending;
      if (w !== null) {
        if (E !== null) {
          var H = E.next;
          E.next = w.next, w.next = H;
        }
        A.baseQueue = E = w, g.pending = null;
      }
      if (E !== null) {
        w = E.next, A = A.baseState;
        var Z = H = null, de = null, we = w;
        do {
          var Ke = we.lane;
          if ((rl & Ke) === Ke) de !== null && (de = de.next = { lane: 0, action: we.action, hasEagerState: we.hasEagerState, eagerState: we.eagerState, next: null }), A = we.hasEagerState ? we.eagerState : c(A, we.action);
          else {
            var xt = {
              lane: Ke,
              action: we.action,
              hasEagerState: we.hasEagerState,
              eagerState: we.eagerState,
              next: null
            };
            de === null ? (Z = de = xt, H = A) : de = de.next = xt, An.lanes |= Ke, ol |= Ke;
          }
          we = we.next;
        } while (we !== null && we !== w);
        de === null ? H = A : de.next = Z, ts(A, u.memoizedState) || ($i = !0), u.memoizedState = A, u.baseState = H, u.baseQueue = de, g.lastRenderedState = A;
      }
      if (c = g.interleaved, c !== null) {
        E = c;
        do
          w = E.lane, An.lanes |= w, ol |= w, E = E.next;
        while (E !== c);
      } else E === null && (g.lanes = 0);
      return [u.memoizedState, g.dispatch];
    }
    function kh(c) {
      var u = ss(), g = u.queue;
      if (g === null) throw Error(o(311));
      g.lastRenderedReducer = c;
      var A = g.dispatch, E = g.pending, w = u.memoizedState;
      if (E !== null) {
        g.pending = null;
        var H = E = E.next;
        do
          w = c(w, H.action), H = H.next;
        while (H !== E);
        ts(w, u.memoizedState) || ($i = !0), u.memoizedState = w, u.baseQueue === null && (u.baseState = w), g.lastRenderedState = w;
      }
      return [w, A];
    }
    function dy() {
    }
    function py(c, u) {
      var g = An, A = ss(), E = u(), w = !ts(A.memoizedState, E);
      if (w && (A.memoizedState = E, $i = !0), A = A.queue, Dc(_y.bind(null, g, A, c), [c]), A.getSnapshot !== u || w || Qn !== null && Qn.memoizedState.tag & 1) {
        if (g.flags |= 2048, Lc(9, gy.bind(null, g, A, E, u), void 0, null), Ln === null) throw Error(o(349));
        (rl & 30) !== 0 || my(g, u, E);
      }
      return E;
    }
    function my(c, u, g) {
      c.flags |= 16384, c = { getSnapshot: u, value: g }, u = An.updateQueue, u === null ? (u = { lastEffect: null, stores: null }, An.updateQueue = u, u.stores = [c]) : (g = u.stores, g === null ? u.stores = [c] : g.push(c));
    }
    function gy(c, u, g, A) {
      u.value = g, u.getSnapshot = A, vy(u) && Er(c, 1, -1);
    }
    function _y(c, u, g) {
      return g(function() {
        vy(u) && Er(c, 1, -1);
      });
    }
    function vy(c) {
      var u = c.getSnapshot;
      c = c.value;
      try {
        var g = u();
        return !ts(c, g);
      } catch {
        return !0;
      }
    }
    function um(c) {
      var u = Ts();
      return typeof c == "function" && (c = c()), u.memoizedState = u.baseState = c, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: zo, lastRenderedState: c }, u.queue = c, c = c.dispatch = Iw.bind(null, An, c), [u.memoizedState, c];
    }
    function Lc(c, u, g, A) {
      return c = { tag: c, create: u, destroy: g, deps: A, next: null }, u = An.updateQueue, u === null ? (u = { lastEffect: null, stores: null }, An.updateQueue = u, u.lastEffect = c.next = c) : (g = u.lastEffect, g === null ? u.lastEffect = c.next = c : (A = g.next, g.next = c, c.next = A, u.lastEffect = c)), c;
    }
    function yy() {
      return ss().memoizedState;
    }
    function Gh(c, u, g, A) {
      var E = Ts();
      An.flags |= c, E.memoizedState = Lc(1 | u, g, void 0, A === void 0 ? null : A);
    }
    function Hh(c, u, g, A) {
      var E = ss();
      A = A === void 0 ? null : A;
      var w = void 0;
      if (li !== null) {
        var H = li.memoizedState;
        if (w = H.destroy, A !== null && am(A, H.deps)) {
          E.memoizedState = Lc(u, g, w, A);
          return;
        }
      }
      An.flags |= c, E.memoizedState = Lc(1 | u, g, w, A);
    }
    function hm(c, u) {
      return Gh(8390656, 8, c, u);
    }
    function Dc(c, u) {
      return Hh(2048, 8, c, u);
    }
    function xy(c, u) {
      return Hh(4, 2, c, u);
    }
    function Ay(c, u) {
      return Hh(4, 4, c, u);
    }
    function My(c, u) {
      if (typeof u == "function") return c = c(), u(c), function() {
        u(null);
      };
      if (u != null) return c = c(), u.current = c, function() {
        u.current = null;
      };
    }
    function Sy(c, u, g) {
      return g = g != null ? g.concat([c]) : null, Hh(4, 4, My.bind(null, u, c), g);
    }
    function fm() {
    }
    function Ey(c, u) {
      var g = ss();
      u = u === void 0 ? null : u;
      var A = g.memoizedState;
      return A !== null && u !== null && am(u, A[1]) ? A[0] : (g.memoizedState = [c, u], c);
    }
    function Ty(c, u) {
      var g = ss();
      u = u === void 0 ? null : u;
      var A = g.memoizedState;
      return A !== null && u !== null && am(u, A[1]) ? A[0] : (c = c(), g.memoizedState = [c, u], c);
    }
    function Bw(c, u) {
      var g = Xt;
      Xt = g !== 0 && 4 > g ? g : 4, c(!0);
      var A = Sr.transition;
      Sr.transition = {};
      try {
        c(!1), u();
      } finally {
        Xt = g, Sr.transition = A;
      }
    }
    function wy() {
      return ss().memoizedState;
    }
    function Pw(c, u, g) {
      var A = eo(c);
      g = { lane: A, action: g, hasEagerState: !1, eagerState: null, next: null }, Cy(c) ? by(u, g) : (Ry(c, u, g), g = wi(), c = Er(c, A, g), c !== null && By(c, u, A));
    }
    function Iw(c, u, g) {
      var A = eo(c), E = { lane: A, action: g, hasEagerState: !1, eagerState: null, next: null };
      if (Cy(c)) by(u, E);
      else {
        Ry(c, u, E);
        var w = c.alternate;
        if (c.lanes === 0 && (w === null || w.lanes === 0) && (w = u.lastRenderedReducer, w !== null)) try {
          var H = u.lastRenderedState, Z = w(H, g);
          if (E.hasEagerState = !0, E.eagerState = Z, ts(Z, H)) return;
        } catch {
        } finally {
        }
        g = wi(), c = Er(c, A, g), c !== null && By(c, u, A);
      }
    }
    function Cy(c) {
      var u = c.alternate;
      return c === An || u !== null && u === An;
    }
    function by(c, u) {
      Pc = Oh = !0;
      var g = c.pending;
      g === null ? u.next = u : (u.next = g.next, g.next = u), c.pending = u;
    }
    function Ry(c, u, g) {
      Ln !== null && (c.mode & 1) !== 0 && (Bt & 2) === 0 ? (c = u.interleaved, c === null ? (g.next = g, is === null ? is = [u] : is.push(u)) : (g.next = c.next, c.next = g), u.interleaved = g) : (c = u.pending, c === null ? g.next = g : (g.next = c.next, c.next = g), u.pending = g);
    }
    function By(c, u, g) {
      if ((g & 4194240) !== 0) {
        var A = u.lanes;
        A &= c.pendingLanes, g |= A, u.lanes = g, Gp(c, g);
      }
    }
    var zh = { readContext: yr, useCallback: ci, useContext: ci, useEffect: ci, useImperativeHandle: ci, useInsertionEffect: ci, useLayoutEffect: ci, useMemo: ci, useReducer: ci, useRef: ci, useState: ci, useDebugValue: ci, useDeferredValue: ci, useTransition: ci, useMutableSource: ci, useSyncExternalStore: ci, useId: ci, unstable_isNewReconciler: !1 }, Lw = { readContext: yr, useCallback: function(c, u) {
      return Ts().memoizedState = [c, u === void 0 ? null : u], c;
    }, useContext: yr, useEffect: hm, useImperativeHandle: function(c, u, g) {
      return g = g != null ? g.concat([c]) : null, Gh(
        4194308,
        4,
        My.bind(null, u, c),
        g
      );
    }, useLayoutEffect: function(c, u) {
      return Gh(4194308, 4, c, u);
    }, useInsertionEffect: function(c, u) {
      return Gh(4, 2, c, u);
    }, useMemo: function(c, u) {
      var g = Ts();
      return u = u === void 0 ? null : u, c = c(), g.memoizedState = [c, u], c;
    }, useReducer: function(c, u, g) {
      var A = Ts();
      return u = g !== void 0 ? g(u) : u, A.memoizedState = A.baseState = u, c = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: c, lastRenderedState: u }, A.queue = c, c = c.dispatch = Pw.bind(null, An, c), [A.memoizedState, c];
    }, useRef: function(c) {
      var u = Ts();
      return c = { current: c }, u.memoizedState = c;
    }, useState: um, useDebugValue: fm, useDeferredValue: function(c) {
      var u = um(c), g = u[0], A = u[1];
      return hm(function() {
        var E = Sr.transition;
        Sr.transition = {};
        try {
          A(c);
        } finally {
          Sr.transition = E;
        }
      }, [c]), g;
    }, useTransition: function() {
      var c = um(!1), u = c[0];
      return c = Bw.bind(null, c[1]), Ts().memoizedState = c, [u, c];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(c, u, g) {
      var A = An, E = Ts();
      if (hn) {
        if (g === void 0) throw Error(o(407));
        g = g();
      } else {
        if (g = u(), Ln === null) throw Error(o(349));
        (rl & 30) !== 0 || my(A, u, g);
      }
      E.memoizedState = g;
      var w = { value: g, getSnapshot: u };
      return E.queue = w, hm(_y.bind(null, A, w, c), [c]), A.flags |= 2048, Lc(9, gy.bind(null, A, w, g, u), void 0, null), g;
    }, useId: function() {
      var c = Ts(), u = Ln.identifierPrefix;
      if (hn) {
        var g = Es, A = Ss;
        g = (A & ~(1 << 32 - Qi(A) - 1)).toString(32) + g, u = ":" + u + "R" + g, g = Ic++, 0 < g && (u += "H" + g.toString(32)), u += ":";
      } else g = Rw++, u = ":" + u + "r" + g.toString(32) + ":";
      return c.memoizedState = u;
    }, unstable_isNewReconciler: !1 }, Dw = {
      readContext: yr,
      useCallback: Ey,
      useContext: yr,
      useEffect: Dc,
      useImperativeHandle: Sy,
      useInsertionEffect: xy,
      useLayoutEffect: Ay,
      useMemo: Ty,
      useReducer: Nh,
      useRef: yy,
      useState: function() {
        return Nh(zo);
      },
      useDebugValue: fm,
      useDeferredValue: function(c) {
        var u = Nh(zo), g = u[0], A = u[1];
        return Dc(function() {
          var E = Sr.transition;
          Sr.transition = {};
          try {
            A(c);
          } finally {
            Sr.transition = E;
          }
        }, [c]), g;
      },
      useTransition: function() {
        var c = Nh(zo)[0], u = ss().memoizedState;
        return [c, u];
      },
      useMutableSource: dy,
      useSyncExternalStore: py,
      useId: wy,
      unstable_isNewReconciler: !1
    }, Fw = {
      readContext: yr,
      useCallback: Ey,
      useContext: yr,
      useEffect: Dc,
      useImperativeHandle: Sy,
      useInsertionEffect: xy,
      useLayoutEffect: Ay,
      useMemo: Ty,
      useReducer: kh,
      useRef: yy,
      useState: function() {
        return kh(zo);
      },
      useDebugValue: fm,
      useDeferredValue: function(c) {
        var u = kh(zo), g = u[0], A = u[1];
        return Dc(function() {
          var E = Sr.transition;
          Sr.transition = {};
          try {
            A(c);
          } finally {
            Sr.transition = E;
          }
        }, [c]), g;
      },
      useTransition: function() {
        var c = kh(zo)[0], u = ss().memoizedState;
        return [c, u];
      },
      useMutableSource: dy,
      useSyncExternalStore: py,
      useId: wy,
      unstable_isNewReconciler: !1
    };
    function dm(c, u) {
      try {
        var g = "", A = u;
        do
          g += bw(A), A = A.return;
        while (A);
        var E = g;
      } catch (w) {
        E = `
Error generating stack: ` + w.message + `
` + w.stack;
      }
      return { value: c, source: u, stack: E };
    }
    function pm(c, u) {
      try {
        console.error(u.value);
      } catch (g) {
        setTimeout(function() {
          throw g;
        });
      }
    }
    var Uw = typeof WeakMap == "function" ? WeakMap : Map;
    function Py(c, u, g) {
      g = Ms(-1, g), g.tag = 3, g.payload = { element: null };
      var A = u.value;
      return g.callback = function() {
        sf || (sf = !0, Im = A), pm(c, u);
      }, g;
    }
    function Iy(c, u, g) {
      g = Ms(-1, g), g.tag = 3;
      var A = c.type.getDerivedStateFromError;
      if (typeof A == "function") {
        var E = u.value;
        g.payload = function() {
          return A(E);
        }, g.callback = function() {
          pm(c, u);
        };
      }
      var w = c.stateNode;
      return w !== null && typeof w.componentDidCatch == "function" && (g.callback = function() {
        pm(c, u), typeof A != "function" && (js === null ? js = /* @__PURE__ */ new Set([this]) : js.add(this));
        var H = u.stack;
        this.componentDidCatch(u.value, { componentStack: H !== null ? H : "" });
      }), g;
    }
    function Ly(c, u, g) {
      var A = c.pingCache;
      if (A === null) {
        A = c.pingCache = new Uw();
        var E = /* @__PURE__ */ new Set();
        A.set(u, E);
      } else E = A.get(u), E === void 0 && (E = /* @__PURE__ */ new Set(), A.set(u, E));
      E.has(g) || (E.add(g), c = Qw.bind(null, c, u, g), u.then(c, c));
    }
    function Dy(c) {
      do {
        var u;
        if ((u = c.tag === 13) && (u = c.memoizedState, u = u !== null ? u.dehydrated !== null : !0), u) return c;
        c = c.return;
      } while (c !== null);
      return null;
    }
    function Fy(c, u, g, A, E) {
      return (c.mode & 1) === 0 ? (c === u ? c.flags |= 65536 : (c.flags |= 128, g.flags |= 131072, g.flags &= -52805, g.tag === 1 && (g.alternate === null ? g.tag = 17 : (u = Ms(-1, 1), u.tag = 2, Zs(g, u))), g.lanes |= 1), c) : (c.flags |= 65536, c.lanes = E, c);
    }
    function os(c) {
      c.flags |= 4;
    }
    function Uy(c, u) {
      if (c !== null && c.child === u.child) return !0;
      if ((u.flags & 16) !== 0) return !1;
      for (c = u.child; c !== null; ) {
        if ((c.flags & 12854) !== 0 || (c.subtreeFlags & 12854) !== 0) return !1;
        c = c.sibling;
      }
      return !0;
    }
    var Fc, Uc, Vh, Wh;
    if (ze) Fc = function(c, u) {
      for (var g = u.child; g !== null; ) {
        if (g.tag === 5 || g.tag === 6) J(c, g.stateNode);
        else if (g.tag !== 4 && g.child !== null) {
          g.child.return = g, g = g.child;
          continue;
        }
        if (g === u) break;
        for (; g.sibling === null; ) {
          if (g.return === null || g.return === u) return;
          g = g.return;
        }
        g.sibling.return = g.return, g = g.sibling;
      }
    }, Uc = function() {
    }, Vh = function(c, u, g, A, E) {
      if (c = c.memoizedProps, c !== A) {
        var w = u.stateNode, H = rs(Mr.current);
        g = ie(w, g, c, A, E, H), (u.updateQueue = g) && os(u);
      }
    }, Wh = function(c, u, g, A) {
      g !== A && os(u);
    };
    else if (X) {
      Fc = function(c, u, g, A) {
        for (var E = u.child; E !== null; ) {
          if (E.tag === 5) {
            var w = E.stateNode;
            g && A && (w = Qe(w, E.type, E.memoizedProps, E)), J(c, w);
          } else if (E.tag === 6) w = E.stateNode, g && A && (w = We(w, E.memoizedProps, E)), J(c, w);
          else if (E.tag !== 4) {
            if (E.tag === 22 && E.memoizedState !== null) w = E.child, w !== null && (w.return = E), Fc(c, E, !0, !0);
            else if (E.child !== null) {
              E.child.return = E, E = E.child;
              continue;
            }
          }
          if (E === u) break;
          for (; E.sibling === null; ) {
            if (E.return === null || E.return === u) return;
            E = E.return;
          }
          E.sibling.return = E.return, E = E.sibling;
        }
      };
      var Oy = function(c, u, g, A) {
        for (var E = u.child; E !== null; ) {
          if (E.tag === 5) {
            var w = E.stateNode;
            g && A && (w = Qe(w, E.type, E.memoizedProps, E)), it(c, w);
          } else if (E.tag === 6) w = E.stateNode, g && A && (w = We(w, E.memoizedProps, E)), it(c, w);
          else if (E.tag !== 4) {
            if (E.tag === 22 && E.memoizedState !== null) w = E.child, w !== null && (w.return = E), Oy(c, E, !0, !0);
            else if (E.child !== null) {
              E.child.return = E, E = E.child;
              continue;
            }
          }
          if (E === u) break;
          for (; E.sibling === null; ) {
            if (E.return === null || E.return === u) return;
            E = E.return;
          }
          E.sibling.return = E.return, E = E.sibling;
        }
      };
      Uc = function(c, u) {
        var g = u.stateNode;
        if (!Uy(c, u)) {
          c = g.containerInfo;
          var A = ot(c);
          Oy(A, u, !1, !1), g.pendingChildren = A, os(u), It(c, A);
        }
      }, Vh = function(c, u, g, A, E) {
        var w = c.stateNode, H = c.memoizedProps;
        if ((c = Uy(c, u)) && H === A) u.stateNode = w;
        else {
          var Z = u.stateNode, de = rs(Mr.current), we = null;
          H !== A && (we = ie(Z, g, H, A, E, de)), c && we === null ? u.stateNode = w : (w = be(w, we, g, H, A, u, c, Z), K(w, g, A, E, de) && os(u), u.stateNode = w, c ? os(u) : Fc(w, u, !1, !1));
        }
      }, Wh = function(c, u, g, A) {
        g !== A ? (c = rs(nl.current), g = rs(Mr.current), u.stateNode = ge(A, c, g, u), os(u)) : u.stateNode = c.stateNode;
      };
    } else Uc = function() {
    }, Vh = function() {
    }, Wh = function() {
    };
    function Oc(c, u) {
      if (!hn) switch (c.tailMode) {
        case "hidden":
          u = c.tail;
          for (var g = null; u !== null; ) u.alternate !== null && (g = u), u = u.sibling;
          g === null ? c.tail = null : g.sibling = null;
          break;
        case "collapsed":
          g = c.tail;
          for (var A = null; g !== null; ) g.alternate !== null && (A = g), g = g.sibling;
          A === null ? u || c.tail === null ? c.tail = null : c.tail.sibling = null : A.sibling = null;
      }
    }
    function ui(c) {
      var u = c.alternate !== null && c.alternate.child === c.child, g = 0, A = 0;
      if (u) for (var E = c.child; E !== null; ) g |= E.lanes | E.childLanes, A |= E.subtreeFlags & 14680064, A |= E.flags & 14680064, E.return = c, E = E.sibling;
      else for (E = c.child; E !== null; ) g |= E.lanes | E.childLanes, A |= E.subtreeFlags, A |= E.flags, E.return = c, E = E.sibling;
      return c.subtreeFlags |= A, c.childLanes = g, u;
    }
    function Ow(c, u, g) {
      var A = u.pendingProps;
      switch ($p(u), u.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return ui(u), null;
        case 1:
          return Kn(u.type) && Cn(), ui(u), null;
        case 3:
          return A = u.stateNode, il(), ft(xn), ft(Rt), om(), A.pendingContext && (A.context = A.pendingContext, A.pendingContext = null), (c === null || c.child === null) && (Cc(u) ? os(u) : c === null || c.memoizedState.isDehydrated && (u.flags & 256) === 0 || (u.flags |= 1024, Nr !== null && (Fm(Nr), Nr = null))), Uc(c, u), ui(u), null;
        case 5:
          rm(u), g = rs(nl.current);
          var E = u.type;
          if (c !== null && u.stateNode != null) Vh(c, u, E, A, g), c.ref !== u.ref && (u.flags |= 512, u.flags |= 2097152);
          else {
            if (!A) {
              if (u.stateNode === null) throw Error(o(166));
              return ui(u), null;
            }
            if (c = rs(Mr.current), Cc(u)) {
              if (!pe) throw Error(o(175));
              c = $t(u.stateNode, u.type, u.memoizedProps, g, c, u, !wc), u.updateQueue = c, c !== null && os(u);
            } else {
              var w = D(E, A, g, c, u);
              Fc(w, u, !1, !1), u.stateNode = w, K(w, E, A, g, c) && os(u);
            }
            u.ref !== null && (u.flags |= 512, u.flags |= 2097152);
          }
          return ui(u), null;
        case 6:
          if (c && u.stateNode != null) Wh(c, u, c.memoizedProps, A);
          else {
            if (typeof A != "string" && u.stateNode === null) throw Error(o(166));
            if (c = rs(nl.current), g = rs(Mr.current), Cc(u)) {
              if (!pe) throw Error(o(176));
              if (c = u.stateNode, A = u.memoizedProps, (g = Kt(c, A, u, !wc)) && (E = Zi, E !== null)) switch (w = (E.mode & 1) !== 0, E.tag) {
                case 3:
                  Je(E.stateNode.containerInfo, c, A, w);
                  break;
                case 5:
                  ht(E.type, E.memoizedProps, E.stateNode, c, A, w);
              }
              g && os(u);
            } else u.stateNode = ge(A, c, g, u);
          }
          return ui(u), null;
        case 13:
          if (ft(pn), A = u.memoizedState, hn && ji !== null && (u.mode & 1) !== 0 && (u.flags & 128) === 0) {
            for (c = ji; c; ) c = yt(c);
            return el(), u.flags |= 98560, u;
          }
          if (A !== null && A.dehydrated !== null) {
            if (A = Cc(u), c === null) {
              if (!A) throw Error(o(318));
              if (!pe) throw Error(o(344));
              if (c = u.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(o(317));
              Ei(c, u);
            } else el(), (u.flags & 128) === 0 && (u.memoizedState = null), u.flags |= 4;
            return ui(u), null;
          }
          return Nr !== null && (Fm(Nr), Nr = null), (u.flags & 128) !== 0 ? (u.lanes = g, u) : (A = A !== null, g = !1, c === null ? Cc(u) : g = c.memoizedState !== null, A && !g && (u.child.flags |= 8192, (u.mode & 1) !== 0 && (c === null || (pn.current & 1) !== 0 ? Gn === 0 && (Gn = 3) : Om())), u.updateQueue !== null && (u.flags |= 4), ui(u), null);
        case 4:
          return il(), Uc(c, u), c === null && Me(u.stateNode.containerInfo), ui(u), null;
        case 10:
          return Yp(u.type._context), ui(u), null;
        case 17:
          return Kn(u.type) && Cn(), ui(u), null;
        case 19:
          if (ft(pn), E = u.memoizedState, E === null) return ui(u), null;
          if (A = (u.flags & 128) !== 0, w = E.rendering, w === null) if (A) Oc(E, !1);
          else {
            if (Gn !== 0 || c !== null && (c.flags & 128) !== 0) for (c = u.child; c !== null; ) {
              if (w = Fh(c), w !== null) {
                for (u.flags |= 128, Oc(E, !1), c = w.updateQueue, c !== null && (u.updateQueue = c, u.flags |= 4), u.subtreeFlags = 0, c = g, A = u.child; A !== null; ) g = A, E = c, g.flags &= 14680066, w = g.alternate, w === null ? (g.childLanes = 0, g.lanes = E, g.child = null, g.subtreeFlags = 0, g.memoizedProps = null, g.memoizedState = null, g.updateQueue = null, g.dependencies = null, g.stateNode = null) : (g.childLanes = w.childLanes, g.lanes = w.lanes, g.child = w.child, g.subtreeFlags = 0, g.deletions = null, g.memoizedProps = w.memoizedProps, g.memoizedState = w.memoizedState, g.updateQueue = w.updateQueue, g.type = w.type, E = w.dependencies, g.dependencies = E === null ? null : { lanes: E.lanes, firstContext: E.firstContext }), A = A.sibling;
                return ke(pn, pn.current & 1 | 2), u.child;
              }
              c = c.sibling;
            }
            E.tail !== null && qn() > Pm && (u.flags |= 128, A = !0, Oc(E, !1), u.lanes = 4194304);
          }
          else {
            if (!A) if (c = Fh(w), c !== null) {
              if (u.flags |= 128, A = !0, c = c.updateQueue, c !== null && (u.updateQueue = c, u.flags |= 4), Oc(E, !0), E.tail === null && E.tailMode === "hidden" && !w.alternate && !hn) return ui(u), null;
            } else 2 * qn() - E.renderingStartTime > Pm && g !== 1073741824 && (u.flags |= 128, A = !0, Oc(E, !1), u.lanes = 4194304);
            E.isBackwards ? (w.sibling = u.child, u.child = w) : (c = E.last, c !== null ? c.sibling = w : u.child = w, E.last = w);
          }
          return E.tail !== null ? (u = E.tail, E.rendering = u, E.tail = u.sibling, E.renderingStartTime = qn(), u.sibling = null, c = pn.current, ke(pn, A ? c & 1 | 2 : c & 1), u) : (ui(u), null);
        case 22:
        case 23:
          return Um(), A = u.memoizedState !== null, c !== null && c.memoizedState !== null !== A && (u.flags |= 8192), A && (u.mode & 1) !== 0 ? (er & 1073741824) !== 0 && (ui(u), ze && u.subtreeFlags & 6 && (u.flags |= 8192)) : ui(u), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(o(156, u.tag));
    }
    var Nw = a.ReactCurrentOwner, $i = !1;
    function Ti(c, u, g, A) {
      u.child = c === null ? hy(u, null, g, A) : tl(u, c.child, g, A);
    }
    function Ny(c, u, g, A, E) {
      g = g.render;
      var w = u.ref;
      return Za(u, E), A = lm(c, u, g, A, w, E), g = cm(), c !== null && !$i ? (u.updateQueue = c.updateQueue, u.flags &= -2053, c.lanes &= ~E, ws(c, u, E)) : (hn && g && jp(u), u.flags |= 1, Ti(c, u, A, E), u.child);
    }
    function ky(c, u, g, A, E) {
      if (c === null) {
        var w = g.type;
        return typeof w == "function" && !Nm(w) && w.defaultProps === void 0 && g.compare === null && g.defaultProps === void 0 ? (u.tag = 15, u.type = w, Gy(c, u, w, A, E)) : (c = ff(g.type, null, A, u, u.mode, E), c.ref = u.ref, c.return = u, u.child = c);
      }
      if (w = c.child, (c.lanes & E) === 0) {
        var H = w.memoizedProps;
        if (g = g.compare, g = g !== null ? g : wh, g(H, A) && c.ref === u.ref) return ws(c, u, E);
      }
      return u.flags |= 1, c = no(w, A), c.ref = u.ref, c.return = u, u.child = c;
    }
    function Gy(c, u, g, A, E) {
      if (c !== null && wh(c.memoizedProps, A) && c.ref === u.ref) if ($i = !1, (c.lanes & E) !== 0) (c.flags & 131072) !== 0 && ($i = !0);
      else return u.lanes = c.lanes, ws(c, u, E);
      return mm(c, u, g, A, E);
    }
    function Hy(c, u, g) {
      var A = u.pendingProps, E = A.children, w = c !== null ? c.memoizedState : null;
      if (A.mode === "hidden") if ((u.mode & 1) === 0) u.memoizedState = { baseLanes: 0, cachePool: null }, ke(sl, er), er |= g;
      else if ((g & 1073741824) !== 0) u.memoizedState = { baseLanes: 0, cachePool: null }, A = w !== null ? w.baseLanes : g, ke(sl, er), er |= A;
      else return c = w !== null ? w.baseLanes | g : g, u.lanes = u.childLanes = 1073741824, u.memoizedState = { baseLanes: c, cachePool: null }, u.updateQueue = null, ke(sl, er), er |= c, null;
      else w !== null ? (A = w.baseLanes | g, u.memoizedState = null) : A = g, ke(sl, er), er |= A;
      return Ti(c, u, E, g), u.child;
    }
    function zy(c, u) {
      var g = u.ref;
      (c === null && g !== null || c !== null && c.ref !== g) && (u.flags |= 512, u.flags |= 2097152);
    }
    function mm(c, u, g, A, E) {
      var w = Kn(g) ? jr : Rt.current;
      return w = vr(u, w), Za(u, E), g = lm(c, u, g, A, w, E), A = cm(), c !== null && !$i ? (u.updateQueue = c.updateQueue, u.flags &= -2053, c.lanes &= ~E, ws(c, u, E)) : (hn && A && jp(u), u.flags |= 1, Ti(c, u, g, E), u.child);
    }
    function Vy(c, u, g, A, E) {
      if (Kn(g)) {
        var w = !0;
        ni(u);
      } else w = !1;
      if (Za(u, E), u.stateNode === null) c !== null && (c.alternate = null, u.alternate = null, u.flags |= 2), iy(u, g, A), Zp(u, g, A, E), A = !0;
      else if (c === null) {
        var H = u.stateNode, Z = u.memoizedProps;
        H.props = Z;
        var de = H.context, we = g.contextType;
        typeof we == "object" && we !== null ? we = yr(we) : (we = Kn(g) ? jr : Rt.current, we = vr(u, we));
        var Ke = g.getDerivedStateFromProps, xt = typeof Ke == "function" || typeof H.getSnapshotBeforeUpdate == "function";
        xt || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (Z !== A || de !== we) && ry(u, H, A, we), Qs = !1;
        var dt = u.memoizedState;
        H.state = dt, Bh(u, A, H, E), de = u.memoizedState, Z !== A || dt !== de || xn.current || Qs ? (typeof Ke == "function" && (Qp(u, g, Ke, A), de = u.memoizedState), (Z = Qs || ny(u, g, Z, A, dt, de, we)) ? (xt || typeof H.UNSAFE_componentWillMount != "function" && typeof H.componentWillMount != "function" || (typeof H.componentWillMount == "function" && H.componentWillMount(), typeof H.UNSAFE_componentWillMount == "function" && H.UNSAFE_componentWillMount()), typeof H.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof H.componentDidMount == "function" && (u.flags |= 4194308), u.memoizedProps = A, u.memoizedState = de), H.props = A, H.state = de, H.context = we, A = Z) : (typeof H.componentDidMount == "function" && (u.flags |= 4194308), A = !1);
      } else {
        H = u.stateNode, jv(c, u), Z = u.memoizedProps, we = u.type === u.elementType ? Z : Or(u.type, Z), H.props = we, xt = u.pendingProps, dt = H.context, de = g.contextType, typeof de == "object" && de !== null ? de = yr(de) : (de = Kn(g) ? jr : Rt.current, de = vr(u, de));
        var tn = g.getDerivedStateFromProps;
        (Ke = typeof tn == "function" || typeof H.getSnapshotBeforeUpdate == "function") || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (Z !== xt || dt !== de) && ry(u, H, A, de), Qs = !1, dt = u.memoizedState, H.state = dt, Bh(u, A, H, E);
        var lt = u.memoizedState;
        Z !== xt || dt !== lt || xn.current || Qs ? (typeof tn == "function" && (Qp(u, g, tn, A), lt = u.memoizedState), (we = Qs || ny(u, g, we, A, dt, lt, de) || !1) ? (Ke || typeof H.UNSAFE_componentWillUpdate != "function" && typeof H.componentWillUpdate != "function" || (typeof H.componentWillUpdate == "function" && H.componentWillUpdate(
          A,
          lt,
          de
        ), typeof H.UNSAFE_componentWillUpdate == "function" && H.UNSAFE_componentWillUpdate(A, lt, de)), typeof H.componentDidUpdate == "function" && (u.flags |= 4), typeof H.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof H.componentDidUpdate != "function" || Z === c.memoizedProps && dt === c.memoizedState || (u.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || Z === c.memoizedProps && dt === c.memoizedState || (u.flags |= 1024), u.memoizedProps = A, u.memoizedState = lt), H.props = A, H.state = lt, H.context = de, A = we) : (typeof H.componentDidUpdate != "function" || Z === c.memoizedProps && dt === c.memoizedState || (u.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || Z === c.memoizedProps && dt === c.memoizedState || (u.flags |= 1024), A = !1);
      }
      return gm(c, u, g, A, w, E);
    }
    function gm(c, u, g, A, E, w) {
      zy(c, u);
      var H = (u.flags & 128) !== 0;
      if (!A && !H) return E && qa(u, g, !1), ws(c, u, w);
      A = u.stateNode, Nw.current = u;
      var Z = H && typeof g.getDerivedStateFromError != "function" ? null : A.render();
      return u.flags |= 1, c !== null && H ? (u.child = tl(u, c.child, null, w), u.child = tl(u, null, Z, w)) : Ti(c, u, Z, w), u.memoizedState = A.state, E && qa(u, g, !0), u.child;
    }
    function Wy(c) {
      var u = c.stateNode;
      u.pendingContext ? $r(c, u.pendingContext, u.pendingContext !== u.context) : u.context && $r(c, u.context, !1), im(c, u.containerInfo);
    }
    function Xy(c, u, g, A, E) {
      return el(), nm(E), u.flags |= 256, Ti(c, u, g, A), u.child;
    }
    var Xh = { dehydrated: null, treeContext: null, retryLane: 0 };
    function Jh(c) {
      return { baseLanes: c, cachePool: null };
    }
    function Jy(c, u, g) {
      var A = u.pendingProps, E = pn.current, w = !1, H = (u.flags & 128) !== 0, Z;
      if ((Z = H) || (Z = c !== null && c.memoizedState === null ? !1 : (E & 2) !== 0), Z ? (w = !0, u.flags &= -129) : (c === null || c.memoizedState !== null) && (E |= 1), ke(pn, E & 1), c === null)
        return tm(u), c = u.memoizedState, c !== null && (c = c.dehydrated, c !== null) ? ((u.mode & 1) === 0 ? u.lanes = 1 : _t(c) ? u.lanes = 8 : u.lanes = 1073741824, null) : (E = A.children, c = A.fallback, w ? (A = u.mode, w = u.child, E = { mode: "hidden", children: E }, (A & 1) === 0 && w !== null ? (w.childLanes = 0, w.pendingProps = E) : w = df(E, A, 0, null), c = Ko(c, A, g, null), w.return = u, c.return = u, w.sibling = c, u.child = w, u.child.memoizedState = Jh(g), u.memoizedState = Xh, c) : _m(u, E));
      if (E = c.memoizedState, E !== null) {
        if (Z = E.dehydrated, Z !== null) {
          if (H)
            return u.flags & 256 ? (u.flags &= -257, Yh(c, u, g, Error(o(422)))) : u.memoizedState !== null ? (u.child = c.child, u.flags |= 128, null) : (w = A.fallback, E = u.mode, A = df({ mode: "visible", children: A.children }, E, 0, null), w = Ko(w, E, g, null), w.flags |= 2, A.return = u, w.return = u, A.sibling = w, u.child = A, (u.mode & 1) !== 0 && tl(
              u,
              c.child,
              null,
              g
            ), u.child.memoizedState = Jh(g), u.memoizedState = Xh, w);
          if ((u.mode & 1) === 0) u = Yh(c, u, g, null);
          else if (_t(Z)) u = Yh(c, u, g, Error(o(419)));
          else if (A = (g & c.childLanes) !== 0, $i || A) {
            if (A = Ln, A !== null) {
              switch (g & -g) {
                case 4:
                  w = 2;
                  break;
                case 16:
                  w = 8;
                  break;
                case 64:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                case 67108864:
                  w = 32;
                  break;
                case 536870912:
                  w = 268435456;
                  break;
                default:
                  w = 0;
              }
              A = (w & (A.suspendedLanes | g)) !== 0 ? 0 : w, A !== 0 && A !== E.retryLane && (E.retryLane = A, Er(c, A, -1));
            }
            Om(), u = Yh(c, u, g, Error(o(421)));
          } else rt(Z) ? (u.flags |= 128, u.child = c.child, u = Zw.bind(null, c), cn(Z, u), u = null) : (g = E.treeContext, pe && (ji = en(Z), Zi = u, hn = !0, Nr = null, wc = !1, g !== null && (xr[Ar++] = Ss, xr[Ar++] = Es, xr[Ar++] = Go, Ss = g.id, Es = g.overflow, Go = u)), u = _m(u, u.pendingProps.children), u.flags |= 4096);
          return u;
        }
        return w ? (A = Ky(c, u, A.children, A.fallback, g), w = u.child, E = c.child.memoizedState, w.memoizedState = E === null ? Jh(g) : { baseLanes: E.baseLanes | g, cachePool: null }, w.childLanes = c.childLanes & ~g, u.memoizedState = Xh, A) : (g = Yy(c, u, A.children, g), u.memoizedState = null, g);
      }
      return w ? (A = Ky(c, u, A.children, A.fallback, g), w = u.child, E = c.child.memoizedState, w.memoizedState = E === null ? Jh(g) : { baseLanes: E.baseLanes | g, cachePool: null }, w.childLanes = c.childLanes & ~g, u.memoizedState = Xh, A) : (g = Yy(c, u, A.children, g), u.memoizedState = null, g);
    }
    function _m(c, u) {
      return u = df({ mode: "visible", children: u }, c.mode, 0, null), u.return = c, c.child = u;
    }
    function Yy(c, u, g, A) {
      var E = c.child;
      return c = E.sibling, g = no(E, { mode: "visible", children: g }), (u.mode & 1) === 0 && (g.lanes = A), g.return = u, g.sibling = null, c !== null && (A = u.deletions, A === null ? (u.deletions = [c], u.flags |= 16) : A.push(c)), u.child = g;
    }
    function Ky(c, u, g, A, E) {
      var w = u.mode;
      c = c.child;
      var H = c.sibling, Z = { mode: "hidden", children: g };
      return (w & 1) === 0 && u.child !== c ? (g = u.child, g.childLanes = 0, g.pendingProps = Z, u.deletions = null) : (g = no(c, Z), g.subtreeFlags = c.subtreeFlags & 14680064), H !== null ? A = no(H, A) : (A = Ko(A, w, E, null), A.flags |= 2), A.return = u, g.return = u, g.sibling = A, u.child = g, A;
    }
    function Yh(c, u, g, A) {
      return A !== null && nm(A), tl(u, c.child, null, g), c = _m(u, u.pendingProps.children), c.flags |= 2, u.memoizedState = null, c;
    }
    function qy(c, u, g) {
      c.lanes |= u;
      var A = c.alternate;
      A !== null && (A.lanes |= u), Kp(c.return, u, g);
    }
    function vm(c, u, g, A, E) {
      var w = c.memoizedState;
      w === null ? c.memoizedState = { isBackwards: u, rendering: null, renderingStartTime: 0, last: A, tail: g, tailMode: E } : (w.isBackwards = u, w.rendering = null, w.renderingStartTime = 0, w.last = A, w.tail = g, w.tailMode = E);
    }
    function Qy(c, u, g) {
      var A = u.pendingProps, E = A.revealOrder, w = A.tail;
      if (Ti(c, u, A.children, g), A = pn.current, (A & 2) !== 0) A = A & 1 | 2, u.flags |= 128;
      else {
        if (c !== null && (c.flags & 128) !== 0) e: for (c = u.child; c !== null; ) {
          if (c.tag === 13) c.memoizedState !== null && qy(c, g, u);
          else if (c.tag === 19) qy(c, g, u);
          else if (c.child !== null) {
            c.child.return = c, c = c.child;
            continue;
          }
          if (c === u) break e;
          for (; c.sibling === null; ) {
            if (c.return === null || c.return === u) break e;
            c = c.return;
          }
          c.sibling.return = c.return, c = c.sibling;
        }
        A &= 1;
      }
      if (ke(pn, A), (u.mode & 1) === 0) u.memoizedState = null;
      else switch (E) {
        case "forwards":
          for (g = u.child, E = null; g !== null; ) c = g.alternate, c !== null && Fh(c) === null && (E = g), g = g.sibling;
          g = E, g === null ? (E = u.child, u.child = null) : (E = g.sibling, g.sibling = null), vm(u, !1, E, g, w);
          break;
        case "backwards":
          for (g = null, E = u.child, u.child = null; E !== null; ) {
            if (c = E.alternate, c !== null && Fh(c) === null) {
              u.child = E;
              break;
            }
            c = E.sibling, E.sibling = g, g = E, E = c;
          }
          vm(u, !0, g, null, w);
          break;
        case "together":
          vm(u, !1, null, null, void 0);
          break;
        default:
          u.memoizedState = null;
      }
      return u.child;
    }
    function ws(c, u, g) {
      if (c !== null && (u.dependencies = c.dependencies), ol |= u.lanes, (g & u.childLanes) === 0) return null;
      if (c !== null && u.child !== c.child) throw Error(o(153));
      if (u.child !== null) {
        for (c = u.child, g = no(c, c.pendingProps), u.child = g, g.return = u; c.sibling !== null; ) c = c.sibling, g = g.sibling = no(c, c.pendingProps), g.return = u;
        g.sibling = null;
      }
      return u.child;
    }
    function kw(c, u, g) {
      switch (u.tag) {
        case 3:
          Wy(u), el();
          break;
        case 5:
          fy(u);
          break;
        case 1:
          Kn(u.type) && ni(u);
          break;
        case 4:
          im(u, u.stateNode.containerInfo);
          break;
        case 10:
          Zv(u, u.type._context, u.memoizedProps.value);
          break;
        case 13:
          var A = u.memoizedState;
          if (A !== null)
            return A.dehydrated !== null ? (ke(pn, pn.current & 1), u.flags |= 128, null) : (g & u.child.childLanes) !== 0 ? Jy(c, u, g) : (ke(pn, pn.current & 1), c = ws(c, u, g), c !== null ? c.sibling : null);
          ke(pn, pn.current & 1);
          break;
        case 19:
          if (A = (g & u.childLanes) !== 0, (c.flags & 128) !== 0) {
            if (A) return Qy(
              c,
              u,
              g
            );
            u.flags |= 128;
          }
          var E = u.memoizedState;
          if (E !== null && (E.rendering = null, E.tail = null, E.lastEffect = null), ke(pn, pn.current), A) break;
          return null;
        case 22:
        case 23:
          return u.lanes = 0, Hy(c, u, g);
      }
      return ws(c, u, g);
    }
    function Gw(c, u) {
      switch ($p(u), u.tag) {
        case 1:
          return Kn(u.type) && Cn(), c = u.flags, c & 65536 ? (u.flags = c & -65537 | 128, u) : null;
        case 3:
          return il(), ft(xn), ft(Rt), om(), c = u.flags, (c & 65536) !== 0 && (c & 128) === 0 ? (u.flags = c & -65537 | 128, u) : null;
        case 5:
          return rm(u), null;
        case 13:
          if (ft(pn), c = u.memoizedState, c !== null && c.dehydrated !== null) {
            if (u.alternate === null) throw Error(o(340));
            el();
          }
          return c = u.flags, c & 65536 ? (u.flags = c & -65537 | 128, u) : null;
        case 19:
          return ft(pn), null;
        case 4:
          return il(), null;
        case 10:
          return Yp(u.type._context), null;
        case 22:
        case 23:
          return Um(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kh = !1, Vo = !1, Hw = typeof WeakSet == "function" ? WeakSet : Set, Ge = null;
    function qh(c, u) {
      var g = c.ref;
      if (g !== null) if (typeof g == "function") try {
        g(null);
      } catch (A) {
        Gi(c, u, A);
      }
      else g.current = null;
    }
    function ym(c, u, g) {
      try {
        g();
      } catch (A) {
        Gi(c, u, A);
      }
    }
    var Zy = !1;
    function zw(c, u) {
      for (V(c.containerInfo), Ge = u; Ge !== null; ) if (c = Ge, u = c.child, (c.subtreeFlags & 1028) !== 0 && u !== null) u.return = c, Ge = u;
      else for (; Ge !== null; ) {
        c = Ge;
        try {
          var g = c.alternate;
          if ((c.flags & 1024) !== 0) switch (c.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (g !== null) {
                var A = g.memoizedProps, E = g.memoizedState, w = c.stateNode, H = w.getSnapshotBeforeUpdate(c.elementType === c.type ? A : Or(c.type, A), E);
                w.__reactInternalSnapshotBeforeUpdate = H;
              }
              break;
            case 3:
              ze && Ce(c.stateNode.containerInfo);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(o(163));
          }
        } catch (Z) {
          Gi(c, c.return, Z);
        }
        if (u = c.sibling, u !== null) {
          u.return = c.return, Ge = u;
          break;
        }
        Ge = c.return;
      }
      return g = Zy, Zy = !1, g;
    }
    function Wo(c, u, g) {
      var A = u.updateQueue;
      if (A = A !== null ? A.lastEffect : null, A !== null) {
        var E = A = A.next;
        do {
          if ((E.tag & c) === c) {
            var w = E.destroy;
            E.destroy = void 0, w !== void 0 && ym(u, g, w);
          }
          E = E.next;
        } while (E !== A);
      }
    }
    function Nc(c, u) {
      if (u = u.updateQueue, u = u !== null ? u.lastEffect : null, u !== null) {
        var g = u = u.next;
        do {
          if ((g.tag & c) === c) {
            var A = g.create;
            g.destroy = A();
          }
          g = g.next;
        } while (g !== u);
      }
    }
    function xm(c) {
      var u = c.ref;
      if (u !== null) {
        var g = c.stateNode;
        switch (c.tag) {
          case 5:
            c = j(g);
            break;
          default:
            c = g;
        }
        typeof u == "function" ? u(c) : u.current = c;
      }
    }
    function jy(c, u, g) {
      if (es && typeof es.onCommitFiberUnmount == "function") try {
        es.onCommitFiberUnmount(Eh, u);
      } catch {
      }
      switch (u.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          if (c = u.updateQueue, c !== null && (c = c.lastEffect, c !== null)) {
            var A = c = c.next;
            do {
              var E = A, w = E.destroy;
              E = E.tag, w !== void 0 && ((E & 2) !== 0 || (E & 4) !== 0) && ym(u, g, w), A = A.next;
            } while (A !== c);
          }
          break;
        case 1:
          if (qh(u, g), c = u.stateNode, typeof c.componentWillUnmount == "function") try {
            c.props = u.memoizedProps, c.state = u.memoizedState, c.componentWillUnmount();
          } catch (H) {
            Gi(
              u,
              g,
              H
            );
          }
          break;
        case 5:
          qh(u, g);
          break;
        case 4:
          ze ? rx(c, u, g) : X && X && (u = u.stateNode.containerInfo, g = ot(u), kt(u, g));
      }
    }
    function $y(c, u, g) {
      for (var A = u; ; ) if (jy(c, A, g), A.child === null || ze && A.tag === 4) {
        if (A === u) break;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === u) return;
          A = A.return;
        }
        A.sibling.return = A.return, A = A.sibling;
      } else A.child.return = A, A = A.child;
    }
    function ex(c) {
      var u = c.alternate;
      u !== null && (c.alternate = null, ex(u)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (u = c.stateNode, u !== null && Q(u)), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
    }
    function tx(c) {
      return c.tag === 5 || c.tag === 3 || c.tag === 4;
    }
    function nx(c) {
      e: for (; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || tx(c.return)) return null;
          c = c.return;
        }
        for (c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
          if (c.flags & 2 || c.child === null || c.tag === 4) continue e;
          c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2)) return c.stateNode;
      }
    }
    function ix(c) {
      if (ze) {
        e: {
          for (var u = c.return; u !== null; ) {
            if (tx(u)) break e;
            u = u.return;
          }
          throw Error(o(160));
        }
        var g = u;
        switch (g.tag) {
          case 5:
            u = g.stateNode, g.flags & 32 && (St(u), g.flags &= -33), g = nx(c), Mm(c, g, u);
            break;
          case 3:
          case 4:
            u = g.stateNode.containerInfo, g = nx(c), Am(c, g, u);
            break;
          default:
            throw Error(o(161));
        }
      }
    }
    function Am(c, u, g) {
      var A = c.tag;
      if (A === 5 || A === 6) c = c.stateNode, u ? je(g, c, u) : ct(g, c);
      else if (A !== 4 && (c = c.child, c !== null)) for (Am(c, u, g), c = c.sibling; c !== null; ) Am(c, u, g), c = c.sibling;
    }
    function Mm(c, u, g) {
      var A = c.tag;
      if (A === 5 || A === 6) c = c.stateNode, u ? mt(g, c, u) : Ze(g, c);
      else if (A !== 4 && (c = c.child, c !== null)) for (Mm(c, u, g), c = c.sibling; c !== null; ) Mm(c, u, g), c = c.sibling;
    }
    function rx(c, u, g) {
      for (var A = u, E = !1, w, H; ; ) {
        if (!E) {
          E = A.return;
          e: for (; ; ) {
            if (E === null) throw Error(o(160));
            switch (w = E.stateNode, E.tag) {
              case 5:
                H = !1;
                break e;
              case 3:
                w = w.containerInfo, H = !0;
                break e;
              case 4:
                w = w.containerInfo, H = !0;
                break e;
            }
            E = E.return;
          }
          E = !0;
        }
        if (A.tag === 5 || A.tag === 6) $y(c, A, g), H ? gt(w, A.stateNode) : Ve(w, A.stateNode);
        else if (A.tag === 18) H ? re(w, A.stateNode) : oe(w, A.stateNode);
        else if (A.tag === 4) {
          if (A.child !== null) {
            w = A.stateNode.containerInfo, H = !0, A.child.return = A, A = A.child;
            continue;
          }
        } else if (jy(c, A, g), A.child !== null) {
          A.child.return = A, A = A.child;
          continue;
        }
        if (A === u) break;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === u) return;
          A = A.return, A.tag === 4 && (E = !1);
        }
        A.sibling.return = A.return, A = A.sibling;
      }
    }
    function Sm(c, u) {
      if (ze) {
        switch (u.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Wo(3, u, u.return), Nc(3, u), Wo(5, u, u.return);
            return;
          case 1:
            return;
          case 5:
            var g = u.stateNode;
            if (g != null) {
              var A = u.memoizedProps;
              c = c !== null ? c.memoizedProps : A;
              var E = u.type, w = u.updateQueue;
              u.updateQueue = null, w !== null && et(g, w, E, c, A, u);
            }
            return;
          case 6:
            if (u.stateNode === null) throw Error(o(162));
            g = u.memoizedProps, ye(u.stateNode, c !== null ? c.memoizedProps : g, g);
            return;
          case 3:
            pe && c !== null && c.memoizedState.isDehydrated && te(u.stateNode.containerInfo);
            return;
          case 12:
            return;
          case 13:
            Qh(u);
            return;
          case 19:
            Qh(u);
            return;
          case 17:
            return;
        }
        throw Error(o(163));
      }
      switch (u.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Wo(3, u, u.return), Nc(3, u), Wo(5, u, u.return);
          return;
        case 12:
          return;
        case 13:
          Qh(u);
          return;
        case 19:
          Qh(u);
          return;
        case 3:
          pe && c !== null && c.memoizedState.isDehydrated && te(u.stateNode.containerInfo);
          break;
        case 22:
        case 23:
          return;
      }
      e: if (X) {
        switch (u.tag) {
          case 1:
          case 5:
          case 6:
            break e;
          case 3:
          case 4:
            u = u.stateNode, kt(u.containerInfo, u.pendingChildren);
            break e;
        }
        throw Error(o(163));
      }
    }
    function Qh(c) {
      var u = c.updateQueue;
      if (u !== null) {
        c.updateQueue = null;
        var g = c.stateNode;
        g === null && (g = c.stateNode = new Hw()), u.forEach(function(A) {
          var E = jw.bind(null, c, A);
          g.has(A) || (g.add(A), A.then(E, E));
        });
      }
    }
    function Vw(c, u) {
      for (Ge = u; Ge !== null; ) {
        u = Ge;
        var g = u.deletions;
        if (g !== null) for (var A = 0; A < g.length; A++) {
          var E = g[A];
          try {
            var w = c;
            ze ? rx(w, E, u) : $y(w, E, u);
            var H = E.alternate;
            H !== null && (H.return = null), E.return = null;
          } catch (st) {
            Gi(E, u, st);
          }
        }
        if (g = u.child, (u.subtreeFlags & 12854) !== 0 && g !== null) g.return = u, Ge = g;
        else for (; Ge !== null; ) {
          u = Ge;
          try {
            var Z = u.flags;
            if (Z & 32 && ze && St(u.stateNode), Z & 512) {
              var de = u.alternate;
              if (de !== null) {
                var we = de.ref;
                we !== null && (typeof we == "function" ? we(null) : we.current = null);
              }
            }
            if (Z & 8192) switch (u.tag) {
              case 13:
                if (u.memoizedState !== null) {
                  var Ke = u.alternate;
                  (Ke === null || Ke.memoizedState === null) && (Bm = qn());
                }
                break;
              case 22:
                var xt = u.memoizedState !== null, dt = u.alternate, tn = dt !== null && dt.memoizedState !== null;
                if (g = u, ze) {
                  e: if (A = g, E = xt, w = null, ze) for (var lt = A; ; ) {
                    if (lt.tag === 5) {
                      if (w === null) {
                        w = lt;
                        var hi = lt.stateNode;
                        E ? Wt(hi) : Ee(lt.stateNode, lt.memoizedProps);
                      }
                    } else if (lt.tag === 6) {
                      if (w === null) {
                        var wr = lt.stateNode;
                        E ? Oe(wr) : Y(wr, lt.memoizedProps);
                      }
                    } else if ((lt.tag !== 22 && lt.tag !== 23 || lt.memoizedState === null || lt === A) && lt.child !== null) {
                      lt.child.return = lt, lt = lt.child;
                      continue;
                    }
                    if (lt === A) break;
                    for (; lt.sibling === null; ) {
                      if (lt.return === null || lt.return === A) break e;
                      w === lt && (w = null), lt = lt.return;
                    }
                    w === lt && (w = null), lt.sibling.return = lt.return, lt = lt.sibling;
                  }
                }
                if (xt && !tn && (g.mode & 1) !== 0) {
                  Ge = g;
                  for (var le = g.child; le !== null; ) {
                    for (g = Ge = le; Ge !== null; ) {
                      A = Ge;
                      var ne = A.child;
                      switch (A.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                          Wo(4, A, A.return);
                          break;
                        case 1:
                          qh(A, A.return);
                          var ue = A.stateNode;
                          if (typeof ue.componentWillUnmount == "function") {
                            var He = A.return;
                            try {
                              ue.props = A.memoizedProps, ue.state = A.memoizedState, ue.componentWillUnmount();
                            } catch (st) {
                              Gi(
                                A,
                                He,
                                st
                              );
                            }
                          }
                          break;
                        case 5:
                          qh(A, A.return);
                          break;
                        case 22:
                          if (A.memoizedState !== null) {
                            ax(g);
                            continue;
                          }
                      }
                      ne !== null ? (ne.return = A, Ge = ne) : ax(g);
                    }
                    le = le.sibling;
                  }
                }
            }
            switch (Z & 4102) {
              case 2:
                ix(u), u.flags &= -3;
                break;
              case 6:
                ix(u), u.flags &= -3, Sm(u.alternate, u);
                break;
              case 4096:
                u.flags &= -4097;
                break;
              case 4100:
                u.flags &= -4097, Sm(u.alternate, u);
                break;
              case 4:
                Sm(u.alternate, u);
            }
          } catch (st) {
            Gi(u, u.return, st);
          }
          if (g = u.sibling, g !== null) {
            g.return = u.return, Ge = g;
            break;
          }
          Ge = u.return;
        }
      }
    }
    function Ww(c, u, g) {
      Ge = c, sx(c);
    }
    function sx(c, u, g) {
      for (var A = (c.mode & 1) !== 0; Ge !== null; ) {
        var E = Ge, w = E.child;
        if (E.tag === 22 && A) {
          var H = E.memoizedState !== null || Kh;
          if (!H) {
            var Z = E.alternate, de = Z !== null && Z.memoizedState !== null || Vo;
            Z = Kh;
            var we = Vo;
            if (Kh = H, (Vo = de) && !we) for (Ge = E; Ge !== null; ) H = Ge, de = H.child, H.tag === 22 && H.memoizedState !== null ? lx(E) : de !== null ? (de.return = H, Ge = de) : lx(E);
            for (; w !== null; ) Ge = w, sx(w), w = w.sibling;
            Ge = E, Kh = Z, Vo = we;
          }
          ox(c);
        } else (E.subtreeFlags & 8772) !== 0 && w !== null ? (w.return = E, Ge = w) : ox(c);
      }
    }
    function ox(c) {
      for (; Ge !== null; ) {
        var u = Ge;
        if ((u.flags & 8772) !== 0) {
          var g = u.alternate;
          try {
            if ((u.flags & 8772) !== 0) switch (u.tag) {
              case 0:
              case 11:
              case 15:
                Vo || Nc(5, u);
                break;
              case 1:
                var A = u.stateNode;
                if (u.flags & 4 && !Vo) if (g === null) A.componentDidMount();
                else {
                  var E = u.elementType === u.type ? g.memoizedProps : Or(u.type, g.memoizedProps);
                  A.componentDidUpdate(E, g.memoizedState, A.__reactInternalSnapshotBeforeUpdate);
                }
                var w = u.updateQueue;
                w !== null && ey(u, w, A);
                break;
              case 3:
                var H = u.updateQueue;
                if (H !== null) {
                  if (g = null, u.child !== null) switch (u.child.tag) {
                    case 5:
                      g = j(u.child.stateNode);
                      break;
                    case 1:
                      g = u.child.stateNode;
                  }
                  ey(u, H, g);
                }
                break;
              case 5:
                var Z = u.stateNode;
                g === null && u.flags & 4 && bt(Z, u.type, u.memoizedProps, u);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (pe && u.memoizedState === null) {
                  var de = u.alternate;
                  if (de !== null) {
                    var we = de.memoizedState;
                    if (we !== null) {
                      var Ke = we.dehydrated;
                      Ke !== null && ae(Ke);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
            Vo || u.flags & 512 && xm(u);
          } catch (xt) {
            Gi(u, u.return, xt);
          }
        }
        if (u === c) {
          Ge = null;
          break;
        }
        if (g = u.sibling, g !== null) {
          g.return = u.return, Ge = g;
          break;
        }
        Ge = u.return;
      }
    }
    function ax(c) {
      for (; Ge !== null; ) {
        var u = Ge;
        if (u === c) {
          Ge = null;
          break;
        }
        var g = u.sibling;
        if (g !== null) {
          g.return = u.return, Ge = g;
          break;
        }
        Ge = u.return;
      }
    }
    function lx(c) {
      for (; Ge !== null; ) {
        var u = Ge;
        try {
          switch (u.tag) {
            case 0:
            case 11:
            case 15:
              var g = u.return;
              try {
                Nc(4, u);
              } catch (de) {
                Gi(u, g, de);
              }
              break;
            case 1:
              var A = u.stateNode;
              if (typeof A.componentDidMount == "function") {
                var E = u.return;
                try {
                  A.componentDidMount();
                } catch (de) {
                  Gi(u, E, de);
                }
              }
              var w = u.return;
              try {
                xm(u);
              } catch (de) {
                Gi(u, w, de);
              }
              break;
            case 5:
              var H = u.return;
              try {
                xm(u);
              } catch (de) {
                Gi(u, H, de);
              }
          }
        } catch (de) {
          Gi(u, u.return, de);
        }
        if (u === c) {
          Ge = null;
          break;
        }
        var Z = u.sibling;
        if (Z !== null) {
          Z.return = u.return, Ge = Z;
          break;
        }
        Ge = u.return;
      }
    }
    var Zh = 0, jh = 1, $h = 2, ef = 3, tf = 4;
    if (typeof Symbol == "function" && Symbol.for) {
      var kc = Symbol.for;
      Zh = kc("selector.component"), jh = kc("selector.has_pseudo_class"), $h = kc("selector.role"), ef = kc("selector.test_id"), tf = kc("selector.text");
    }
    function Em(c) {
      var u = ce(c);
      if (u != null) {
        if (typeof u.memoizedProps["data-testname"] != "string") throw Error(o(364));
        return u;
      }
      if (c = $(c), c === null) throw Error(o(362));
      return c.stateNode.current;
    }
    function Tm(c, u) {
      switch (u.$$typeof) {
        case Zh:
          if (c.type === u.value) return !0;
          break;
        case jh:
          e: {
            u = u.value, c = [c, 0];
            for (var g = 0; g < c.length; ) {
              var A = c[g++], E = c[g++], w = u[E];
              if (A.tag !== 5 || !_e(A)) {
                for (; w != null && Tm(A, w); ) E++, w = u[E];
                if (E === u.length) {
                  u = !0;
                  break e;
                } else for (A = A.child; A !== null; ) c.push(A, E), A = A.sibling;
              }
            }
            u = !1;
          }
          return u;
        case $h:
          if (c.tag === 5 && Ue(c.stateNode, u.value)) return !0;
          break;
        case tf:
          if ((c.tag === 5 || c.tag === 6) && (c = Ae(c), c !== null && 0 <= c.indexOf(u.value))) return !0;
          break;
        case ef:
          if (c.tag === 5 && (c = c.memoizedProps["data-testname"], typeof c == "string" && c.toLowerCase() === u.value.toLowerCase())) return !0;
          break;
        default:
          throw Error(o(365));
      }
      return !1;
    }
    function wm(c) {
      switch (c.$$typeof) {
        case Zh:
          return "<" + (R(c.value) || "Unknown") + ">";
        case jh:
          return ":has(" + (wm(c) || "") + ")";
        case $h:
          return '[role="' + c.value + '"]';
        case tf:
          return '"' + c.value + '"';
        case ef:
          return '[data-testname="' + c.value + '"]';
        default:
          throw Error(o(365));
      }
    }
    function cx(c, u) {
      var g = [];
      c = [c, 0];
      for (var A = 0; A < c.length; ) {
        var E = c[A++], w = c[A++], H = u[w];
        if (E.tag !== 5 || !_e(E)) {
          for (; H != null && Tm(E, H); ) w++, H = u[w];
          if (w === u.length) g.push(E);
          else for (E = E.child; E !== null; ) c.push(E, w), E = E.sibling;
        }
      }
      return g;
    }
    function Cm(c, u) {
      if (!L) throw Error(o(363));
      c = Em(c), c = cx(c, u), u = [], c = Array.from(c);
      for (var g = 0; g < c.length; ) {
        var A = c[g++];
        if (A.tag === 5) _e(A) || u.push(A.stateNode);
        else for (A = A.child; A !== null; ) c.push(A), A = A.sibling;
      }
      return u;
    }
    var Xw = Math.ceil, nf = a.ReactCurrentDispatcher, bm = a.ReactCurrentOwner, bn = a.ReactCurrentBatchConfig, Bt = 0, Ln = null, Dn = null, ii = 0, er = 0, sl = un(0), Gn = 0, Gc = null, ol = 0, rf = 0, Rm = 0, Hc = null, Ni = null, Bm = 0, Pm = 1 / 0;
    function al() {
      Pm = qn() + 500;
    }
    var sf = !1, Im = null, js = null, of = !1, $s = null, af = 0, zc = 0, Lm = null, lf = -1, cf = 0;
    function wi() {
      return (Bt & 6) !== 0 ? qn() : lf !== -1 ? lf : lf = qn();
    }
    function eo(c) {
      return (c.mode & 1) === 0 ? 1 : (Bt & 2) !== 0 && ii !== 0 ? ii & -ii : Cw.transition !== null ? (cf === 0 && (c = Ah, Ah <<= 1, (Ah & 4194240) === 0 && (Ah = 64), cf = c), cf) : (c = Xt, c !== 0 ? c : fe());
    }
    function Er(c, u, g) {
      if (50 < zc) throw zc = 0, Lm = null, Error(o(185));
      var A = uf(c, u);
      return A === null ? null : (Tc(A, u, g), ((Bt & 2) === 0 || A !== Ln) && (A === Ln && ((Bt & 2) === 0 && (rf |= u), Gn === 4 && to(A, ii)), ki(A, g), u === 1 && Bt === 0 && (c.mode & 1) === 0 && (al(), Th && ns())), A);
    }
    function uf(c, u) {
      c.lanes |= u;
      var g = c.alternate;
      for (g !== null && (g.lanes |= u), g = c, c = c.return; c !== null; ) c.childLanes |= u, g = c.alternate, g !== null && (g.childLanes |= u), g = c, c = c.return;
      return g.tag === 3 ? g.stateNode : null;
    }
    function ki(c, u) {
      var g = c.callbackNode;
      vw(c, u);
      var A = Sh(c, c === Ln ? ii : 0);
      if (A === 0) g !== null && qv(g), c.callbackNode = null, c.callbackPriority = 0;
      else if (u = A & -A, c.callbackPriority !== u) {
        if (g != null && qv(g), u === 1) c.tag === 0 ? ww(hx.bind(null, c)) : Qv(hx.bind(null, c)), Ie ? O(function() {
          Bt === 0 && ns();
        }) : Hp(zp, ns), g = null;
        else {
          switch (Kv(A)) {
            case 1:
              g = zp;
              break;
            case 4:
              g = Mw;
              break;
            case 16:
              g = Vp;
              break;
            case 536870912:
              g = Sw;
              break;
            default:
              g = Vp;
          }
          g = xx(g, ux.bind(null, c));
        }
        c.callbackPriority = u, c.callbackNode = g;
      }
    }
    function ux(c, u) {
      if (lf = -1, cf = 0, (Bt & 6) !== 0) throw Error(o(327));
      var g = c.callbackNode;
      if (Yo() && c.callbackNode !== g) return null;
      var A = Sh(c, c === Ln ? ii : 0);
      if (A === 0) return null;
      if ((A & 30) !== 0 || (A & c.expiredLanes) !== 0 || u) u = hf(c, A);
      else {
        u = A;
        var E = Bt;
        Bt |= 2;
        var w = px();
        (Ln !== c || ii !== u) && (al(), Xo(c, u));
        do
          try {
            Kw();
            break;
          } catch (Z) {
            dx(c, Z);
          }
        while (!0);
        Jp(), nf.current = w, Bt = E, Dn !== null ? u = 0 : (Ln = null, ii = 0, u = Gn);
      }
      if (u !== 0) {
        if (u === 2 && (E = Np(c), E !== 0 && (A = E, u = Dm(c, E))), u === 1) throw g = Gc, Xo(c, 0), to(c, A), ki(c, qn()), g;
        if (u === 6) to(c, A);
        else {
          if (E = c.current.alternate, (A & 30) === 0 && !Jw(E) && (u = hf(c, A), u === 2 && (w = Np(c), w !== 0 && (A = w, u = Dm(c, w))), u === 1)) throw g = Gc, Xo(c, 0), to(c, A), ki(c, qn()), g;
          switch (c.finishedWork = E, c.finishedLanes = A, u) {
            case 0:
            case 1:
              throw Error(o(345));
            case 2:
              Jo(c, Ni);
              break;
            case 3:
              if (to(c, A), (A & 130023424) === A && (u = Bm + 500 - qn(), 10 < u)) {
                if (Sh(c, 0) !== 0) break;
                if (E = c.suspendedLanes, (E & A) !== A) {
                  wi(), c.pingedLanes |= c.suspendedLanes & E;
                  break;
                }
                c.timeoutHandle = me(Jo.bind(null, c, Ni), u);
                break;
              }
              Jo(c, Ni);
              break;
            case 4:
              if (to(c, A), (A & 4194240) === A) break;
              for (u = c.eventTimes, E = -1; 0 < A; ) {
                var H = 31 - Qi(A);
                w = 1 << H, H = u[H], H > E && (E = H), A &= ~w;
              }
              if (A = E, A = qn() - A, A = (120 > A ? 120 : 480 > A ? 480 : 1080 > A ? 1080 : 1920 > A ? 1920 : 3e3 > A ? 3e3 : 4320 > A ? 4320 : 1960 * Xw(A / 1960)) - A, 10 < A) {
                c.timeoutHandle = me(Jo.bind(null, c, Ni), A);
                break;
              }
              Jo(c, Ni);
              break;
            case 5:
              Jo(c, Ni);
              break;
            default:
              throw Error(o(329));
          }
        }
      }
      return ki(c, qn()), c.callbackNode === g ? ux.bind(null, c) : null;
    }
    function Dm(c, u) {
      var g = Hc;
      return c.current.memoizedState.isDehydrated && (Xo(c, u).flags |= 256), c = hf(c, u), c !== 2 && (u = Ni, Ni = g, u !== null && Fm(u)), c;
    }
    function Fm(c) {
      Ni === null ? Ni = c : Ni.push.apply(Ni, c);
    }
    function Jw(c) {
      for (var u = c; ; ) {
        if (u.flags & 16384) {
          var g = u.updateQueue;
          if (g !== null && (g = g.stores, g !== null)) for (var A = 0; A < g.length; A++) {
            var E = g[A], w = E.getSnapshot;
            E = E.value;
            try {
              if (!ts(w(), E)) return !1;
            } catch {
              return !1;
            }
          }
        }
        if (g = u.child, u.subtreeFlags & 16384 && g !== null) g.return = u, u = g;
        else {
          if (u === c) break;
          for (; u.sibling === null; ) {
            if (u.return === null || u.return === c) return !0;
            u = u.return;
          }
          u.sibling.return = u.return, u = u.sibling;
        }
      }
      return !0;
    }
    function to(c, u) {
      for (u &= ~Rm, u &= ~rf, c.suspendedLanes |= u, c.pingedLanes &= ~u, c = c.expirationTimes; 0 < u; ) {
        var g = 31 - Qi(u), A = 1 << g;
        c[g] = -1, u &= ~A;
      }
    }
    function hx(c) {
      if ((Bt & 6) !== 0) throw Error(o(327));
      Yo();
      var u = Sh(c, 0);
      if ((u & 1) === 0) return ki(c, qn()), null;
      var g = hf(c, u);
      if (c.tag !== 0 && g === 2) {
        var A = Np(c);
        A !== 0 && (u = A, g = Dm(c, A));
      }
      if (g === 1) throw g = Gc, Xo(c, 0), to(c, u), ki(c, qn()), g;
      if (g === 6) throw Error(o(345));
      return c.finishedWork = c.current.alternate, c.finishedLanes = u, Jo(c, Ni), ki(c, qn()), null;
    }
    function fx(c) {
      $s !== null && $s.tag === 0 && (Bt & 6) === 0 && Yo();
      var u = Bt;
      Bt |= 1;
      var g = bn.transition, A = Xt;
      try {
        if (bn.transition = null, Xt = 1, c) return c();
      } finally {
        Xt = A, bn.transition = g, Bt = u, (Bt & 6) === 0 && ns();
      }
    }
    function Um() {
      er = sl.current, ft(sl);
    }
    function Xo(c, u) {
      c.finishedWork = null, c.finishedLanes = 0;
      var g = c.timeoutHandle;
      if (g !== Pe && (c.timeoutHandle = Pe, Be(g)), Dn !== null) for (g = Dn.return; g !== null; ) {
        var A = g;
        switch ($p(A), A.tag) {
          case 1:
            A = A.type.childContextTypes, A != null && Cn();
            break;
          case 3:
            il(), ft(xn), ft(Rt), om();
            break;
          case 5:
            rm(A);
            break;
          case 4:
            il();
            break;
          case 13:
            ft(pn);
            break;
          case 19:
            ft(pn);
            break;
          case 10:
            Yp(A.type._context);
            break;
          case 22:
          case 23:
            Um();
        }
        g = g.return;
      }
      if (Ln = c, Dn = c = no(c.current, null), ii = er = u, Gn = 0, Gc = null, Rm = rf = ol = 0, Ni = Hc = null, is !== null) {
        for (u = 0; u < is.length; u++) if (g = is[u], A = g.interleaved, A !== null) {
          g.interleaved = null;
          var E = A.next, w = g.pending;
          if (w !== null) {
            var H = w.next;
            w.next = E, A.next = H;
          }
          g.pending = A;
        }
        is = null;
      }
      return c;
    }
    function dx(c, u) {
      do {
        var g = Dn;
        try {
          if (Jp(), Uh.current = zh, Oh) {
            for (var A = An.memoizedState; A !== null; ) {
              var E = A.queue;
              E !== null && (E.pending = null), A = A.next;
            }
            Oh = !1;
          }
          if (rl = 0, Qn = li = An = null, Pc = !1, Ic = 0, bm.current = null, g === null || g.return === null) {
            Gn = 1, Gc = u, Dn = null;
            break;
          }
          e: {
            var w = c, H = g.return, Z = g, de = u;
            if (u = ii, Z.flags |= 32768, de !== null && typeof de == "object" && typeof de.then == "function") {
              var we = de, Ke = Z, xt = Ke.tag;
              if ((Ke.mode & 1) === 0 && (xt === 0 || xt === 11 || xt === 15)) {
                var dt = Ke.alternate;
                dt ? (Ke.updateQueue = dt.updateQueue, Ke.memoizedState = dt.memoizedState, Ke.lanes = dt.lanes) : (Ke.updateQueue = null, Ke.memoizedState = null);
              }
              var tn = Dy(H);
              if (tn !== null) {
                tn.flags &= -257, Fy(tn, H, Z, w, u), tn.mode & 1 && Ly(w, we, u), u = tn, de = we;
                var lt = u.updateQueue;
                if (lt === null) {
                  var hi = /* @__PURE__ */ new Set();
                  hi.add(de), u.updateQueue = hi;
                } else lt.add(de);
                break e;
              } else {
                if ((u & 1) === 0) {
                  Ly(w, we, u), Om();
                  break e;
                }
                de = Error(o(426));
              }
            } else if (hn && Z.mode & 1) {
              var wr = Dy(H);
              if (wr !== null) {
                (wr.flags & 65536) === 0 && (wr.flags |= 256), Fy(wr, H, Z, w, u), nm(de);
                break e;
              }
            }
            w = de, Gn !== 4 && (Gn = 2), Hc === null ? Hc = [w] : Hc.push(w), de = dm(de, Z), Z = H;
            do {
              switch (Z.tag) {
                case 3:
                  Z.flags |= 65536, u &= -u, Z.lanes |= u;
                  var le = Py(Z, de, u);
                  $v(Z, le);
                  break e;
                case 1:
                  w = de;
                  var ne = Z.type, ue = Z.stateNode;
                  if ((Z.flags & 128) === 0 && (typeof ne.getDerivedStateFromError == "function" || ue !== null && typeof ue.componentDidCatch == "function" && (js === null || !js.has(ue)))) {
                    Z.flags |= 65536, u &= -u, Z.lanes |= u;
                    var He = Iy(Z, w, u);
                    $v(Z, He);
                    break e;
                  }
              }
              Z = Z.return;
            } while (Z !== null);
          }
          gx(g);
        } catch (st) {
          u = st, Dn === g && g !== null && (Dn = g = g.return);
          continue;
        }
        break;
      } while (!0);
    }
    function px() {
      var c = nf.current;
      return nf.current = zh, c === null ? zh : c;
    }
    function Om() {
      (Gn === 0 || Gn === 3 || Gn === 2) && (Gn = 4), Ln === null || (ol & 268435455) === 0 && (rf & 268435455) === 0 || to(Ln, ii);
    }
    function hf(c, u) {
      var g = Bt;
      Bt |= 2;
      var A = px();
      Ln === c && ii === u || Xo(c, u);
      do
        try {
          Yw();
          break;
        } catch (E) {
          dx(c, E);
        }
      while (!0);
      if (Jp(), Bt = g, nf.current = A, Dn !== null) throw Error(o(261));
      return Ln = null, ii = 0, Gn;
    }
    function Yw() {
      for (; Dn !== null; ) mx(Dn);
    }
    function Kw() {
      for (; Dn !== null && !xw(); ) mx(Dn);
    }
    function mx(c) {
      var u = yx(c.alternate, c, er);
      c.memoizedProps = c.pendingProps, u === null ? gx(c) : Dn = u, bm.current = null;
    }
    function gx(c) {
      var u = c;
      do {
        var g = u.alternate;
        if (c = u.return, (u.flags & 32768) === 0) {
          if (g = Ow(g, u, er), g !== null) {
            Dn = g;
            return;
          }
        } else {
          if (g = Gw(g, u), g !== null) {
            g.flags &= 32767, Dn = g;
            return;
          }
          if (c !== null) c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null;
          else {
            Gn = 6, Dn = null;
            return;
          }
        }
        if (u = u.sibling, u !== null) {
          Dn = u;
          return;
        }
        Dn = u = c;
      } while (u !== null);
      Gn === 0 && (Gn = 5);
    }
    function Jo(c, u) {
      var g = Xt, A = bn.transition;
      try {
        bn.transition = null, Xt = 1, qw(c, u, g);
      } finally {
        bn.transition = A, Xt = g;
      }
      return null;
    }
    function qw(c, u, g) {
      do
        Yo();
      while ($s !== null);
      if ((Bt & 6) !== 0) throw Error(o(327));
      var A = c.finishedWork, E = c.finishedLanes;
      if (A === null) return null;
      if (c.finishedWork = null, c.finishedLanes = 0, A === c.current) throw Error(o(177));
      c.callbackNode = null, c.callbackPriority = 0;
      var w = A.lanes | A.childLanes;
      if (yw(c, w), c === Ln && (Dn = Ln = null, ii = 0), (A.subtreeFlags & 2064) === 0 && (A.flags & 2064) === 0 || of || (of = !0, xx(Vp, function() {
        return Yo(), null;
      })), w = (A.flags & 15990) !== 0, (A.subtreeFlags & 15990) !== 0 || w) {
        w = bn.transition, bn.transition = null;
        var H = Xt;
        Xt = 1;
        var Z = Bt;
        Bt |= 4, bm.current = null, zw(c, A), Vw(c, A), I(c.containerInfo), c.current = A, Ww(A), Aw(), Bt = Z, Xt = H, bn.transition = w;
      } else c.current = A;
      if (of && (of = !1, $s = c, af = E), w = c.pendingLanes, w === 0 && (js = null), Ew(A.stateNode), ki(c, qn()), u !== null) for (g = c.onRecoverableError, A = 0; A < u.length; A++) g(u[A]);
      if (sf) throw sf = !1, c = Im, Im = null, c;
      return (af & 1) !== 0 && c.tag !== 0 && Yo(), w = c.pendingLanes, (w & 1) !== 0 ? c === Lm ? zc++ : (zc = 0, Lm = c) : zc = 0, ns(), null;
    }
    function Yo() {
      if ($s !== null) {
        var c = Kv(af), u = bn.transition, g = Xt;
        try {
          if (bn.transition = null, Xt = 16 > c ? 16 : c, $s === null) var A = !1;
          else {
            if (c = $s, $s = null, af = 0, (Bt & 6) !== 0) throw Error(o(331));
            var E = Bt;
            for (Bt |= 4, Ge = c.current; Ge !== null; ) {
              var w = Ge, H = w.child;
              if ((Ge.flags & 16) !== 0) {
                var Z = w.deletions;
                if (Z !== null) {
                  for (var de = 0; de < Z.length; de++) {
                    var we = Z[de];
                    for (Ge = we; Ge !== null; ) {
                      var Ke = Ge;
                      switch (Ke.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Wo(8, Ke, w);
                      }
                      var xt = Ke.child;
                      if (xt !== null) xt.return = Ke, Ge = xt;
                      else for (; Ge !== null; ) {
                        Ke = Ge;
                        var dt = Ke.sibling, tn = Ke.return;
                        if (ex(Ke), Ke === we) {
                          Ge = null;
                          break;
                        }
                        if (dt !== null) {
                          dt.return = tn, Ge = dt;
                          break;
                        }
                        Ge = tn;
                      }
                    }
                  }
                  var lt = w.alternate;
                  if (lt !== null) {
                    var hi = lt.child;
                    if (hi !== null) {
                      lt.child = null;
                      do {
                        var wr = hi.sibling;
                        hi.sibling = null, hi = wr;
                      } while (hi !== null);
                    }
                  }
                  Ge = w;
                }
              }
              if ((w.subtreeFlags & 2064) !== 0 && H !== null) H.return = w, Ge = H;
              else e: for (; Ge !== null; ) {
                if (w = Ge, (w.flags & 2048) !== 0) switch (w.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Wo(9, w, w.return);
                }
                var le = w.sibling;
                if (le !== null) {
                  le.return = w.return, Ge = le;
                  break e;
                }
                Ge = w.return;
              }
            }
            var ne = c.current;
            for (Ge = ne; Ge !== null; ) {
              H = Ge;
              var ue = H.child;
              if ((H.subtreeFlags & 2064) !== 0 && ue !== null) ue.return = H, Ge = ue;
              else e: for (H = ne; Ge !== null; ) {
                if (Z = Ge, (Z.flags & 2048) !== 0) try {
                  switch (Z.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Nc(9, Z);
                  }
                } catch (st) {
                  Gi(Z, Z.return, st);
                }
                if (Z === H) {
                  Ge = null;
                  break e;
                }
                var He = Z.sibling;
                if (He !== null) {
                  He.return = Z.return, Ge = He;
                  break e;
                }
                Ge = Z.return;
              }
            }
            if (Bt = E, ns(), es && typeof es.onPostCommitFiberRoot == "function") try {
              es.onPostCommitFiberRoot(Eh, c);
            } catch {
            }
            A = !0;
          }
          return A;
        } finally {
          Xt = g, bn.transition = u;
        }
      }
      return !1;
    }
    function _x(c, u, g) {
      u = dm(g, u), u = Py(c, u, 1), Zs(c, u), u = wi(), c = uf(c, 1), c !== null && (Tc(c, 1, u), ki(c, u));
    }
    function Gi(c, u, g) {
      if (c.tag === 3) _x(c, c, g);
      else for (; u !== null; ) {
        if (u.tag === 3) {
          _x(u, c, g);
          break;
        } else if (u.tag === 1) {
          var A = u.stateNode;
          if (typeof u.type.getDerivedStateFromError == "function" || typeof A.componentDidCatch == "function" && (js === null || !js.has(A))) {
            c = dm(g, c), c = Iy(u, c, 1), Zs(u, c), c = wi(), u = uf(u, 1), u !== null && (Tc(u, 1, c), ki(u, c));
            break;
          }
        }
        u = u.return;
      }
    }
    function Qw(c, u, g) {
      var A = c.pingCache;
      A !== null && A.delete(u), u = wi(), c.pingedLanes |= c.suspendedLanes & g, Ln === c && (ii & g) === g && (Gn === 4 || Gn === 3 && (ii & 130023424) === ii && 500 > qn() - Bm ? Xo(c, 0) : Rm |= g), ki(c, u);
    }
    function vx(c, u) {
      u === 0 && ((c.mode & 1) === 0 ? u = 1 : (u = Mh, Mh <<= 1, (Mh & 130023424) === 0 && (Mh = 4194304)));
      var g = wi();
      c = uf(c, u), c !== null && (Tc(c, u, g), ki(c, g));
    }
    function Zw(c) {
      var u = c.memoizedState, g = 0;
      u !== null && (g = u.retryLane), vx(c, g);
    }
    function jw(c, u) {
      var g = 0;
      switch (c.tag) {
        case 13:
          var A = c.stateNode, E = c.memoizedState;
          E !== null && (g = E.retryLane);
          break;
        case 19:
          A = c.stateNode;
          break;
        default:
          throw Error(o(314));
      }
      A !== null && A.delete(u), vx(c, g);
    }
    var yx;
    yx = function(c, u, g) {
      if (c !== null) if (c.memoizedProps !== u.pendingProps || xn.current) $i = !0;
      else {
        if ((c.lanes & g) === 0 && (u.flags & 128) === 0) return $i = !1, kw(c, u, g);
        $i = (c.flags & 131072) !== 0;
      }
      else $i = !1, hn && (u.flags & 1048576) !== 0 && sy(u, Lh, u.index);
      switch (u.lanes = 0, u.tag) {
        case 2:
          var A = u.type;
          c !== null && (c.alternate = null, u.alternate = null, u.flags |= 2), c = u.pendingProps;
          var E = vr(u, Rt.current);
          Za(u, g), E = lm(null, u, A, c, E, g);
          var w = cm();
          return u.flags |= 1, typeof E == "object" && E !== null && typeof E.render == "function" && E.$$typeof === void 0 ? (u.tag = 1, u.memoizedState = null, u.updateQueue = null, Kn(A) ? (w = !0, ni(u)) : w = !1, u.memoizedState = E.state !== null && E.state !== void 0 ? E.state : null, qp(u), E.updater = Ph, u.stateNode = E, E._reactInternals = u, Zp(u, A, c, g), u = gm(null, u, A, !0, w, g)) : (u.tag = 0, hn && w && jp(u), Ti(null, u, E, g), u = u.child), u;
        case 16:
          A = u.elementType;
          e: {
            switch (c !== null && (c.alternate = null, u.alternate = null, u.flags |= 2), c = u.pendingProps, E = A._init, A = E(A._payload), u.type = A, E = u.tag = eC(A), c = Or(A, c), E) {
              case 0:
                u = mm(null, u, A, c, g);
                break e;
              case 1:
                u = Vy(
                  null,
                  u,
                  A,
                  c,
                  g
                );
                break e;
              case 11:
                u = Ny(null, u, A, c, g);
                break e;
              case 14:
                u = ky(null, u, A, Or(A.type, c), g);
                break e;
            }
            throw Error(o(306, A, ""));
          }
          return u;
        case 0:
          return A = u.type, E = u.pendingProps, E = u.elementType === A ? E : Or(A, E), mm(c, u, A, E, g);
        case 1:
          return A = u.type, E = u.pendingProps, E = u.elementType === A ? E : Or(A, E), Vy(c, u, A, E, g);
        case 3:
          e: {
            if (Wy(u), c === null) throw Error(o(387));
            A = u.pendingProps, w = u.memoizedState, E = w.element, jv(c, u), Bh(u, A, null, g);
            var H = u.memoizedState;
            if (A = H.element, pe && w.isDehydrated) if (w = {
              element: A,
              isDehydrated: !1,
              cache: H.cache,
              transitions: H.transitions
            }, u.updateQueue.baseState = w, u.memoizedState = w, u.flags & 256) {
              E = Error(o(423)), u = Xy(c, u, A, g, E);
              break e;
            } else if (A !== E) {
              E = Error(o(424)), u = Xy(c, u, A, g, E);
              break e;
            } else for (pe && (ji = wn(u.stateNode.containerInfo), Zi = u, hn = !0, Nr = null, wc = !1), g = hy(u, null, A, g), u.child = g; g; ) g.flags = g.flags & -3 | 4096, g = g.sibling;
            else {
              if (el(), A === E) {
                u = ws(c, u, g);
                break e;
              }
              Ti(c, u, A, g);
            }
            u = u.child;
          }
          return u;
        case 5:
          return fy(u), c === null && tm(u), A = u.type, E = u.pendingProps, w = c !== null ? c.memoizedProps : null, H = E.children, he(A, E) ? H = null : w !== null && he(A, w) && (u.flags |= 32), zy(c, u), Ti(c, u, H, g), u.child;
        case 6:
          return c === null && tm(u), null;
        case 13:
          return Jy(c, u, g);
        case 4:
          return im(u, u.stateNode.containerInfo), A = u.pendingProps, c === null ? u.child = tl(u, null, A, g) : Ti(c, u, A, g), u.child;
        case 11:
          return A = u.type, E = u.pendingProps, E = u.elementType === A ? E : Or(A, E), Ny(c, u, A, E, g);
        case 7:
          return Ti(c, u, u.pendingProps, g), u.child;
        case 8:
          return Ti(c, u, u.pendingProps.children, g), u.child;
        case 12:
          return Ti(c, u, u.pendingProps.children, g), u.child;
        case 10:
          e: {
            if (A = u.type._context, E = u.pendingProps, w = u.memoizedProps, H = E.value, Zv(u, A, H), w !== null) if (ts(w.value, H)) {
              if (w.children === E.children && !xn.current) {
                u = ws(c, u, g);
                break e;
              }
            } else for (w = u.child, w !== null && (w.return = u); w !== null; ) {
              var Z = w.dependencies;
              if (Z !== null) {
                H = w.child;
                for (var de = Z.firstContext; de !== null; ) {
                  if (de.context === A) {
                    if (w.tag === 1) {
                      de = Ms(-1, g & -g), de.tag = 2;
                      var we = w.updateQueue;
                      if (we !== null) {
                        we = we.shared;
                        var Ke = we.pending;
                        Ke === null ? de.next = de : (de.next = Ke.next, Ke.next = de), we.pending = de;
                      }
                    }
                    w.lanes |= g, de = w.alternate, de !== null && (de.lanes |= g), Kp(w.return, g, u), Z.lanes |= g;
                    break;
                  }
                  de = de.next;
                }
              } else if (w.tag === 10) H = w.type === u.type ? null : w.child;
              else if (w.tag === 18) {
                if (H = w.return, H === null) throw Error(o(341));
                H.lanes |= g, Z = H.alternate, Z !== null && (Z.lanes |= g), Kp(H, g, u), H = w.sibling;
              } else H = w.child;
              if (H !== null) H.return = w;
              else for (H = w; H !== null; ) {
                if (H === u) {
                  H = null;
                  break;
                }
                if (w = H.sibling, w !== null) {
                  w.return = H.return, H = w;
                  break;
                }
                H = H.return;
              }
              w = H;
            }
            Ti(c, u, E.children, g), u = u.child;
          }
          return u;
        case 9:
          return E = u.type, A = u.pendingProps.children, Za(u, g), E = yr(E), A = A(E), u.flags |= 1, Ti(c, u, A, g), u.child;
        case 14:
          return A = u.type, E = Or(A, u.pendingProps), E = Or(A.type, E), ky(c, u, A, E, g);
        case 15:
          return Gy(c, u, u.type, u.pendingProps, g);
        case 17:
          return A = u.type, E = u.pendingProps, E = u.elementType === A ? E : Or(A, E), c !== null && (c.alternate = null, u.alternate = null, u.flags |= 2), u.tag = 1, Kn(A) ? (c = !0, ni(u)) : c = !1, Za(u, g), iy(u, A, E), Zp(u, A, E, g), gm(null, u, A, !0, c, g);
        case 19:
          return Qy(c, u, g);
        case 22:
          return Hy(c, u, g);
      }
      throw Error(o(156, u.tag));
    };
    function xx(c, u) {
      return Hp(c, u);
    }
    function $w(c, u, g, A) {
      this.tag = c, this.key = g, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = u, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = A, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Tr(c, u, g, A) {
      return new $w(c, u, g, A);
    }
    function Nm(c) {
      return c = c.prototype, !(!c || !c.isReactComponent);
    }
    function eC(c) {
      if (typeof c == "function") return Nm(c) ? 1 : 0;
      if (c != null) {
        if (c = c.$$typeof, c === x) return 11;
        if (c === S) return 14;
      }
      return 2;
    }
    function no(c, u) {
      var g = c.alternate;
      return g === null ? (g = Tr(c.tag, u, c.key, c.mode), g.elementType = c.elementType, g.type = c.type, g.stateNode = c.stateNode, g.alternate = c, c.alternate = g) : (g.pendingProps = u, g.type = c.type, g.flags = 0, g.subtreeFlags = 0, g.deletions = null), g.flags = c.flags & 14680064, g.childLanes = c.childLanes, g.lanes = c.lanes, g.child = c.child, g.memoizedProps = c.memoizedProps, g.memoizedState = c.memoizedState, g.updateQueue = c.updateQueue, u = c.dependencies, g.dependencies = u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }, g.sibling = c.sibling, g.index = c.index, g.ref = c.ref, g;
    }
    function ff(c, u, g, A, E, w) {
      var H = 2;
      if (A = c, typeof c == "function") Nm(c) && (H = 1);
      else if (typeof c == "string") H = 5;
      else e: switch (c) {
        case f:
          return Ko(g.children, E, w, u);
        case d:
          H = 8, E |= 8;
          break;
        case p:
          return c = Tr(12, g, u, E | 2), c.elementType = p, c.lanes = w, c;
        case y:
          return c = Tr(13, g, u, E), c.elementType = y, c.lanes = w, c;
        case v:
          return c = Tr(19, g, u, E), c.elementType = v, c.lanes = w, c;
        case T:
          return df(g, E, w, u);
        default:
          if (typeof c == "object" && c !== null) switch (c.$$typeof) {
            case m:
              H = 10;
              break e;
            case _:
              H = 9;
              break e;
            case x:
              H = 11;
              break e;
            case S:
              H = 14;
              break e;
            case M:
              H = 16, A = null;
              break e;
          }
          throw Error(o(130, c == null ? c : typeof c, ""));
      }
      return u = Tr(H, g, u, E), u.elementType = c, u.type = A, u.lanes = w, u;
    }
    function Ko(c, u, g, A) {
      return c = Tr(7, c, A, u), c.lanes = g, c;
    }
    function df(c, u, g, A) {
      return c = Tr(22, c, A, u), c.elementType = T, c.lanes = g, c.stateNode = {}, c;
    }
    function km(c, u, g) {
      return c = Tr(6, c, null, u), c.lanes = g, c;
    }
    function Gm(c, u, g) {
      return u = Tr(4, c.children !== null ? c.children : [], c.key, u), u.lanes = g, u.stateNode = { containerInfo: c.containerInfo, pendingChildren: null, implementation: c.implementation }, u;
    }
    function tC(c, u, g, A, E) {
      this.tag = u, this.containerInfo = c, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Pe, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = kp(0), this.expirationTimes = kp(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = kp(0), this.identifierPrefix = A, this.onRecoverableError = E, pe && (this.mutableSourceEagerHydrationData = null);
    }
    function Ax(c, u, g, A, E, w, H, Z, de) {
      return c = new tC(c, u, g, Z, de), u === 1 ? (u = 1, w === !0 && (u |= 8)) : u = 0, w = Tr(3, null, null, u), c.current = w, w.stateNode = c, w.memoizedState = { element: A, isDehydrated: g, cache: null, transitions: null }, qp(w), c;
    }
    function Mx(c) {
      if (!c) return _r;
      c = c._reactInternals;
      e: {
        if (C(c) !== c || c.tag !== 1) throw Error(o(170));
        var u = c;
        do {
          switch (u.tag) {
            case 3:
              u = u.stateNode.context;
              break e;
            case 1:
              if (Kn(u.type)) {
                u = u.stateNode.__reactInternalMemoizedMergedChildContext;
                break e;
              }
          }
          u = u.return;
        } while (u !== null);
        throw Error(o(171));
      }
      if (c.tag === 1) {
        var g = c.type;
        if (Kn(g)) return Ka(c, g, u);
      }
      return u;
    }
    function Sx(c) {
      var u = c._reactInternals;
      if (u === void 0)
        throw typeof c.render == "function" ? Error(o(188)) : (c = Object.keys(c).join(","), Error(o(268, c)));
      return c = W(u), c === null ? null : c.stateNode;
    }
    function Ex(c, u) {
      if (c = c.memoizedState, c !== null && c.dehydrated !== null) {
        var g = c.retryLane;
        c.retryLane = g !== 0 && g < u ? g : u;
      }
    }
    function Hm(c, u) {
      Ex(c, u), (c = c.alternate) && Ex(c, u);
    }
    function nC(c) {
      return c = W(c), c === null ? null : c.stateNode;
    }
    function iC() {
      return null;
    }
    return t.attemptContinuousHydration = function(c) {
      if (c.tag === 13) {
        var u = wi();
        Er(c, 134217728, u), Hm(c, 134217728);
      }
    }, t.attemptHydrationAtCurrentPriority = function(c) {
      if (c.tag === 13) {
        var u = wi(), g = eo(c);
        Er(c, g, u), Hm(c, g);
      }
    }, t.attemptSynchronousHydration = function(c) {
      switch (c.tag) {
        case 3:
          var u = c.stateNode;
          if (u.current.memoizedState.isDehydrated) {
            var g = Ec(u.pendingLanes);
            g !== 0 && (Gp(u, g | 1), ki(u, qn()), (Bt & 6) === 0 && (al(), ns()));
          }
          break;
        case 13:
          var A = wi();
          fx(function() {
            return Er(c, 1, A);
          }), Hm(c, 1);
      }
    }, t.batchedUpdates = function(c, u) {
      var g = Bt;
      Bt |= 1;
      try {
        return c(u);
      } finally {
        Bt = g, Bt === 0 && (al(), Th && ns());
      }
    }, t.createComponentSelector = function(c) {
      return { $$typeof: Zh, value: c };
    }, t.createContainer = function(c, u, g, A, E, w, H) {
      return Ax(c, u, !1, null, g, A, E, w, H);
    }, t.createHasPseudoClassSelector = function(c) {
      return { $$typeof: jh, value: c };
    }, t.createHydrationContainer = function(c, u, g, A, E, w, H, Z, de) {
      return c = Ax(g, A, !0, c, E, w, H, Z, de), c.context = Mx(null), g = c.current, A = wi(), E = eo(g), w = Ms(A, E), w.callback = u ?? null, Zs(g, w), c.current.lanes = E, Tc(c, E, A), ki(c, A), c;
    }, t.createPortal = function(c, u, g) {
      var A = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return { $$typeof: h, key: A == null ? null : "" + A, children: c, containerInfo: u, implementation: g };
    }, t.createRoleSelector = function(c) {
      return { $$typeof: $h, value: c };
    }, t.createTestNameSelector = function(c) {
      return { $$typeof: ef, value: c };
    }, t.createTextSelector = function(c) {
      return { $$typeof: tf, value: c };
    }, t.deferredUpdates = function(c) {
      var u = Xt, g = bn.transition;
      try {
        return bn.transition = null, Xt = 16, c();
      } finally {
        Xt = u, bn.transition = g;
      }
    }, t.discreteUpdates = function(c, u, g, A, E) {
      var w = Xt, H = bn.transition;
      try {
        return bn.transition = null, Xt = 1, c(u, g, A, E);
      } finally {
        Xt = w, bn.transition = H, Bt === 0 && al();
      }
    }, t.findAllNodes = Cm, t.findBoundingRects = function(c, u) {
      if (!L) throw Error(o(363));
      u = Cm(c, u), c = [];
      for (var g = 0; g < u.length; g++) c.push(xe(u[g]));
      for (u = c.length - 1; 0 < u; u--) {
        g = c[u];
        for (var A = g.x, E = A + g.width, w = g.y, H = w + g.height, Z = u - 1; 0 <= Z; Z--) if (u !== Z) {
          var de = c[Z], we = de.x, Ke = we + de.width, xt = de.y, dt = xt + de.height;
          if (A >= we && w >= xt && E <= Ke && H <= dt) {
            c.splice(u, 1);
            break;
          } else if (A !== we || g.width !== de.width || dt < w || xt > H) {
            if (!(w !== xt || g.height !== de.height || Ke < A || we > E)) {
              we > A && (de.width += we - A, de.x = A), Ke < E && (de.width = E - we), c.splice(u, 1);
              break;
            }
          } else {
            xt > w && (de.height += xt - w, de.y = w), dt < H && (de.height = H - xt), c.splice(u, 1);
            break;
          }
        }
      }
      return c;
    }, t.findHostInstance = Sx, t.findHostInstanceWithNoPortals = function(c) {
      return c = G(c), c = c !== null ? z(c) : null, c === null ? null : c.stateNode;
    }, t.findHostInstanceWithWarning = function(c) {
      return Sx(c);
    }, t.flushControlled = function(c) {
      var u = Bt;
      Bt |= 1;
      var g = bn.transition, A = Xt;
      try {
        bn.transition = null, Xt = 1, c();
      } finally {
        Xt = A, bn.transition = g, Bt = u, Bt === 0 && (al(), ns());
      }
    }, t.flushPassiveEffects = Yo, t.flushSync = fx, t.focusWithin = function(c, u) {
      if (!L) throw Error(o(363));
      for (c = Em(c), u = cx(c, u), u = Array.from(u), c = 0; c < u.length; ) {
        var g = u[c++];
        if (!_e(g)) {
          if (g.tag === 5 && Le(g.stateNode)) return !0;
          for (g = g.child; g !== null; ) u.push(g), g = g.sibling;
        }
      }
      return !1;
    }, t.getCurrentUpdatePriority = function() {
      return Xt;
    }, t.getFindAllNodesFailureDescription = function(c, u) {
      if (!L) throw Error(o(363));
      var g = 0, A = [];
      c = [Em(c), 0];
      for (var E = 0; E < c.length; ) {
        var w = c[E++], H = c[E++], Z = u[H];
        if ((w.tag !== 5 || !_e(w)) && (Tm(w, Z) && (A.push(wm(Z)), H++, H > g && (g = H)), H < u.length)) for (w = w.child; w !== null; ) c.push(w, H), w = w.sibling;
      }
      if (g < u.length) {
        for (c = []; g < u.length; g++) c.push(wm(u[g]));
        return `findAllNodes was able to match part of the selector:
  ` + (A.join(" > ") + `

No matching component was found for:
  `) + c.join(" > ");
      }
      return null;
    }, t.getPublicRootInstance = function(c) {
      if (c = c.current, !c.child) return null;
      switch (c.child.tag) {
        case 5:
          return j(c.child.stateNode);
        default:
          return c.child.stateNode;
      }
    }, t.injectIntoDevTools = function(c) {
      if (c = { bundleType: c.bundleType, version: c.version, rendererPackageName: c.rendererPackageName, rendererConfig: c.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: a.ReactCurrentDispatcher, findHostInstanceByFiber: nC, findFiberByHostInstance: c.findFiberByHostInstance || iC, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") c = !1;
      else {
        var u = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (u.isDisabled || !u.supportsFiber) c = !0;
        else {
          try {
            Eh = u.inject(c), es = u;
          } catch {
          }
          c = !!u.checkDCE;
        }
      }
      return c;
    }, t.isAlreadyRendering = function() {
      return !1;
    }, t.observeVisibleRects = function(c, u, g, A) {
      if (!L) throw Error(o(363));
      c = Cm(c, u);
      var E = Te(c, g, A).disconnect;
      return { disconnect: function() {
        E();
      } };
    }, t.registerMutableSourceForHydration = function(c, u) {
      var g = u._getVersion;
      g = g(u._source), c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [u, g] : c.mutableSourceEagerHydrationData.push(u, g);
    }, t.runWithPriority = function(c, u) {
      var g = Xt;
      try {
        return Xt = c, u();
      } finally {
        Xt = g;
      }
    }, t.shouldError = function() {
      return null;
    }, t.shouldSuspend = function() {
      return !1;
    }, t.updateContainer = function(c, u, g, A) {
      var E = u.current, w = wi(), H = eo(E);
      return g = Mx(g), u.context === null ? u.context = g : u.pendingContext = g, u = Ms(w, H), u.payload = { element: c }, A = A === void 0 ? null : A, A !== null && (u.callback = A), Zs(E, u), c = Er(E, H, w), c !== null && Rh(c, E, H), H;
    }, t;
  }), Pg;
}
var uM;
function u2() {
  return uM || (uM = 1, bg.exports = c2()), bg.exports;
}
var h2 = u2();
const f2 = /* @__PURE__ */ sC(h2);
var Ig = { exports: {} }, Lg = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hM;
function d2() {
  return hM || (hM = 1, function(s) {
    function e(N, V) {
      var I = N.length;
      N.push(V);
      e: for (; 0 < I; ) {
        var D = I - 1 >>> 1, J = N[D];
        if (0 < i(J, V)) N[D] = V, N[I] = J, I = D;
        else break e;
      }
    }
    function t(N) {
      return N.length === 0 ? null : N[0];
    }
    function n(N) {
      if (N.length === 0) return null;
      var V = N[0], I = N.pop();
      if (I !== V) {
        N[0] = I;
        e: for (var D = 0, J = N.length, K = J >>> 1; D < K; ) {
          var ie = 2 * (D + 1) - 1, he = N[ie], ge = ie + 1, me = N[ge];
          if (0 > i(he, I)) ge < J && 0 > i(me, he) ? (N[D] = me, N[ge] = I, D = ge) : (N[D] = he, N[ie] = I, D = ie);
          else if (ge < J && 0 > i(me, I)) N[D] = me, N[ge] = I, D = ge;
          else break e;
        }
      }
      return V;
    }
    function i(N, V) {
      var I = N.sortIndex - V.sortIndex;
      return I !== 0 ? I : N.id - V.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var r = performance;
      s.unstable_now = function() {
        return r.now();
      };
    } else {
      var o = Date, a = o.now();
      s.unstable_now = function() {
        return o.now() - a;
      };
    }
    var l = [], h = [], f = 1, d = null, p = 3, m = !1, _ = !1, x = !1, y = typeof setTimeout == "function" ? setTimeout : null, v = typeof clearTimeout == "function" ? clearTimeout : null, S = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function M(N) {
      for (var V = t(h); V !== null; ) {
        if (V.callback === null) n(h);
        else if (V.startTime <= N) n(h), V.sortIndex = V.expirationTime, e(l, V);
        else break;
        V = t(h);
      }
    }
    function T(N) {
      if (x = !1, M(N), !_) if (t(l) !== null) _ = !0, j(P);
      else {
        var V = t(h);
        V !== null && ee(T, V.startTime - N);
      }
    }
    function P(N, V) {
      _ = !1, x && (x = !1, v(U), U = -1), m = !0;
      var I = p;
      try {
        for (M(V), d = t(l); d !== null && (!(d.expirationTime > V) || N && !G()); ) {
          var D = d.callback;
          if (typeof D == "function") {
            d.callback = null, p = d.priorityLevel;
            var J = D(d.expirationTime <= V);
            V = s.unstable_now(), typeof J == "function" ? d.callback = J : d === t(l) && n(l), M(V);
          } else n(l);
          d = t(l);
        }
        if (d !== null) var K = !0;
        else {
          var ie = t(h);
          ie !== null && ee(T, ie.startTime - V), K = !1;
        }
        return K;
      } finally {
        d = null, p = I, m = !1;
      }
    }
    var b = !1, R = null, U = -1, C = 5, B = -1;
    function G() {
      return !(s.unstable_now() - B < C);
    }
    function W() {
      if (R !== null) {
        var N = s.unstable_now();
        B = N;
        var V = !0;
        try {
          V = R(!0, N);
        } finally {
          V ? se() : (b = !1, R = null);
        }
      } else b = !1;
    }
    var se;
    if (typeof S == "function") se = function() {
      S(W);
    };
    else if (typeof MessageChannel < "u") {
      var z = new MessageChannel(), q = z.port2;
      z.port1.onmessage = W, se = function() {
        q.postMessage(null);
      };
    } else se = function() {
      y(W, 0);
    };
    function j(N) {
      R = N, b || (b = !0, se());
    }
    function ee(N, V) {
      U = y(function() {
        N(s.unstable_now());
      }, V);
    }
    s.unstable_IdlePriority = 5, s.unstable_ImmediatePriority = 1, s.unstable_LowPriority = 4, s.unstable_NormalPriority = 3, s.unstable_Profiling = null, s.unstable_UserBlockingPriority = 2, s.unstable_cancelCallback = function(N) {
      N.callback = null;
    }, s.unstable_continueExecution = function() {
      _ || m || (_ = !0, j(P));
    }, s.unstable_forceFrameRate = function(N) {
      0 > N || 125 < N ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < N ? Math.floor(1e3 / N) : 5;
    }, s.unstable_getCurrentPriorityLevel = function() {
      return p;
    }, s.unstable_getFirstCallbackNode = function() {
      return t(l);
    }, s.unstable_next = function(N) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var V = 3;
          break;
        default:
          V = p;
      }
      var I = p;
      p = V;
      try {
        return N();
      } finally {
        p = I;
      }
    }, s.unstable_pauseExecution = function() {
    }, s.unstable_requestPaint = function() {
    }, s.unstable_runWithPriority = function(N, V) {
      switch (N) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          N = 3;
      }
      var I = p;
      p = N;
      try {
        return V();
      } finally {
        p = I;
      }
    }, s.unstable_scheduleCallback = function(N, V, I) {
      var D = s.unstable_now();
      switch (typeof I == "object" && I !== null ? (I = I.delay, I = typeof I == "number" && 0 < I ? D + I : D) : I = D, N) {
        case 1:
          var J = -1;
          break;
        case 2:
          J = 250;
          break;
        case 5:
          J = 1073741823;
          break;
        case 4:
          J = 1e4;
          break;
        default:
          J = 5e3;
      }
      return J = I + J, N = { id: f++, callback: V, priorityLevel: N, startTime: I, expirationTime: J, sortIndex: -1 }, I > D ? (N.sortIndex = I, e(h, N), t(l) === null && N === t(h) && (x ? (v(U), U = -1) : x = !0, ee(T, I - D))) : (N.sortIndex = J, e(l, N), _ || m || (_ = !0, j(P))), N;
    }, s.unstable_shouldYield = G, s.unstable_wrapCallback = function(N) {
      var V = p;
      return function() {
        var I = p;
        p = V;
        try {
          return N.apply(this, arguments);
        } finally {
          p = I;
        }
      };
    };
  }(Lg)), Lg;
}
var fM;
function p2() {
  return fM || (fM = 1, Ig.exports = d2()), Ig.exports;
}
var dM = p2();
const yv = {}, m2 = (s) => void Object.assign(yv, s);
function g2(s, e) {
  function t(f, {
    args: d = [],
    attach: p,
    ...m
  }, _) {
    let x = `${f[0].toUpperCase()}${f.slice(1)}`, y;
    if (f === "primitive") {
      if (m.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
      const v = m.object;
      y = Dl(v, {
        type: f,
        root: _,
        attach: p,
        primitive: !0
      });
    } else {
      const v = yv[x];
      if (!v)
        throw new Error(`R3F: ${x} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(d)) throw new Error("R3F: The args prop must be an array!");
      y = Dl(new v(...d), {
        type: f,
        root: _,
        attach: p,
        // Save args in case we need to reconstruct later for HMR
        memoizedProps: {
          args: d
        }
      });
    }
    return y.__r3f.attach === void 0 && (y.isBufferGeometry ? y.__r3f.attach = "geometry" : y.isMaterial && (y.__r3f.attach = "material")), x !== "inject" && Ug(y, m), y;
  }
  function n(f, d) {
    let p = !1;
    if (d) {
      var m, _;
      (m = d.__r3f) != null && m.attach ? Fg(f, d, d.__r3f.attach) : d.isObject3D && f.isObject3D && (f.add(d), p = !0), p || (_ = f.__r3f) == null || _.objects.push(d), d.__r3f || Dl(d, {}), d.__r3f.parent = f, Z_(d), Fl(d);
    }
  }
  function i(f, d, p) {
    let m = !1;
    if (d) {
      var _, x;
      if ((_ = d.__r3f) != null && _.attach)
        Fg(f, d, d.__r3f.attach);
      else if (d.isObject3D && f.isObject3D) {
        d.parent = f, d.dispatchEvent({
          type: "added"
        }), f.dispatchEvent({
          type: "childadded",
          child: d
        });
        const y = f.children.filter((S) => S !== d), v = y.indexOf(p);
        f.children = [...y.slice(0, v), d, ...y.slice(v)], m = !0;
      }
      m || (x = f.__r3f) == null || x.objects.push(d), d.__r3f || Dl(d, {}), d.__r3f.parent = f, Z_(d), Fl(d);
    }
  }
  function r(f, d, p = !1) {
    f && [...f].forEach((m) => o(d, m, p));
  }
  function o(f, d, p) {
    if (d) {
      var m, _, x;
      if (d.__r3f && (d.__r3f.parent = null), (m = f.__r3f) != null && m.objects && (f.__r3f.objects = f.__r3f.objects.filter((T) => T !== d)), (_ = d.__r3f) != null && _.attach)
        vM(f, d, d.__r3f.attach);
      else if (d.isObject3D && f.isObject3D) {
        var y;
        f.remove(d), (y = d.__r3f) != null && y.root && E2(Bd(d), d);
      }
      const S = (x = d.__r3f) == null ? void 0 : x.primitive, M = !S && (p === void 0 ? d.dispose !== null : p);
      if (!S) {
        var v;
        r((v = d.__r3f) == null ? void 0 : v.objects, d, M), r(d.children, d, M);
      }
      if (delete d.__r3f, M && d.dispose && d.type !== "Scene") {
        const T = () => {
          try {
            d.dispose();
          } catch {
          }
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u" ? dM.unstable_scheduleCallback(dM.unstable_IdlePriority, T) : T();
      }
      Fl(f);
    }
  }
  function a(f, d, p, m) {
    var _;
    const x = (_ = f.__r3f) == null ? void 0 : _.parent;
    if (!x) return;
    const y = t(d, p, f.__r3f.root);
    if (f.children) {
      for (const v of f.children)
        v.__r3f && n(y, v);
      f.children = f.children.filter((v) => !v.__r3f);
    }
    f.__r3f.objects.forEach((v) => n(y, v)), f.__r3f.objects = [], f.__r3f.autoRemovedBeforeAppend || o(x, f), y.parent && (y.__r3f.autoRemovedBeforeAppend = !0), n(x, y), y.raycast && y.__r3f.eventCount && Bd(y).getState().internal.interaction.push(y), [m, m.alternate].forEach((v) => {
      v !== null && (v.stateNode = y, v.ref && (typeof v.ref == "function" ? v.ref(y) : v.ref.current = y));
    });
  }
  const l = () => {
  };
  return {
    reconciler: f2({
      createInstance: t,
      removeChild: o,
      appendChild: n,
      appendInitialChild: n,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (f, d) => {
        if (!d) return;
        const p = f.getState().scene;
        p.__r3f && (p.__r3f.root = f, n(p, d));
      },
      removeChildFromContainer: (f, d) => {
        d && o(f.getState().scene, d);
      },
      insertInContainerBefore: (f, d, p) => {
        if (!d || !p) return;
        const m = f.getState().scene;
        m.__r3f && i(m, d, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (f) => f,
      finalizeInitialChildren(f) {
        var d;
        return !!((d = f?.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(f, d, p, m) {
        var _;
        if (((_ = f?.__r3f) != null ? _ : {}).primitive && m.object && m.object !== f)
          return [!0];
        {
          const {
            args: y = [],
            children: v,
            ...S
          } = m, {
            args: M = [],
            children: T,
            ...P
          } = p;
          if (!Array.isArray(y)) throw new Error("R3F: the args prop must be an array!");
          if (y.some((R, U) => R !== M[U])) return [!0];
          const b = P1(f, S, P, !0);
          return b.changes.length ? [!1, b] : null;
        }
      },
      commitUpdate(f, [d, p], m, _, x, y) {
        d ? a(f, m, x, y) : Ug(f, p);
      },
      commitMount(f, d, p, m) {
        var _;
        const x = (_ = f.__r3f) != null ? _ : {};
        f.raycast && x.handlers && x.eventCount && Bd(f).getState().internal.interaction.push(f);
      },
      getPublicInstance: (f) => f,
      prepareForCommit: () => null,
      preparePortalMount: (f) => Dl(f.getState().scene),
      resetAfterCommit: () => {
      },
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(f) {
        var d;
        const {
          attach: p,
          parent: m
        } = (d = f.__r3f) != null ? d : {};
        p && m && vM(m, f, p), f.isObject3D && (f.visible = !1), Fl(f);
      },
      unhideInstance(f, d) {
        var p;
        const {
          attach: m,
          parent: _
        } = (p = f.__r3f) != null ? p : {};
        m && _ && Fg(_, f, m), (f.isObject3D && d.visible == null || d.visible) && (f.visible = !0), Fl(f);
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874
      // @ts-expect-error
      getCurrentEventPriority: () => e ? e() : zl.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {
      },
      afterActiveInstanceBlur: () => {
      },
      detachDeletedInstance: () => {
      },
      now: typeof performance < "u" && ln.fun(performance.now) ? performance.now : ln.fun(Date.now) ? Date.now : () => 0,
      // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503
      scheduleTimeout: ln.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: ln.fun(clearTimeout) ? clearTimeout : void 0
    }),
    applyProps: Ug
  };
}
var pM, mM;
const Dg = (s) => "colorSpace" in s || "outputColorSpace" in s, T1 = () => {
  var s;
  return (s = yv.ColorManagement) != null ? s : null;
}, w1 = (s) => s && s.isOrthographicCamera, _2 = (s) => s && s.hasOwnProperty("current"), _h = typeof window < "u" && ((pM = window.document) != null && pM.createElement || ((mM = window.navigator) == null ? void 0 : mM.product) === "ReactNative") ? nt.useLayoutEffect : nt.useEffect;
function C1(s) {
  const e = nt.useRef(s);
  return _h(() => void (e.current = s), [s]), e;
}
function v2({
  set: s
}) {
  return _h(() => (s(new Promise(() => null)), () => s(!1)), [s]), null;
}
class b1 extends nt.Component {
  constructor(...e) {
    super(...e), this.state = {
      error: !1
    };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
b1.getDerivedStateFromError = () => ({
  error: !0
});
const R1 = "__default", gM = /* @__PURE__ */ new Map(), y2 = (s) => s && !!s.memoized && !!s.changes;
function B1(s) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(s) ? Math.min(Math.max(s[0], t), s[1]) : s;
}
const tu = (s) => {
  var e;
  return (e = s.__r3f) == null ? void 0 : e.root.getState();
};
function Bd(s) {
  let e = s.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const ln = {
  obj: (s) => s === Object(s) && !ln.arr(s) && typeof s != "function",
  fun: (s) => typeof s == "function",
  str: (s) => typeof s == "string",
  num: (s) => typeof s == "number",
  boo: (s) => typeof s == "boolean",
  und: (s) => s === void 0,
  arr: (s) => Array.isArray(s),
  equ(s, e, {
    arrays: t = "shallow",
    objects: n = "reference",
    strict: i = !0
  } = {}) {
    if (typeof s != typeof e || !!s != !!e) return !1;
    if (ln.str(s) || ln.num(s) || ln.boo(s)) return s === e;
    const r = ln.obj(s);
    if (r && n === "reference") return s === e;
    const o = ln.arr(s);
    if (o && t === "reference") return s === e;
    if ((o || r) && s === e) return !0;
    let a;
    for (a in s) if (!(a in e)) return !1;
    if (r && t === "shallow" && n === "shallow") {
      for (a in i ? e : s) if (!ln.equ(s[a], e[a], {
        strict: i,
        objects: "reference"
      })) return !1;
    } else
      for (a in i ? e : s) if (s[a] !== e[a]) return !1;
    if (ln.und(a)) {
      if (o && s.length === 0 && e.length === 0 || r && Object.keys(s).length === 0 && Object.keys(e).length === 0) return !0;
      if (s !== e) return !1;
    }
    return !0;
  }
};
function x2(s) {
  const e = {
    nodes: {},
    materials: {}
  };
  return s && s.traverse((t) => {
    t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material);
  }), e;
}
function A2(s) {
  s.dispose && s.type !== "Scene" && s.dispose();
  for (const e in s)
    e.dispose == null || e.dispose(), delete s[e];
}
function Dl(s, e) {
  const t = s;
  return t.__r3f = {
    type: "",
    root: null,
    previousAttach: null,
    memoizedProps: {},
    eventCount: 0,
    handlers: {},
    objects: [],
    parent: null,
    ...e
  }, s;
}
function Q_(s, e) {
  let t = s;
  if (e.includes("-")) {
    const n = e.split("-"), i = n.pop();
    return t = n.reduce((r, o) => r[o], s), {
      target: t,
      key: i
    };
  } else return {
    target: t,
    key: e
  };
}
const _M = /-\d+$/;
function Fg(s, e, t) {
  if (ln.str(t)) {
    if (_M.test(t)) {
      const r = t.replace(_M, ""), {
        target: o,
        key: a
      } = Q_(s, r);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const {
      target: n,
      key: i
    } = Q_(s, t);
    e.__r3f.previousAttach = n[i], n[i] = e;
  } else e.__r3f.previousAttach = t(s, e);
}
function vM(s, e, t) {
  var n, i;
  if (ln.str(t)) {
    const {
      target: r,
      key: o
    } = Q_(s, t), a = e.__r3f.previousAttach;
    a === void 0 ? delete r[o] : r[o] = a;
  } else (n = e.__r3f) == null || n.previousAttach == null || n.previousAttach(s, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function P1(s, {
  children: e,
  key: t,
  ref: n,
  ...i
}, {
  children: r,
  key: o,
  ref: a,
  ...l
} = {}, h = !1) {
  const f = s.__r3f, d = Object.entries(i), p = [];
  if (h) {
    const _ = Object.keys(l);
    for (let x = 0; x < _.length; x++)
      i.hasOwnProperty(_[x]) || d.unshift([_[x], R1 + "remove"]);
  }
  d.forEach(([_, x]) => {
    var y;
    if ((y = s.__r3f) != null && y.primitive && _ === "object" || ln.equ(x, l[_])) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(_)) return p.push([_, x, !0, []]);
    let v = [];
    _.includes("-") && (v = _.split("-")), p.push([_, x, !1, v]);
    for (const S in i) {
      const M = i[S];
      S.startsWith(`${_}-`) && p.push([S, M, !1, S.split("-")]);
    }
  });
  const m = {
    ...i
  };
  return f != null && f.memoizedProps && f != null && f.memoizedProps.args && (m.args = f.memoizedProps.args), f != null && f.memoizedProps && f != null && f.memoizedProps.attach && (m.attach = f.memoizedProps.attach), {
    memoized: m,
    changes: p
  };
}
function Ug(s, e) {
  var t;
  const n = s.__r3f, i = n?.root, r = i == null || i.getState == null ? void 0 : i.getState(), {
    memoized: o,
    changes: a
  } = y2(e) ? e : P1(s, e), l = n?.eventCount;
  s.__r3f && (s.__r3f.memoizedProps = o);
  for (let p = 0; p < a.length; p++) {
    let [m, _, x, y] = a[p];
    if (Dg(s)) {
      const T = "srgb", P = "srgb-linear";
      m === "encoding" ? (m = "colorSpace", _ = _ === 3001 ? T : P) : m === "outputEncoding" && (m = "outputColorSpace", _ = _ === 3001 ? T : P);
    }
    let v = s, S = v[m];
    if (y.length && (S = y.reduce((M, T) => M[T], s), !(S && S.set))) {
      const [M, ...T] = y.reverse();
      v = T.reverse().reduce((P, b) => P[b], s), m = M;
    }
    if (_ === R1 + "remove")
      if (v.constructor) {
        let M = gM.get(v.constructor);
        M || (M = new v.constructor(), gM.set(v.constructor, M)), _ = M[m];
      } else
        _ = 0;
    if (x && n)
      _ ? n.handlers[m] = _ : delete n.handlers[m], n.eventCount = Object.keys(n.handlers).length;
    else if (S && S.set && (S.copy || S instanceof Ea)) {
      if (Array.isArray(_))
        S.fromArray ? S.fromArray(_) : S.set(..._);
      else if (S.copy && _ && _.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.
      // Loosen to unminified names, ignoring descendents.
      // https://github.com/pmndrs/react-three-fiber/issues/2856
      // TODO: fix upstream and remove in v9
      S.constructor === _.constructor)
        S.copy(_);
      else if (_ !== void 0) {
        var h;
        const M = (h = S) == null ? void 0 : h.isColor;
        !M && S.setScalar ? S.setScalar(_) : S instanceof Ea && _ instanceof Ea ? S.mask = _.mask : S.set(_), !T1() && r && !r.linear && M && S.convertSRGBToLinear();
      }
    } else {
      var f;
      if (v[m] = _, (f = v[m]) != null && f.isTexture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129
      v[m].format === Di && v[m].type === ds && r) {
        const M = v[m];
        Dg(M) && Dg(r.gl) ? M.colorSpace = r.gl.outputColorSpace : M.encoding = r.gl.outputEncoding;
      }
    }
    Fl(s);
  }
  if (n && n.parent && s.raycast && l !== n.eventCount) {
    const p = Bd(s).getState().internal, m = p.interaction.indexOf(s);
    m > -1 && p.interaction.splice(m, 1), n.eventCount && p.interaction.push(s);
  }
  return !(a.length === 1 && a[0][0] === "onUpdate") && a.length && (t = s.__r3f) != null && t.parent && Z_(s), s;
}
function Fl(s) {
  var e, t;
  const n = (e = s.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  n && n.internal.frames === 0 && n.invalidate();
}
function Z_(s) {
  s.onUpdate == null || s.onUpdate(s);
}
function M2(s, e) {
  s.manual || (w1(s) ? (s.left = e.width / -2, s.right = e.width / 2, s.top = e.height / 2, s.bottom = e.height / -2) : s.aspect = e.width / e.height, s.updateProjectionMatrix(), s.updateMatrixWorld());
}
function od(s) {
  return (s.eventObject || s.object).uuid + "/" + s.index + s.instanceId;
}
function S2() {
  var s;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e) return zl.DefaultEventPriority;
  switch ((s = e.event) == null ? void 0 : s.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return zl.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return zl.ContinuousEventPriority;
    default:
      return zl.DefaultEventPriority;
  }
}
function I1(s, e, t, n) {
  const i = t.get(e);
  i && (t.delete(e), t.size === 0 && (s.delete(n), i.target.releasePointerCapture(n)));
}
function E2(s, e) {
  const {
    internal: t
  } = s.getState();
  t.interaction = t.interaction.filter((n) => n !== e), t.initialHits = t.initialHits.filter((n) => n !== e), t.hovered.forEach((n, i) => {
    (n.eventObject === e || n.object === e) && t.hovered.delete(i);
  }), t.capturedMap.forEach((n, i) => {
    I1(t.capturedMap, e, n, i);
  });
}
function T2(s) {
  function e(l) {
    const {
      internal: h
    } = s.getState(), f = l.offsetX - h.initialClick[0], d = l.offsetY - h.initialClick[1];
    return Math.round(Math.sqrt(f * f + d * d));
  }
  function t(l) {
    return l.filter((h) => ["Move", "Over", "Enter", "Out", "Leave"].some((f) => {
      var d;
      return (d = h.__r3f) == null ? void 0 : d.handlers["onPointer" + f];
    }));
  }
  function n(l, h) {
    const f = s.getState(), d = /* @__PURE__ */ new Set(), p = [], m = h ? h(f.internal.interaction) : f.internal.interaction;
    for (let v = 0; v < m.length; v++) {
      const S = tu(m[v]);
      S && (S.raycaster.camera = void 0);
    }
    f.previousRoot || f.events.compute == null || f.events.compute(l, f);
    function _(v) {
      const S = tu(v);
      if (!S || !S.events.enabled || S.raycaster.camera === null) return [];
      if (S.raycaster.camera === void 0) {
        var M;
        S.events.compute == null || S.events.compute(l, S, (M = S.previousRoot) == null ? void 0 : M.getState()), S.raycaster.camera === void 0 && (S.raycaster.camera = null);
      }
      return S.raycaster.camera ? S.raycaster.intersectObject(v, !0) : [];
    }
    let x = m.flatMap(_).sort((v, S) => {
      const M = tu(v.object), T = tu(S.object);
      return !M || !T ? v.distance - S.distance : T.events.priority - M.events.priority || v.distance - S.distance;
    }).filter((v) => {
      const S = od(v);
      return d.has(S) ? !1 : (d.add(S), !0);
    });
    f.events.filter && (x = f.events.filter(x, f));
    for (const v of x) {
      let S = v.object;
      for (; S; ) {
        var y;
        (y = S.__r3f) != null && y.eventCount && p.push({
          ...v,
          eventObject: S
        }), S = S.parent;
      }
    }
    if ("pointerId" in l && f.internal.capturedMap.has(l.pointerId))
      for (let v of f.internal.capturedMap.get(l.pointerId).values())
        d.has(od(v.intersection)) || p.push(v.intersection);
    return p;
  }
  function i(l, h, f, d) {
    const p = s.getState();
    if (l.length) {
      const m = {
        stopped: !1
      };
      for (const _ of l) {
        const x = tu(_.object) || p, {
          raycaster: y,
          pointer: v,
          camera: S,
          internal: M
        } = x, T = new k(v.x, v.y, 0).unproject(S), P = (B) => {
          var G, W;
          return (G = (W = M.capturedMap.get(B)) == null ? void 0 : W.has(_.eventObject)) != null ? G : !1;
        }, b = (B) => {
          const G = {
            intersection: _,
            target: h.target
          };
          M.capturedMap.has(B) ? M.capturedMap.get(B).set(_.eventObject, G) : M.capturedMap.set(B, /* @__PURE__ */ new Map([[_.eventObject, G]])), h.target.setPointerCapture(B);
        }, R = (B) => {
          const G = M.capturedMap.get(B);
          G && I1(M.capturedMap, _.eventObject, G, B);
        };
        let U = {};
        for (let B in h) {
          let G = h[B];
          typeof G != "function" && (U[B] = G);
        }
        let C = {
          ..._,
          ...U,
          pointer: v,
          intersections: l,
          stopped: m.stopped,
          delta: f,
          unprojectedPoint: T,
          ray: y.ray,
          camera: S,
          // Hijack stopPropagation, which just sets a flag
          stopPropagation() {
            const B = "pointerId" in h && M.capturedMap.get(h.pointerId);
            if (
              // ...if this pointer hasn't been captured
              (!B || // ... or if the hit object is capturing the pointer
              B.has(_.eventObject)) && (C.stopped = m.stopped = !0, M.hovered.size && Array.from(M.hovered.values()).find((G) => G.eventObject === _.eventObject))
            ) {
              const G = l.slice(0, l.indexOf(_));
              r([...G, _]);
            }
          },
          // there should be a distinction between target and currentTarget
          target: {
            hasPointerCapture: P,
            setPointerCapture: b,
            releasePointerCapture: R
          },
          currentTarget: {
            hasPointerCapture: P,
            setPointerCapture: b,
            releasePointerCapture: R
          },
          nativeEvent: h
        };
        if (d(C), m.stopped === !0) break;
      }
    }
    return l;
  }
  function r(l) {
    const {
      internal: h
    } = s.getState();
    for (const f of h.hovered.values())
      if (!l.length || !l.find((d) => d.object === f.object && d.index === f.index && d.instanceId === f.instanceId)) {
        const p = f.eventObject.__r3f, m = p?.handlers;
        if (h.hovered.delete(od(f)), p != null && p.eventCount) {
          const _ = {
            ...f,
            intersections: l
          };
          m.onPointerOut == null || m.onPointerOut(_), m.onPointerLeave == null || m.onPointerLeave(_);
        }
      }
  }
  function o(l, h) {
    for (let f = 0; f < h.length; f++) {
      const d = h[f].__r3f;
      d == null || d.handlers.onPointerMissed == null || d.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => r([]);
      case "onLostPointerCapture":
        return (h) => {
          const {
            internal: f
          } = s.getState();
          "pointerId" in h && f.capturedMap.has(h.pointerId) && requestAnimationFrame(() => {
            f.capturedMap.has(h.pointerId) && (f.capturedMap.delete(h.pointerId), r([]));
          });
        };
    }
    return function(f) {
      const {
        onPointerMissed: d,
        internal: p
      } = s.getState();
      p.lastEvent.current = f;
      const m = l === "onPointerMove", _ = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick", y = n(f, m ? t : void 0), v = _ ? e(f) : 0;
      l === "onPointerDown" && (p.initialClick = [f.offsetX, f.offsetY], p.initialHits = y.map((M) => M.eventObject)), _ && !y.length && v <= 2 && (o(f, p.interaction), d && d(f)), m && r(y);
      function S(M) {
        const T = M.eventObject, P = T.__r3f, b = P?.handlers;
        if (P != null && P.eventCount)
          if (m) {
            if (b.onPointerOver || b.onPointerEnter || b.onPointerOut || b.onPointerLeave) {
              const R = od(M), U = p.hovered.get(R);
              U ? U.stopped && M.stopPropagation() : (p.hovered.set(R, M), b.onPointerOver == null || b.onPointerOver(M), b.onPointerEnter == null || b.onPointerEnter(M));
            }
            b.onPointerMove == null || b.onPointerMove(M);
          } else {
            const R = b[l];
            R ? (!_ || p.initialHits.includes(T)) && (o(f, p.interaction.filter((U) => !p.initialHits.includes(U))), R(M)) : _ && p.initialHits.includes(T) && o(f, p.interaction.filter((U) => !p.initialHits.includes(U)));
          }
      }
      i(y, f, v, S);
    };
  }
  return {
    handlePointer: a
  };
}
const L1 = (s) => !!(s != null && s.render), D1 = /* @__PURE__ */ nt.createContext(null), w2 = (s, e) => {
  const t = n2((a, l) => {
    const h = new k(), f = new k(), d = new k();
    function p(v = l().camera, S = f, M = l().size) {
      const {
        width: T,
        height: P,
        top: b,
        left: R
      } = M, U = T / P;
      S.isVector3 ? d.copy(S) : d.set(...S);
      const C = v.getWorldPosition(h).distanceTo(d);
      if (w1(v))
        return {
          width: T / v.zoom,
          height: P / v.zoom,
          top: b,
          left: R,
          factor: 1,
          distance: C,
          aspect: U
        };
      {
        const B = v.fov * Math.PI / 180, G = 2 * Math.tan(B / 2) * C, W = G * (T / P);
        return {
          width: W,
          height: G,
          top: b,
          left: R,
          factor: T / W,
          distance: C,
          aspect: U
        };
      }
    }
    let m;
    const _ = (v) => a((S) => ({
      performance: {
        ...S.performance,
        current: v
      }
    })), x = new ve();
    return {
      set: a,
      get: l,
      // Mock objects that have to be configured
      gl: null,
      camera: null,
      raycaster: null,
      events: {
        priority: 1,
        enabled: !0,
        connected: !1
      },
      xr: null,
      scene: null,
      invalidate: (v = 1) => s(l(), v),
      advance: (v, S) => e(v, S, l()),
      legacy: !1,
      linear: !1,
      flat: !1,
      controls: null,
      clock: new mv(),
      pointer: x,
      mouse: x,
      frameloop: "always",
      onPointerMissed: void 0,
      performance: {
        current: 1,
        min: 0.5,
        max: 1,
        debounce: 200,
        regress: () => {
          const v = l();
          m && clearTimeout(m), v.performance.current !== v.performance.min && _(v.performance.min), m = setTimeout(() => _(l().performance.max), v.performance.debounce);
        }
      },
      size: {
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        updateStyle: !1
      },
      viewport: {
        initialDpr: 0,
        dpr: 0,
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        aspect: 0,
        distance: 0,
        factor: 0,
        getCurrentViewport: p
      },
      setEvents: (v) => a((S) => ({
        ...S,
        events: {
          ...S.events,
          ...v
        }
      })),
      setSize: (v, S, M, T, P) => {
        const b = l().camera, R = {
          width: v,
          height: S,
          top: T || 0,
          left: P || 0,
          updateStyle: M
        };
        a((U) => ({
          size: R,
          viewport: {
            ...U.viewport,
            ...p(b, f, R)
          }
        }));
      },
      setDpr: (v) => a((S) => {
        const M = B1(v);
        return {
          viewport: {
            ...S.viewport,
            dpr: M,
            initialDpr: S.viewport.initialDpr || M
          }
        };
      }),
      setFrameloop: (v = "always") => {
        const S = l().clock;
        S.stop(), S.elapsedTime = 0, v !== "never" && (S.start(), S.elapsedTime = 0), a(() => ({
          frameloop: v
        }));
      },
      previousRoot: void 0,
      internal: {
        active: !1,
        priority: 0,
        frames: 0,
        lastEvent: /* @__PURE__ */ nt.createRef(),
        interaction: [],
        hovered: /* @__PURE__ */ new Map(),
        subscribers: [],
        initialClick: [0, 0],
        initialHits: [],
        capturedMap: /* @__PURE__ */ new Map(),
        subscribe: (v, S, M) => {
          const T = l().internal;
          return T.priority = T.priority + (S > 0 ? 1 : 0), T.subscribers.push({
            ref: v,
            priority: S,
            store: M
          }), T.subscribers = T.subscribers.sort((P, b) => P.priority - b.priority), () => {
            const P = l().internal;
            P != null && P.subscribers && (P.priority = P.priority - (S > 0 ? 1 : 0), P.subscribers = P.subscribers.filter((b) => b.ref !== v));
          };
        }
      }
    };
  }), n = t.getState();
  let i = n.size, r = n.viewport.dpr, o = n.camera;
  return t.subscribe(() => {
    const {
      camera: a,
      size: l,
      viewport: h,
      gl: f,
      set: d
    } = t.getState();
    if (l.width !== i.width || l.height !== i.height || h.dpr !== r) {
      var p;
      i = l, r = h.dpr, M2(a, l), f.setPixelRatio(h.dpr);
      const m = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && f.domElement instanceof HTMLCanvasElement;
      f.setSize(l.width, l.height, m);
    }
    a !== o && (o = a, d((m) => ({
      viewport: {
        ...m.viewport,
        ...m.viewport.getCurrentViewport(a)
      }
    })));
  }), t.subscribe((a) => s(a)), t;
};
let ad, C2 = /* @__PURE__ */ new Set(), b2 = /* @__PURE__ */ new Set(), R2 = /* @__PURE__ */ new Set();
function Og(s, e) {
  if (s.size)
    for (const {
      callback: t
    } of s.values())
      t(e);
}
function nu(s, e) {
  switch (s) {
    case "before":
      return Og(C2, e);
    case "after":
      return Og(b2, e);
    case "tail":
      return Og(R2, e);
  }
}
let Ng, kg;
function Gg(s, e, t) {
  let n = e.clock.getDelta();
  for (e.frameloop === "never" && typeof s == "number" && (n = s - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = s), Ng = e.internal.subscribers, ad = 0; ad < Ng.length; ad++)
    kg = Ng[ad], kg.ref.current(kg.store.getState(), n, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function B2(s) {
  let e = !1, t = !1, n, i, r;
  function o(h) {
    i = requestAnimationFrame(o), e = !0, n = 0, nu("before", h), t = !0;
    for (const d of s.values()) {
      var f;
      r = d.store.getState(), r.internal.active && (r.frameloop === "always" || r.internal.frames > 0) && !((f = r.gl.xr) != null && f.isPresenting) && (n += Gg(h, r));
    }
    if (t = !1, nu("after", h), n === 0)
      return nu("tail", h), e = !1, cancelAnimationFrame(i);
  }
  function a(h, f = 1) {
    var d;
    if (!h) return s.forEach((p) => a(p.store.getState(), f));
    (d = h.gl.xr) != null && d.isPresenting || !h.internal.active || h.frameloop === "never" || (f > 1 ? h.internal.frames = Math.min(60, h.internal.frames + f) : t ? h.internal.frames = 2 : h.internal.frames = 1, e || (e = !0, requestAnimationFrame(o)));
  }
  function l(h, f = !0, d, p) {
    if (f && nu("before", h), d) Gg(h, d, p);
    else for (const m of s.values()) Gg(h, m.store.getState());
    f && nu("after", h);
  }
  return {
    loop: o,
    invalidate: a,
    advance: l
  };
}
function F1() {
  const s = nt.useContext(D1);
  if (!s) throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return s;
}
function P2(s = (t) => t, e) {
  return F1()(s, e);
}
function I2(s, e = 0) {
  const t = F1(), n = t.getState().internal.subscribe, i = C1(s);
  return _h(() => n(i, e, t), [e, n, t]), null;
}
const yM = /* @__PURE__ */ new WeakMap();
function U1(s, e) {
  return function(t, ...n) {
    let i = yM.get(t);
    return i || (i = new t(), yM.set(t, i)), s && s(i), Promise.all(n.map((r) => new Promise((o, a) => i.load(r, (l) => {
      l.scene && Object.assign(l, x2(l.scene)), o(l);
    }, e, (l) => a(new Error(`Could not load ${r}: ${l?.message}`))))));
  };
}
function vh(s, e, t, n) {
  const i = Array.isArray(e) ? e : [e], r = r2(U1(t, n), [s, ...i], {
    equal: ln.equ
  });
  return Array.isArray(e) ? r : r[0];
}
vh.preload = function(s, e, t) {
  const n = Array.isArray(e) ? e : [e];
  return s2(U1(t), [s, ...n]);
};
vh.clear = function(s, e) {
  const t = Array.isArray(e) ? e : [e];
  return o2([s, ...t]);
};
const cc = /* @__PURE__ */ new Map(), {
  invalidate: xM,
  advance: AM
} = B2(cc), {
  reconciler: Jd,
  applyProps: Rl
} = g2(cc, S2), Bl = {
  objects: "shallow",
  strict: !1
}, L2 = (s, e) => {
  const t = typeof s == "function" ? s(e) : s;
  return L1(t) ? t : new Y0({
    powerPreference: "high-performance",
    canvas: e,
    antialias: !0,
    alpha: !0,
    ...s
  });
};
function D2(s, e) {
  const t = typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement;
  if (e) {
    const {
      width: n,
      height: i,
      top: r,
      left: o,
      updateStyle: a = t
    } = e;
    return {
      width: n,
      height: i,
      top: r,
      left: o,
      updateStyle: a
    };
  } else if (typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement && s.parentElement) {
    const {
      width: n,
      height: i,
      top: r,
      left: o
    } = s.parentElement.getBoundingClientRect();
    return {
      width: n,
      height: i,
      top: r,
      left: o,
      updateStyle: t
    };
  } else if (typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas)
    return {
      width: s.width,
      height: s.height,
      top: 0,
      left: 0,
      updateStyle: t
    };
  return {
    width: 0,
    height: 0,
    top: 0,
    left: 0
  };
}
function F2(s) {
  const e = cc.get(s), t = e?.fiber, n = e?.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? (
    // In modern browsers, reportError will dispatch an error event,
    // emulating an uncaught JavaScript error.
    reportError
  ) : (
    // In older browsers and test environments, fallback to console.error.
    console.error
  ), r = n || w2(xM, AM), o = t || Jd.createContainer(r, zl.ConcurrentRoot, null, !1, null, "", i, null);
  e || cc.set(s, {
    fiber: o,
    store: r
  });
  let a, l = !1, h;
  return {
    configure(f = {}) {
      let {
        gl: d,
        size: p,
        scene: m,
        events: _,
        onCreated: x,
        shadows: y = !1,
        linear: v = !1,
        flat: S = !1,
        legacy: M = !1,
        orthographic: T = !1,
        frameloop: P = "always",
        dpr: b = [1, 2],
        performance: R,
        raycaster: U,
        camera: C,
        onPointerMissed: B
      } = f, G = r.getState(), W = G.gl;
      G.gl || G.set({
        gl: W = L2(d, s)
      });
      let se = G.raycaster;
      se || G.set({
        raycaster: se = new A1()
      });
      const {
        params: z,
        ...q
      } = U || {};
      if (ln.equ(q, se, Bl) || Rl(se, {
        ...q
      }), ln.equ(z, se.params, Bl) || Rl(se, {
        params: {
          ...se.params,
          ...z
        }
      }), !G.camera || G.camera === h && !ln.equ(h, C, Bl)) {
        h = C;
        const I = C instanceof ah, D = I ? C : T ? new xc(0, 0, 0, 0, 0.1, 1e3) : new Wn(75, 0, 0.1, 1e3);
        I || (D.position.z = 5, C && (Rl(D, C), ("aspect" in C || "left" in C || "right" in C || "bottom" in C || "top" in C) && (D.manual = !0, D.updateProjectionMatrix())), !G.camera && !(C != null && C.rotation) && D.lookAt(0, 0, 0)), G.set({
          camera: D
        }), se.camera = D;
      }
      if (!G.scene) {
        let I;
        m != null && m.isScene ? I = m : (I = new K0(), m && Rl(I, m)), G.set({
          scene: Dl(I)
        });
      }
      if (!G.xr) {
        var j;
        const I = (K, ie) => {
          const he = r.getState();
          he.frameloop !== "never" && AM(K, !0, he, ie);
        }, D = () => {
          const K = r.getState();
          K.gl.xr.enabled = K.gl.xr.isPresenting, K.gl.xr.setAnimationLoop(K.gl.xr.isPresenting ? I : null), K.gl.xr.isPresenting || xM(K);
        }, J = {
          connect() {
            const K = r.getState().gl;
            K.xr.addEventListener("sessionstart", D), K.xr.addEventListener("sessionend", D);
          },
          disconnect() {
            const K = r.getState().gl;
            K.xr.removeEventListener("sessionstart", D), K.xr.removeEventListener("sessionend", D);
          }
        };
        typeof ((j = W.xr) == null ? void 0 : j.addEventListener) == "function" && J.connect(), G.set({
          xr: J
        });
      }
      if (W.shadowMap) {
        const I = W.shadowMap.enabled, D = W.shadowMap.type;
        if (W.shadowMap.enabled = !!y, ln.boo(y))
          W.shadowMap.type = mu;
        else if (ln.str(y)) {
          var ee;
          const J = {
            basic: vS,
            percentage: op,
            soft: mu,
            variance: Vr
          };
          W.shadowMap.type = (ee = J[y]) != null ? ee : mu;
        } else ln.obj(y) && Object.assign(W.shadowMap, y);
        (I !== W.shadowMap.enabled || D !== W.shadowMap.type) && (W.shadowMap.needsUpdate = !0);
      }
      const N = T1();
      N && ("enabled" in N ? N.enabled = !M : "legacyMode" in N && (N.legacyMode = M)), l || Rl(W, {
        outputEncoding: v ? 3e3 : 3001,
        toneMapping: S ? fs : w0
      }), G.legacy !== M && G.set(() => ({
        legacy: M
      })), G.linear !== v && G.set(() => ({
        linear: v
      })), G.flat !== S && G.set(() => ({
        flat: S
      })), d && !ln.fun(d) && !L1(d) && !ln.equ(d, W, Bl) && Rl(W, d), _ && !G.events.handlers && G.set({
        events: _(r)
      });
      const V = D2(s, p);
      return ln.equ(V, G.size, Bl) || G.setSize(V.width, V.height, V.updateStyle, V.top, V.left), b && G.viewport.dpr !== B1(b) && G.setDpr(b), G.frameloop !== P && G.setFrameloop(P), G.onPointerMissed || G.set({
        onPointerMissed: B
      }), R && !ln.equ(R, G.performance, Bl) && G.set((I) => ({
        performance: {
          ...I.performance,
          ...R
        }
      })), a = x, l = !0, this;
    },
    render(f) {
      return l || this.configure(), Jd.updateContainer(/* @__PURE__ */ Pn.jsx(U2, {
        store: r,
        children: f,
        onCreated: a,
        rootElement: s
      }), o, null, () => {
      }), r;
    },
    unmount() {
      O1(s);
    }
  };
}
function U2({
  store: s,
  children: e,
  onCreated: t,
  rootElement: n
}) {
  return _h(() => {
    const i = s.getState();
    i.set((r) => ({
      internal: {
        ...r.internal,
        active: !0
      }
    })), t && t(i), s.getState().events.connected || i.events.connect == null || i.events.connect(n);
  }, []), /* @__PURE__ */ Pn.jsx(D1.Provider, {
    value: s,
    children: e
  });
}
function O1(s, e) {
  const t = cc.get(s), n = t?.fiber;
  if (n) {
    const i = t?.store.getState();
    i && (i.internal.active = !1), Jd.updateContainer(null, n, null, () => {
      i && setTimeout(() => {
        try {
          var r, o, a, l;
          i.events.disconnect == null || i.events.disconnect(), (r = i.gl) == null || (o = r.renderLists) == null || o.dispose == null || o.dispose(), (a = i.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (l = i.gl) != null && l.xr && i.xr.disconnect(), A2(i), cc.delete(s);
        } catch {
        }
      }, 500);
    });
  }
}
Jd.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: nt.version
});
const Hg = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0]
};
function O2(s) {
  const {
    handlePointer: e
  } = T2(s);
  return {
    priority: 1,
    enabled: !0,
    compute(t, n, i) {
      n.pointer.set(t.offsetX / n.size.width * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1), n.raycaster.setFromCamera(n.pointer, n.camera);
    },
    connected: void 0,
    handlers: Object.keys(Hg).reduce((t, n) => ({
      ...t,
      [n]: e(n)
    }), {}),
    update: () => {
      var t;
      const {
        events: n,
        internal: i
      } = s.getState();
      (t = i.lastEvent) != null && t.current && n.handlers && n.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var n;
      const {
        set: i,
        events: r
      } = s.getState();
      r.disconnect == null || r.disconnect(), i((o) => ({
        events: {
          ...o.events,
          connected: t
        }
      })), Object.entries((n = r.handlers) != null ? n : []).forEach(([o, a]) => {
        const [l, h] = Hg[o];
        t.addEventListener(l, a, {
          passive: h
        });
      });
    },
    disconnect: () => {
      const {
        set: t,
        events: n
      } = s.getState();
      if (n.connected) {
        var i;
        Object.entries((i = n.handlers) != null ? i : []).forEach(([r, o]) => {
          if (n && n.connected instanceof HTMLElement) {
            const [a] = Hg[r];
            n.connected.removeEventListener(a, o);
          }
        }), t((r) => ({
          events: {
            ...r.events,
            connected: void 0
          }
        }));
      }
    }
  };
}
function MM(s, e) {
  let t;
  return (...n) => {
    window.clearTimeout(t), t = window.setTimeout(() => s(...n), e);
  };
}
function N2({ debounce: s, scroll: e, polyfill: t, offsetSize: n } = { debounce: 0, scroll: !1, offsetSize: !1 }) {
  const i = t || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!i) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [r, o] = nt.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), a = nt.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: r, orientationHandler: null }), l = s ? typeof s == "number" ? s : s.scroll : null, h = s ? typeof s == "number" ? s : s.resize : null, f = nt.useRef(!1);
  nt.useEffect(() => (f.current = !0, () => void (f.current = !1)));
  const [d, p, m] = nt.useMemo(() => {
    const v = () => {
      if (!a.current.element) return;
      const { left: S, top: M, width: T, height: P, bottom: b, right: R, x: U, y: C } = a.current.element.getBoundingClientRect(), B = { left: S, top: M, width: T, height: P, bottom: b, right: R, x: U, y: C };
      a.current.element instanceof HTMLElement && n && (B.height = a.current.element.offsetHeight, B.width = a.current.element.offsetWidth), Object.freeze(B), f.current && !z2(a.current.lastBounds, B) && o(a.current.lastBounds = B);
    };
    return [v, h ? MM(v, h) : v, l ? MM(v, l) : v];
  }, [o, n, l, h]);
  function _() {
    a.current.scrollContainers && (a.current.scrollContainers.forEach((v) => v.removeEventListener("scroll", m, !0)), a.current.scrollContainers = null), a.current.resizeObserver && (a.current.resizeObserver.disconnect(), a.current.resizeObserver = null), a.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", a.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", a.current.orientationHandler));
  }
  function x() {
    a.current.element && (a.current.resizeObserver = new i(m), a.current.resizeObserver.observe(a.current.element), e && a.current.scrollContainers && a.current.scrollContainers.forEach((v) => v.addEventListener("scroll", m, { capture: !0, passive: !0 })), a.current.orientationHandler = () => {
      m();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", a.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", a.current.orientationHandler));
  }
  const y = (v) => {
    !v || v === a.current.element || (_(), a.current.element = v, a.current.scrollContainers = N1(v), x());
  };
  return G2(m, !!e), k2(p), nt.useEffect(() => {
    _(), x();
  }, [e, m, p]), nt.useEffect(() => _, []), [y, r, d];
}
function k2(s) {
  nt.useEffect(() => {
    const e = s;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [s]);
}
function G2(s, e) {
  nt.useEffect(() => {
    if (e) {
      const t = s;
      return window.addEventListener("scroll", t, { capture: !0, passive: !0 }), () => void window.removeEventListener("scroll", t, !0);
    }
  }, [s, e]);
}
function N1(s) {
  const e = [];
  if (!s || s === document.body) return e;
  const { overflow: t, overflowX: n, overflowY: i } = window.getComputedStyle(s);
  return [t, n, i].some((r) => r === "auto" || r === "scroll") && e.push(s), [...e, ...N1(s.parentElement)];
}
const H2 = ["x", "y", "top", "bottom", "left", "right", "width", "height"], z2 = (s, e) => H2.every((t) => s[t] === e[t]);
var V2 = Object.defineProperty, W2 = Object.defineProperties, X2 = Object.getOwnPropertyDescriptors, SM = Object.getOwnPropertySymbols, J2 = Object.prototype.hasOwnProperty, Y2 = Object.prototype.propertyIsEnumerable, EM = (s, e, t) => e in s ? V2(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t, TM = (s, e) => {
  for (var t in e || (e = {}))
    J2.call(e, t) && EM(s, t, e[t]);
  if (SM)
    for (var t of SM(e))
      Y2.call(e, t) && EM(s, t, e[t]);
  return s;
}, K2 = (s, e) => W2(s, X2(e)), wM, CM;
typeof window < "u" && ((wM = window.document) != null && wM.createElement || ((CM = window.navigator) == null ? void 0 : CM.product) === "ReactNative") ? nt.useLayoutEffect : nt.useEffect;
function k1(s, e, t) {
  if (!s)
    return;
  if (t(s) === !0)
    return s;
  let n = s.child;
  for (; n; ) {
    const i = k1(n, e, t);
    if (i)
      return i;
    n = n.sibling;
  }
}
function G1(s) {
  try {
    return Object.defineProperties(s, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {
        }
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {
        }
      }
    });
  } catch {
    return s;
  }
}
const bM = console.error;
console.error = function() {
  const s = [...arguments].join("");
  if (s?.startsWith("Warning:") && s.includes("useContext")) {
    console.error = bM;
    return;
  }
  return bM.apply(this, arguments);
};
const xv = G1(nt.createContext(null));
class H1 extends nt.Component {
  render() {
    return /* @__PURE__ */ nt.createElement(xv.Provider, {
      value: this._reactInternals
    }, this.props.children);
  }
}
function q2() {
  const s = nt.useContext(xv);
  if (s === null)
    throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = nt.useId();
  return nt.useMemo(() => {
    for (const n of [s, s?.alternate]) {
      if (!n)
        continue;
      const i = k1(n, !1, (r) => {
        let o = r.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e)
            return !0;
          o = o.next;
        }
      });
      if (i)
        return i;
    }
  }, [s, e]);
}
function Q2() {
  const s = q2(), [e] = nt.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = s;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const i = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      i && i !== xv && !e.has(i) && e.set(i, nt.useContext(G1(i)));
    }
    t = t.return;
  }
  return e;
}
function Z2() {
  const s = Q2();
  return nt.useMemo(
    () => Array.from(s.keys()).reduce(
      (e, t) => (n) => /* @__PURE__ */ nt.createElement(e, null, /* @__PURE__ */ nt.createElement(t.Provider, K2(TM({}, n), {
        value: s.get(t)
      }))),
      (e) => /* @__PURE__ */ nt.createElement(H1, TM({}, e))
    ),
    [s]
  );
}
const j2 = /* @__PURE__ */ nt.forwardRef(function({
  children: e,
  fallback: t,
  resize: n,
  style: i,
  gl: r,
  events: o = O2,
  eventSource: a,
  eventPrefix: l,
  shadows: h,
  linear: f,
  flat: d,
  legacy: p,
  orthographic: m,
  frameloop: _,
  dpr: x,
  performance: y,
  raycaster: v,
  camera: S,
  scene: M,
  onPointerMissed: T,
  onCreated: P,
  ...b
}, R) {
  nt.useMemo(() => m2(ZD), []);
  const U = Z2(), [C, B] = N2({
    scroll: !0,
    debounce: {
      scroll: 50,
      resize: 0
    },
    ...n
  }), G = nt.useRef(null), W = nt.useRef(null);
  nt.useImperativeHandle(R, () => G.current);
  const se = C1(T), [z, q] = nt.useState(!1), [j, ee] = nt.useState(!1);
  if (z) throw z;
  if (j) throw j;
  const N = nt.useRef(null);
  _h(() => {
    const I = G.current;
    B.width > 0 && B.height > 0 && I && (N.current || (N.current = F2(I)), N.current.configure({
      gl: r,
      events: o,
      shadows: h,
      linear: f,
      flat: d,
      legacy: p,
      orthographic: m,
      frameloop: _,
      dpr: x,
      performance: y,
      raycaster: v,
      camera: S,
      scene: M,
      size: B,
      // Pass mutable reference to onPointerMissed so it's free to update
      onPointerMissed: (...D) => se.current == null ? void 0 : se.current(...D),
      onCreated: (D) => {
        D.events.connect == null || D.events.connect(a ? _2(a) ? a.current : a : W.current), l && D.setEvents({
          compute: (J, K) => {
            const ie = J[l + "X"], he = J[l + "Y"];
            K.pointer.set(ie / K.size.width * 2 - 1, -(he / K.size.height) * 2 + 1), K.raycaster.setFromCamera(K.pointer, K.camera);
          }
        }), P?.(D);
      }
    }), N.current.render(/* @__PURE__ */ Pn.jsx(U, {
      children: /* @__PURE__ */ Pn.jsx(b1, {
        set: ee,
        children: /* @__PURE__ */ Pn.jsx(nt.Suspense, {
          fallback: /* @__PURE__ */ Pn.jsx(v2, {
            set: q
          }),
          children: e ?? null
        })
      })
    })));
  }), nt.useEffect(() => {
    const I = G.current;
    if (I) return () => O1(I);
  }, []);
  const V = a ? "none" : "auto";
  return /* @__PURE__ */ Pn.jsx("div", {
    ref: W,
    style: {
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      pointerEvents: V,
      ...i
    },
    ...b,
    children: /* @__PURE__ */ Pn.jsx("div", {
      ref: C,
      style: {
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ Pn.jsx("canvas", {
        ref: G,
        style: {
          display: "block"
        },
        children: t
      })
    })
  });
}), $2 = /* @__PURE__ */ nt.forwardRef(function(e, t) {
  return /* @__PURE__ */ Pn.jsx(H1, {
    children: /* @__PURE__ */ Pn.jsx(j2, {
      ...e,
      ref: t
    })
  });
}), eF = parseInt(rh.replace(/\D+/g, ""));
function RM(s, e) {
  if (e === aE)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), s;
  if (e === zd || e === F0) {
    let t = s.getIndex();
    if (t === null) {
      const o = [], a = s.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++)
          o.push(l);
        s.setIndex(o), t = s.getIndex();
      } else
        return console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ), s;
    }
    const n = t.count - 2, i = [];
    if (t)
      if (e === zd)
        for (let o = 1; o <= n; o++)
          i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
      else
        for (let o = 0; o < n; o++)
          o % 2 === 0 ? (i.push(t.getX(o)), i.push(t.getX(o + 1)), i.push(t.getX(o + 2))) : (i.push(t.getX(o + 2)), i.push(t.getX(o + 1)), i.push(t.getX(o)));
    i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const r = s.clone();
    return r.setIndex(i), r.clearGroups(), r;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), s;
}
function Yd(s) {
  if (typeof TextDecoder < "u")
    return new TextDecoder().decode(s);
  let e = "";
  for (let t = 0, n = s.length; t < n; t++)
    e += String.fromCharCode(s[t]);
  try {
    return decodeURIComponent(escape(e));
  } catch {
    return e;
  }
}
const ya = "srgb", Vs = "srgb-linear", BM = 3001, tF = 3e3;
class Av extends Si {
  constructor(e) {
    super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
      return new oF(t);
    }), this.register(function(t) {
      return new aF(t);
    }), this.register(function(t) {
      return new gF(t);
    }), this.register(function(t) {
      return new _F(t);
    }), this.register(function(t) {
      return new vF(t);
    }), this.register(function(t) {
      return new cF(t);
    }), this.register(function(t) {
      return new uF(t);
    }), this.register(function(t) {
      return new hF(t);
    }), this.register(function(t) {
      return new fF(t);
    }), this.register(function(t) {
      return new sF(t);
    }), this.register(function(t) {
      return new dF(t);
    }), this.register(function(t) {
      return new lF(t);
    }), this.register(function(t) {
      return new mF(t);
    }), this.register(function(t) {
      return new pF(t);
    }), this.register(function(t) {
      return new iF(t);
    }), this.register(function(t) {
      return new yF(t);
    }), this.register(function(t) {
      return new xF(t);
    });
  }
  load(e, t, n, i) {
    const r = this;
    let o;
    if (this.resourcePath !== "")
      o = this.resourcePath;
    else if (this.path !== "") {
      const h = To.extractUrlBase(e);
      o = To.resolveURL(h, this.path);
    } else
      o = To.extractUrlBase(e);
    this.manager.itemStart(e);
    const a = function(h) {
      i ? i(h) : console.error(h), r.manager.itemError(e), r.manager.itemEnd(e);
    }, l = new pr(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(
      e,
      function(h) {
        try {
          r.parse(
            h,
            o,
            function(f) {
              t(f), r.manager.itemEnd(e);
            },
            a
          );
        } catch (f) {
          a(f);
        }
      },
      n,
      a
    );
  }
  setDRACOLoader(e) {
    return this.dracoLoader = e, this;
  }
  setDDSLoader() {
    throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
  }
  setKTX2Loader(e) {
    return this.ktx2Loader = e, this;
  }
  setMeshoptDecoder(e) {
    return this.meshoptDecoder = e, this;
  }
  register(e) {
    return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
  }
  unregister(e) {
    return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
  }
  parse(e, t, n, i) {
    let r;
    const o = {}, a = {};
    if (typeof e == "string")
      r = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (Yd(new Uint8Array(e.slice(0, 4))) === z1) {
        try {
          o[Ot.KHR_BINARY_GLTF] = new AF(e);
        } catch (f) {
          i && i(f);
          return;
        }
        r = JSON.parse(o[Ot.KHR_BINARY_GLTF].content);
      } else
        r = JSON.parse(Yd(new Uint8Array(e)));
    else
      r = e;
    if (r.asset === void 0 || r.asset.version[0] < 2) {
      i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const l = new DF(r, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const f = this.pluginCallbacks[h](l);
      f.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[f.name] = f, o[f.name] = !0;
    }
    if (r.extensionsUsed)
      for (let h = 0; h < r.extensionsUsed.length; ++h) {
        const f = r.extensionsUsed[h], d = r.extensionsRequired || [];
        switch (f) {
          case Ot.KHR_MATERIALS_UNLIT:
            o[f] = new rF();
            break;
          case Ot.KHR_DRACO_MESH_COMPRESSION:
            o[f] = new MF(r, this.dracoLoader);
            break;
          case Ot.KHR_TEXTURE_TRANSFORM:
            o[f] = new SF();
            break;
          case Ot.KHR_MESH_QUANTIZATION:
            o[f] = new EF();
            break;
          default:
            d.indexOf(f) >= 0 && a[f] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".');
        }
      }
    l.setExtensions(o), l.setPlugins(a), l.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function(i, r) {
      n.parse(e, t, i, r);
    });
  }
}
function nF() {
  let s = {};
  return {
    get: function(e) {
      return s[e];
    },
    add: function(e, t) {
      s[e] = t;
    },
    remove: function(e) {
      delete s[e];
    },
    removeAll: function() {
      s = {};
    }
  };
}
const Ot = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class iF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_LIGHTS_PUNCTUAL, this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const e = this.parser, t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const r = t[n];
      r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser, n = "light:" + e;
    let i = t.cache.get(n);
    if (i)
      return i;
    const r = t.json, l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
    let h;
    const f = new Ne(16777215);
    l.color !== void 0 && f.setRGB(l.color[0], l.color[1], l.color[2], Vs);
    const d = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        h = new dv(f), h.target.position.set(0, 0, -1), h.add(h.target);
        break;
      case "point":
        h = new fv(f), h.distance = d;
        break;
      case "spot":
        h = new hv(f), h.distance = d, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, h.angle = l.spot.outerConeAngle, h.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, h.target.position.set(0, 0, -1), h.add(h.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return h.position.set(0, 0, 0), h.decay = 2, Ls(h, l), l.intensity !== void 0 && (h.intensity = l.intensity), h.name = t.createUniqueName(l.name || "light_" + e), i = Promise.resolve(h), t.cache.add(n, i), i;
  }
  getDependency(e, t) {
    if (e === "light")
      return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this, n = this.parser, r = n.json.nodes[e], a = (r.extensions && r.extensions[this.name] || {}).light;
    return a === void 0 ? null : this._loadLight(a).then(function(l) {
      return n._getNodeRef(t.cache, a, l);
    });
  }
}
class rF {
  constructor() {
    this.name = Ot.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return ur;
  }
  extendParams(e, t, n) {
    const i = [];
    e.color = new Ne(1, 1, 1), e.opacity = 1;
    const r = t.pbrMetallicRoughness;
    if (r) {
      if (Array.isArray(r.baseColorFactor)) {
        const o = r.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], Vs), e.opacity = o[3];
      }
      r.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", r.baseColorTexture, ya));
    }
    return Promise.all(i);
  }
}
class sF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name].emissiveStrength;
    return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
  }
}
class oF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ur;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ve(a, a);
    }
    return Promise.all(r);
  }
}
class aF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ur;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name];
    return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
  }
}
class lF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ur;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && r.push(
      n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)
    ), Promise.all(r);
  }
}
class cF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ur;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [];
    t.sheenColor = new Ne(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
    const o = i.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const a = o.sheenColorFactor;
      t.sheenColor.setRGB(a[0], a[1], a[2], Vs);
    }
    return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, ya)), o.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(r);
  }
}
class uF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ur;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(r);
  }
}
class hF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ur;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
    const a = o.attenuationColor || [1, 1, 1];
    return t.attenuationColor = new Ne().setRGB(
      a[0],
      a[1],
      a[2],
      Vs
    ), Promise.all(r);
  }
}
class fF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_IOR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ur;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = i.extensions[this.name];
    return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
  }
}
class dF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ur;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return t.specularColor = new Ne().setRGB(a[0], a[1], a[2], Vs), o.specularColorTexture !== void 0 && r.push(
      n.assignTexture(t, "specularColorMap", o.specularColorTexture, ya)
    ), Promise.all(r);
  }
}
class pF {
  constructor(e) {
    this.parser = e, this.name = Ot.EXT_MATERIALS_BUMP;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ur;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && r.push(n.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(r);
  }
}
class mF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Ur;
  }
  extendMaterialParams(e, t) {
    const n = this.parser, i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name])
      return Promise.resolve();
    const r = [], o = i.extensions[this.name];
    return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(r);
  }
}
class gF {
  constructor(e) {
    this.parser = e, this.name = Ot.KHR_TEXTURE_BASISU;
  }
  loadTexture(e) {
    const t = this.parser, n = t.json, i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name])
      return null;
    const r = i.extensions[this.name], o = t.options.ktx2Loader;
    if (!o) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      return null;
    }
    return t.loadTextureImage(e, r.source, o);
  }
}
class _F {
  constructor(e) {
    this.parser = e, this.name = Ot.EXT_TEXTURE_WEBP, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const o = r.extensions[t], a = i.images[o.source];
    let l = n.textureLoader;
    if (a.uri) {
      const h = n.options.manager.getHandler(a.uri);
      h !== null && (l = h);
    }
    return this.detectSupport().then(function(h) {
      if (h)
        return n.loadTextureImage(e, o.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class vF {
  constructor(e) {
    this.parser = e, this.name = Ot.EXT_TEXTURE_AVIF, this.isSupported = null;
  }
  loadTexture(e) {
    const t = this.name, n = this.parser, i = n.json, r = i.textures[e];
    if (!r.extensions || !r.extensions[t])
      return null;
    const o = r.extensions[t], a = i.images[o.source];
    let l = n.textureLoader;
    if (a.uri) {
      const h = n.options.manager.getHandler(a.uri);
      h !== null && (l = h);
    }
    return this.detectSupport().then(function(h) {
      if (h)
        return n.loadTextureImage(e, o.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return this.isSupported || (this.isSupported = new Promise(function(e) {
      const t = new Image();
      t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
        e(t.height === 1);
      };
    })), this.isSupported;
  }
}
class yF {
  constructor(e) {
    this.name = Ot.EXT_MESHOPT_COMPRESSION, this.parser = e;
  }
  loadBufferView(e) {
    const t = this.parser.json, n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name], r = this.parser.getDependency("buffer", i.buffer), o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        return null;
      }
      return r.then(function(a) {
        const l = i.byteOffset || 0, h = i.byteLength || 0, f = i.count, d = i.byteStride, p = new Uint8Array(a, l, h);
        return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(f, d, p, i.mode, i.filter).then(function(m) {
          return m.buffer;
        }) : o.ready.then(function() {
          const m = new ArrayBuffer(f * d);
          return o.decodeGltfBuffer(
            new Uint8Array(m),
            f,
            d,
            p,
            i.mode,
            i.filter
          ), m;
        });
      });
    } else
      return null;
  }
}
class xF {
  constructor(e) {
    this.name = Ot.EXT_MESH_GPU_INSTANCING, this.parser = e;
  }
  createNodeMesh(e) {
    const t = this.parser.json, n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const h of i.primitives)
      if (h.mode !== Rr.TRIANGLES && h.mode !== Rr.TRIANGLE_STRIP && h.mode !== Rr.TRIANGLE_FAN && h.mode !== void 0)
        return null;
    const o = n.extensions[this.name].attributes, a = [], l = {};
    for (const h in o)
      a.push(
        this.parser.getDependency("accessor", o[h]).then((f) => (l[h] = f, l[h]))
      );
    return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((h) => {
      const f = h.pop(), d = f.isGroup ? f.children : [f], p = h[0].count, m = [];
      for (const _ of d) {
        const x = new pt(), y = new k(), v = new yi(), S = new k(1, 1, 1), M = new Z0(_.geometry, _.material, p);
        for (let T = 0; T < p; T++)
          l.TRANSLATION && y.fromBufferAttribute(l.TRANSLATION, T), l.ROTATION && v.fromBufferAttribute(l.ROTATION, T), l.SCALE && S.fromBufferAttribute(l.SCALE, T), M.setMatrixAt(T, x.compose(y, v, S));
        for (const T in l)
          if (T === "_COLOR_0") {
            const P = l[T];
            M.instanceColor = new Ua(P.array, P.itemSize, P.normalized);
          } else T !== "TRANSLATION" && T !== "ROTATION" && T !== "SCALE" && _.geometry.setAttribute(T, l[T]);
        zt.prototype.copy.call(M, _), this.parser.assignFinalMaterial(M), m.push(M);
      }
      return f.isGroup ? (f.clear(), f.add(...m), f) : m[0];
    }));
  }
}
const z1 = "glTF", iu = 12, PM = { JSON: 1313821514, BIN: 5130562 };
class AF {
  constructor(e) {
    this.name = Ot.KHR_BINARY_GLTF, this.content = null, this.body = null;
    const t = new DataView(e, 0, iu);
    if (this.header = {
      magic: Yd(new Uint8Array(e.slice(0, 4))),
      version: t.getUint32(4, !0),
      length: t.getUint32(8, !0)
    }, this.header.magic !== z1)
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - iu, i = new DataView(e, iu);
    let r = 0;
    for (; r < n; ) {
      const o = i.getUint32(r, !0);
      r += 4;
      const a = i.getUint32(r, !0);
      if (r += 4, a === PM.JSON) {
        const l = new Uint8Array(e, iu + r, o);
        this.content = Yd(l);
      } else if (a === PM.BIN) {
        const l = iu + r;
        this.body = e.slice(l, l + o);
      }
      r += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class MF {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    this.name = Ot.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json, i = this.dracoLoader, r = e.extensions[this.name].bufferView, o = e.extensions[this.name].attributes, a = {}, l = {}, h = {};
    for (const f in o) {
      const d = j_[f] || f.toLowerCase();
      a[d] = o[f];
    }
    for (const f in e.attributes) {
      const d = j_[f] || f.toLowerCase();
      if (o[f] !== void 0) {
        const p = n.accessors[e.attributes[f]], m = Kl[p.componentType];
        h[d] = m.name, l[d] = p.normalized === !0;
      }
    }
    return t.getDependency("bufferView", r).then(function(f) {
      return new Promise(function(d, p) {
        i.decodeDracoFile(
          f,
          function(m) {
            for (const _ in m.attributes) {
              const x = m.attributes[_], y = l[_];
              y !== void 0 && (x.normalized = y);
            }
            d(m);
          },
          a,
          h,
          Vs,
          p
        );
      });
    });
  }
}
class SF {
  constructor() {
    this.name = Ot.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e;
  }
}
class EF {
  constructor() {
    this.name = Ot.KHR_MESH_QUANTIZATION;
  }
}
class V1 extends Sc {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i * 3 + i;
    for (let o = 0; o !== i; o++)
      t[o] = n[r + o];
    return t;
  }
  interpolate_(e, t, n, i) {
    const r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = a * 2, h = a * 3, f = i - t, d = (n - t) / f, p = d * d, m = p * d, _ = e * h, x = _ - h, y = -2 * m + 3 * p, v = m - p, S = 1 - y, M = v - p + d;
    for (let T = 0; T !== a; T++) {
      const P = o[x + T + a], b = o[x + T + l] * f, R = o[_ + T + a], U = o[_ + T] * f;
      r[T] = S * P + M * b + y * R + v * U;
    }
    return r;
  }
}
const TF = /* @__PURE__ */ new yi();
class wF extends V1 {
  interpolate_(e, t, n, i) {
    const r = super.interpolate_(e, t, n, i);
    return TF.fromArray(r).normalize().toArray(r), r;
  }
}
const Rr = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, Kl = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
}, IM = {
  9728: Sn,
  9729: gn,
  9984: Uu,
  9985: lp,
  9986: Jl,
  9987: _s
}, LM = {
  33071: ri,
  33648: nc,
  10497: Bo
}, zg = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, j_ = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  // uv => uv1, 4 uv channels
  // https://github.com/mrdoob/three.js/pull/25943
  // https://github.com/mrdoob/three.js/pull/25788
  ...eF >= 152 ? {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3"
  } : {
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2"
  },
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
}, fo = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
}, CF = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: Fa,
  STEP: rc
}, Vg = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function bF(s) {
  return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new gh({
    color: 16777215,
    emissive: 0,
    metalness: 1,
    roughness: 1,
    transparent: !1,
    depthTest: !0,
    side: gs
  })), s.DefaultMaterial;
}
function sa(s, e, t) {
  for (const n in t.extensions)
    s[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n]);
}
function Ls(s, e) {
  e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(s.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
}
function RF(s, e, t) {
  let n = !1, i = !1, r = !1;
  for (let h = 0, f = e.length; h < f; h++) {
    const d = e[h];
    if (d.POSITION !== void 0 && (n = !0), d.NORMAL !== void 0 && (i = !0), d.COLOR_0 !== void 0 && (r = !0), n && i && r)
      break;
  }
  if (!n && !i && !r)
    return Promise.resolve(s);
  const o = [], a = [], l = [];
  for (let h = 0, f = e.length; h < f; h++) {
    const d = e[h];
    if (n) {
      const p = d.POSITION !== void 0 ? t.getDependency("accessor", d.POSITION) : s.attributes.position;
      o.push(p);
    }
    if (i) {
      const p = d.NORMAL !== void 0 ? t.getDependency("accessor", d.NORMAL) : s.attributes.normal;
      a.push(p);
    }
    if (r) {
      const p = d.COLOR_0 !== void 0 ? t.getDependency("accessor", d.COLOR_0) : s.attributes.color;
      l.push(p);
    }
  }
  return Promise.all([
    Promise.all(o),
    Promise.all(a),
    Promise.all(l)
  ]).then(function(h) {
    const f = h[0], d = h[1], p = h[2];
    return n && (s.morphAttributes.position = f), i && (s.morphAttributes.normal = d), r && (s.morphAttributes.color = p), s.morphTargetsRelative = !0, s;
  });
}
function BF(s, e) {
  if (s.updateMorphTargets(), e.weights !== void 0)
    for (let t = 0, n = e.weights.length; t < n; t++)
      s.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (s.morphTargetInfluences.length === t.length) {
      s.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        s.morphTargetDictionary[t[n]] = n;
    } else
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
  }
}
function PF(s) {
  let e;
  const t = s.extensions && s.extensions[Ot.KHR_DRACO_MESH_COMPRESSION];
  if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Wg(t.attributes) : e = s.indices + ":" + Wg(s.attributes) + ":" + s.mode, s.targets !== void 0)
    for (let n = 0, i = s.targets.length; n < i; n++)
      e += ":" + Wg(s.targets[n]);
  return e;
}
function Wg(s) {
  let e = "";
  const t = Object.keys(s).sort();
  for (let n = 0, i = t.length; n < i; n++)
    e += t[n] + ":" + s[t[n]] + ";";
  return e;
}
function $_(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function IF(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png";
}
const LF = /* @__PURE__ */ new pt();
class DF {
  constructor(e = {}, t = {}) {
    this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new nF(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = { refs: {}, uses: {} }, this.cameraCache = { refs: {}, uses: {} }, this.lightCache = { refs: {}, uses: {} }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
    let n = !1, i = !1, r = -1;
    typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || i && r < 98 ? this.textureLoader = new c1(this.options.manager) : this.textureLoader = new _1(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new pr(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this, i = this.json, r = this.extensions;
    this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
      return o._markDefs && o._markDefs();
    }), Promise.all(
      this._invokeAll(function(o) {
        return o.beforeRoot && o.beforeRoot();
      })
    ).then(function() {
      return Promise.all([
        n.getDependencies("scene"),
        n.getDependencies("animation"),
        n.getDependencies("camera")
      ]);
    }).then(function(o) {
      const a = {
        scene: o[0][i.scene || 0],
        scenes: o[0],
        animations: o[1],
        cameras: o[2],
        asset: i.asset,
        parser: n,
        userData: {}
      };
      return sa(r, a, i), Ls(a, i), Promise.all(
        n._invokeAll(function(l) {
          return l.afterRoot && l.afterRoot(a);
        })
      ).then(function() {
        for (const l of a.scenes)
          l.updateMatrixWorld();
        e(a);
      });
    }).catch(t);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const o = t[i].joints;
      for (let a = 0, l = o.length; a < l; a++)
        e[o[a]].isBone = !0;
    }
    for (let i = 0, r = e.length; i < r; i++) {
      const o = e[i];
      o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(e, t) {
    t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1)
      return n;
    const i = n.clone(), r = (o, a) => {
      const l = this.associations.get(o);
      l != null && this.associations.set(a, l);
      for (const [h, f] of o.children.entries())
        r(f, a.children[h]);
    };
    return r(n, i), i.name += "_instance_" + e.uses[t]++, i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i)
        return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      r && n.push(r);
    }
    return n;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function(r) {
            return r.loadNode && r.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function(r) {
            return r.loadMesh && r.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function(r) {
            return r.loadBufferView && r.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function(r) {
            return r.loadMaterial && r.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function(r) {
            return r.loadTexture && r.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function(r) {
            return r.loadAnimation && r.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (i = this._invokeOne(function(r) {
            return r != this && r.getDependency && r.getDependency(e, t);
          }), !i)
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this, i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      t = Promise.all(
        i.map(function(r, o) {
          return n.getDependency(e, o);
        })
      ), this.cache.add(e, t);
    }
    return t;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(e) {
    const t = this.json.buffers[e], n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ot.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function(r, o) {
      n.load(To.resolveURL(t.uri, i.path), r, void 0, function() {
        o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function(n) {
      const i = t.byteLength || 0, r = t.byteOffset || 0;
      return n.slice(r, r + i);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(e) {
    const t = this, n = this.json, i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const o = zg[i.type], a = Kl[i.componentType], l = i.normalized === !0, h = new a(i.count * o);
      return Promise.resolve(new Vt(h, o, l));
    }
    const r = [];
    return i.bufferView !== void 0 ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), i.sparse !== void 0 && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then(function(o) {
      const a = o[0], l = zg[i.type], h = Kl[i.componentType], f = h.BYTES_PER_ELEMENT, d = f * l, p = i.byteOffset || 0, m = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0, _ = i.normalized === !0;
      let x, y;
      if (m && m !== d) {
        const v = Math.floor(p / m), S = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + v + ":" + i.count;
        let M = t.cache.get(S);
        M || (x = new h(a, v * m, i.count * m / f), M = new hh(x, m / f), t.cache.add(S, M)), y = new Po(
          M,
          l,
          p % m / f,
          _
        );
      } else
        a === null ? x = new h(i.count * l) : x = new h(a, p, i.count * l), y = new Vt(x, l, _);
      if (i.sparse !== void 0) {
        const v = zg.SCALAR, S = Kl[i.sparse.indices.componentType], M = i.sparse.indices.byteOffset || 0, T = i.sparse.values.byteOffset || 0, P = new S(
          o[1],
          M,
          i.sparse.count * v
        ), b = new h(o[2], T, i.sparse.count * l);
        a !== null && (y = new Vt(
          y.array.slice(),
          y.itemSize,
          y.normalized
        ));
        for (let R = 0, U = P.length; R < U; R++) {
          const C = P[R];
          if (y.setX(C, b[R * l]), l >= 2 && y.setY(C, b[R * l + 1]), l >= 3 && y.setZ(C, b[R * l + 2]), l >= 4 && y.setW(C, b[R * l + 3]), l >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return y;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(e) {
    const t = this.json, n = this.options, r = t.textures[e].source, o = t.images[r];
    let a = this.textureLoader;
    if (o.uri) {
      const l = n.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, r, a);
  }
  loadTextureImage(e, t, n) {
    const i = this, r = this.json, o = r.textures[e], a = r.images[t], l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l])
      return this.textureCache[l];
    const h = this.loadImageSource(t, n).then(function(f) {
      f.flipY = !1, f.name = o.name || a.name || "", f.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (f.name = a.uri);
      const p = (r.samplers || {})[o.sampler] || {};
      return f.magFilter = IM[p.magFilter] || gn, f.minFilter = IM[p.minFilter] || _s, f.wrapS = LM[p.wrapS] || Bo, f.wrapT = LM[p.wrapT] || Bo, i.associations.set(f, { textures: e }), f;
    }).catch(function() {
      return null;
    });
    return this.textureCache[l] = h, h;
  }
  loadImageSource(e, t) {
    const n = this, i = this.json, r = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((d) => d.clone());
    const o = i.images[e], a = self.URL || self.webkitURL;
    let l = o.uri || "", h = !1;
    if (o.bufferView !== void 0)
      l = n.getDependency("bufferView", o.bufferView).then(function(d) {
        h = !0;
        const p = new Blob([d], { type: o.mimeType });
        return l = a.createObjectURL(p), l;
      });
    else if (o.uri === void 0)
      throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
    const f = Promise.resolve(l).then(function(d) {
      return new Promise(function(p, m) {
        let _ = p;
        t.isImageBitmapLoader === !0 && (_ = function(x) {
          const y = new yn(x);
          y.needsUpdate = !0, p(y);
        }), t.load(To.resolveURL(d, r.path), _, void 0, m);
      });
    }).then(function(d) {
      return h === !0 && a.revokeObjectURL(l), Ls(d, o), d.userData.mimeType = o.mimeType || IF(o.uri), d;
    }).catch(function(d) {
      throw console.error("THREE.GLTFLoader: Couldn't load texture", l), d;
    });
    return this.sourceCache[e] = f, f;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(e, t, n, i) {
    const r = this;
    return this.getDependency("texture", n.index).then(function(o) {
      if (!o)
        return null;
      if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(), o.channel = n.texCoord), r.extensions[Ot.KHR_TEXTURE_TRANSFORM]) {
        const a = n.extensions !== void 0 ? n.extensions[Ot.KHR_TEXTURE_TRANSFORM] : void 0;
        if (a) {
          const l = r.associations.get(o);
          o = r.extensions[Ot.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), r.associations.set(o, l);
        }
      }
      return i !== void 0 && (typeof i == "number" && (i = i === BM ? ya : Vs), "colorSpace" in o ? o.colorSpace = i : o.encoding = i === ya ? BM : tF), e[t] = o, o;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0, r = t.attributes.color !== void 0, o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l || (l = new _p(), Xn.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l;
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(a);
      l || (l = new Mi(), Xn.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l;
    }
    if (i || r || o) {
      let a = "ClonedMaterial:" + n.uuid + ":";
      i && (a += "derivative-tangents:"), r && (a += "vertex-colors:"), o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l || (l = n.clone(), r && (l.vertexColors = !0), o && (l.flatShading = !0), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))), n = l;
    }
    e.material = n;
  }
  getMaterialType() {
    return gh;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(e) {
    const t = this, n = this.json, i = this.extensions, r = n.materials[e];
    let o;
    const a = {}, l = r.extensions || {}, h = [];
    if (l[Ot.KHR_MATERIALS_UNLIT]) {
      const d = i[Ot.KHR_MATERIALS_UNLIT];
      o = d.getMaterialType(), h.push(d.extendParams(a, r, t));
    } else {
      const d = r.pbrMetallicRoughness || {};
      if (a.color = new Ne(1, 1, 1), a.opacity = 1, Array.isArray(d.baseColorFactor)) {
        const p = d.baseColorFactor;
        a.color.setRGB(p[0], p[1], p[2], Vs), a.opacity = p[3];
      }
      d.baseColorTexture !== void 0 && h.push(t.assignTexture(a, "map", d.baseColorTexture, ya)), a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1, a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1, d.metallicRoughnessTexture !== void 0 && (h.push(t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)), h.push(t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture))), o = this._invokeOne(function(p) {
        return p.getMaterialType && p.getMaterialType(e);
      }), h.push(
        Promise.all(
          this._invokeAll(function(p) {
            return p.extendMaterialParams && p.extendMaterialParams(e, a);
          })
        )
      );
    }
    r.doubleSided === !0 && (a.side = Xr);
    const f = r.alphaMode || Vg.OPAQUE;
    if (f === Vg.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, f === Vg.MASK && (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : 0.5)), r.normalTexture !== void 0 && o !== ur && (h.push(t.assignTexture(a, "normalMap", r.normalTexture)), a.normalScale = new ve(1, 1), r.normalTexture.scale !== void 0)) {
      const d = r.normalTexture.scale;
      a.normalScale.set(d, d);
    }
    if (r.occlusionTexture !== void 0 && o !== ur && (h.push(t.assignTexture(a, "aoMap", r.occlusionTexture)), r.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = r.occlusionTexture.strength)), r.emissiveFactor !== void 0 && o !== ur) {
      const d = r.emissiveFactor;
      a.emissive = new Ne().setRGB(
        d[0],
        d[1],
        d[2],
        Vs
      );
    }
    return r.emissiveTexture !== void 0 && o !== ur && h.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, ya)), Promise.all(h).then(function() {
      const d = new o(a);
      return r.name && (d.name = r.name), Ls(d, r), t.associations.set(d, { materials: e }), r.extensions && sa(i, d, r), d;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(e) {
    const t = Ht.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(e) {
    const t = this, n = this.extensions, i = this.primitiveCache;
    function r(a) {
      return n[Ot.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
        return DM(l, a, t);
      });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const h = e[a], f = PF(h), d = i[f];
      if (d)
        o.push(d.promise);
      else {
        let p;
        h.extensions && h.extensions[Ot.KHR_DRACO_MESH_COMPRESSION] ? p = r(h) : p = DM(new Mt(), h, t), i[f] = { primitive: h, promise: p }, o.push(p);
      }
    }
    return Promise.all(o);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(e) {
    const t = this, n = this.json, i = this.extensions, r = n.meshes[e], o = r.primitives, a = [];
    for (let l = 0, h = o.length; l < h; l++) {
      const f = o[l].material === void 0 ? bF(this.cache) : this.getDependency("material", o[l].material);
      a.push(f);
    }
    return a.push(t.loadGeometries(o)), Promise.all(a).then(function(l) {
      const h = l.slice(0, l.length - 1), f = l[l.length - 1], d = [];
      for (let m = 0, _ = f.length; m < _; m++) {
        const x = f[m], y = o[m];
        let v;
        const S = h[m];
        if (y.mode === Rr.TRIANGLES || y.mode === Rr.TRIANGLE_STRIP || y.mode === Rr.TRIANGLE_FAN || y.mode === void 0)
          v = r.isSkinnedMesh === !0 ? new Q0(x, S) : new kn(x, S), v.isSkinnedMesh === !0 && v.normalizeSkinWeights(), y.mode === Rr.TRIANGLE_STRIP ? v.geometry = RM(v.geometry, F0) : y.mode === Rr.TRIANGLE_FAN && (v.geometry = RM(v.geometry, zd));
        else if (y.mode === Rr.LINES)
          v = new qr(x, S);
        else if (y.mode === Rr.LINE_STRIP)
          v = new Js(x, S);
        else if (y.mode === Rr.LINE_LOOP)
          v = new j0(x, S);
        else if (y.mode === Rr.POINTS)
          v = new $0(x, S);
        else
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + y.mode);
        Object.keys(v.geometry.morphAttributes).length > 0 && BF(v, r), v.name = t.createUniqueName(r.name || "mesh_" + e), Ls(v, r), y.extensions && sa(i, v, y), t.assignFinalMaterial(v), d.push(v);
      }
      for (let m = 0, _ = d.length; m < _; m++)
        t.associations.set(d[m], {
          meshes: e,
          primitives: m
        });
      if (d.length === 1)
        return r.extensions && sa(i, d[0], r), d[0];
      const p = new ks();
      r.extensions && sa(i, p, r), t.associations.set(p, { meshes: e });
      for (let m = 0, _ = d.length; m < _; m++)
        p.add(d[m]);
      return p;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e], i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return n.type === "perspective" ? t = new Wn(
      _u.radToDeg(i.yfov),
      i.aspectRatio || 1,
      i.znear || 1,
      i.zfar || 2e6
    ) : n.type === "orthographic" && (t = new xc(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), Ls(t, n), Promise.resolve(t);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(e) {
    const t = this.json.skins[e], n = [];
    for (let i = 0, r = t.joints.length; i < r; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
      const r = i.pop(), o = i, a = [], l = [];
      for (let h = 0, f = o.length; h < f; h++) {
        const d = o[h];
        if (d) {
          a.push(d);
          const p = new pt();
          r !== null && p.fromArray(r.array, h * 16), l.push(p);
        } else
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[h]);
      }
      return new fh(a, l);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(e) {
    const t = this.json, n = this, i = t.animations[e], r = i.name ? i.name : "animation_" + e, o = [], a = [], l = [], h = [], f = [];
    for (let d = 0, p = i.channels.length; d < p; d++) {
      const m = i.channels[d], _ = i.samplers[m.sampler], x = m.target, y = x.node, v = i.parameters !== void 0 ? i.parameters[_.input] : _.input, S = i.parameters !== void 0 ? i.parameters[_.output] : _.output;
      x.node !== void 0 && (o.push(this.getDependency("node", y)), a.push(this.getDependency("accessor", v)), l.push(this.getDependency("accessor", S)), h.push(_), f.push(x));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(h),
      Promise.all(f)
    ]).then(function(d) {
      const p = d[0], m = d[1], _ = d[2], x = d[3], y = d[4], v = [];
      for (let S = 0, M = p.length; S < M; S++) {
        const T = p[S], P = m[S], b = _[S], R = x[S], U = y[S];
        if (T === void 0)
          continue;
        T.updateMatrix && T.updateMatrix();
        const C = n._createAnimationTracks(T, P, b, R, U);
        if (C)
          for (let B = 0; B < C.length; B++)
            v.push(C[B]);
      }
      return new lc(r, void 0, v);
    });
  }
  createNodeMesh(e) {
    const t = this.json, n = this, i = t.nodes[e];
    return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(r) {
      const o = n._getNodeRef(n.meshCache, i.mesh, r);
      return i.weights !== void 0 && o.traverse(function(a) {
        if (a.isMesh)
          for (let l = 0, h = i.weights.length; l < h; l++)
            a.morphTargetInfluences[l] = i.weights[l];
      }), o;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(e) {
    const t = this.json, n = this, i = t.nodes[e], r = n._loadNodeShallow(e), o = [], a = i.children || [];
    for (let h = 0, f = a.length; h < f; h++)
      o.push(n.getDependency("node", a[h]));
    const l = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
    return Promise.all([r, Promise.all(o), l]).then(function(h) {
      const f = h[0], d = h[1], p = h[2];
      p !== null && f.traverse(function(m) {
        m.isSkinnedMesh && m.bind(p, LF);
      });
      for (let m = 0, _ = d.length; m < _; m++)
        f.add(d[m]);
      return f;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(e) {
    const t = this.json, n = this.extensions, i = this;
    if (this.nodeCache[e] !== void 0)
      return this.nodeCache[e];
    const r = t.nodes[e], o = r.name ? i.createUniqueName(r.name) : "", a = [], l = i._invokeOne(function(h) {
      return h.createNodeMesh && h.createNodeMesh(e);
    });
    return l && a.push(l), r.camera !== void 0 && a.push(
      i.getDependency("camera", r.camera).then(function(h) {
        return i._getNodeRef(i.cameraCache, r.camera, h);
      })
    ), i._invokeAll(function(h) {
      return h.createNodeAttachment && h.createNodeAttachment(e);
    }).forEach(function(h) {
      a.push(h);
    }), this.nodeCache[e] = Promise.all(a).then(function(h) {
      let f;
      if (r.isBone === !0 ? f = new gp() : h.length > 1 ? f = new ks() : h.length === 1 ? f = h[0] : f = new zt(), f !== h[0])
        for (let d = 0, p = h.length; d < p; d++)
          f.add(h[d]);
      if (r.name && (f.userData.name = r.name, f.name = o), Ls(f, r), r.extensions && sa(n, f, r), r.matrix !== void 0) {
        const d = new pt();
        d.fromArray(r.matrix), f.applyMatrix4(d);
      } else
        r.translation !== void 0 && f.position.fromArray(r.translation), r.rotation !== void 0 && f.quaternion.fromArray(r.rotation), r.scale !== void 0 && f.scale.fromArray(r.scale);
      return i.associations.has(f) || i.associations.set(f, {}), i.associations.get(f).nodes = e, f;
    }), this.nodeCache[e];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(e) {
    const t = this.extensions, n = this.json.scenes[e], i = this, r = new ks();
    n.name && (r.name = i.createUniqueName(n.name)), Ls(r, n), n.extensions && sa(t, r, n);
    const o = n.nodes || [], a = [];
    for (let l = 0, h = o.length; l < h; l++)
      a.push(i.getDependency("node", o[l]));
    return Promise.all(a).then(function(l) {
      for (let f = 0, d = l.length; f < d; f++)
        r.add(l[f]);
      const h = (f) => {
        const d = /* @__PURE__ */ new Map();
        for (const [p, m] of i.associations)
          (p instanceof Xn || p instanceof yn) && d.set(p, m);
        return f.traverse((p) => {
          const m = i.associations.get(p);
          m != null && d.set(p, m);
        }), d;
      };
      return i.associations = h(r), r;
    });
  }
  _createAnimationTracks(e, t, n, i, r) {
    const o = [], a = e.name ? e.name : e.uuid, l = [];
    fo[r.path] === fo.weights ? e.traverse(function(p) {
      p.morphTargetInfluences && l.push(p.name ? p.name : p.uuid);
    }) : l.push(a);
    let h;
    switch (fo[r.path]) {
      case fo.weights:
        h = Na;
        break;
      case fo.rotation:
        h = Io;
        break;
      case fo.position:
      case fo.scale:
        h = ka;
        break;
      default:
        switch (n.itemSize) {
          case 1:
            h = Na;
            break;
          case 2:
          case 3:
          default:
            h = ka;
            break;
        }
        break;
    }
    const f = i.interpolation !== void 0 ? CF[i.interpolation] : Fa, d = this._getArrayFromAccessor(n);
    for (let p = 0, m = l.length; p < m; p++) {
      const _ = new h(
        l[p] + "." + fo[r.path],
        t.array,
        d,
        f
      );
      i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(_), o.push(_);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const n = $_(t.constructor), i = new Float32Array(t.length);
      for (let r = 0, o = t.length; r < o; r++)
        i[r] = t[r] * n;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    e.createInterpolant = function(n) {
      const i = this instanceof Io ? wF : V1;
      return new i(this.times, this.values, this.getValueSize() / 3, n);
    }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0;
  }
}
function FF(s, e, t) {
  const n = e.attributes, i = new xi();
  if (n.POSITION !== void 0) {
    const a = t.json.accessors[n.POSITION], l = a.min, h = a.max;
    if (l !== void 0 && h !== void 0) {
      if (i.set(new k(l[0], l[1], l[2]), new k(h[0], h[1], h[2])), a.normalized) {
        const f = $_(Kl[a.componentType]);
        i.min.multiplyScalar(f), i.max.multiplyScalar(f);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else
    return;
  const r = e.targets;
  if (r !== void 0) {
    const a = new k(), l = new k();
    for (let h = 0, f = r.length; h < f; h++) {
      const d = r[h];
      if (d.POSITION !== void 0) {
        const p = t.json.accessors[d.POSITION], m = p.min, _ = p.max;
        if (m !== void 0 && _ !== void 0) {
          if (l.setX(Math.max(Math.abs(m[0]), Math.abs(_[0]))), l.setY(Math.max(Math.abs(m[1]), Math.abs(_[1]))), l.setZ(Math.max(Math.abs(m[2]), Math.abs(_[2]))), p.normalized) {
            const x = $_(Kl[p.componentType]);
            l.multiplyScalar(x);
          }
          a.max(l);
        } else
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      }
    }
    i.expandByVector(a);
  }
  s.boundingBox = i;
  const o = new oi();
  i.getCenter(o.center), o.radius = i.min.distanceTo(i.max) / 2, s.boundingSphere = o;
}
function DM(s, e, t) {
  const n = e.attributes, i = [];
  function r(o, a) {
    return t.getDependency("accessor", o).then(function(l) {
      s.setAttribute(a, l);
    });
  }
  for (const o in n) {
    const a = j_[o] || o.toLowerCase();
    a in s.attributes || i.push(r(n[o], a));
  }
  if (e.indices !== void 0 && !s.index) {
    const o = t.getDependency("accessor", e.indices).then(function(a) {
      s.setIndex(a);
    });
    i.push(o);
  }
  return Ls(s, e), FF(s, e, t), Promise.all(i).then(function() {
    return e.targets !== void 0 ? RF(s, e.targets, t) : s;
  });
}
const Xg = /* @__PURE__ */ new WeakMap();
class UF extends Si {
  constructor(e) {
    super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(e) {
    return this.decoderPath = e, this;
  }
  setDecoderConfig(e) {
    return this.decoderConfig = e, this;
  }
  setWorkerLimit(e) {
    return this.workerLimit = e, this;
  }
  load(e, t, n, i) {
    const r = new pr(this.manager);
    r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(
      e,
      (o) => {
        const a = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: !1
        };
        this.decodeGeometry(o, a).then(t).catch(i);
      },
      n,
      i
    );
  }
  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
  decodeDracoFile(e, t, n, i) {
    const r = {
      attributeIDs: n || this.defaultAttributeIDs,
      attributeTypes: i || this.defaultAttributeTypes,
      useUniqueIDs: !!n
    };
    this.decodeGeometry(e, r).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const h = t.attributeTypes[l];
      h.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = h.name);
    }
    const n = JSON.stringify(t);
    if (Xg.has(e)) {
      const l = Xg.get(e);
      if (l.key === n)
        return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let i;
    const r = this.workerNextTaskID++, o = e.byteLength, a = this._getWorker(r, o).then((l) => (i = l, new Promise((h, f) => {
      i._callbacks[r] = { resolve: h, reject: f }, i.postMessage({ type: "decode", id: r, taskConfig: t, buffer: e }, [e]);
    }))).then((l) => this._createGeometry(l.geometry));
    return a.catch(() => !0).then(() => {
      i && r && this._releaseTask(i, r);
    }), Xg.set(e, {
      key: n,
      promise: a
    }), a;
  }
  _createGeometry(e) {
    const t = new Mt();
    e.index && t.setIndex(new Vt(e.index.array, 1));
    for (let n = 0; n < e.attributes.length; n++) {
      const i = e.attributes[n], r = i.name, o = i.array, a = i.itemSize;
      t.setAttribute(r, new Vt(o, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const n = new pr(this.manager);
    return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((i, r) => {
      n.load(e, i, void 0, r);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending)
      return this.decoderPending;
    const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js", t = [];
    return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((n) => {
      const i = n[0];
      e || (this.decoderConfig.wasmBinary = n[1]);
      const r = OF.toString(), o = [
        "/* draco decoder */",
        i,
        "",
        "/* worker */",
        r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([o]));
    }), this.decoderPending;
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const i = new Worker(this.workerSourceURL);
        i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({ type: "init", decoderConfig: this.decoderConfig }), i.onmessage = function(r) {
          const o = r.data;
          switch (o.type) {
            case "decode":
              i._callbacks[o.id].resolve(o);
              break;
            case "error":
              i._callbacks[o.id].reject(o);
              break;
            default:
              console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"');
          }
        }, this.workerPool.push(i);
      } else
        this.workerPool.sort(function(i, r) {
          return i._taskLoad > r._taskLoad ? -1 : 1;
        });
      const n = this.workerPool[this.workerPool.length - 1];
      return n._taskCosts[e] = t, n._taskLoad += t, n;
    });
  }
  _releaseTask(e, t) {
    e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return this.workerPool.length = 0, this;
  }
}
function OF() {
  let s, e;
  onmessage = function(o) {
    const a = o.data;
    switch (a.type) {
      case "init":
        s = a.decoderConfig, e = new Promise(function(f) {
          s.onModuleLoaded = function(d) {
            f({ draco: d });
          }, DracoDecoderModule(s);
        });
        break;
      case "decode":
        const l = a.buffer, h = a.taskConfig;
        e.then((f) => {
          const d = f.draco, p = new d.Decoder(), m = new d.DecoderBuffer();
          m.Init(new Int8Array(l), l.byteLength);
          try {
            const _ = t(d, p, m, h), x = _.attributes.map((y) => y.array.buffer);
            _.index && x.push(_.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: _ }, x);
          } catch (_) {
            console.error(_), self.postMessage({ type: "error", id: a.id, error: _.message });
          } finally {
            d.destroy(m), d.destroy(p);
          }
        });
        break;
    }
  };
  function t(o, a, l, h) {
    const f = h.attributeIDs, d = h.attributeTypes;
    let p, m;
    const _ = a.GetEncodedGeometryType(l);
    if (_ === o.TRIANGULAR_MESH)
      p = new o.Mesh(), m = a.DecodeBufferToMesh(l, p);
    else if (_ === o.POINT_CLOUD)
      p = new o.PointCloud(), m = a.DecodeBufferToPointCloud(l, p);
    else
      throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!m.ok() || p.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
    const x = { index: null, attributes: [] };
    for (const y in f) {
      const v = self[d[y]];
      let S, M;
      if (h.useUniqueIDs)
        M = f[y], S = a.GetAttributeByUniqueId(p, M);
      else {
        if (M = a.GetAttributeId(p, o[f[y]]), M === -1)
          continue;
        S = a.GetAttribute(p, M);
      }
      x.attributes.push(i(o, a, p, y, v, S));
    }
    return _ === o.TRIANGULAR_MESH && (x.index = n(o, a, p)), o.destroy(p), x;
  }
  function n(o, a, l) {
    const f = l.num_faces() * 3, d = f * 4, p = o._malloc(d);
    a.GetTrianglesUInt32Array(l, d, p);
    const m = new Uint32Array(o.HEAPF32.buffer, p, f).slice();
    return o._free(p), { array: m, itemSize: 1 };
  }
  function i(o, a, l, h, f, d) {
    const p = d.num_components(), _ = l.num_points() * p, x = _ * f.BYTES_PER_ELEMENT, y = r(o, f), v = o._malloc(x);
    a.GetAttributeDataArrayForAllPoints(l, d, y, x, v);
    const S = new f(o.HEAPF32.buffer, v, _).slice();
    return o._free(v), {
      name: h,
      array: S,
      itemSize: p
    };
  }
  function r(o, a) {
    switch (a) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
let ld;
const Jg = () => {
  if (ld)
    return ld;
  const s = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", t = new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    4,
    1,
    96,
    0,
    0,
    3,
    3,
    2,
    0,
    0,
    5,
    3,
    1,
    0,
    1,
    12,
    1,
    0,
    10,
    22,
    2,
    12,
    0,
    65,
    0,
    65,
    0,
    65,
    0,
    252,
    10,
    0,
    0,
    11,
    7,
    0,
    65,
    0,
    253,
    15,
    26,
    11
  ]), n = new Uint8Array([
    32,
    0,
    65,
    253,
    3,
    1,
    2,
    34,
    4,
    106,
    6,
    5,
    11,
    8,
    7,
    20,
    13,
    33,
    12,
    16,
    128,
    9,
    116,
    64,
    19,
    113,
    127,
    15,
    10,
    21,
    22,
    14,
    255,
    66,
    24,
    54,
    136,
    107,
    18,
    23,
    192,
    26,
    114,
    118,
    132,
    17,
    77,
    101,
    130,
    144,
    27,
    87,
    131,
    44,
    45,
    74,
    156,
    154,
    70,
    167
  ]);
  if (typeof WebAssembly != "object")
    return {
      supported: !1
    };
  let i = s;
  WebAssembly.validate(t) && (i = e);
  let r;
  const o = WebAssembly.instantiate(a(i), {}).then((d) => {
    r = d.instance, r.exports.__wasm_call_ctors();
  });
  function a(d) {
    const p = new Uint8Array(d.length);
    for (let _ = 0; _ < d.length; ++_) {
      const x = d.charCodeAt(_);
      p[_] = x > 96 ? x - 71 : x > 64 ? x - 65 : x > 47 ? x + 4 : x > 46 ? 63 : 62;
    }
    let m = 0;
    for (let _ = 0; _ < d.length; ++_)
      p[m++] = p[_] < 60 ? n[p[_]] : (p[_] - 60) * 64 + p[++_];
    return p.buffer.slice(0, m);
  }
  function l(d, p, m, _, x, y) {
    const v = r.exports.sbrk, S = m + 3 & -4, M = v(S * _), T = v(x.length), P = new Uint8Array(r.exports.memory.buffer);
    P.set(x, T);
    const b = d(M, m, _, T, x.length);
    if (b === 0 && y && y(M, S, _), p.set(P.subarray(M, M + m * _)), v(M - v(0)), b !== 0)
      throw new Error(`Malformed buffer data: ${b}`);
  }
  const h = {
    // legacy index-based enums for glTF
    0: "",
    1: "meshopt_decodeFilterOct",
    2: "meshopt_decodeFilterQuat",
    3: "meshopt_decodeFilterExp",
    // string-based enums for glTF
    NONE: "",
    OCTAHEDRAL: "meshopt_decodeFilterOct",
    QUATERNION: "meshopt_decodeFilterQuat",
    EXPONENTIAL: "meshopt_decodeFilterExp"
  }, f = {
    // legacy index-based enums for glTF
    0: "meshopt_decodeVertexBuffer",
    1: "meshopt_decodeIndexBuffer",
    2: "meshopt_decodeIndexSequence",
    // string-based enums for glTF
    ATTRIBUTES: "meshopt_decodeVertexBuffer",
    TRIANGLES: "meshopt_decodeIndexBuffer",
    INDICES: "meshopt_decodeIndexSequence"
  };
  return ld = {
    ready: o,
    supported: !0,
    decodeVertexBuffer(d, p, m, _, x) {
      l(
        r.exports.meshopt_decodeVertexBuffer,
        d,
        p,
        m,
        _,
        r.exports[h[x]]
      );
    },
    decodeIndexBuffer(d, p, m, _) {
      l(r.exports.meshopt_decodeIndexBuffer, d, p, m, _);
    },
    decodeIndexSequence(d, p, m, _) {
      l(r.exports.meshopt_decodeIndexSequence, d, p, m, _);
    },
    decodeGltfBuffer(d, p, m, _, x, y) {
      l(
        r.exports[f[x]],
        d,
        p,
        m,
        _,
        r.exports[h[y]]
      );
    }
  }, ld;
};
let cd = null, W1 = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";
function X1(s = !0, e = !0, t) {
  return (n) => {
    t && t(n), s && (cd || (cd = new UF()), cd.setDecoderPath(typeof s == "string" ? s : W1), n.setDRACOLoader(cd)), e && n.setMeshoptDecoder(typeof Jg == "function" ? Jg() : Jg);
  };
}
const Ku = (s, e, t, n) => vh(Av, s, X1(e, t, n));
Ku.preload = (s, e, t, n) => vh.preload(Av, s, X1(e, t, n));
Ku.clear = (s) => vh.clear(Av, s);
Ku.setDecoderPath = (s) => {
  W1 = s;
};
function Ds(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function J1(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, s.__proto__ = e;
}
/*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var dr = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
}, uc = {
  duration: 0.5,
  overwrite: !1,
  delay: 0
}, Mv, ai, fn, Ir = 1e8, rn = 1 / Ir, e0 = Math.PI * 2, NF = e0 / 4, kF = 0, Y1 = Math.sqrt, GF = Math.cos, HF = Math.sin, ti = function(e) {
  return typeof e == "string";
}, Tn = function(e) {
  return typeof e == "function";
}, Ys = function(e) {
  return typeof e == "number";
}, Sv = function(e) {
  return typeof e > "u";
}, xs = function(e) {
  return typeof e == "object";
}, Xi = function(e) {
  return e !== !1;
}, Ev = function() {
  return typeof window < "u";
}, ud = function(e) {
  return Tn(e) || ti(e);
}, K1 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, Ai = Array.isArray, t0 = /(?:-?\.?\d|\.)+/gi, q1 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Vl = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Yg = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Q1 = /[+-]=-?[.\d]+/, Z1 = /[^,'"\[\]\s]+/gi, zF = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, mn, as, n0, Tv, mr = {}, Kd = {}, j1, $1 = function(e) {
  return (Kd = hc(e, mr)) && qi;
}, wv = function(e, t) {
  return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, qu = function(e, t) {
  return !t && console.warn(e);
}, eT = function(e, t) {
  return e && (mr[e] = t) && Kd && (Kd[e] = t) || mr;
}, Qu = function() {
  return 0;
}, VF = {
  suppressEvents: !0,
  isStart: !0,
  kill: !1
}, Pd = {
  suppressEvents: !0,
  kill: !1
}, WF = {
  suppressEvents: !0
}, Cv = {}, wo = [], i0 = {}, tT, sr = {}, Kg = {}, FM = 30, Id = [], bv = "", Rv = function(e) {
  var t = e[0], n, i;
  if (xs(t) || Tn(t) || (e = [e]), !(n = (t._gsap || {}).harness)) {
    for (i = Id.length; i-- && !Id[i].targetTest(t); )
      ;
    n = Id[i];
  }
  for (i = e.length; i--; )
    e[i] && (e[i]._gsap || (e[i]._gsap = new TT(e[i], n))) || e.splice(i, 1);
  return e;
}, Ca = function(e) {
  return e._gsap || Rv(Lr(e))[0]._gsap;
}, nT = function(e, t, n) {
  return (n = e[t]) && Tn(n) ? e[t]() : Sv(n) && e.getAttribute && e.getAttribute(t) || n;
}, Ji = function(e, t) {
  return (e = e.split(",")).forEach(t) || e;
}, Bn = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, Nn = function(e) {
  return Math.round(e * 1e7) / 1e7 || 0;
}, ql = function(e, t) {
  var n = t.charAt(0), i = parseFloat(t.substr(2));
  return e = parseFloat(e), n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i;
}, XF = function(e, t) {
  for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; )
    ;
  return i < n;
}, qd = function() {
  var e = wo.length, t = wo.slice(0), n, i;
  for (i0 = {}, wo.length = 0, n = 0; n < e; n++)
    i = t[n], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
}, Bv = function(e) {
  return !!(e._initted || e._startAt || e.add);
}, iT = function(e, t, n, i) {
  wo.length && !ai && qd(), e.render(t, n, !!(ai && t < 0 && Bv(e))), wo.length && !ai && qd();
}, rT = function(e) {
  var t = parseFloat(e);
  return (t || t === 0) && (e + "").match(Z1).length < 2 ? t : ti(e) ? e.trim() : e;
}, sT = function(e) {
  return e;
}, gr = function(e, t) {
  for (var n in t)
    n in e || (e[n] = t[n]);
  return e;
}, JF = function(e) {
  return function(t, n) {
    for (var i in n)
      i in t || i === "duration" && e || i === "ease" || (t[i] = n[i]);
  };
}, hc = function(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}, UM = function s(e, t) {
  for (var n in t)
    n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = xs(t[n]) ? s(e[n] || (e[n] = {}), t[n]) : t[n]);
  return e;
}, Qd = function(e, t) {
  var n = {}, i;
  for (i in e)
    i in t || (n[i] = e[i]);
  return n;
}, Au = function(e) {
  var t = e.parent || mn, n = e.keyframes ? JF(Ai(e.keyframes)) : gr;
  if (Xi(e.inherit))
    for (; t; )
      n(e, t.vars.defaults), t = t.parent || t._dp;
  return e;
}, YF = function(e, t) {
  for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; )
    ;
  return n < 0;
}, oT = function(e, t, n, i, r) {
  var o = e[i], a;
  if (r)
    for (a = t[r]; o && o[r] > a; )
      o = o._prev;
  return o ? (t._next = o._next, o._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = o, t.parent = t._dp = e, t;
}, Dp = function(e, t, n, i) {
  n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
  var r = t._prev, o = t._next;
  r ? r._next = o : e[n] === t && (e[n] = o), o ? o._prev = r : e[i] === t && (e[i] = r), t._next = t._prev = t.parent = null;
}, Lo = function(e, t) {
  e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0;
}, ba = function(e, t) {
  if (e && (!t || t._end > e._dur || t._start < 0))
    for (var n = e; n; )
      n._dirty = 1, n = n.parent;
  return e;
}, KF = function(e) {
  for (var t = e.parent; t && t.parent; )
    t._dirty = 1, t.totalDuration(), t = t.parent;
  return e;
}, r0 = function(e, t, n, i) {
  return e._startAt && (ai ? e._startAt.revert(Pd) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i));
}, qF = function s(e) {
  return !e || e._ts && s(e.parent);
}, OM = function(e) {
  return e._repeat ? fc(e._tTime, e = e.duration() + e._rDelay) * e : 0;
}, fc = function(e, t) {
  var n = Math.floor(e = Nn(e / t));
  return e && n === e ? n - 1 : n;
}, Zd = function(e, t) {
  return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, Fp = function(e) {
  return e._end = Nn(e._start + (e._tDur / Math.abs(e._ts || e._rts || rn) || 0));
}, Up = function(e, t) {
  var n = e._dp;
  return n && n.smoothChildTiming && e._ts && (e._start = Nn(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Fp(e), n._dirty || ba(n, e)), e;
}, aT = function(e, t) {
  var n;
  if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = Zd(e.rawTime(), t), (!t._dur || yh(0, t.totalDuration(), n) - t._tTime > rn) && t.render(n, !0)), ba(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
    if (e._dur < e.duration())
      for (n = e; n._dp; )
        n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
    e._zTime = -rn;
  }
}, cs = function(e, t, n, i) {
  return t.parent && Lo(t), t._start = Nn((Ys(n) ? n : n || e !== mn ? br(e, n, t) : e._time) + t._delay), t._end = Nn(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), oT(e, t, "_first", "_last", e._sort ? "_start" : 0), s0(t) || (e._recent = t), i || aT(e, t), e._ts < 0 && Up(e, e._tTime), e;
}, lT = function(e, t) {
  return (mr.ScrollTrigger || wv("scrollTrigger", t)) && mr.ScrollTrigger.create(t, e);
}, cT = function(e, t, n, i, r) {
  if (Iv(e, t, r), !e._initted)
    return 1;
  if (!n && e._pt && !ai && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && tT !== lr.frame)
    return wo.push(e), e._lazy = [r, i], 1;
}, QF = function s(e) {
  var t = e.parent;
  return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || s(t));
}, s0 = function(e) {
  var t = e.data;
  return t === "isFromStart" || t === "isStart";
}, ZF = function(e, t, n, i) {
  var r = e.ratio, o = t < 0 || !t && (!e._start && QF(e) && !(!e._initted && s0(e)) || (e._ts < 0 || e._dp._ts < 0) && !s0(e)) ? 0 : 1, a = e._rDelay, l = 0, h, f, d;
  if (a && e._repeat && (l = yh(0, e._tDur, t), f = fc(l, a), e._yoyo && f & 1 && (o = 1 - o), f !== fc(e._tTime, a) && (r = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== r || ai || i || e._zTime === rn || !t && e._zTime) {
    if (!e._initted && cT(e, t, i, n, l))
      return;
    for (d = e._zTime, e._zTime = t || (n ? rn : 0), n || (n = t && !d), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = l, h = e._pt; h; )
      h.r(o, h.d), h = h._next;
    t < 0 && r0(e, t, n, !0), e._onUpdate && !n && hr(e, "onUpdate"), l && e._repeat && !n && e.parent && hr(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === o && (o && Lo(e, 1), !n && !ai && (hr(e, o ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()));
  } else e._zTime || (e._zTime = t);
}, jF = function(e, t, n) {
  var i;
  if (n > t)
    for (i = e._first; i && i._start <= n; ) {
      if (i.data === "isPause" && i._start > t)
        return i;
      i = i._next;
    }
  else
    for (i = e._last; i && i._start >= n; ) {
      if (i.data === "isPause" && i._start < t)
        return i;
      i = i._prev;
    }
}, dc = function(e, t, n, i) {
  var r = e._repeat, o = Nn(t) || 0, a = e._tTime / e._tDur;
  return a && !i && (e._time *= o / e._dur), e._dur = o, e._tDur = r ? r < 0 ? 1e10 : Nn(o * (r + 1) + e._rDelay * r) : o, a > 0 && !i && Up(e, e._tTime = e._tDur * a), e.parent && Fp(e), n || ba(e.parent, e), e;
}, NM = function(e) {
  return e instanceof Fi ? ba(e) : dc(e, e._dur);
}, $F = {
  _start: 0,
  endTime: Qu,
  totalDuration: Qu
}, br = function s(e, t, n) {
  var i = e.labels, r = e._recent || $F, o = e.duration() >= Ir ? r.endTime(!1) : e._dur, a, l, h;
  return ti(t) && (isNaN(t) || t in i) ? (l = t.charAt(0), h = t.substr(-1) === "%", a = t.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")), (l === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (h ? (a < 0 ? r : n).totalDuration() / 100 : 1)) : a < 0 ? (t in i || (i[t] = o), i[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)), h && n && (l = l / 100 * (Ai(n) ? n[0] : n).totalDuration()), a > 1 ? s(e, t.substr(0, a - 1), n) + l : o + l)) : t == null ? o : +t;
}, Mu = function(e, t, n) {
  var i = Ys(t[1]), r = (i ? 2 : 1) + (e < 2 ? 0 : 1), o = t[r], a, l;
  if (i && (o.duration = t[1]), o.parent = n, e) {
    for (a = o, l = n; l && !("immediateRender" in a); )
      a = l.vars.defaults || {}, l = Xi(l.vars.inherit) && l.parent;
    o.immediateRender = Xi(a.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[r - 1];
  }
  return new On(t[0], o, t[r + 1]);
}, ko = function(e, t) {
  return e || e === 0 ? t(e) : t;
}, yh = function(e, t, n) {
  return n < e ? e : n > t ? t : n;
}, _i = function(e, t) {
  return !ti(e) || !(t = zF.exec(e)) ? "" : t[1];
}, e3 = function(e, t, n) {
  return ko(n, function(i) {
    return yh(e, t, i);
  });
}, o0 = [].slice, uT = function(e, t) {
  return e && xs(e) && "length" in e && (!t && !e.length || e.length - 1 in e && xs(e[0])) && !e.nodeType && e !== as;
}, t3 = function(e, t, n) {
  return n === void 0 && (n = []), e.forEach(function(i) {
    var r;
    return ti(i) && !t || uT(i, 1) ? (r = n).push.apply(r, Lr(i)) : n.push(i);
  }) || n;
}, Lr = function(e, t, n) {
  return fn && !t && fn.selector ? fn.selector(e) : ti(e) && !n && (n0 || !pc()) ? o0.call((t || Tv).querySelectorAll(e), 0) : Ai(e) ? t3(e, n) : uT(e) ? o0.call(e, 0) : e ? [e] : [];
}, a0 = function(e) {
  return e = Lr(e)[0] || qu("Invalid scope") || {}, function(t) {
    var n = e.current || e.nativeElement || e;
    return Lr(t, n.querySelectorAll ? n : n === e ? qu("Invalid scope") || Tv.createElement("div") : e);
  };
}, hT = function(e) {
  return e.sort(function() {
    return 0.5 - Math.random();
  });
}, fT = function(e) {
  if (Tn(e))
    return e;
  var t = xs(e) ? e : {
    each: e
  }, n = Ra(t.ease), i = t.from || 0, r = parseFloat(t.base) || 0, o = {}, a = i > 0 && i < 1, l = isNaN(i) || a, h = t.axis, f = i, d = i;
  return ti(i) ? f = d = {
    center: 0.5,
    edges: 0.5,
    end: 1
  }[i] || 0 : !a && l && (f = i[0], d = i[1]), function(p, m, _) {
    var x = (_ || t).length, y = o[x], v, S, M, T, P, b, R, U, C;
    if (!y) {
      if (C = t.grid === "auto" ? 0 : (t.grid || [1, Ir])[1], !C) {
        for (R = -Ir; R < (R = _[C++].getBoundingClientRect().left) && C < x; )
          ;
        C < x && C--;
      }
      for (y = o[x] = [], v = l ? Math.min(C, x) * f - 0.5 : i % C, S = C === Ir ? 0 : l ? x * d / C - 0.5 : i / C | 0, R = 0, U = Ir, b = 0; b < x; b++)
        M = b % C - v, T = S - (b / C | 0), y[b] = P = h ? Math.abs(h === "y" ? T : M) : Y1(M * M + T * T), P > R && (R = P), P < U && (U = P);
      i === "random" && hT(y), y.max = R - U, y.min = U, y.v = x = (parseFloat(t.amount) || parseFloat(t.each) * (C > x ? x - 1 : h ? h === "y" ? x / C : C : Math.max(C, x / C)) || 0) * (i === "edges" ? -1 : 1), y.b = x < 0 ? r - x : r, y.u = _i(t.amount || t.each) || 0, n = n && x < 0 ? MT(n) : n;
    }
    return x = (y[p] - y.min) / y.max || 0, Nn(y.b + (n ? n(x) : x) * y.v) + y.u;
  };
}, l0 = function(e) {
  var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
  return function(n) {
    var i = Nn(Math.round(parseFloat(n) / e) * e * t);
    return (i - i % 1) / t + (Ys(n) ? 0 : _i(n));
  };
}, dT = function(e, t) {
  var n = Ai(e), i, r;
  return !n && xs(e) && (i = n = e.radius || Ir, e.values ? (e = Lr(e.values), (r = !Ys(e[0])) && (i *= i)) : e = l0(e.increment)), ko(t, n ? Tn(e) ? function(o) {
    return r = e(o), Math.abs(r - o) <= i ? r : o;
  } : function(o) {
    for (var a = parseFloat(r ? o.x : o), l = parseFloat(r ? o.y : 0), h = Ir, f = 0, d = e.length, p, m; d--; )
      r ? (p = e[d].x - a, m = e[d].y - l, p = p * p + m * m) : p = Math.abs(e[d] - a), p < h && (h = p, f = d);
    return f = !i || h <= i ? e[f] : o, r || f === o || Ys(o) ? f : f + _i(o);
  } : l0(e));
}, pT = function(e, t, n, i) {
  return ko(Ai(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
    return Ai(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) * n * i) / i;
  });
}, n3 = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(i) {
    return t.reduce(function(r, o) {
      return o(r);
    }, i);
  };
}, i3 = function(e, t) {
  return function(n) {
    return e(parseFloat(n)) + (t || _i(n));
  };
}, r3 = function(e, t, n) {
  return gT(e, t, 0, 1, n);
}, mT = function(e, t, n) {
  return ko(n, function(i) {
    return e[~~t(i)];
  });
}, s3 = function s(e, t, n) {
  var i = t - e;
  return Ai(e) ? mT(e, s(0, e.length), t) : ko(n, function(r) {
    return (i + (r - e) % i) % i + e;
  });
}, o3 = function s(e, t, n) {
  var i = t - e, r = i * 2;
  return Ai(e) ? mT(e, s(0, e.length - 1), t) : ko(n, function(o) {
    return o = (r + (o - e) % r) % r || 0, e + (o > i ? r - o : o);
  });
}, Zu = function(e) {
  for (var t = 0, n = "", i, r, o, a; ~(i = e.indexOf("random(", t)); )
    o = e.indexOf(")", i), a = e.charAt(i + 7) === "[", r = e.substr(i + 7, o - i - 7).match(a ? Z1 : t0), n += e.substr(t, i - t) + pT(a ? r : +r[0], a ? 0 : +r[1], +r[2] || 1e-5), t = o + 1;
  return n + e.substr(t, e.length - t);
}, gT = function(e, t, n, i, r) {
  var o = t - e, a = i - n;
  return ko(r, function(l) {
    return n + ((l - e) / o * a || 0);
  });
}, a3 = function s(e, t, n, i) {
  var r = isNaN(e + t) ? 0 : function(m) {
    return (1 - m) * e + m * t;
  };
  if (!r) {
    var o = ti(e), a = {}, l, h, f, d, p;
    if (n === !0 && (i = 1) && (n = null), o)
      e = {
        p: e
      }, t = {
        p: t
      };
    else if (Ai(e) && !Ai(t)) {
      for (f = [], d = e.length, p = d - 2, h = 1; h < d; h++)
        f.push(s(e[h - 1], e[h]));
      d--, r = function(_) {
        _ *= d;
        var x = Math.min(p, ~~_);
        return f[x](_ - x);
      }, n = t;
    } else i || (e = hc(Ai(e) ? [] : {}, e));
    if (!f) {
      for (l in t)
        Pv.call(a, e, l, "get", t[l]);
      r = function(_) {
        return Fv(_, a) || (o ? e.p : e);
      };
    }
  }
  return ko(n, r);
}, kM = function(e, t, n) {
  var i = e.labels, r = Ir, o, a, l;
  for (o in i)
    a = i[o] - t, a < 0 == !!n && a && r > (a = Math.abs(a)) && (l = o, r = a);
  return l;
}, hr = function(e, t, n) {
  var i = e.vars, r = i[t], o = fn, a = e._ctx, l, h, f;
  if (r)
    return l = i[t + "Params"], h = i.callbackScope || e, n && wo.length && qd(), a && (fn = a), f = l ? r.apply(h, l) : r.call(h), fn = o, f;
}, lu = function(e) {
  return Lo(e), e.scrollTrigger && e.scrollTrigger.kill(!!ai), e.progress() < 1 && hr(e, "onInterrupt"), e;
}, Wl, _T = [], vT = function(e) {
  if (e)
    if (e = !e.name && e.default || e, Ev() || e.headless) {
      var t = e.name, n = Tn(e), i = t && !n && e.init ? function() {
        this._props = [];
      } : e, r = {
        init: Qu,
        render: Fv,
        add: Pv,
        kill: S3,
        modifier: M3,
        rawVars: 0
      }, o = {
        targetTest: 0,
        get: 0,
        getSetter: Dv,
        aliases: {},
        register: 0
      };
      if (pc(), e !== i) {
        if (sr[t])
          return;
        gr(i, gr(Qd(e, r), o)), hc(i.prototype, hc(r, Qd(e, o))), sr[i.prop = t] = i, e.targetTest && (Id.push(i), Cv[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
      }
      eT(t, i), e.register && e.register(qi, i, Yi);
    } else
      _T.push(e);
}, nn = 255, cu = {
  aqua: [0, nn, nn],
  lime: [0, nn, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, nn],
  navy: [0, 0, 128],
  white: [nn, nn, nn],
  olive: [128, 128, 0],
  yellow: [nn, nn, 0],
  orange: [nn, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [nn, 0, 0],
  pink: [nn, 192, 203],
  cyan: [0, nn, nn],
  transparent: [nn, nn, nn, 0]
}, qg = function(e, t, n) {
  return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (n - t) * e * 6 : e < 0.5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * nn + 0.5 | 0;
}, yT = function(e, t, n) {
  var i = e ? Ys(e) ? [e >> 16, e >> 8 & nn, e & nn] : 0 : cu.black, r, o, a, l, h, f, d, p, m, _;
  if (!i) {
    if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), cu[e])
      i = cu[e];
    else if (e.charAt(0) === "#") {
      if (e.length < 6 && (r = e.charAt(1), o = e.charAt(2), a = e.charAt(3), e = "#" + r + r + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9)
        return i = parseInt(e.substr(1, 6), 16), [i >> 16, i >> 8 & nn, i & nn, parseInt(e.substr(7), 16) / 255];
      e = parseInt(e.substr(1), 16), i = [e >> 16, e >> 8 & nn, e & nn];
    } else if (e.substr(0, 3) === "hsl") {
      if (i = _ = e.match(t0), !t)
        l = +i[0] % 360 / 360, h = +i[1] / 100, f = +i[2] / 100, o = f <= 0.5 ? f * (h + 1) : f + h - f * h, r = f * 2 - o, i.length > 3 && (i[3] *= 1), i[0] = qg(l + 1 / 3, r, o), i[1] = qg(l, r, o), i[2] = qg(l - 1 / 3, r, o);
      else if (~e.indexOf("="))
        return i = e.match(q1), n && i.length < 4 && (i[3] = 1), i;
    } else
      i = e.match(t0) || cu.transparent;
    i = i.map(Number);
  }
  return t && !_ && (r = i[0] / nn, o = i[1] / nn, a = i[2] / nn, d = Math.max(r, o, a), p = Math.min(r, o, a), f = (d + p) / 2, d === p ? l = h = 0 : (m = d - p, h = f > 0.5 ? m / (2 - d - p) : m / (d + p), l = d === r ? (o - a) / m + (o < a ? 6 : 0) : d === o ? (a - r) / m + 2 : (r - o) / m + 4, l *= 60), i[0] = ~~(l + 0.5), i[1] = ~~(h * 100 + 0.5), i[2] = ~~(f * 100 + 0.5)), n && i.length < 4 && (i[3] = 1), i;
}, xT = function(e) {
  var t = [], n = [], i = -1;
  return e.split(Co).forEach(function(r) {
    var o = r.match(Vl) || [];
    t.push.apply(t, o), n.push(i += o.length + 1);
  }), t.c = n, t;
}, GM = function(e, t, n) {
  var i = "", r = (e + i).match(Co), o = t ? "hsla(" : "rgba(", a = 0, l, h, f, d;
  if (!r)
    return e;
  if (r = r.map(function(p) {
    return (p = yT(p, t, 1)) && o + (t ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) + ")";
  }), n && (f = xT(e), l = n.c, l.join(i) !== f.c.join(i)))
    for (h = e.replace(Co, "1").split(Vl), d = h.length - 1; a < d; a++)
      i += h[a] + (~l.indexOf(a) ? r.shift() || o + "0,0,0,0)" : (f.length ? f : r.length ? r : n).shift());
  if (!h)
    for (h = e.split(Co), d = h.length - 1; a < d; a++)
      i += h[a] + r[a];
  return i + h[d];
}, Co = function() {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
  for (e in cu)
    s += "|" + e + "\\b";
  return new RegExp(s + ")", "gi");
}(), l3 = /hsl[a]?\(/, AT = function(e) {
  var t = e.join(" "), n;
  if (Co.lastIndex = 0, Co.test(t))
    return n = l3.test(t), e[1] = GM(e[1], n), e[0] = GM(e[0], n, xT(e[1])), !0;
}, ju, lr = function() {
  var s = Date.now, e = 500, t = 33, n = s(), i = n, r = 1e3 / 240, o = r, a = [], l, h, f, d, p, m, _ = function x(y) {
    var v = s() - i, S = y === !0, M, T, P, b;
    if ((v > e || v < 0) && (n += v - t), i += v, P = i - n, M = P - o, (M > 0 || S) && (b = ++d.frame, p = P - d.time * 1e3, d.time = P = P / 1e3, o += M + (M >= r ? 4 : r - M), T = 1), S || (l = h(x)), T)
      for (m = 0; m < a.length; m++)
        a[m](P, p, b, y);
  };
  return d = {
    time: 0,
    frame: 0,
    tick: function() {
      _(!0);
    },
    deltaRatio: function(y) {
      return p / (1e3 / (y || 60));
    },
    wake: function() {
      j1 && (!n0 && Ev() && (as = n0 = window, Tv = as.document || {}, mr.gsap = qi, (as.gsapVersions || (as.gsapVersions = [])).push(qi.version), $1(Kd || as.GreenSockGlobals || !as.gsap && as || {}), _T.forEach(vT)), f = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && d.sleep(), h = f || function(y) {
        return setTimeout(y, o - d.time * 1e3 + 1 | 0);
      }, ju = 1, _(2));
    },
    sleep: function() {
      (f ? cancelAnimationFrame : clearTimeout)(l), ju = 0, h = Qu;
    },
    lagSmoothing: function(y, v) {
      e = y || 1 / 0, t = Math.min(v || 33, e);
    },
    fps: function(y) {
      r = 1e3 / (y || 240), o = d.time * 1e3 + r;
    },
    add: function(y, v, S) {
      var M = v ? function(T, P, b, R) {
        y(T, P, b, R), d.remove(M);
      } : y;
      return d.remove(y), a[S ? "unshift" : "push"](M), pc(), M;
    },
    remove: function(y, v) {
      ~(v = a.indexOf(y)) && a.splice(v, 1) && m >= v && m--;
    },
    _listeners: a
  }, d;
}(), pc = function() {
  return !ju && lr.wake();
}, Gt = {}, c3 = /^[\d.\-M][\d.\-,\s]/, u3 = /["']/g, h3 = function(e) {
  for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], r = 1, o = n.length, a, l, h; r < o; r++)
    l = n[r], a = r !== o - 1 ? l.lastIndexOf(",") : l.length, h = l.substr(0, a), t[i] = isNaN(h) ? h.replace(u3, "").trim() : +h, i = l.substr(a + 1).trim();
  return t;
}, f3 = function(e) {
  var t = e.indexOf("(") + 1, n = e.indexOf(")"), i = e.indexOf("(", t);
  return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n);
}, d3 = function(e) {
  var t = (e + "").split("("), n = Gt[t[0]];
  return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [h3(t[1])] : f3(e).split(",").map(rT)) : Gt._CE && c3.test(e) ? Gt._CE("", e) : n;
}, MT = function(e) {
  return function(t) {
    return 1 - e(1 - t);
  };
}, ST = function s(e, t) {
  for (var n = e._first, i; n; )
    n instanceof Fi ? s(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? s(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next;
}, Ra = function(e, t) {
  return e && (Tn(e) ? e : Gt[e] || d3(e)) || t;
}, Ya = function(e, t, n, i) {
  n === void 0 && (n = function(l) {
    return 1 - t(1 - l);
  }), i === void 0 && (i = function(l) {
    return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
  });
  var r = {
    easeIn: t,
    easeOut: n,
    easeInOut: i
  }, o;
  return Ji(e, function(a) {
    Gt[a] = mr[a] = r, Gt[o = a.toLowerCase()] = n;
    for (var l in r)
      Gt[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Gt[a + "." + l] = r[l];
  }), r;
}, ET = function(e) {
  return function(t) {
    return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
  };
}, Qg = function s(e, t, n) {
  var i = t >= 1 ? t : 1, r = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), o = r / e0 * (Math.asin(1 / i) || 0), a = function(f) {
    return f === 1 ? 1 : i * Math.pow(2, -10 * f) * HF((f - o) * r) + 1;
  }, l = e === "out" ? a : e === "in" ? function(h) {
    return 1 - a(1 - h);
  } : ET(a);
  return r = e0 / r, l.config = function(h, f) {
    return s(e, h, f);
  }, l;
}, Zg = function s(e, t) {
  t === void 0 && (t = 1.70158);
  var n = function(o) {
    return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
  }, i = e === "out" ? n : e === "in" ? function(r) {
    return 1 - n(1 - r);
  } : ET(n);
  return i.config = function(r) {
    return s(e, r);
  }, i;
};
Ji("Linear,Quad,Cubic,Quart,Quint,Strong", function(s, e) {
  var t = e < 5 ? e + 1 : e;
  Ya(s + ",Power" + (t - 1), e ? function(n) {
    return Math.pow(n, t);
  } : function(n) {
    return n;
  }, function(n) {
    return 1 - Math.pow(1 - n, t);
  }, function(n) {
    return n < 0.5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2;
  });
});
Gt.Linear.easeNone = Gt.none = Gt.Linear.easeIn;
Ya("Elastic", Qg("in"), Qg("out"), Qg());
(function(s, e) {
  var t = 1 / e, n = 2 * t, i = 2.5 * t, r = function(a) {
    return a < t ? s * a * a : a < n ? s * Math.pow(a - 1.5 / e, 2) + 0.75 : a < i ? s * (a -= 2.25 / e) * a + 0.9375 : s * Math.pow(a - 2.625 / e, 2) + 0.984375;
  };
  Ya("Bounce", function(o) {
    return 1 - r(1 - o);
  }, r);
})(7.5625, 2.75);
Ya("Expo", function(s) {
  return Math.pow(2, 10 * (s - 1)) * s + s * s * s * s * s * s * (1 - s);
});
Ya("Circ", function(s) {
  return -(Y1(1 - s * s) - 1);
});
Ya("Sine", function(s) {
  return s === 1 ? 1 : -GF(s * NF) + 1;
});
Ya("Back", Zg("in"), Zg("out"), Zg());
Gt.SteppedEase = Gt.steps = mr.SteppedEase = {
  config: function(e, t) {
    e === void 0 && (e = 1);
    var n = 1 / e, i = e + (t ? 0 : 1), r = t ? 1 : 0, o = 1 - rn;
    return function(a) {
      return ((i * yh(0, o, a) | 0) + r) * n;
    };
  }
};
uc.ease = Gt["quad.out"];
Ji("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(s) {
  return bv += s + "," + s + "Params,";
});
var TT = function(e, t) {
  this.id = kF++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : nT, this.set = t ? t.getSetter : Dv;
}, $u = /* @__PURE__ */ function() {
  function s(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, dc(this, +t.duration, 1, 1), this.data = t.data, fn && (this._ctx = fn, fn.data.push(this)), ju || lr.wake();
  }
  var e = s.prototype;
  return e.delay = function(n) {
    return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay;
  }, e.duration = function(n) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur;
  }, e.totalDuration = function(n) {
    return arguments.length ? (this._dirty = 0, dc(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, e.totalTime = function(n, i) {
    if (pc(), !arguments.length)
      return this._tTime;
    var r = this._dp;
    if (r && r.smoothChildTiming && this._ts) {
      for (Up(this, n), !r._dp || r.parent || aT(r, this); r && r.parent; )
        r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && cs(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === rn || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), iT(this, n, i)), this;
  }, e.time = function(n, i) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + OM(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time;
  }, e.totalProgress = function(n, i) {
    return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
  }, e.progress = function(n, i) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + OM(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(n, i) {
    var r = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (n - 1) * r, i) : this._repeat ? fc(this._tTime, r) + 1 : 1;
  }, e.timeScale = function(n, i) {
    if (!arguments.length)
      return this._rts === -rn ? 0 : this._rts;
    if (this._rts === n)
      return this;
    var r = this.parent && this._ts ? Zd(this.parent._time, this) : this._tTime;
    return this._rts = +n || 0, this._ts = this._ps || n === -rn ? 0 : this._rts, this.totalTime(yh(-Math.abs(this._delay), this.totalDuration(), r), i !== !1), Fp(this), KF(this);
  }, e.paused = function(n) {
    return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (pc(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== rn && (this._tTime -= rn)))), this) : this._ps;
  }, e.startTime = function(n) {
    if (arguments.length) {
      this._start = n;
      var i = this.parent || this._dp;
      return i && (i._sort || !this.parent) && cs(i, this, n - this._delay), this;
    }
    return this._start;
  }, e.endTime = function(n) {
    return this._start + (Xi(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, e.rawTime = function(n) {
    var i = this.parent || this._dp;
    return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? Zd(i.rawTime(n), this) : this._tTime : this._tTime;
  }, e.revert = function(n) {
    n === void 0 && (n = WF);
    var i = ai;
    return ai = n, Bv(this) && (this.timeline && this.timeline.revert(n), this.totalTime(-0.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), ai = i, this;
  }, e.globalTime = function(n) {
    for (var i = this, r = arguments.length ? n : i.rawTime(); i; )
      r = i._start + r / (Math.abs(i._ts) || 1), i = i._dp;
    return !this.parent && this._sat ? this._sat.globalTime(n) : r;
  }, e.repeat = function(n) {
    return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, NM(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, e.repeatDelay = function(n) {
    if (arguments.length) {
      var i = this._time;
      return this._rDelay = n, NM(this), i ? this.time(i) : this;
    }
    return this._rDelay;
  }, e.yoyo = function(n) {
    return arguments.length ? (this._yoyo = n, this) : this._yoyo;
  }, e.seek = function(n, i) {
    return this.totalTime(br(this, n), Xi(i));
  }, e.restart = function(n, i) {
    return this.play().totalTime(n ? -this._delay : 0, Xi(i)), this._dur || (this._zTime = -rn), this;
  }, e.play = function(n, i) {
    return n != null && this.seek(n, i), this.reversed(!1).paused(!1);
  }, e.reverse = function(n, i) {
    return n != null && this.seek(n || this.totalDuration(), i), this.reversed(!0).paused(!1);
  }, e.pause = function(n, i) {
    return n != null && this.seek(n, i), this.paused(!0);
  }, e.resume = function() {
    return this.paused(!1);
  }, e.reversed = function(n) {
    return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -rn : 0)), this) : this._rts < 0;
  }, e.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -rn, this;
  }, e.isActive = function() {
    var n = this.parent || this._dp, i = this._start, r;
    return !!(!n || this._ts && this._initted && n.isActive() && (r = n.rawTime(!0)) >= i && r < this.endTime(!0) - rn);
  }, e.eventCallback = function(n, i, r) {
    var o = this.vars;
    return arguments.length > 1 ? (i ? (o[n] = i, r && (o[n + "Params"] = r), n === "onUpdate" && (this._onUpdate = i)) : delete o[n], this) : o[n];
  }, e.then = function(n) {
    var i = this;
    return new Promise(function(r) {
      var o = Tn(n) ? n : sT, a = function() {
        var h = i.then;
        i.then = null, Tn(o) && (o = o(i)) && (o.then || o === i) && (i.then = h), r(o), i.then = h;
      };
      i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? a() : i._prom = a;
    });
  }, e.kill = function() {
    lu(this);
  }, s;
}();
gr($u.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -rn,
  _prom: 0,
  _ps: !1,
  _rts: 1
});
var Fi = /* @__PURE__ */ function(s) {
  J1(e, s);
  function e(n, i) {
    var r;
    return n === void 0 && (n = {}), r = s.call(this, n) || this, r.labels = {}, r.smoothChildTiming = !!n.smoothChildTiming, r.autoRemoveChildren = !!n.autoRemoveChildren, r._sort = Xi(n.sortChildren), mn && cs(n.parent || mn, Ds(r), i), n.reversed && r.reverse(), n.paused && r.paused(!0), n.scrollTrigger && lT(Ds(r), n.scrollTrigger), r;
  }
  var t = e.prototype;
  return t.to = function(i, r, o) {
    return Mu(0, arguments, this), this;
  }, t.from = function(i, r, o) {
    return Mu(1, arguments, this), this;
  }, t.fromTo = function(i, r, o, a) {
    return Mu(2, arguments, this), this;
  }, t.set = function(i, r, o) {
    return r.duration = 0, r.parent = this, Au(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new On(i, r, br(this, o), 1), this;
  }, t.call = function(i, r, o) {
    return cs(this, On.delayedCall(0, i, r), o);
  }, t.staggerTo = function(i, r, o, a, l, h, f) {
    return o.duration = r, o.stagger = o.stagger || a, o.onComplete = h, o.onCompleteParams = f, o.parent = this, new On(i, o, br(this, l)), this;
  }, t.staggerFrom = function(i, r, o, a, l, h, f) {
    return o.runBackwards = 1, Au(o).immediateRender = Xi(o.immediateRender), this.staggerTo(i, r, o, a, l, h, f);
  }, t.staggerFromTo = function(i, r, o, a, l, h, f, d) {
    return a.startAt = o, Au(a).immediateRender = Xi(a.immediateRender), this.staggerTo(i, r, a, l, h, f, d);
  }, t.render = function(i, r, o) {
    var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, h = this._dur, f = i <= 0 ? 0 : Nn(i), d = this._zTime < 0 != i < 0 && (this._initted || !h), p, m, _, x, y, v, S, M, T, P, b, R;
    if (this !== mn && f > l && i >= 0 && (f = l), f !== this._tTime || o || d) {
      if (a !== this._time && h && (f += this._time - a, i += this._time - a), p = f, T = this._start, M = this._ts, v = !M, d && (h || (a = this._zTime), (i || !r) && (this._zTime = i)), this._repeat) {
        if (b = this._yoyo, y = h + this._rDelay, this._repeat < -1 && i < 0)
          return this.totalTime(y * 100 + i, r, o);
        if (p = Nn(f % y), f === l ? (x = this._repeat, p = h) : (P = Nn(f / y), x = ~~P, x && x === P && (p = h, x--), p > h && (p = h)), P = fc(this._tTime, y), !a && this._tTime && P !== x && this._tTime - P * y - this._dur <= 0 && (P = x), b && x & 1 && (p = h - p, R = 1), x !== P && !this._lock) {
          var U = b && P & 1, C = U === (b && x & 1);
          if (x < P && (U = !U), a = U ? 0 : f % h ? h : f, this._lock = 1, this.render(a || (R ? 0 : Nn(x * y)), r, !h)._lock = 0, this._tTime = f, !r && this.parent && hr(this, "onRepeat"), this.vars.repeatRefresh && !R && (this.invalidate()._lock = 1), a && a !== this._time || v !== !this._ts || this.vars.onRepeat && !this.parent && !this._act)
            return this;
          if (h = this._dur, l = this._tDur, C && (this._lock = 2, a = U ? h : -1e-4, this.render(a, !0), this.vars.repeatRefresh && !R && this.invalidate()), this._lock = 0, !this._ts && !v)
            return this;
          ST(this, R);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (S = jF(this, Nn(a), Nn(p)), S && (f -= p - (p = S._start))), this._tTime = f, this._time = p, this._act = !M, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, a = 0), !a && f && !r && !P && (hr(this, "onStart"), this._tTime !== f))
        return this;
      if (p >= a && i >= 0)
        for (m = this._first; m; ) {
          if (_ = m._next, (m._act || p >= m._start) && m._ts && S !== m) {
            if (m.parent !== this)
              return this.render(i, r, o);
            if (m.render(m._ts > 0 ? (p - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (p - m._start) * m._ts, r, o), p !== this._time || !this._ts && !v) {
              S = 0, _ && (f += this._zTime = -rn);
              break;
            }
          }
          m = _;
        }
      else {
        m = this._last;
        for (var B = i < 0 ? i : p; m; ) {
          if (_ = m._prev, (m._act || B <= m._end) && m._ts && S !== m) {
            if (m.parent !== this)
              return this.render(i, r, o);
            if (m.render(m._ts > 0 ? (B - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (B - m._start) * m._ts, r, o || ai && Bv(m)), p !== this._time || !this._ts && !v) {
              S = 0, _ && (f += this._zTime = B ? -rn : rn);
              break;
            }
          }
          m = _;
        }
      }
      if (S && !r && (this.pause(), S.render(p >= a ? 0 : -rn)._zTime = p >= a ? 1 : -1, this._ts))
        return this._start = T, Fp(this), this.render(i, r, o);
      this._onUpdate && !r && hr(this, "onUpdate", !0), (f === l && this._tTime >= this.totalDuration() || !f && a) && (T === this._start || Math.abs(M) !== Math.abs(this._ts)) && (this._lock || ((i || !h) && (f === l && this._ts > 0 || !f && this._ts < 0) && Lo(this, 1), !r && !(i < 0 && !a) && (f || a || !l) && (hr(this, f === l && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(f < l && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, t.add = function(i, r) {
    var o = this;
    if (Ys(r) || (r = br(this, r, i)), !(i instanceof $u)) {
      if (Ai(i))
        return i.forEach(function(a) {
          return o.add(a, r);
        }), this;
      if (ti(i))
        return this.addLabel(i, r);
      if (Tn(i))
        i = On.delayedCall(0, i);
      else
        return this;
    }
    return this !== i ? cs(this, i, r) : this;
  }, t.getChildren = function(i, r, o, a) {
    i === void 0 && (i = !0), r === void 0 && (r = !0), o === void 0 && (o = !0), a === void 0 && (a = -Ir);
    for (var l = [], h = this._first; h; )
      h._start >= a && (h instanceof On ? r && l.push(h) : (o && l.push(h), i && l.push.apply(l, h.getChildren(!0, r, o)))), h = h._next;
    return l;
  }, t.getById = function(i) {
    for (var r = this.getChildren(1, 1, 1), o = r.length; o--; )
      if (r[o].vars.id === i)
        return r[o];
  }, t.remove = function(i) {
    return ti(i) ? this.removeLabel(i) : Tn(i) ? this.killTweensOf(i) : (i.parent === this && Dp(this, i), i === this._recent && (this._recent = this._last), ba(this));
  }, t.totalTime = function(i, r) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Nn(lr.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), s.prototype.totalTime.call(this, i, r), this._forcing = 0, this) : this._tTime;
  }, t.addLabel = function(i, r) {
    return this.labels[i] = br(this, r), this;
  }, t.removeLabel = function(i) {
    return delete this.labels[i], this;
  }, t.addPause = function(i, r, o) {
    var a = On.delayedCall(0, r || Qu, o);
    return a.data = "isPause", this._hasPause = 1, cs(this, a, br(this, i));
  }, t.removePause = function(i) {
    var r = this._first;
    for (i = br(this, i); r; )
      r._start === i && r.data === "isPause" && Lo(r), r = r._next;
  }, t.killTweensOf = function(i, r, o) {
    for (var a = this.getTweensOf(i, o), l = a.length; l--; )
      _o !== a[l] && a[l].kill(i, r);
    return this;
  }, t.getTweensOf = function(i, r) {
    for (var o = [], a = Lr(i), l = this._first, h = Ys(r), f; l; )
      l instanceof On ? XF(l._targets, a) && (h ? (!_o || l._initted && l._ts) && l.globalTime(0) <= r && l.globalTime(l.totalDuration()) > r : !r || l.isActive()) && o.push(l) : (f = l.getTweensOf(a, r)).length && o.push.apply(o, f), l = l._next;
    return o;
  }, t.tweenTo = function(i, r) {
    r = r || {};
    var o = this, a = br(o, i), l = r, h = l.startAt, f = l.onStart, d = l.onStartParams, p = l.immediateRender, m, _ = On.to(o, gr({
      ease: r.ease || "none",
      lazy: !1,
      immediateRender: !1,
      time: a,
      overwrite: "auto",
      duration: r.duration || Math.abs((a - (h && "time" in h ? h.time : o._time)) / o.timeScale()) || rn,
      onStart: function() {
        if (o.pause(), !m) {
          var y = r.duration || Math.abs((a - (h && "time" in h ? h.time : o._time)) / o.timeScale());
          _._dur !== y && dc(_, y, 0, 1).render(_._time, !0, !0), m = 1;
        }
        f && f.apply(_, d || []);
      }
    }, r));
    return p ? _.render(0) : _;
  }, t.tweenFromTo = function(i, r, o) {
    return this.tweenTo(r, gr({
      startAt: {
        time: br(this, i)
      }
    }, o));
  }, t.recent = function() {
    return this._recent;
  }, t.nextLabel = function(i) {
    return i === void 0 && (i = this._time), kM(this, br(this, i));
  }, t.previousLabel = function(i) {
    return i === void 0 && (i = this._time), kM(this, br(this, i), 1);
  }, t.currentLabel = function(i) {
    return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + rn);
  }, t.shiftChildren = function(i, r, o) {
    o === void 0 && (o = 0);
    for (var a = this._first, l = this.labels, h; a; )
      a._start >= o && (a._start += i, a._end += i), a = a._next;
    if (r)
      for (h in l)
        l[h] >= o && (l[h] += i);
    return ba(this);
  }, t.invalidate = function(i) {
    var r = this._first;
    for (this._lock = 0; r; )
      r.invalidate(i), r = r._next;
    return s.prototype.invalidate.call(this, i);
  }, t.clear = function(i) {
    i === void 0 && (i = !0);
    for (var r = this._first, o; r; )
      o = r._next, this.remove(r), r = o;
    return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), ba(this);
  }, t.totalDuration = function(i) {
    var r = 0, o = this, a = o._last, l = Ir, h, f, d;
    if (arguments.length)
      return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -i : i));
    if (o._dirty) {
      for (d = o.parent; a; )
        h = a._prev, a._dirty && a.totalDuration(), f = a._start, f > l && o._sort && a._ts && !o._lock ? (o._lock = 1, cs(o, a, f - a._delay, 1)._lock = 0) : l = f, f < 0 && a._ts && (r -= f, (!d && !o._dp || d && d.smoothChildTiming) && (o._start += f / o._ts, o._time -= f, o._tTime -= f), o.shiftChildren(-f, !1, -1 / 0), l = 0), a._end > r && a._ts && (r = a._end), a = h;
      dc(o, o === mn && o._time > r ? o._time : r, 1, 1), o._dirty = 0;
    }
    return o._tDur;
  }, e.updateRoot = function(i) {
    if (mn._ts && (iT(mn, Zd(i, mn)), tT = lr.frame), lr.frame >= FM) {
      FM += dr.autoSleep || 120;
      var r = mn._first;
      if ((!r || !r._ts) && dr.autoSleep && lr._listeners.length < 2) {
        for (; r && !r._ts; )
          r = r._next;
        r || lr.sleep();
      }
    }
  }, e;
}($u);
gr(Fi.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});
var p3 = function(e, t, n, i, r, o, a) {
  var l = new Yi(this._pt, e, t, 0, 1, PT, null, r), h = 0, f = 0, d, p, m, _, x, y, v, S;
  for (l.b = n, l.e = i, n += "", i += "", (v = ~i.indexOf("random(")) && (i = Zu(i)), o && (S = [n, i], o(S, e, t), n = S[0], i = S[1]), p = n.match(Yg) || []; d = Yg.exec(i); )
    _ = d[0], x = i.substring(h, d.index), m ? m = (m + 1) % 5 : x.substr(-5) === "rgba(" && (m = 1), _ !== p[f++] && (y = parseFloat(p[f - 1]) || 0, l._pt = {
      _next: l._pt,
      p: x || f === 1 ? x : ",",
      //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
      s: y,
      c: _.charAt(1) === "=" ? ql(y, _) - y : parseFloat(_) - y,
      m: m && m < 4 ? Math.round : 0
    }, h = Yg.lastIndex);
  return l.c = h < i.length ? i.substring(h, i.length) : "", l.fp = a, (Q1.test(i) || v) && (l.e = 0), this._pt = l, l;
}, Pv = function(e, t, n, i, r, o, a, l, h, f) {
  Tn(i) && (i = i(r || 0, e, o));
  var d = e[t], p = n !== "get" ? n : Tn(d) ? h ? e[t.indexOf("set") || !Tn(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](h) : e[t]() : d, m = Tn(d) ? h ? y3 : RT : Lv, _;
  if (ti(i) && (~i.indexOf("random(") && (i = Zu(i)), i.charAt(1) === "=" && (_ = ql(p, i) + (_i(p) || 0), (_ || _ === 0) && (i = _))), !f || p !== i || c0)
    return !isNaN(p * i) && i !== "" ? (_ = new Yi(this._pt, e, t, +p || 0, i - (p || 0), typeof d == "boolean" ? A3 : BT, 0, m), h && (_.fp = h), a && _.modifier(a, this, e), this._pt = _) : (!d && !(t in e) && wv(t, i), p3.call(this, e, t, p, i, m, l || dr.stringFilter, h));
}, m3 = function(e, t, n, i, r) {
  if (Tn(e) && (e = Su(e, r, t, n, i)), !xs(e) || e.style && e.nodeType || Ai(e) || K1(e))
    return ti(e) ? Su(e, r, t, n, i) : e;
  var o = {}, a;
  for (a in e)
    o[a] = Su(e[a], r, t, n, i);
  return o;
}, wT = function(e, t, n, i, r, o) {
  var a, l, h, f;
  if (sr[e] && (a = new sr[e]()).init(r, a.rawVars ? t[e] : m3(t[e], i, r, o, n), n, i, o) !== !1 && (n._pt = l = new Yi(n._pt, r, e, 0, 1, a.render, a, 0, a.priority), n !== Wl))
    for (h = n._ptLookup[n._targets.indexOf(r)], f = a._props.length; f--; )
      h[a._props[f]] = l;
  return a;
}, _o, c0, Iv = function s(e, t, n) {
  var i = e.vars, r = i.ease, o = i.startAt, a = i.immediateRender, l = i.lazy, h = i.onUpdate, f = i.runBackwards, d = i.yoyoEase, p = i.keyframes, m = i.autoRevert, _ = e._dur, x = e._startAt, y = e._targets, v = e.parent, S = v && v.data === "nested" ? v.vars.targets : y, M = e._overwrite === "auto" && !Mv, T = e.timeline, P, b, R, U, C, B, G, W, se, z, q, j, ee;
  if (T && (!p || !r) && (r = "none"), e._ease = Ra(r, uc.ease), e._yEase = d ? MT(Ra(d === !0 ? r : d, uc.ease)) : 0, d && e._yoyo && !e._repeat && (d = e._yEase, e._yEase = e._ease, e._ease = d), e._from = !T && !!i.runBackwards, !T || p && !i.stagger) {
    if (W = y[0] ? Ca(y[0]).harness : 0, j = W && i[W.prop], P = Qd(i, Cv), x && (x._zTime < 0 && x.progress(1), t < 0 && f && a && !m ? x.render(-1, !0) : x.revert(f && _ ? Pd : VF), x._lazy = 0), o) {
      if (Lo(e._startAt = On.set(y, gr({
        data: "isStart",
        overwrite: !1,
        parent: v,
        immediateRender: !0,
        lazy: !x && Xi(l),
        startAt: null,
        delay: 0,
        onUpdate: h && function() {
          return hr(e, "onUpdate");
        },
        stagger: 0
      }, o))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (ai || !a && !m) && e._startAt.revert(Pd), a && _ && t <= 0 && n <= 0) {
        t && (e._zTime = t);
        return;
      }
    } else if (f && _ && !x) {
      if (t && (a = !1), R = gr({
        overwrite: !1,
        data: "isFromStart",
        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        lazy: a && !x && Xi(l),
        immediateRender: a,
        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        stagger: 0,
        parent: v
        //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
      }, P), j && (R[W.prop] = j), Lo(e._startAt = On.set(y, R)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (ai ? e._startAt.revert(Pd) : e._startAt.render(-1, !0)), e._zTime = t, !a)
        s(e._startAt, rn, rn);
      else if (!t)
        return;
    }
    for (e._pt = e._ptCache = 0, l = _ && Xi(l) || l && !_, b = 0; b < y.length; b++) {
      if (C = y[b], G = C._gsap || Rv(y)[b]._gsap, e._ptLookup[b] = z = {}, i0[G.id] && wo.length && qd(), q = S === y ? b : S.indexOf(C), W && (se = new W()).init(C, j || P, e, q, S) !== !1 && (e._pt = U = new Yi(e._pt, C, se.name, 0, 1, se.render, se, 0, se.priority), se._props.forEach(function(N) {
        z[N] = U;
      }), se.priority && (B = 1)), !W || j)
        for (R in P)
          sr[R] && (se = wT(R, P, e, q, C, S)) ? se.priority && (B = 1) : z[R] = U = Pv.call(e, C, R, "get", P[R], q, S, 0, i.stringFilter);
      e._op && e._op[b] && e.kill(C, e._op[b]), M && e._pt && (_o = e, mn.killTweensOf(C, z, e.globalTime(t)), ee = !e.parent, _o = 0), e._pt && l && (i0[G.id] = 1);
    }
    B && IT(e), e._onInit && e._onInit(e);
  }
  e._onUpdate = h, e._initted = (!e._op || e._pt) && !ee, p && t <= 0 && T.render(Ir, !0, !0);
}, g3 = function(e, t, n, i, r, o, a, l) {
  var h = (e._pt && e._ptCache || (e._ptCache = {}))[t], f, d, p, m;
  if (!h)
    for (h = e._ptCache[t] = [], p = e._ptLookup, m = e._targets.length; m--; ) {
      if (f = p[m][t], f && f.d && f.d._pt)
        for (f = f.d._pt; f && f.p !== t && f.fp !== t; )
          f = f._next;
      if (!f)
        return c0 = 1, e.vars[t] = "+=0", Iv(e, a), c0 = 0, l ? qu(t + " not eligible for reset") : 1;
      h.push(f);
    }
  for (m = h.length; m--; )
    d = h[m], f = d._pt || d, f.s = (i || i === 0) && !r ? i : f.s + (i || 0) + o * f.c, f.c = n - f.s, d.e && (d.e = Bn(n) + _i(d.e)), d.b && (d.b = f.s + _i(d.b));
}, _3 = function(e, t) {
  var n = e[0] ? Ca(e[0]).harness : 0, i = n && n.aliases, r, o, a, l;
  if (!i)
    return t;
  r = hc({}, t);
  for (o in i)
    if (o in r)
      for (l = i[o].split(","), a = l.length; a--; )
        r[l[a]] = r[o];
  return r;
}, v3 = function(e, t, n, i) {
  var r = t.ease || i || "power1.inOut", o, a;
  if (Ai(t))
    a = n[e] || (n[e] = []), t.forEach(function(l, h) {
      return a.push({
        t: h / (t.length - 1) * 100,
        v: l,
        e: r
      });
    });
  else
    for (o in t)
      a = n[o] || (n[o] = []), o === "ease" || a.push({
        t: parseFloat(e),
        v: t[o],
        e: r
      });
}, Su = function(e, t, n, i, r) {
  return Tn(e) ? e.call(t, n, i, r) : ti(e) && ~e.indexOf("random(") ? Zu(e) : e;
}, CT = bv + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", bT = {};
Ji(CT + ",id,stagger,delay,duration,paused,scrollTrigger", function(s) {
  return bT[s] = 1;
});
var On = /* @__PURE__ */ function(s) {
  J1(e, s);
  function e(n, i, r, o) {
    var a;
    typeof i == "number" && (r.duration = i, i = r, r = null), a = s.call(this, o ? i : Au(i)) || this;
    var l = a.vars, h = l.duration, f = l.delay, d = l.immediateRender, p = l.stagger, m = l.overwrite, _ = l.keyframes, x = l.defaults, y = l.scrollTrigger, v = l.yoyoEase, S = i.parent || mn, M = (Ai(n) || K1(n) ? Ys(n[0]) : "length" in i) ? [n] : Lr(n), T, P, b, R, U, C, B, G;
    if (a._targets = M.length ? Rv(M) : qu("GSAP target " + n + " not found. https://gsap.com", !dr.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = m, _ || p || ud(h) || ud(f)) {
      if (i = a.vars, T = a.timeline = new Fi({
        data: "nested",
        defaults: x || {},
        targets: S && S.data === "nested" ? S.vars.targets : M
      }), T.kill(), T.parent = T._dp = Ds(a), T._start = 0, p || ud(h) || ud(f)) {
        if (R = M.length, B = p && fT(p), xs(p))
          for (U in p)
            ~CT.indexOf(U) && (G || (G = {}), G[U] = p[U]);
        for (P = 0; P < R; P++)
          b = Qd(i, bT), b.stagger = 0, v && (b.yoyoEase = v), G && hc(b, G), C = M[P], b.duration = +Su(h, Ds(a), P, C, M), b.delay = (+Su(f, Ds(a), P, C, M) || 0) - a._delay, !p && R === 1 && b.delay && (a._delay = f = b.delay, a._start += f, b.delay = 0), T.to(C, b, B ? B(P, C, M) : 0), T._ease = Gt.none;
        T.duration() ? h = f = 0 : a.timeline = 0;
      } else if (_) {
        Au(gr(T.vars.defaults, {
          ease: "none"
        })), T._ease = Ra(_.ease || i.ease || "none");
        var W = 0, se, z, q;
        if (Ai(_))
          _.forEach(function(j) {
            return T.to(M, j, ">");
          }), T.duration();
        else {
          b = {};
          for (U in _)
            U === "ease" || U === "easeEach" || v3(U, _[U], b, _.easeEach);
          for (U in b)
            for (se = b[U].sort(function(j, ee) {
              return j.t - ee.t;
            }), W = 0, P = 0; P < se.length; P++)
              z = se[P], q = {
                ease: z.e,
                duration: (z.t - (P ? se[P - 1].t : 0)) / 100 * h
              }, q[U] = z.v, T.to(M, q, W), W += q.duration;
          T.duration() < h && T.to({}, {
            duration: h - T.duration()
          });
        }
      }
      h || a.duration(h = T.duration());
    } else
      a.timeline = 0;
    return m === !0 && !Mv && (_o = Ds(a), mn.killTweensOf(M), _o = 0), cs(S, Ds(a), r), i.reversed && a.reverse(), i.paused && a.paused(!0), (d || !h && !_ && a._start === Nn(S._time) && Xi(d) && qF(Ds(a)) && S.data !== "nested") && (a._tTime = -rn, a.render(Math.max(0, -f) || 0)), y && lT(Ds(a), y), a;
  }
  var t = e.prototype;
  return t.render = function(i, r, o) {
    var a = this._time, l = this._tDur, h = this._dur, f = i < 0, d = i > l - rn && !f ? l : i < rn ? 0 : i, p, m, _, x, y, v, S, M, T;
    if (!h)
      ZF(this, i, r, o);
    else if (d !== this._tTime || !i || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== f || this._lazy) {
      if (p = d, M = this.timeline, this._repeat) {
        if (x = h + this._rDelay, this._repeat < -1 && f)
          return this.totalTime(x * 100 + i, r, o);
        if (p = Nn(d % x), d === l ? (_ = this._repeat, p = h) : (y = Nn(d / x), _ = ~~y, _ && _ === y ? (p = h, _--) : p > h && (p = h)), v = this._yoyo && _ & 1, v && (T = this._yEase, p = h - p), y = fc(this._tTime, x), p === a && !o && this._initted && _ === y)
          return this._tTime = d, this;
        _ !== y && (M && this._yEase && ST(M, v), this.vars.repeatRefresh && !v && !this._lock && p !== x && this._initted && (this._lock = o = 1, this.render(Nn(x * _), !0).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (cT(this, f ? i : p, o, r, d))
          return this._tTime = 0, this;
        if (a !== this._time && !(o && this.vars.repeatRefresh && _ !== y))
          return this;
        if (h !== this._dur)
          return this.render(i, r, o);
      }
      if (this._tTime = d, this._time = p, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = S = (T || this._ease)(p / h), this._from && (this.ratio = S = 1 - S), !a && d && !r && !y && (hr(this, "onStart"), this._tTime !== d))
        return this;
      for (m = this._pt; m; )
        m.r(S, m.d), m = m._next;
      M && M.render(i < 0 ? i : M._dur * M._ease(p / this._dur), r, o) || this._startAt && (this._zTime = i), this._onUpdate && !r && (f && r0(this, i, r, o), hr(this, "onUpdate")), this._repeat && _ !== y && this.vars.onRepeat && !r && this.parent && hr(this, "onRepeat"), (d === this._tDur || !d) && this._tTime === d && (f && !this._onUpdate && r0(this, i, !0, !0), (i || !h) && (d === this._tDur && this._ts > 0 || !d && this._ts < 0) && Lo(this, 1), !r && !(f && !a) && (d || a || v) && (hr(this, d === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(d < l && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, t.targets = function() {
    return this._targets;
  }, t.invalidate = function(i) {
    return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), s.prototype.invalidate.call(this, i);
  }, t.resetTo = function(i, r, o, a, l) {
    ju || lr.wake(), this._ts || this.play();
    var h = Math.min(this._dur, (this._dp._time - this._start) * this._ts), f;
    return this._initted || Iv(this, h), f = this._ease(h / this._dur), g3(this, i, r, o, a, f, h, l) ? this.resetTo(i, r, o, a, 1) : (Up(this, 0), this.parent || oT(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, t.kill = function(i, r) {
    if (r === void 0 && (r = "all"), !i && (!r || r === "all"))
      return this._lazy = this._pt = 0, this.parent ? lu(this) : this.scrollTrigger && this.scrollTrigger.kill(!!ai), this;
    if (this.timeline) {
      var o = this.timeline.totalDuration();
      return this.timeline.killTweensOf(i, r, _o && _o.vars.overwrite !== !0)._first || lu(this), this.parent && o !== this.timeline.totalDuration() && dc(this, this._dur * this.timeline._tDur / o, 0, 1), this;
    }
    var a = this._targets, l = i ? Lr(i) : a, h = this._ptLookup, f = this._pt, d, p, m, _, x, y, v;
    if ((!r || r === "all") && YF(a, l))
      return r === "all" && (this._pt = 0), lu(this);
    for (d = this._op = this._op || [], r !== "all" && (ti(r) && (x = {}, Ji(r, function(S) {
      return x[S] = 1;
    }), r = x), r = _3(a, r)), v = a.length; v--; )
      if (~l.indexOf(a[v])) {
        p = h[v], r === "all" ? (d[v] = r, _ = p, m = {}) : (m = d[v] = d[v] || {}, _ = r);
        for (x in _)
          y = p && p[x], y && ((!("kill" in y.d) || y.d.kill(x) === !0) && Dp(this, y, "_pt"), delete p[x]), m !== "all" && (m[x] = 1);
      }
    return this._initted && !this._pt && f && lu(this), this;
  }, e.to = function(i, r) {
    return new e(i, r, arguments[2]);
  }, e.from = function(i, r) {
    return Mu(1, arguments);
  }, e.delayedCall = function(i, r, o, a) {
    return new e(r, 0, {
      immediateRender: !1,
      lazy: !1,
      overwrite: !1,
      delay: i,
      onComplete: r,
      onReverseComplete: r,
      onCompleteParams: o,
      onReverseCompleteParams: o,
      callbackScope: a
    });
  }, e.fromTo = function(i, r, o) {
    return Mu(2, arguments);
  }, e.set = function(i, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(i, r);
  }, e.killTweensOf = function(i, r, o) {
    return mn.killTweensOf(i, r, o);
  }, e;
}($u);
gr(On.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
});
Ji("staggerTo,staggerFrom,staggerFromTo", function(s) {
  On[s] = function() {
    var e = new Fi(), t = o0.call(arguments, 0);
    return t.splice(s === "staggerFromTo" ? 5 : 4, 0, 0), e[s].apply(e, t);
  };
});
var Lv = function(e, t, n) {
  return e[t] = n;
}, RT = function(e, t, n) {
  return e[t](n);
}, y3 = function(e, t, n, i) {
  return e[t](i.fp, n);
}, x3 = function(e, t, n) {
  return e.setAttribute(t, n);
}, Dv = function(e, t) {
  return Tn(e[t]) ? RT : Sv(e[t]) && e.setAttribute ? x3 : Lv;
}, BT = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
}, A3 = function(e, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * e), t);
}, PT = function(e, t) {
  var n = t._pt, i = "";
  if (!e && t.b)
    i = t.b;
  else if (e === 1 && t.e)
    i = t.e;
  else {
    for (; n; )
      i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i, n = n._next;
    i += t.c;
  }
  t.set(t.t, t.p, i, t);
}, Fv = function(e, t) {
  for (var n = t._pt; n; )
    n.r(e, n.d), n = n._next;
}, M3 = function(e, t, n, i) {
  for (var r = this._pt, o; r; )
    o = r._next, r.p === i && r.modifier(e, t, n), r = o;
}, S3 = function(e) {
  for (var t = this._pt, n, i; t; )
    i = t._next, t.p === e && !t.op || t.op === e ? Dp(this, t, "_pt") : t.dep || (n = 1), t = i;
  return !n;
}, E3 = function(e, t, n, i) {
  i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
}, IT = function(e) {
  for (var t = e._pt, n, i, r, o; t; ) {
    for (n = t._next, i = r; i && i.pr > t.pr; )
      i = i._next;
    (t._prev = i ? i._prev : o) ? t._prev._next = t : r = t, (t._next = i) ? i._prev = t : o = t, t = n;
  }
  e._pt = r;
}, Yi = /* @__PURE__ */ function() {
  function s(t, n, i, r, o, a, l, h, f) {
    this.t = n, this.s = r, this.c = o, this.p = i, this.r = a || BT, this.d = l || this, this.set = h || Lv, this.pr = f || 0, this._next = t, t && (t._prev = this);
  }
  var e = s.prototype;
  return e.modifier = function(n, i, r) {
    this.mSet = this.mSet || this.set, this.set = E3, this.m = n, this.mt = r, this.tween = i;
  }, s;
}();
Ji(bv + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(s) {
  return Cv[s] = 1;
});
mr.TweenMax = mr.TweenLite = On;
mr.TimelineLite = mr.TimelineMax = Fi;
mn = new Fi({
  sortChildren: !1,
  defaults: uc,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0
});
dr.stringFilter = AT;
var Ba = [], Ld = {}, T3 = [], HM = 0, w3 = 0, jg = function(e) {
  return (Ld[e] || T3).map(function(t) {
    return t();
  });
}, u0 = function() {
  var e = Date.now(), t = [];
  e - HM > 2 && (jg("matchMediaInit"), Ba.forEach(function(n) {
    var i = n.queries, r = n.conditions, o, a, l, h;
    for (a in i)
      o = as.matchMedia(i[a]).matches, o && (l = 1), o !== r[a] && (r[a] = o, h = 1);
    h && (n.revert(), l && t.push(n));
  }), jg("matchMediaRevert"), t.forEach(function(n) {
    return n.onMatch(n, function(i) {
      return n.add(null, i);
    });
  }), HM = e, jg("matchMedia"));
}, LT = /* @__PURE__ */ function() {
  function s(t, n) {
    this.selector = n && a0(n), this.data = [], this._r = [], this.isReverted = !1, this.id = w3++, t && this.add(t);
  }
  var e = s.prototype;
  return e.add = function(n, i, r) {
    Tn(n) && (r = i, i = n, n = Tn);
    var o = this, a = function() {
      var h = fn, f = o.selector, d;
      return h && h !== o && h.data.push(o), r && (o.selector = a0(r)), fn = o, d = i.apply(o, arguments), Tn(d) && o._r.push(d), fn = h, o.selector = f, o.isReverted = !1, d;
    };
    return o.last = a, n === Tn ? a(o, function(l) {
      return o.add(null, l);
    }) : n ? o[n] = a : a;
  }, e.ignore = function(n) {
    var i = fn;
    fn = null, n(this), fn = i;
  }, e.getTweens = function() {
    var n = [];
    return this.data.forEach(function(i) {
      return i instanceof s ? n.push.apply(n, i.getTweens()) : i instanceof On && !(i.parent && i.parent.data === "nested") && n.push(i);
    }), n;
  }, e.clear = function() {
    this._r.length = this.data.length = 0;
  }, e.kill = function(n, i) {
    var r = this;
    if (n ? function() {
      for (var a = r.getTweens(), l = r.data.length, h; l--; )
        h = r.data[l], h.data === "isFlip" && (h.revert(), h.getChildren(!0, !0, !1).forEach(function(f) {
          return a.splice(a.indexOf(f), 1);
        }));
      for (a.map(function(f) {
        return {
          g: f._dur || f._delay || f._sat && !f._sat.vars.immediateRender ? f.globalTime(0) : -1 / 0,
          t: f
        };
      }).sort(function(f, d) {
        return d.g - f.g || -1 / 0;
      }).forEach(function(f) {
        return f.t.revert(n);
      }), l = r.data.length; l--; )
        h = r.data[l], h instanceof Fi ? h.data !== "nested" && (h.scrollTrigger && h.scrollTrigger.revert(), h.kill()) : !(h instanceof On) && h.revert && h.revert(n);
      r._r.forEach(function(f) {
        return f(n, r);
      }), r.isReverted = !0;
    }() : this.data.forEach(function(a) {
      return a.kill && a.kill();
    }), this.clear(), i)
      for (var o = Ba.length; o--; )
        Ba[o].id === this.id && Ba.splice(o, 1);
  }, e.revert = function(n) {
    this.kill(n || {});
  }, s;
}(), C3 = /* @__PURE__ */ function() {
  function s(t) {
    this.contexts = [], this.scope = t, fn && fn.data.push(this);
  }
  var e = s.prototype;
  return e.add = function(n, i, r) {
    xs(n) || (n = {
      matches: n
    });
    var o = new LT(0, r || this.scope), a = o.conditions = {}, l, h, f;
    fn && !o.selector && (o.selector = fn.selector), this.contexts.push(o), i = o.add("onMatch", i), o.queries = n;
    for (h in n)
      h === "all" ? f = 1 : (l = as.matchMedia(n[h]), l && (Ba.indexOf(o) < 0 && Ba.push(o), (a[h] = l.matches) && (f = 1), l.addListener ? l.addListener(u0) : l.addEventListener("change", u0)));
    return f && i(o, function(d) {
      return o.add(null, d);
    }), this;
  }, e.revert = function(n) {
    this.kill(n || {});
  }, e.kill = function(n) {
    this.contexts.forEach(function(i) {
      return i.kill(n, !0);
    });
  }, s;
}(), jd = {
  registerPlugin: function() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    t.forEach(function(i) {
      return vT(i);
    });
  },
  timeline: function(e) {
    return new Fi(e);
  },
  getTweensOf: function(e, t) {
    return mn.getTweensOf(e, t);
  },
  getProperty: function(e, t, n, i) {
    ti(e) && (e = Lr(e)[0]);
    var r = Ca(e || {}).get, o = n ? sT : rT;
    return n === "native" && (n = ""), e && (t ? o((sr[t] && sr[t].get || r)(e, t, n, i)) : function(a, l, h) {
      return o((sr[a] && sr[a].get || r)(e, a, l, h));
    });
  },
  quickSetter: function(e, t, n) {
    if (e = Lr(e), e.length > 1) {
      var i = e.map(function(f) {
        return qi.quickSetter(f, t, n);
      }), r = i.length;
      return function(f) {
        for (var d = r; d--; )
          i[d](f);
      };
    }
    e = e[0] || {};
    var o = sr[t], a = Ca(e), l = a.harness && (a.harness.aliases || {})[t] || t, h = o ? function(f) {
      var d = new o();
      Wl._pt = 0, d.init(e, n ? f + n : f, Wl, 0, [e]), d.render(1, d), Wl._pt && Fv(1, Wl);
    } : a.set(e, l);
    return o ? h : function(f) {
      return h(e, l, n ? f + n : f, a, 1);
    };
  },
  quickTo: function(e, t, n) {
    var i, r = qi.to(e, gr((i = {}, i[t] = "+=0.1", i.paused = !0, i.stagger = 0, i), n || {})), o = function(l, h, f) {
      return r.resetTo(t, l, h, f);
    };
    return o.tween = r, o;
  },
  isTweening: function(e) {
    return mn.getTweensOf(e, !0).length > 0;
  },
  defaults: function(e) {
    return e && e.ease && (e.ease = Ra(e.ease, uc.ease)), UM(uc, e || {});
  },
  config: function(e) {
    return UM(dr, e || {});
  },
  registerEffect: function(e) {
    var t = e.name, n = e.effect, i = e.plugins, r = e.defaults, o = e.extendTimeline;
    (i || "").split(",").forEach(function(a) {
      return a && !sr[a] && !mr[a] && qu(t + " effect requires " + a + " plugin.");
    }), Kg[t] = function(a, l, h) {
      return n(Lr(a), gr(l || {}, r), h);
    }, o && (Fi.prototype[t] = function(a, l, h) {
      return this.add(Kg[t](a, xs(l) ? l : (h = l) && {}, this), h);
    });
  },
  registerEase: function(e, t) {
    Gt[e] = Ra(t);
  },
  parseEase: function(e, t) {
    return arguments.length ? Ra(e, t) : Gt;
  },
  getById: function(e) {
    return mn.getById(e);
  },
  exportRoot: function(e, t) {
    e === void 0 && (e = {});
    var n = new Fi(e), i, r;
    for (n.smoothChildTiming = Xi(e.smoothChildTiming), mn.remove(n), n._dp = 0, n._time = n._tTime = mn._time, i = mn._first; i; )
      r = i._next, (t || !(!i._dur && i instanceof On && i.vars.onComplete === i._targets[0])) && cs(n, i, i._start - i._delay), i = r;
    return cs(mn, n, 0), n;
  },
  context: function(e, t) {
    return e ? new LT(e, t) : fn;
  },
  matchMedia: function(e) {
    return new C3(e);
  },
  matchMediaRefresh: function() {
    return Ba.forEach(function(e) {
      var t = e.conditions, n, i;
      for (i in t)
        t[i] && (t[i] = !1, n = 1);
      n && e.revert();
    }) || u0();
  },
  addEventListener: function(e, t) {
    var n = Ld[e] || (Ld[e] = []);
    ~n.indexOf(t) || n.push(t);
  },
  removeEventListener: function(e, t) {
    var n = Ld[e], i = n && n.indexOf(t);
    i >= 0 && n.splice(i, 1);
  },
  utils: {
    wrap: s3,
    wrapYoyo: o3,
    distribute: fT,
    random: pT,
    snap: dT,
    normalize: r3,
    getUnit: _i,
    clamp: e3,
    splitColor: yT,
    toArray: Lr,
    selector: a0,
    mapRange: gT,
    pipe: n3,
    unitize: i3,
    interpolate: a3,
    shuffle: hT
  },
  install: $1,
  effects: Kg,
  ticker: lr,
  updateRoot: Fi.updateRoot,
  plugins: sr,
  globalTimeline: mn,
  core: {
    PropTween: Yi,
    globals: eT,
    Tween: On,
    Timeline: Fi,
    Animation: $u,
    getCache: Ca,
    _removeLinkedListItem: Dp,
    reverting: function() {
      return ai;
    },
    context: function(e) {
      return e && fn && (fn.data.push(e), e._ctx = fn), fn;
    },
    suppressOverwrites: function(e) {
      return Mv = e;
    }
  }
};
Ji("to,from,fromTo,delayedCall,set,killTweensOf", function(s) {
  return jd[s] = On[s];
});
lr.add(Fi.updateRoot);
Wl = jd.to({}, {
  duration: 0
});
var b3 = function(e, t) {
  for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
    n = n._next;
  return n;
}, R3 = function(e, t) {
  var n = e._targets, i, r, o;
  for (i in t)
    for (r = n.length; r--; )
      o = e._ptLookup[r][i], o && (o = o.d) && (o._pt && (o = b3(o, i)), o && o.modifier && o.modifier(t[i], e, n[r], i));
}, $g = function(e, t) {
  return {
    name: e,
    headless: 1,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function(i, r, o) {
      o._onInit = function(a) {
        var l, h;
        if (ti(r) && (l = {}, Ji(r, function(f) {
          return l[f] = 1;
        }), r = l), t) {
          l = {};
          for (h in r)
            l[h] = t(r[h]);
          r = l;
        }
        R3(a, r);
      };
    }
  };
}, qi = jd.registerPlugin({
  name: "attr",
  init: function(e, t, n, i, r) {
    var o, a, l;
    this.tween = n;
    for (o in t)
      l = e.getAttribute(o) || "", a = this.add(e, "setAttribute", (l || 0) + "", t[o], i, r, 0, 0, o), a.op = o, a.b = l, this._props.push(o);
  },
  render: function(e, t) {
    for (var n = t._pt; n; )
      ai ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next;
  }
}, {
  name: "endArray",
  headless: 1,
  init: function(e, t) {
    for (var n = t.length; n--; )
      this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
  }
}, $g("roundProps", l0), $g("modifiers"), $g("snap", dT)) || jd;
On.version = Fi.version = qi.version = "3.13.0";
j1 = 1;
Ev() && pc();
Gt.Power0;
Gt.Power1;
Gt.Power2;
Gt.Power3;
Gt.Power4;
Gt.Linear;
Gt.Quad;
Gt.Cubic;
Gt.Quart;
Gt.Quint;
Gt.Strong;
Gt.Elastic;
Gt.Back;
Gt.SteppedEase;
Gt.Bounce;
Gt.Sine;
Gt.Expo;
Gt.Circ;
/*!
 * CSSPlugin 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var zM, vo, Ql, Uv, xa, VM, Ov, B3 = function() {
  return typeof window < "u";
}, Ks = {}, ua = 180 / Math.PI, Zl = Math.PI / 180, Pl = Math.atan2, WM = 1e8, Nv = /([A-Z])/g, P3 = /(left|right|width|margin|padding|x)/i, I3 = /[\s,\(]\S/, us = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
}, h0 = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, L3 = function(e, t) {
  return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, D3 = function(e, t) {
  return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
}, F3 = function(e, t) {
  var n = t.s + t.c * e;
  t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
}, DT = function(e, t) {
  return t.set(t.t, t.p, e ? t.e : t.b, t);
}, FT = function(e, t) {
  return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
}, U3 = function(e, t, n) {
  return e.style[t] = n;
}, O3 = function(e, t, n) {
  return e.style.setProperty(t, n);
}, N3 = function(e, t, n) {
  return e._gsap[t] = n;
}, k3 = function(e, t, n) {
  return e._gsap.scaleX = e._gsap.scaleY = n;
}, G3 = function(e, t, n, i, r) {
  var o = e._gsap;
  o.scaleX = o.scaleY = n, o.renderTransform(r, o);
}, H3 = function(e, t, n, i, r) {
  var o = e._gsap;
  o[t] = n, o.renderTransform(r, o);
}, vn = "transform", Ki = vn + "Origin", z3 = function s(e, t) {
  var n = this, i = this.target, r = i.style, o = i._gsap;
  if (e in Ks && r) {
    if (this.tfm = this.tfm || {}, e !== "transform")
      e = us[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(a) {
        return n.tfm[a] = Fs(i, a);
      }) : this.tfm[e] = o.x ? o[e] : Fs(i, e), e === Ki && (this.tfm.zOrigin = o.zOrigin);
    else
      return us.transform.split(",").forEach(function(a) {
        return s.call(n, a, t);
      });
    if (this.props.indexOf(vn) >= 0)
      return;
    o.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(Ki, t, "")), e = vn;
  }
  (r || t) && this.props.push(e, t, r[e]);
}, UT = function(e) {
  e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"));
}, V3 = function() {
  var e = this.props, t = this.target, n = t.style, i = t._gsap, r, o;
  for (r = 0; r < e.length; r += 3)
    e[r + 1] ? e[r + 1] === 2 ? t[e[r]](e[r + 2]) : t[e[r]] = e[r + 2] : e[r + 2] ? n[e[r]] = e[r + 2] : n.removeProperty(e[r].substr(0, 2) === "--" ? e[r] : e[r].replace(Nv, "-$1").toLowerCase());
  if (this.tfm) {
    for (o in this.tfm)
      i[o] = this.tfm[o];
    i.svg && (i.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), r = Ov(), (!r || !r.isStart) && !n[vn] && (UT(n), i.zOrigin && n[Ki] && (n[Ki] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1);
  }
}, OT = function(e, t) {
  var n = {
    target: e,
    props: [],
    revert: V3,
    save: z3
  };
  return e._gsap || qi.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function(i) {
    return n.save(i);
  }), n;
}, NT, f0 = function(e, t) {
  var n = vo.createElementNS ? vo.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : vo.createElement(e);
  return n && n.style ? n : vo.createElement(e);
}, Dr = function s(e, t, n) {
  var i = getComputedStyle(e);
  return i[t] || i.getPropertyValue(t.replace(Nv, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && s(e, mc(t) || t, 1) || "";
}, XM = "O,Moz,ms,Ms,Webkit".split(","), mc = function(e, t, n) {
  var i = t || xa, r = i.style, o = 5;
  if (e in r && !n)
    return e;
  for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(XM[o] + e in r); )
    ;
  return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? XM[o] : "") + e;
}, d0 = function() {
  B3() && window.document && (zM = window, vo = zM.document, Ql = vo.documentElement, xa = f0("div") || {
    style: {}
  }, f0("div"), vn = mc(vn), Ki = vn + "Origin", xa.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", NT = !!mc("perspective"), Ov = qi.core.reverting, Uv = 1);
}, JM = function(e) {
  var t = e.ownerSVGElement, n = f0("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = e.cloneNode(!0), r;
  i.style.display = "block", n.appendChild(i), Ql.appendChild(n);
  try {
    r = i.getBBox();
  } catch {
  }
  return n.removeChild(i), Ql.removeChild(n), r;
}, YM = function(e, t) {
  for (var n = t.length; n--; )
    if (e.hasAttribute(t[n]))
      return e.getAttribute(t[n]);
}, kT = function(e) {
  var t, n;
  try {
    t = e.getBBox();
  } catch {
    t = JM(e), n = 1;
  }
  return t && (t.width || t.height) || n || (t = JM(e)), t && !t.width && !t.x && !t.y ? {
    x: +YM(e, ["x", "cx", "x1"]) || 0,
    y: +YM(e, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : t;
}, GT = function(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && kT(e));
}, Ga = function(e, t) {
  if (t) {
    var n = e.style, i;
    t in Ks && t !== Ki && (t = vn), n.removeProperty ? (i = t.substr(0, 2), (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(i === "--" ? t : t.replace(Nv, "-$1").toLowerCase())) : n.removeAttribute(t);
  }
}, yo = function(e, t, n, i, r, o) {
  var a = new Yi(e._pt, t, n, 0, 1, o ? FT : DT);
  return e._pt = a, a.b = i, a.e = r, e._props.push(n), a;
}, KM = {
  deg: 1,
  rad: 1,
  turn: 1
}, W3 = {
  grid: 1,
  flex: 1
}, Do = function s(e, t, n, i) {
  var r = parseFloat(n) || 0, o = (n + "").trim().substr((r + "").length) || "px", a = xa.style, l = P3.test(t), h = e.tagName.toLowerCase() === "svg", f = (h ? "client" : "offset") + (l ? "Width" : "Height"), d = 100, p = i === "px", m = i === "%", _, x, y, v;
  if (i === o || !r || KM[i] || KM[o])
    return r;
  if (o !== "px" && !p && (r = s(e, t, n, "px")), v = e.getCTM && GT(e), (m || o === "%") && (Ks[t] || ~t.indexOf("adius")))
    return _ = v ? e.getBBox()[l ? "width" : "height"] : e[f], Bn(m ? r / _ * d : r / 100 * _);
  if (a[l ? "width" : "height"] = d + (p ? o : i), x = i !== "rem" && ~t.indexOf("adius") || i === "em" && e.appendChild && !h ? e : e.parentNode, v && (x = (e.ownerSVGElement || {}).parentNode), (!x || x === vo || !x.appendChild) && (x = vo.body), y = x._gsap, y && m && y.width && l && y.time === lr.time && !y.uncache)
    return Bn(r / y.width * d);
  if (m && (t === "height" || t === "width")) {
    var S = e.style[t];
    e.style[t] = d + i, _ = e[f], S ? e.style[t] = S : Ga(e, t);
  } else
    (m || o === "%") && !W3[Dr(x, "display")] && (a.position = Dr(e, "position")), x === e && (a.position = "static"), x.appendChild(xa), _ = xa[f], x.removeChild(xa), a.position = "absolute";
  return l && m && (y = Ca(x), y.time = lr.time, y.width = x[f]), Bn(p ? _ * r / d : _ && r ? d / _ * r : 0);
}, Fs = function(e, t, n, i) {
  var r;
  return Uv || d0(), t in us && t !== "transform" && (t = us[t], ~t.indexOf(",") && (t = t.split(",")[0])), Ks[t] && t !== "transform" ? (r = th(e, i), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : ep(Dr(e, Ki)) + " " + r.zOrigin + "px") : (r = e.style[t], (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) && (r = $d[t] && $d[t](e, t, n) || Dr(e, t) || nT(e, t) || (t === "opacity" ? 1 : 0))), n && !~(r + "").trim().indexOf(" ") ? Do(e, t, r, n) + n : r;
}, X3 = function(e, t, n, i) {
  if (!n || n === "none") {
    var r = mc(t, e, 1), o = r && Dr(e, r, 1);
    o && o !== n ? (t = r, n = o) : t === "borderColor" && (n = Dr(e, "borderTopColor"));
  }
  var a = new Yi(this._pt, e.style, t, 0, 1, PT), l = 0, h = 0, f, d, p, m, _, x, y, v, S, M, T, P;
  if (a.b = n, a.e = i, n += "", i += "", i.substring(0, 6) === "var(--" && (i = Dr(e, i.substring(4, i.indexOf(")")))), i === "auto" && (x = e.style[t], e.style[t] = i, i = Dr(e, t) || i, x ? e.style[t] = x : Ga(e, t)), f = [n, i], AT(f), n = f[0], i = f[1], p = n.match(Vl) || [], P = i.match(Vl) || [], P.length) {
    for (; d = Vl.exec(i); )
      y = d[0], S = i.substring(l, d.index), _ ? _ = (_ + 1) % 5 : (S.substr(-5) === "rgba(" || S.substr(-5) === "hsla(") && (_ = 1), y !== (x = p[h++] || "") && (m = parseFloat(x) || 0, T = x.substr((m + "").length), y.charAt(1) === "=" && (y = ql(m, y) + T), v = parseFloat(y), M = y.substr((v + "").length), l = Vl.lastIndex - M.length, M || (M = M || dr.units[t] || T, l === i.length && (i += M, a.e += M)), T !== M && (m = Do(e, t, x, M) || 0), a._pt = {
        _next: a._pt,
        p: S || h === 1 ? S : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: m,
        c: v - m,
        m: _ && _ < 4 || t === "zIndex" ? Math.round : 0
      });
    a.c = l < i.length ? i.substring(l, i.length) : "";
  } else
    a.r = t === "display" && i === "none" ? FT : DT;
  return Q1.test(i) && (a.e = 0), this._pt = a, a;
}, qM = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
}, J3 = function(e) {
  var t = e.split(" "), n = t[0], i = t[1] || "50%";
  return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n, n = i, i = e), t[0] = qM[n] || n, t[1] = qM[i] || i, t.join(" ");
}, Y3 = function(e, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var n = t.t, i = n.style, r = t.u, o = n._gsap, a, l, h;
    if (r === "all" || r === !0)
      i.cssText = "", l = 1;
    else
      for (r = r.split(","), h = r.length; --h > -1; )
        a = r[h], Ks[a] && (l = 1, a = a === "transformOrigin" ? Ki : vn), Ga(n, a);
    l && (Ga(n, vn), o && (o.svg && n.removeAttribute("transform"), i.scale = i.rotate = i.translate = "none", th(n, 1), o.uncache = 1, UT(i)));
  }
}, $d = {
  clearProps: function(e, t, n, i, r) {
    if (r.data !== "isFromStart") {
      var o = e._pt = new Yi(e._pt, t, n, 0, 0, Y3);
      return o.u = i, o.pr = -10, o.tween = r, e._props.push(n), 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */
}, eh = [1, 0, 0, 1, 0, 0], HT = {}, zT = function(e) {
  return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
}, QM = function(e) {
  var t = Dr(e, vn);
  return zT(t) ? eh : t.substr(7).match(q1).map(Bn);
}, kv = function(e, t) {
  var n = e._gsap || Ca(e), i = e.style, r = QM(e), o, a, l, h;
  return n.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, r = [l.a, l.b, l.c, l.d, l.e, l.f], r.join(",") === "1,0,0,1,0,0" ? eh : r) : (r === eh && !e.offsetParent && e !== Ql && !n.svg && (l = i.display, i.display = "block", o = e.parentNode, (!o || !e.offsetParent && !e.getBoundingClientRect().width) && (h = 1, a = e.nextElementSibling, Ql.appendChild(e)), r = QM(e), l ? i.display = l : Ga(e, "display"), h && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Ql.removeChild(e))), t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
}, p0 = function(e, t, n, i, r, o) {
  var a = e._gsap, l = r || kv(e, !0), h = a.xOrigin || 0, f = a.yOrigin || 0, d = a.xOffset || 0, p = a.yOffset || 0, m = l[0], _ = l[1], x = l[2], y = l[3], v = l[4], S = l[5], M = t.split(" "), T = parseFloat(M[0]) || 0, P = parseFloat(M[1]) || 0, b, R, U, C;
  n ? l !== eh && (R = m * y - _ * x) && (U = T * (y / R) + P * (-x / R) + (x * S - y * v) / R, C = T * (-_ / R) + P * (m / R) - (m * S - _ * v) / R, T = U, P = C) : (b = kT(e), T = b.x + (~M[0].indexOf("%") ? T / 100 * b.width : T), P = b.y + (~(M[1] || M[0]).indexOf("%") ? P / 100 * b.height : P)), i || i !== !1 && a.smooth ? (v = T - h, S = P - f, a.xOffset = d + (v * m + S * x) - v, a.yOffset = p + (v * _ + S * y) - S) : a.xOffset = a.yOffset = 0, a.xOrigin = T, a.yOrigin = P, a.smooth = !!i, a.origin = t, a.originIsAbsolute = !!n, e.style[Ki] = "0px 0px", o && (yo(o, a, "xOrigin", h, T), yo(o, a, "yOrigin", f, P), yo(o, a, "xOffset", d, a.xOffset), yo(o, a, "yOffset", p, a.yOffset)), e.setAttribute("data-svg-origin", T + " " + P);
}, th = function(e, t) {
  var n = e._gsap || new TT(e);
  if ("x" in n && !t && !n.uncache)
    return n;
  var i = e.style, r = n.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(e), h = Dr(e, Ki) || "0", f, d, p, m, _, x, y, v, S, M, T, P, b, R, U, C, B, G, W, se, z, q, j, ee, N, V, I, D, J, K, ie, he;
  return f = d = p = x = y = v = S = M = T = 0, m = _ = 1, n.svg = !!(e.getCTM && GT(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (i[vn] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[vn] !== "none" ? l[vn] : "")), i.scale = i.rotate = i.translate = "none"), R = kv(e, n.svg), n.svg && (n.uncache ? (N = e.getBBox(), h = n.xOrigin - N.x + "px " + (n.yOrigin - N.y) + "px", ee = "") : ee = !t && e.getAttribute("data-svg-origin"), p0(e, ee || h, !!ee || n.originIsAbsolute, n.smooth !== !1, R)), P = n.xOrigin || 0, b = n.yOrigin || 0, R !== eh && (G = R[0], W = R[1], se = R[2], z = R[3], f = q = R[4], d = j = R[5], R.length === 6 ? (m = Math.sqrt(G * G + W * W), _ = Math.sqrt(z * z + se * se), x = G || W ? Pl(W, G) * ua : 0, S = se || z ? Pl(se, z) * ua + x : 0, S && (_ *= Math.abs(Math.cos(S * Zl))), n.svg && (f -= P - (P * G + b * se), d -= b - (P * W + b * z))) : (he = R[6], K = R[7], I = R[8], D = R[9], J = R[10], ie = R[11], f = R[12], d = R[13], p = R[14], U = Pl(he, J), y = U * ua, U && (C = Math.cos(-U), B = Math.sin(-U), ee = q * C + I * B, N = j * C + D * B, V = he * C + J * B, I = q * -B + I * C, D = j * -B + D * C, J = he * -B + J * C, ie = K * -B + ie * C, q = ee, j = N, he = V), U = Pl(-se, J), v = U * ua, U && (C = Math.cos(-U), B = Math.sin(-U), ee = G * C - I * B, N = W * C - D * B, V = se * C - J * B, ie = z * B + ie * C, G = ee, W = N, se = V), U = Pl(W, G), x = U * ua, U && (C = Math.cos(U), B = Math.sin(U), ee = G * C + W * B, N = q * C + j * B, W = W * C - G * B, j = j * C - q * B, G = ee, q = N), y && Math.abs(y) + Math.abs(x) > 359.9 && (y = x = 0, v = 180 - v), m = Bn(Math.sqrt(G * G + W * W + se * se)), _ = Bn(Math.sqrt(j * j + he * he)), U = Pl(q, j), S = Math.abs(U) > 2e-4 ? U * ua : 0, T = ie ? 1 / (ie < 0 ? -ie : ie) : 0), n.svg && (ee = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !zT(Dr(e, vn)), ee && e.setAttribute("transform", ee))), Math.abs(S) > 90 && Math.abs(S) < 270 && (r ? (m *= -1, S += x <= 0 ? 180 : -180, x += x <= 0 ? 180 : -180) : (_ *= -1, S += S <= 0 ? 180 : -180)), t = t || n.uncache, n.x = f - ((n.xPercent = f && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-f) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + o, n.y = d - ((n.yPercent = d && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-d) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + o, n.z = p + o, n.scaleX = Bn(m), n.scaleY = Bn(_), n.rotation = Bn(x) + a, n.rotationX = Bn(y) + a, n.rotationY = Bn(v) + a, n.skewX = S + a, n.skewY = M + a, n.transformPerspective = T + o, (n.zOrigin = parseFloat(h.split(" ")[2]) || !t && n.zOrigin || 0) && (i[Ki] = ep(h)), n.xOffset = n.yOffset = 0, n.force3D = dr.force3D, n.renderTransform = n.svg ? q3 : NT ? VT : K3, n.uncache = 0, n;
}, ep = function(e) {
  return (e = e.split(" "))[0] + " " + e[1];
}, e_ = function(e, t, n) {
  var i = _i(t);
  return Bn(parseFloat(t) + parseFloat(Do(e, "x", n + "px", i))) + i;
}, K3 = function(e, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, VT(e, t);
}, oa = "0deg", ru = "0px", aa = ") ", VT = function(e, t) {
  var n = t || this, i = n.xPercent, r = n.yPercent, o = n.x, a = n.y, l = n.z, h = n.rotation, f = n.rotationY, d = n.rotationX, p = n.skewX, m = n.skewY, _ = n.scaleX, x = n.scaleY, y = n.transformPerspective, v = n.force3D, S = n.target, M = n.zOrigin, T = "", P = v === "auto" && e && e !== 1 || v === !0;
  if (M && (d !== oa || f !== oa)) {
    var b = parseFloat(f) * Zl, R = Math.sin(b), U = Math.cos(b), C;
    b = parseFloat(d) * Zl, C = Math.cos(b), o = e_(S, o, R * C * -M), a = e_(S, a, -Math.sin(b) * -M), l = e_(S, l, U * C * -M + M);
  }
  y !== ru && (T += "perspective(" + y + aa), (i || r) && (T += "translate(" + i + "%, " + r + "%) "), (P || o !== ru || a !== ru || l !== ru) && (T += l !== ru || P ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + aa), h !== oa && (T += "rotate(" + h + aa), f !== oa && (T += "rotateY(" + f + aa), d !== oa && (T += "rotateX(" + d + aa), (p !== oa || m !== oa) && (T += "skew(" + p + ", " + m + aa), (_ !== 1 || x !== 1) && (T += "scale(" + _ + ", " + x + aa), S.style[vn] = T || "translate(0, 0)";
}, q3 = function(e, t) {
  var n = t || this, i = n.xPercent, r = n.yPercent, o = n.x, a = n.y, l = n.rotation, h = n.skewX, f = n.skewY, d = n.scaleX, p = n.scaleY, m = n.target, _ = n.xOrigin, x = n.yOrigin, y = n.xOffset, v = n.yOffset, S = n.forceCSS, M = parseFloat(o), T = parseFloat(a), P, b, R, U, C;
  l = parseFloat(l), h = parseFloat(h), f = parseFloat(f), f && (f = parseFloat(f), h += f, l += f), l || h ? (l *= Zl, h *= Zl, P = Math.cos(l) * d, b = Math.sin(l) * d, R = Math.sin(l - h) * -p, U = Math.cos(l - h) * p, h && (f *= Zl, C = Math.tan(h - f), C = Math.sqrt(1 + C * C), R *= C, U *= C, f && (C = Math.tan(f), C = Math.sqrt(1 + C * C), P *= C, b *= C)), P = Bn(P), b = Bn(b), R = Bn(R), U = Bn(U)) : (P = d, U = p, b = R = 0), (M && !~(o + "").indexOf("px") || T && !~(a + "").indexOf("px")) && (M = Do(m, "x", o, "px"), T = Do(m, "y", a, "px")), (_ || x || y || v) && (M = Bn(M + _ - (_ * P + x * R) + y), T = Bn(T + x - (_ * b + x * U) + v)), (i || r) && (C = m.getBBox(), M = Bn(M + i / 100 * C.width), T = Bn(T + r / 100 * C.height)), C = "matrix(" + P + "," + b + "," + R + "," + U + "," + M + "," + T + ")", m.setAttribute("transform", C), S && (m.style[vn] = C);
}, Q3 = function(e, t, n, i, r) {
  var o = 360, a = ti(r), l = parseFloat(r) * (a && ~r.indexOf("rad") ? ua : 1), h = l - i, f = i + h + "deg", d, p;
  return a && (d = r.split("_")[1], d === "short" && (h %= o, h !== h % (o / 2) && (h += h < 0 ? o : -o)), d === "cw" && h < 0 ? h = (h + o * WM) % o - ~~(h / o) * o : d === "ccw" && h > 0 && (h = (h - o * WM) % o - ~~(h / o) * o)), e._pt = p = new Yi(e._pt, t, n, i, h, L3), p.e = f, p.u = "deg", e._props.push(n), p;
}, ZM = function(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}, Z3 = function(e, t, n) {
  var i = ZM({}, n._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", o = n.style, a, l, h, f, d, p, m, _;
  i.svg ? (h = n.getAttribute("transform"), n.setAttribute("transform", ""), o[vn] = t, a = th(n, 1), Ga(n, vn), n.setAttribute("transform", h)) : (h = getComputedStyle(n)[vn], o[vn] = t, a = th(n, 1), o[vn] = h);
  for (l in Ks)
    h = i[l], f = a[l], h !== f && r.indexOf(l) < 0 && (m = _i(h), _ = _i(f), d = m !== _ ? Do(n, l, h, _) : parseFloat(h), p = parseFloat(f), e._pt = new Yi(e._pt, a, l, d, p - d, h0), e._pt.u = _ || 0, e._props.push(l));
  ZM(a, i);
};
Ji("padding,margin,Width,Radius", function(s, e) {
  var t = "Top", n = "Right", i = "Bottom", r = "Left", o = (e < 3 ? [t, n, i, r] : [t + r, t + n, i + n, i + r]).map(function(a) {
    return e < 2 ? s + a : "border" + a + s;
  });
  $d[e > 1 ? "border" + s : s] = function(a, l, h, f, d) {
    var p, m;
    if (arguments.length < 4)
      return p = o.map(function(_) {
        return Fs(a, _, h);
      }), m = p.join(" "), m.split(p[0]).length === 5 ? p[0] : m;
    p = (f + "").split(" "), m = {}, o.forEach(function(_, x) {
      return m[_] = p[x] = p[x] || p[(x - 1) / 2 | 0];
    }), a.init(l, m, d);
  };
});
var WT = {
  name: "css",
  register: d0,
  targetTest: function(e) {
    return e.style && e.nodeType;
  },
  init: function(e, t, n, i, r) {
    var o = this._props, a = e.style, l = n.vars.startAt, h, f, d, p, m, _, x, y, v, S, M, T, P, b, R, U;
    Uv || d0(), this.styles = this.styles || OT(e), U = this.styles.props, this.tween = n;
    for (x in t)
      if (x !== "autoRound" && (f = t[x], !(sr[x] && wT(x, t, n, i, e, r)))) {
        if (m = typeof f, _ = $d[x], m === "function" && (f = f.call(n, i, e, r), m = typeof f), m === "string" && ~f.indexOf("random(") && (f = Zu(f)), _)
          _(this, e, x, f, n) && (R = 1);
        else if (x.substr(0, 2) === "--")
          h = (getComputedStyle(e).getPropertyValue(x) + "").trim(), f += "", Co.lastIndex = 0, Co.test(h) || (y = _i(h), v = _i(f)), v ? y !== v && (h = Do(e, x, h, v) + v) : y && (f += y), this.add(a, "setProperty", h, f, i, r, 0, 0, x), o.push(x), U.push(x, 0, a[x]);
        else if (m !== "undefined") {
          if (l && x in l ? (h = typeof l[x] == "function" ? l[x].call(n, i, e, r) : l[x], ti(h) && ~h.indexOf("random(") && (h = Zu(h)), _i(h + "") || h === "auto" || (h += dr.units[x] || _i(Fs(e, x)) || ""), (h + "").charAt(1) === "=" && (h = Fs(e, x))) : h = Fs(e, x), p = parseFloat(h), S = m === "string" && f.charAt(1) === "=" && f.substr(0, 2), S && (f = f.substr(2)), d = parseFloat(f), x in us && (x === "autoAlpha" && (p === 1 && Fs(e, "visibility") === "hidden" && d && (p = 0), U.push("visibility", 0, a.visibility), yo(this, a, "visibility", p ? "inherit" : "hidden", d ? "inherit" : "hidden", !d)), x !== "scale" && x !== "transform" && (x = us[x], ~x.indexOf(",") && (x = x.split(",")[0]))), M = x in Ks, M) {
            if (this.styles.save(x), m === "string" && f.substring(0, 6) === "var(--" && (f = Dr(e, f.substring(4, f.indexOf(")"))), d = parseFloat(f)), T || (P = e._gsap, P.renderTransform && !t.parseTransform || th(e, t.parseTransform), b = t.smoothOrigin !== !1 && P.smooth, T = this._pt = new Yi(this._pt, a, vn, 0, 1, P.renderTransform, P, 0, -1), T.dep = 1), x === "scale")
              this._pt = new Yi(this._pt, P, "scaleY", P.scaleY, (S ? ql(P.scaleY, S + d) : d) - P.scaleY || 0, h0), this._pt.u = 0, o.push("scaleY", x), x += "X";
            else if (x === "transformOrigin") {
              U.push(Ki, 0, a[Ki]), f = J3(f), P.svg ? p0(e, f, 0, b, 0, this) : (v = parseFloat(f.split(" ")[2]) || 0, v !== P.zOrigin && yo(this, P, "zOrigin", P.zOrigin, v), yo(this, a, x, ep(h), ep(f)));
              continue;
            } else if (x === "svgOrigin") {
              p0(e, f, 1, b, 0, this);
              continue;
            } else if (x in HT) {
              Q3(this, P, x, p, S ? ql(p, S + f) : f);
              continue;
            } else if (x === "smoothOrigin") {
              yo(this, P, "smooth", P.smooth, f);
              continue;
            } else if (x === "force3D") {
              P[x] = f;
              continue;
            } else if (x === "transform") {
              Z3(this, f, e);
              continue;
            }
          } else x in a || (x = mc(x) || x);
          if (M || (d || d === 0) && (p || p === 0) && !I3.test(f) && x in a)
            y = (h + "").substr((p + "").length), d || (d = 0), v = _i(f) || (x in dr.units ? dr.units[x] : y), y !== v && (p = Do(e, x, h, v)), this._pt = new Yi(this._pt, M ? P : a, x, p, (S ? ql(p, S + d) : d) - p, !M && (v === "px" || x === "zIndex") && t.autoRound !== !1 ? F3 : h0), this._pt.u = v || 0, y !== v && v !== "%" && (this._pt.b = h, this._pt.r = D3);
          else if (x in a)
            X3.call(this, e, x, h, S ? S + f : f);
          else if (x in e)
            this.add(e, x, h || e[x], S ? S + f : f, i, r);
          else if (x !== "parseTransform") {
            wv(x, f);
            continue;
          }
          M || (x in a ? U.push(x, 0, a[x]) : typeof e[x] == "function" ? U.push(x, 2, e[x]()) : U.push(x, 1, h || e[x])), o.push(x);
        }
      }
    R && IT(this);
  },
  render: function(e, t) {
    if (t.tween._time || !Ov())
      for (var n = t._pt; n; )
        n.r(e, n.d), n = n._next;
    else
      t.styles.revert();
  },
  get: Fs,
  aliases: us,
  getSetter: function(e, t, n) {
    var i = us[t];
    return i && i.indexOf(",") < 0 && (t = i), t in Ks && t !== Ki && (e._gsap.x || Fs(e, "x")) ? n && VM === n ? t === "scale" ? k3 : N3 : (VM = n || {}) && (t === "scale" ? G3 : H3) : e.style && !Sv(e.style[t]) ? U3 : ~t.indexOf("-") ? O3 : Dv(e, t);
  },
  core: {
    _removeProperty: Ga,
    _getMatrix: kv
  }
};
qi.utils.checkPrefix = mc;
qi.core.getStyleSaver = OT;
(function(s, e, t, n) {
  var i = Ji(s + "," + e + "," + t, function(r) {
    Ks[r] = 1;
  });
  Ji(e, function(r) {
    dr.units[r] = "deg", HT[r] = 1;
  }), us[i[13]] = s + "," + e, Ji(n, function(r) {
    var o = r.split(":");
    us[o[1]] = i[o[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Ji("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(s) {
  dr.units[s] = "px";
});
qi.registerPlugin(WT);
var jl = qi.registerPlugin(WT) || qi;
jl.core.Tween;
function j3(s, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(s, n.key, n);
  }
}
function $3(s, e, t) {
  return e && j3(s.prototype, e), s;
}
/*!
 * Observer 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var si, Dd, cr, xo, Ao, $l, XT, ha, Eu, JT, Hs, zr, YT, KT = function() {
  return si || typeof window < "u" && (si = window.gsap) && si.registerPlugin && si;
}, qT = 1, Xl = [], Ft = [], ms = [], Tu = Date.now, m0 = function(e, t) {
  return t;
}, eU = function() {
  var e = Eu.core, t = e.bridge || {}, n = e._scrollers, i = e._proxies;
  n.push.apply(n, Ft), i.push.apply(i, ms), Ft = n, ms = i, m0 = function(o, a) {
    return t[o](a);
  };
}, bo = function(e, t) {
  return ~ms.indexOf(e) && ms[ms.indexOf(e) + 1][t];
}, wu = function(e) {
  return !!~JT.indexOf(e);
}, Ri = function(e, t, n, i, r) {
  return e.addEventListener(t, n, {
    passive: i !== !1,
    capture: !!r
  });
}, bi = function(e, t, n, i) {
  return e.removeEventListener(t, n, !!i);
}, hd = "scrollLeft", fd = "scrollTop", g0 = function() {
  return Hs && Hs.isPressed || Ft.cache++;
}, tp = function(e, t) {
  var n = function i(r) {
    if (r || r === 0) {
      qT && (cr.history.scrollRestoration = "manual");
      var o = Hs && Hs.isPressed;
      r = i.v = Math.round(r) || (Hs && Hs.iOS ? 1 : 0), e(r), i.cacheID = Ft.cache, o && m0("ss", r);
    } else (t || Ft.cache !== i.cacheID || m0("ref")) && (i.cacheID = Ft.cache, i.v = e());
    return i.v + i.offset;
  };
  return n.offset = 0, e && n;
}, Ui = {
  s: hd,
  p: "left",
  p2: "Left",
  os: "right",
  os2: "Right",
  d: "width",
  d2: "Width",
  a: "x",
  sc: tp(function(s) {
    return arguments.length ? cr.scrollTo(s, zn.sc()) : cr.pageXOffset || xo[hd] || Ao[hd] || $l[hd] || 0;
  })
}, zn = {
  s: fd,
  p: "top",
  p2: "Top",
  os: "bottom",
  os2: "Bottom",
  d: "height",
  d2: "Height",
  a: "y",
  op: Ui,
  sc: tp(function(s) {
    return arguments.length ? cr.scrollTo(Ui.sc(), s) : cr.pageYOffset || xo[fd] || Ao[fd] || $l[fd] || 0;
  })
}, zi = function(e, t) {
  return (t && t._ctx && t._ctx.selector || si.utils.toArray)(e)[0] || (typeof e == "string" && si.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null);
}, tU = function(e, t) {
  for (var n = t.length; n--; )
    if (t[n] === e || t[n].contains(e))
      return !0;
  return !1;
}, Fo = function(e, t) {
  var n = t.s, i = t.sc;
  wu(e) && (e = xo.scrollingElement || Ao);
  var r = Ft.indexOf(e), o = i === zn.sc ? 1 : 2;
  !~r && (r = Ft.push(e) - 1), Ft[r + o] || Ri(e, "scroll", g0);
  var a = Ft[r + o], l = a || (Ft[r + o] = tp(bo(e, n), !0) || (wu(e) ? i : tp(function(h) {
    return arguments.length ? e[n] = h : e[n];
  })));
  return l.target = e, a || (l.smooth = si.getProperty(e, "scrollBehavior") === "smooth"), l;
}, _0 = function(e, t, n) {
  var i = e, r = e, o = Tu(), a = o, l = t || 50, h = Math.max(500, l * 3), f = function(_, x) {
    var y = Tu();
    x || y - o > l ? (r = i, i = _, a = o, o = y) : n ? i += _ : i = r + (_ - r) / (y - a) * (o - a);
  }, d = function() {
    r = i = n ? 0 : i, a = o = 0;
  }, p = function(_) {
    var x = a, y = r, v = Tu();
    return (_ || _ === 0) && _ !== i && f(_), o === a || v - a > h ? 0 : (i + (n ? y : -y)) / ((n ? v : o) - x) * 1e3;
  };
  return {
    update: f,
    reset: d,
    getVelocity: p
  };
}, su = function(e, t) {
  return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e;
}, jM = function(e) {
  var t = Math.max.apply(Math, e), n = Math.min.apply(Math, e);
  return Math.abs(t) >= Math.abs(n) ? t : n;
}, QT = function() {
  Eu = si.core.globals().ScrollTrigger, Eu && Eu.core && eU();
}, ZT = function(e) {
  return si = e || KT(), !Dd && si && typeof document < "u" && document.body && (cr = window, xo = document, Ao = xo.documentElement, $l = xo.body, JT = [cr, xo, Ao, $l], si.utils.clamp, YT = si.core.context || function() {
  }, ha = "onpointerenter" in $l ? "pointer" : "mouse", XT = In.isTouch = cr.matchMedia && cr.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in cr || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, zr = In.eventTypes = ("ontouchstart" in Ao ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Ao ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
    return qT = 0;
  }, 500), QT(), Dd = 1), Dd;
};
Ui.op = zn;
Ft.cache = 0;
var In = /* @__PURE__ */ function() {
  function s(t) {
    this.init(t);
  }
  var e = s.prototype;
  return e.init = function(n) {
    Dd || ZT(si) || console.warn("Please gsap.registerPlugin(Observer)"), Eu || QT();
    var i = n.tolerance, r = n.dragMinimum, o = n.type, a = n.target, l = n.lineHeight, h = n.debounce, f = n.preventDefault, d = n.onStop, p = n.onStopDelay, m = n.ignore, _ = n.wheelSpeed, x = n.event, y = n.onDragStart, v = n.onDragEnd, S = n.onDrag, M = n.onPress, T = n.onRelease, P = n.onRight, b = n.onLeft, R = n.onUp, U = n.onDown, C = n.onChangeX, B = n.onChangeY, G = n.onChange, W = n.onToggleX, se = n.onToggleY, z = n.onHover, q = n.onHoverEnd, j = n.onMove, ee = n.ignoreCheck, N = n.isNormalizer, V = n.onGestureStart, I = n.onGestureEnd, D = n.onWheel, J = n.onEnable, K = n.onDisable, ie = n.onClick, he = n.scrollSpeed, ge = n.capture, me = n.allowClicks, Be = n.lockAxis, Pe = n.onLockAxis;
    this.target = a = zi(a) || Ao, this.vars = n, m && (m = si.utils.toArray(m)), i = i || 1e-9, r = r || 0, _ = _ || 1, he = he || 1, o = o || "wheel,touch,pointer", h = h !== !1, l || (l = parseFloat(cr.getComputedStyle($l).lineHeight) || 22);
    var De, ze, X, pe, ce, Me, fe, Q = this, Ie = 0, O = 0, L = n.passive || !f && n.passive !== !1, $ = Fo(a, Ui), xe = Fo(a, zn), Ae = $(), _e = xe(), Ue = ~o.indexOf("touch") && !~o.indexOf("pointer") && zr[0] === "pointerdown", Le = wu(a), Te = a.ownerDocument || xo, Ze = [0, 0, 0], ct = [0, 0, 0], ye = 0, bt = function() {
      return ye = Tu();
    }, et = function(We, tt) {
      return (Q.event = We) && m && tU(We.target, m) || tt && Ue && We.pointerType !== "touch" || ee && ee(We, tt);
    }, mt = function() {
      Q._vx.reset(), Q._vy.reset(), ze.pause(), d && d(Q);
    }, je = function() {
      var We = Q.deltaX = jM(Ze), tt = Q.deltaY = jM(ct), Se = Math.abs(We) >= i, ut = Math.abs(tt) >= i;
      G && (Se || ut) && G(Q, We, tt, Ze, ct), Se && (P && Q.deltaX > 0 && P(Q), b && Q.deltaX < 0 && b(Q), C && C(Q), W && Q.deltaX < 0 != Ie < 0 && W(Q), Ie = Q.deltaX, Ze[0] = Ze[1] = Ze[2] = 0), ut && (U && Q.deltaY > 0 && U(Q), R && Q.deltaY < 0 && R(Q), B && B(Q), se && Q.deltaY < 0 != O < 0 && se(Q), O = Q.deltaY, ct[0] = ct[1] = ct[2] = 0), (pe || X) && (j && j(Q), X && (y && X === 1 && y(Q), S && S(Q), X = 0), pe = !1), Me && !(Me = !1) && Pe && Pe(Q), ce && (D(Q), ce = !1), De = 0;
    }, Ve = function(We, tt, Se) {
      Ze[Se] += We, ct[Se] += tt, Q._vx.update(We), Q._vy.update(tt), h ? De || (De = requestAnimationFrame(je)) : je();
    }, gt = function(We, tt) {
      Be && !fe && (Q.axis = fe = Math.abs(We) > Math.abs(tt) ? "x" : "y", Me = !0), fe !== "y" && (Ze[2] += We, Q._vx.update(We, !0)), fe !== "x" && (ct[2] += tt, Q._vy.update(tt, !0)), h ? De || (De = requestAnimationFrame(je)) : je();
    }, St = function(We) {
      if (!et(We, 1)) {
        We = su(We, f);
        var tt = We.clientX, Se = We.clientY, ut = tt - Q.x, rt = Se - Q.y, _t = Q.isDragging;
        Q.x = tt, Q.y = Se, (_t || (ut || rt) && (Math.abs(Q.startX - tt) >= r || Math.abs(Q.startY - Se) >= r)) && (X = _t ? 2 : 1, _t || (Q.isDragging = !0), gt(ut, rt));
      }
    }, Wt = Q.onPress = function(Qe) {
      et(Qe, 1) || Qe && Qe.button || (Q.axis = fe = null, ze.pause(), Q.isPressed = !0, Qe = su(Qe), Ie = O = 0, Q.startX = Q.x = Qe.clientX, Q.startY = Q.y = Qe.clientY, Q._vx.reset(), Q._vy.reset(), Ri(N ? a : Te, zr[1], St, L, !0), Q.deltaX = Q.deltaY = 0, M && M(Q));
    }, Oe = Q.onRelease = function(Qe) {
      if (!et(Qe, 1)) {
        bi(N ? a : Te, zr[1], St, !0);
        var We = !isNaN(Q.y - Q.startY), tt = Q.isDragging, Se = tt && (Math.abs(Q.x - Q.startX) > 3 || Math.abs(Q.y - Q.startY) > 3), ut = su(Qe);
        !Se && We && (Q._vx.reset(), Q._vy.reset(), f && me && si.delayedCall(0.08, function() {
          if (Tu() - ye > 300 && !Qe.defaultPrevented) {
            if (Qe.target.click)
              Qe.target.click();
            else if (Te.createEvent) {
              var rt = Te.createEvent("MouseEvents");
              rt.initMouseEvent("click", !0, !0, cr, 1, ut.screenX, ut.screenY, ut.clientX, ut.clientY, !1, !1, !1, !1, 0, null), Qe.target.dispatchEvent(rt);
            }
          }
        })), Q.isDragging = Q.isGesturing = Q.isPressed = !1, d && tt && !N && ze.restart(!0), X && je(), v && tt && v(Q), T && T(Q, Se);
      }
    }, Ee = function(We) {
      return We.touches && We.touches.length > 1 && (Q.isGesturing = !0) && V(We, Q.isDragging);
    }, Y = function() {
      return (Q.isGesturing = !1) || I(Q);
    }, Ce = function(We) {
      if (!et(We)) {
        var tt = $(), Se = xe();
        Ve((tt - Ae) * he, (Se - _e) * he, 1), Ae = tt, _e = Se, d && ze.restart(!0);
      }
    }, be = function(We) {
      if (!et(We)) {
        We = su(We, f), D && (ce = !0);
        var tt = (We.deltaMode === 1 ? l : We.deltaMode === 2 ? cr.innerHeight : 1) * _;
        Ve(We.deltaX * tt, We.deltaY * tt, 0), d && !N && ze.restart(!0);
      }
    }, ot = function(We) {
      if (!et(We)) {
        var tt = We.clientX, Se = We.clientY, ut = tt - Q.x, rt = Se - Q.y;
        Q.x = tt, Q.y = Se, pe = !0, d && ze.restart(!0), (ut || rt) && gt(ut, rt);
      }
    }, it = function(We) {
      Q.event = We, z(Q);
    }, It = function(We) {
      Q.event = We, q(Q);
    }, kt = function(We) {
      return et(We) || su(We, f) && ie(Q);
    };
    ze = Q._dc = si.delayedCall(p || 0.25, mt).pause(), Q.deltaX = Q.deltaY = 0, Q._vx = _0(0, 50, !0), Q._vy = _0(0, 50, !0), Q.scrollX = $, Q.scrollY = xe, Q.isDragging = Q.isGesturing = Q.isPressed = !1, YT(this), Q.enable = function(Qe) {
      return Q.isEnabled || (Ri(Le ? Te : a, "scroll", g0), o.indexOf("scroll") >= 0 && Ri(Le ? Te : a, "scroll", Ce, L, ge), o.indexOf("wheel") >= 0 && Ri(a, "wheel", be, L, ge), (o.indexOf("touch") >= 0 && XT || o.indexOf("pointer") >= 0) && (Ri(a, zr[0], Wt, L, ge), Ri(Te, zr[2], Oe), Ri(Te, zr[3], Oe), me && Ri(a, "click", bt, !0, !0), ie && Ri(a, "click", kt), V && Ri(Te, "gesturestart", Ee), I && Ri(Te, "gestureend", Y), z && Ri(a, ha + "enter", it), q && Ri(a, ha + "leave", It), j && Ri(a, ha + "move", ot)), Q.isEnabled = !0, Q.isDragging = Q.isGesturing = Q.isPressed = pe = X = !1, Q._vx.reset(), Q._vy.reset(), Ae = $(), _e = xe(), Qe && Qe.type && Wt(Qe), J && J(Q)), Q;
    }, Q.disable = function() {
      Q.isEnabled && (Xl.filter(function(Qe) {
        return Qe !== Q && wu(Qe.target);
      }).length || bi(Le ? Te : a, "scroll", g0), Q.isPressed && (Q._vx.reset(), Q._vy.reset(), bi(N ? a : Te, zr[1], St, !0)), bi(Le ? Te : a, "scroll", Ce, ge), bi(a, "wheel", be, ge), bi(a, zr[0], Wt, ge), bi(Te, zr[2], Oe), bi(Te, zr[3], Oe), bi(a, "click", bt, !0), bi(a, "click", kt), bi(Te, "gesturestart", Ee), bi(Te, "gestureend", Y), bi(a, ha + "enter", it), bi(a, ha + "leave", It), bi(a, ha + "move", ot), Q.isEnabled = Q.isPressed = Q.isDragging = !1, K && K(Q));
    }, Q.kill = Q.revert = function() {
      Q.disable();
      var Qe = Xl.indexOf(Q);
      Qe >= 0 && Xl.splice(Qe, 1), Hs === Q && (Hs = 0);
    }, Xl.push(Q), N && wu(a) && (Hs = Q), Q.enable(x);
  }, $3(s, [{
    key: "velocityX",
    get: function() {
      return this._vx.getVelocity();
    }
  }, {
    key: "velocityY",
    get: function() {
      return this._vy.getVelocity();
    }
  }]), s;
}();
In.version = "3.13.0";
In.create = function(s) {
  return new In(s);
};
In.register = ZT;
In.getAll = function() {
  return Xl.slice();
};
In.getById = function(s) {
  return Xl.filter(function(e) {
    return e.vars.id === s;
  })[0];
};
KT() && si.registerPlugin(In);
/*!
 * ScrollTrigger 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
*/
var qe, Ul, Dt, an, or, qt, Gv, np, nh, Cu, uu, dd, mi, Op, v0, Ii, $M, eS, Ol, jT, t_, $T, Pi, y0, ew, tw, po, x0, Hv, ec, zv, ip, A0, n_, pd = 1, gi = Date.now, i_ = gi(), Fr = 0, hu = 0, tS = function(e, t, n) {
  var i = rr(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
  return n["_" + t + "Clamp"] = i, i ? e.substr(6, e.length - 7) : e;
}, nS = function(e, t) {
  return t && (!rr(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e;
}, nU = function s() {
  return hu && requestAnimationFrame(s);
}, iS = function() {
  return Op = 1;
}, rS = function() {
  return Op = 0;
}, ls = function(e) {
  return e;
}, fu = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, nw = function() {
  return typeof window < "u";
}, iw = function() {
  return qe || nw() && (qe = window.gsap) && qe.registerPlugin && qe;
}, Ha = function(e) {
  return !!~Gv.indexOf(e);
}, rw = function(e) {
  return (e === "Height" ? zv : Dt["inner" + e]) || or["client" + e] || qt["client" + e];
}, sw = function(e) {
  return bo(e, "getBoundingClientRect") || (Ha(e) ? function() {
    return kd.width = Dt.innerWidth, kd.height = zv, kd;
  } : function() {
    return Os(e);
  });
}, iU = function(e, t, n) {
  var i = n.d, r = n.d2, o = n.a;
  return (o = bo(e, "getBoundingClientRect")) ? function() {
    return o()[i];
  } : function() {
    return (t ? rw(r) : e["client" + r]) || 0;
  };
}, rU = function(e, t) {
  return !t || ~ms.indexOf(e) ? sw(e) : function() {
    return kd;
  };
}, hs = function(e, t) {
  var n = t.s, i = t.d2, r = t.d, o = t.a;
  return Math.max(0, (n = "scroll" + i) && (o = bo(e, n)) ? o() - sw(e)()[r] : Ha(e) ? (or[n] || qt[n]) - rw(i) : e[n] - e["offset" + i]);
}, md = function(e, t) {
  for (var n = 0; n < Ol.length; n += 3)
    (!t || ~t.indexOf(Ol[n + 1])) && e(Ol[n], Ol[n + 1], Ol[n + 2]);
}, rr = function(e) {
  return typeof e == "string";
}, vi = function(e) {
  return typeof e == "function";
}, du = function(e) {
  return typeof e == "number";
}, fa = function(e) {
  return typeof e == "object";
}, ou = function(e, t, n) {
  return e && e.progress(t ? 0 : 1) && n && e.pause();
}, r_ = function(e, t) {
  if (e.enabled) {
    var n = e._ctx ? e._ctx.add(function() {
      return t(e);
    }) : t(e);
    n && n.totalTime && (e.callbackAnimation = n);
  }
}, Il = Math.abs, ow = "left", aw = "top", Vv = "right", Wv = "bottom", Pa = "width", Ia = "height", bu = "Right", Ru = "Left", Bu = "Top", Pu = "Bottom", Un = "padding", Br = "margin", gc = "Width", Xv = "Height", Hn = "px", Pr = function(e) {
  return Dt.getComputedStyle(e);
}, sU = function(e) {
  var t = Pr(e).position;
  e.style.position = t === "absolute" || t === "fixed" ? t : "relative";
}, sS = function(e, t) {
  for (var n in t)
    n in e || (e[n] = t[n]);
  return e;
}, Os = function(e, t) {
  var n = t && Pr(e)[v0] !== "matrix(1, 0, 0, 1, 0, 0)" && qe.to(e, {
    x: 0,
    y: 0,
    xPercent: 0,
    yPercent: 0,
    rotation: 0,
    rotationX: 0,
    rotationY: 0,
    scale: 1,
    skewX: 0,
    skewY: 0
  }).progress(1), i = e.getBoundingClientRect();
  return n && n.progress(0).kill(), i;
}, rp = function(e, t) {
  var n = t.d2;
  return e["offset" + n] || e["client" + n] || 0;
}, lw = function(e) {
  var t = [], n = e.labels, i = e.duration(), r;
  for (r in n)
    t.push(n[r] / i);
  return t;
}, oU = function(e) {
  return function(t) {
    return qe.utils.snap(lw(e), t);
  };
}, Jv = function(e) {
  var t = qe.utils.snap(e), n = Array.isArray(e) && e.slice(0).sort(function(i, r) {
    return i - r;
  });
  return n ? function(i, r, o) {
    o === void 0 && (o = 1e-3);
    var a;
    if (!r)
      return t(i);
    if (r > 0) {
      for (i -= o, a = 0; a < n.length; a++)
        if (n[a] >= i)
          return n[a];
      return n[a - 1];
    } else
      for (a = n.length, i += o; a--; )
        if (n[a] <= i)
          return n[a];
    return n[0];
  } : function(i, r, o) {
    o === void 0 && (o = 1e-3);
    var a = t(i);
    return !r || Math.abs(a - i) < o || a - i < 0 == r < 0 ? a : t(r < 0 ? i - e : i + e);
  };
}, aU = function(e) {
  return function(t, n) {
    return Jv(lw(e))(t, n.direction);
  };
}, gd = function(e, t, n, i) {
  return n.split(",").forEach(function(r) {
    return e(t, r, i);
  });
}, ei = function(e, t, n, i, r) {
  return e.addEventListener(t, n, {
    passive: !i,
    capture: !!r
  });
}, $n = function(e, t, n, i) {
  return e.removeEventListener(t, n, !!i);
}, _d = function(e, t, n) {
  n = n && n.wheelHandler, n && (e(t, "wheel", n), e(t, "touchmove", n));
}, oS = {
  startColor: "green",
  endColor: "red",
  indent: 0,
  fontSize: "16px",
  fontWeight: "normal"
}, vd = {
  toggleActions: "play",
  anticipatePin: 0
}, sp = {
  top: 0,
  left: 0,
  center: 0.5,
  bottom: 1,
  right: 1
}, Fd = function(e, t) {
  if (rr(e)) {
    var n = e.indexOf("="), i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
    ~n && (e.indexOf("%") > n && (i *= t / 100), e = e.substr(0, n - 1)), e = i + (e in sp ? sp[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0);
  }
  return e;
}, yd = function(e, t, n, i, r, o, a, l) {
  var h = r.startColor, f = r.endColor, d = r.fontSize, p = r.indent, m = r.fontWeight, _ = an.createElement("div"), x = Ha(n) || bo(n, "pinType") === "fixed", y = e.indexOf("scroller") !== -1, v = x ? qt : n, S = e.indexOf("start") !== -1, M = S ? h : f, T = "border-color:" + M + ";font-size:" + d + ";color:" + M + ";font-weight:" + m + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
  return T += "position:" + ((y || l) && x ? "fixed;" : "absolute;"), (y || l || !x) && (T += (i === zn ? Vv : Wv) + ":" + (o + parseFloat(p)) + "px;"), a && (T += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), _._isStart = S, _.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), _.style.cssText = T, _.innerText = t || t === 0 ? e + "-" + t : e, v.children[0] ? v.insertBefore(_, v.children[0]) : v.appendChild(_), _._offset = _["offset" + i.op.d2], Ud(_, 0, i, S), _;
}, Ud = function(e, t, n, i) {
  var r = {
    display: "block"
  }, o = n[i ? "os2" : "p2"], a = n[i ? "p2" : "os2"];
  e._isFlipped = i, r[n.a + "Percent"] = i ? -100 : 0, r[n.a] = i ? "1px" : 0, r["border" + o + gc] = 1, r["border" + a + gc] = 0, r[n.p] = t + "px", qe.set(e, r);
}, Pt = [], M0 = {}, ih, aS = function() {
  return gi() - Fr > 34 && (ih || (ih = requestAnimationFrame(Ws)));
}, Ll = function() {
  (!Pi || !Pi.isPressed || Pi.startX > qt.clientWidth) && (Ft.cache++, Pi ? ih || (ih = requestAnimationFrame(Ws)) : Ws(), Fr || Va("scrollStart"), Fr = gi());
}, s_ = function() {
  tw = Dt.innerWidth, ew = Dt.innerHeight;
}, pu = function(e) {
  Ft.cache++, (e === !0 || !mi && !$T && !an.fullscreenElement && !an.webkitFullscreenElement && (!y0 || tw !== Dt.innerWidth || Math.abs(Dt.innerHeight - ew) > Dt.innerHeight * 0.25)) && np.restart(!0);
}, za = {}, lU = [], cw = function s() {
  return $n(Ut, "scrollEnd", s) || Aa(!0);
}, Va = function(e) {
  return za[e] && za[e].map(function(t) {
    return t();
  }) || lU;
}, ir = [], uw = function(e) {
  for (var t = 0; t < ir.length; t += 5)
    (!e || ir[t + 4] && ir[t + 4].query === e) && (ir[t].style.cssText = ir[t + 1], ir[t].getBBox && ir[t].setAttribute("transform", ir[t + 2] || ""), ir[t + 3].uncache = 1);
}, Yv = function(e, t) {
  var n;
  for (Ii = 0; Ii < Pt.length; Ii++)
    n = Pt[Ii], n && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0));
  ip = !0, t && uw(t), t || Va("revert");
}, hw = function(e, t) {
  Ft.cache++, (t || !Li) && Ft.forEach(function(n) {
    return vi(n) && n.cacheID++ && (n.rec = 0);
  }), rr(e) && (Dt.history.scrollRestoration = Hv = e);
}, Li, La = 0, lS, cU = function() {
  if (lS !== La) {
    var e = lS = La;
    requestAnimationFrame(function() {
      return e === La && Aa(!0);
    });
  }
}, fw = function() {
  qt.appendChild(ec), zv = !Pi && ec.offsetHeight || Dt.innerHeight, qt.removeChild(ec);
}, cS = function(e) {
  return nh(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
    return t.style.display = e ? "none" : "block";
  });
}, Aa = function(e, t) {
  if (or = an.documentElement, qt = an.body, Gv = [Dt, an, or, qt], Fr && !e && !ip) {
    ei(Ut, "scrollEnd", cw);
    return;
  }
  fw(), Li = Ut.isRefreshing = !0, Ft.forEach(function(i) {
    return vi(i) && ++i.cacheID && (i.rec = i());
  });
  var n = Va("refreshInit");
  jT && Ut.sort(), t || Yv(), Ft.forEach(function(i) {
    vi(i) && (i.smooth && (i.target.style.scrollBehavior = "auto"), i(0));
  }), Pt.slice(0).forEach(function(i) {
    return i.refresh();
  }), ip = !1, Pt.forEach(function(i) {
    if (i._subPinOffset && i.pin) {
      var r = i.vars.horizontal ? "offsetWidth" : "offsetHeight", o = i.pin[r];
      i.revert(!0, 1), i.adjustPinSpacing(i.pin[r] - o), i.refresh();
    }
  }), A0 = 1, cS(!0), Pt.forEach(function(i) {
    var r = hs(i.scroller, i._dir), o = i.vars.end === "max" || i._endClamp && i.end > r, a = i._startClamp && i.start >= r;
    (o || a) && i.setPositions(a ? r - 1 : i.start, o ? Math.max(a ? r : i.start + 1, r) : i.end, !0);
  }), cS(!1), A0 = 0, n.forEach(function(i) {
    return i && i.render && i.render(-1);
  }), Ft.forEach(function(i) {
    vi(i) && (i.smooth && requestAnimationFrame(function() {
      return i.target.style.scrollBehavior = "smooth";
    }), i.rec && i(i.rec));
  }), hw(Hv, 1), np.pause(), La++, Li = 2, Ws(2), Pt.forEach(function(i) {
    return vi(i.vars.onRefresh) && i.vars.onRefresh(i);
  }), Li = Ut.isRefreshing = !1, Va("refresh");
}, S0 = 0, Od = 1, Iu, Ws = function(e) {
  if (e === 2 || !Li && !ip) {
    Ut.isUpdating = !0, Iu && Iu.update(0);
    var t = Pt.length, n = gi(), i = n - i_ >= 50, r = t && Pt[0].scroll();
    if (Od = S0 > r ? -1 : 1, Li || (S0 = r), i && (Fr && !Op && n - Fr > 200 && (Fr = 0, Va("scrollEnd")), uu = i_, i_ = n), Od < 0) {
      for (Ii = t; Ii-- > 0; )
        Pt[Ii] && Pt[Ii].update(0, i);
      Od = 1;
    } else
      for (Ii = 0; Ii < t; Ii++)
        Pt[Ii] && Pt[Ii].update(0, i);
    Ut.isUpdating = !1;
  }
  ih = 0;
}, E0 = [ow, aw, Wv, Vv, Br + Pu, Br + bu, Br + Bu, Br + Ru, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], Nd = E0.concat([Pa, Ia, "boxSizing", "max" + gc, "max" + Xv, "position", Br, Un, Un + Bu, Un + bu, Un + Pu, Un + Ru]), uU = function(e, t, n) {
  tc(n);
  var i = e._gsap;
  if (i.spacerIsNative)
    tc(i.spacerState);
  else if (e._gsap.swappedIn) {
    var r = t.parentNode;
    r && (r.insertBefore(e, t), r.removeChild(t));
  }
  e._gsap.swappedIn = !1;
}, o_ = function(e, t, n, i) {
  if (!e._gsap.swappedIn) {
    for (var r = E0.length, o = t.style, a = e.style, l; r--; )
      l = E0[r], o[l] = n[l];
    o.position = n.position === "absolute" ? "absolute" : "relative", n.display === "inline" && (o.display = "inline-block"), a[Wv] = a[Vv] = "auto", o.flexBasis = n.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[Pa] = rp(e, Ui) + Hn, o[Ia] = rp(e, zn) + Hn, o[Un] = a[Br] = a[aw] = a[ow] = "0", tc(i), a[Pa] = a["max" + gc] = n[Pa], a[Ia] = a["max" + Xv] = n[Ia], a[Un] = n[Un], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0;
  }
}, hU = /([A-Z])/g, tc = function(e) {
  if (e) {
    var t = e.t.style, n = e.length, i = 0, r, o;
    for ((e.t._gsap || qe.core.getCache(e.t)).uncache = 1; i < n; i += 2)
      o = e[i + 1], r = e[i], o ? t[r] = o : t[r] && t.removeProperty(r.replace(hU, "-$1").toLowerCase());
  }
}, xd = function(e) {
  for (var t = Nd.length, n = e.style, i = [], r = 0; r < t; r++)
    i.push(Nd[r], n[Nd[r]]);
  return i.t = e, i;
}, fU = function(e, t, n) {
  for (var i = [], r = e.length, o = n ? 8 : 0, a; o < r; o += 2)
    a = e[o], i.push(a, a in t ? t[a] : e[o + 1]);
  return i.t = e.t, i;
}, kd = {
  left: 0,
  top: 0
}, uS = function(e, t, n, i, r, o, a, l, h, f, d, p, m, _) {
  vi(e) && (e = e(l)), rr(e) && e.substr(0, 3) === "max" && (e = p + (e.charAt(4) === "=" ? Fd("0" + e.substr(3), n) : 0));
  var x = m ? m.time() : 0, y, v, S;
  if (m && m.seek(0), isNaN(e) || (e = +e), du(e))
    m && (e = qe.utils.mapRange(m.scrollTrigger.start, m.scrollTrigger.end, 0, p, e)), a && Ud(a, n, i, !0);
  else {
    vi(t) && (t = t(l));
    var M = (e || "0").split(" "), T, P, b, R;
    S = zi(t, l) || qt, T = Os(S) || {}, (!T || !T.left && !T.top) && Pr(S).display === "none" && (R = S.style.display, S.style.display = "block", T = Os(S), R ? S.style.display = R : S.style.removeProperty("display")), P = Fd(M[0], T[i.d]), b = Fd(M[1] || "0", n), e = T[i.p] - h[i.p] - f + P + r - b, a && Ud(a, b, i, n - b < 20 || a._isStart && b > 20), n -= n - b;
  }
  if (_ && (l[_] = e || -1e-3, e < 0 && (e = 0)), o) {
    var U = e + n, C = o._isStart;
    y = "scroll" + i.d2, Ud(o, U, i, C && U > 20 || !C && (d ? Math.max(qt[y], or[y]) : o.parentNode[y]) <= U + 1), d && (h = Os(a), d && (o.style[i.op.p] = h[i.op.p] - i.op.m - o._offset + Hn));
  }
  return m && S && (y = Os(S), m.seek(p), v = Os(S), m._caScrollDist = y[i.p] - v[i.p], e = e / m._caScrollDist * p), m && m.seek(x), m ? e : Math.round(e);
}, dU = /(webkit|moz|length|cssText|inset)/i, hS = function(e, t, n, i) {
  if (e.parentNode !== t) {
    var r = e.style, o, a;
    if (t === qt) {
      e._stOrig = r.cssText, a = Pr(e);
      for (o in a)
        !+o && !dU.test(o) && a[o] && typeof r[o] == "string" && o !== "0" && (r[o] = a[o]);
      r.top = n, r.left = i;
    } else
      r.cssText = e._stOrig;
    qe.core.getCache(e).uncache = 1, t.appendChild(e);
  }
}, dw = function(e, t, n) {
  var i = t, r = i;
  return function(o) {
    var a = Math.round(e());
    return a !== i && a !== r && Math.abs(a - i) > 3 && Math.abs(a - r) > 3 && (o = a, n && n()), r = i, i = Math.round(o), i;
  };
}, Ad = function(e, t, n) {
  var i = {};
  i[t.p] = "+=" + n, qe.set(e, i);
}, fS = function(e, t) {
  var n = Fo(e, t), i = "_scroll" + t.p2, r = function o(a, l, h, f, d) {
    var p = o.tween, m = l.onComplete, _ = {};
    h = h || n();
    var x = dw(n, h, function() {
      p.kill(), o.tween = 0;
    });
    return d = f && d || 0, f = f || a - h, p && p.kill(), l[i] = a, l.inherit = !1, l.modifiers = _, _[i] = function() {
      return x(h + f * p.ratio + d * p.ratio * p.ratio);
    }, l.onUpdate = function() {
      Ft.cache++, o.tween && Ws();
    }, l.onComplete = function() {
      o.tween = 0, m && m.call(p);
    }, p = o.tween = qe.to(e, l), p;
  };
  return e[i] = n, n.wheelHandler = function() {
    return r.tween && r.tween.kill() && (r.tween = 0);
  }, ei(e, "wheel", n.wheelHandler), Ut.isTouch && ei(e, "touchmove", n.wheelHandler), r;
}, Ut = /* @__PURE__ */ function() {
  function s(t, n) {
    Ul || s.register(qe) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), x0(this), this.init(t, n);
  }
  var e = s.prototype;
  return e.init = function(n, i) {
    if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !hu) {
      this.update = this.refresh = this.kill = ls;
      return;
    }
    n = sS(rr(n) || du(n) || n.nodeType ? {
      trigger: n
    } : n, vd);
    var r = n, o = r.onUpdate, a = r.toggleClass, l = r.id, h = r.onToggle, f = r.onRefresh, d = r.scrub, p = r.trigger, m = r.pin, _ = r.pinSpacing, x = r.invalidateOnRefresh, y = r.anticipatePin, v = r.onScrubComplete, S = r.onSnapComplete, M = r.once, T = r.snap, P = r.pinReparent, b = r.pinSpacer, R = r.containerAnimation, U = r.fastScrollEnd, C = r.preventOverlaps, B = n.horizontal || n.containerAnimation && n.horizontal !== !1 ? Ui : zn, G = !d && d !== 0, W = zi(n.scroller || Dt), se = qe.core.getCache(W), z = Ha(W), q = ("pinType" in n ? n.pinType : bo(W, "pinType") || z && "fixed") === "fixed", j = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack], ee = G && n.toggleActions.split(" "), N = "markers" in n ? n.markers : vd.markers, V = z ? 0 : parseFloat(Pr(W)["border" + B.p2 + gc]) || 0, I = this, D = n.onRefreshInit && function() {
      return n.onRefreshInit(I);
    }, J = iU(W, z, B), K = rU(W, z), ie = 0, he = 0, ge = 0, me = Fo(W, B), Be, Pe, De, ze, X, pe, ce, Me, fe, Q, Ie, O, L, $, xe, Ae, _e, Ue, Le, Te, Ze, ct, ye, bt, et, mt, je, Ve, gt, St, Wt, Oe, Ee, Y, Ce, be, ot, it, It;
    if (I._startClamp = I._endClamp = !1, I._dir = B, y *= 45, I.scroller = W, I.scroll = R ? R.time.bind(R) : me, ze = me(), I.vars = n, i = i || n.animation, "refreshPriority" in n && (jT = 1, n.refreshPriority === -9999 && (Iu = I)), se.tweenScroll = se.tweenScroll || {
      top: fS(W, zn),
      left: fS(W, Ui)
    }, I.tweenTo = Be = se.tweenScroll[B.p], I.scrubDuration = function(Se) {
      Ee = du(Se) && Se, Ee ? Oe ? Oe.duration(Se) : Oe = qe.to(i, {
        ease: "expo",
        totalProgress: "+=0",
        inherit: !1,
        duration: Ee,
        paused: !0,
        onComplete: function() {
          return v && v(I);
        }
      }) : (Oe && Oe.progress(1).kill(), Oe = 0);
    }, i && (i.vars.lazy = !1, i._initted && !I.isReverted || i.vars.immediateRender !== !1 && n.immediateRender !== !1 && i.duration() && i.render(0, !0, !0), I.animation = i.pause(), i.scrollTrigger = I, I.scrubDuration(d), St = 0, l || (l = i.vars.id)), T && ((!fa(T) || T.push) && (T = {
      snapTo: T
    }), "scrollBehavior" in qt.style && qe.set(z ? [qt, or] : W, {
      scrollBehavior: "auto"
    }), Ft.forEach(function(Se) {
      return vi(Se) && Se.target === (z ? an.scrollingElement || or : W) && (Se.smooth = !1);
    }), De = vi(T.snapTo) ? T.snapTo : T.snapTo === "labels" ? oU(i) : T.snapTo === "labelsDirectional" ? aU(i) : T.directional !== !1 ? function(Se, ut) {
      return Jv(T.snapTo)(Se, gi() - he < 500 ? 0 : ut.direction);
    } : qe.utils.snap(T.snapTo), Y = T.duration || {
      min: 0.1,
      max: 2
    }, Y = fa(Y) ? Cu(Y.min, Y.max) : Cu(Y, Y), Ce = qe.delayedCall(T.delay || Ee / 2 || 0.1, function() {
      var Se = me(), ut = gi() - he < 500, rt = Be.tween;
      if ((ut || Math.abs(I.getVelocity()) < 10) && !rt && !Op && ie !== Se) {
        var _t = (Se - pe) / $, cn = i && !G ? i.totalProgress() : _t, yt = ut ? 0 : (cn - Wt) / (gi() - uu) * 1e3 || 0, jt = qe.utils.clamp(-_t, 1 - _t, Il(yt / 2) * yt / 0.185), wn = _t + (T.inertia === !1 ? 0 : jt), en, $t, Kt = T, Ei = Kt.onStart, F = Kt.onInterrupt, te = Kt.onComplete;
        if (en = De(wn, I), du(en) || (en = wn), $t = Math.max(0, Math.round(pe + en * $)), Se <= ce && Se >= pe && $t !== Se) {
          if (rt && !rt._initted && rt.data <= Il($t - Se))
            return;
          T.inertia === !1 && (jt = en - _t), Be($t, {
            duration: Y(Il(Math.max(Il(wn - cn), Il(en - cn)) * 0.185 / yt / 0.05 || 0)),
            ease: T.ease || "power3",
            data: Il($t - Se),
            // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
            onInterrupt: function() {
              return Ce.restart(!0) && F && F(I);
            },
            onComplete: function() {
              I.update(), ie = me(), i && !G && (Oe ? Oe.resetTo("totalProgress", en, i._tTime / i._tDur) : i.progress(en)), St = Wt = i && !G ? i.totalProgress() : I.progress, S && S(I), te && te(I);
            }
          }, Se, jt * $, $t - Se - jt * $), Ei && Ei(I, Be.tween);
        }
      } else I.isActive && ie !== Se && Ce.restart(!0);
    }).pause()), l && (M0[l] = I), p = I.trigger = zi(p || m !== !0 && m), It = p && p._gsap && p._gsap.stRevert, It && (It = It(I)), m = m === !0 ? p : zi(m), rr(a) && (a = {
      targets: p,
      className: a
    }), m && (_ === !1 || _ === Br || (_ = !_ && m.parentNode && m.parentNode.style && Pr(m.parentNode).display === "flex" ? !1 : Un), I.pin = m, Pe = qe.core.getCache(m), Pe.spacer ? xe = Pe.pinState : (b && (b = zi(b), b && !b.nodeType && (b = b.current || b.nativeElement), Pe.spacerIsNative = !!b, b && (Pe.spacerState = xd(b))), Pe.spacer = Ue = b || an.createElement("div"), Ue.classList.add("pin-spacer"), l && Ue.classList.add("pin-spacer-" + l), Pe.pinState = xe = xd(m)), n.force3D !== !1 && qe.set(m, {
      force3D: !0
    }), I.spacer = Ue = Pe.spacer, gt = Pr(m), bt = gt[_ + B.os2], Te = qe.getProperty(m), Ze = qe.quickSetter(m, B.a, Hn), o_(m, Ue, gt), _e = xd(m)), N) {
      O = fa(N) ? sS(N, oS) : oS, Q = yd("scroller-start", l, W, B, O, 0), Ie = yd("scroller-end", l, W, B, O, 0, Q), Le = Q["offset" + B.op.d2];
      var kt = zi(bo(W, "content") || W);
      Me = this.markerStart = yd("start", l, kt, B, O, Le, 0, R), fe = this.markerEnd = yd("end", l, kt, B, O, Le, 0, R), R && (it = qe.quickSetter([Me, fe], B.a, Hn)), !q && !(ms.length && bo(W, "fixedMarkers") === !0) && (sU(z ? qt : W), qe.set([Q, Ie], {
        force3D: !0
      }), mt = qe.quickSetter(Q, B.a, Hn), Ve = qe.quickSetter(Ie, B.a, Hn));
    }
    if (R) {
      var Qe = R.vars.onUpdate, We = R.vars.onUpdateParams;
      R.eventCallback("onUpdate", function() {
        I.update(0, 0, 1), Qe && Qe.apply(R, We || []);
      });
    }
    if (I.previous = function() {
      return Pt[Pt.indexOf(I) - 1];
    }, I.next = function() {
      return Pt[Pt.indexOf(I) + 1];
    }, I.revert = function(Se, ut) {
      if (!ut)
        return I.kill(!0);
      var rt = Se !== !1 || !I.enabled, _t = mi;
      rt !== I.isReverted && (rt && (be = Math.max(me(), I.scroll.rec || 0), ge = I.progress, ot = i && i.progress()), Me && [Me, fe, Q, Ie].forEach(function(cn) {
        return cn.style.display = rt ? "none" : "block";
      }), rt && (mi = I, I.update(rt)), m && (!P || !I.isActive) && (rt ? uU(m, Ue, xe) : o_(m, Ue, Pr(m), et)), rt || I.update(rt), mi = _t, I.isReverted = rt);
    }, I.refresh = function(Se, ut, rt, _t) {
      if (!((mi || !I.enabled) && !ut)) {
        if (m && Se && Fr) {
          ei(s, "scrollEnd", cw);
          return;
        }
        !Li && D && D(I), mi = I, Be.tween && !rt && (Be.tween.kill(), Be.tween = 0), Oe && Oe.pause(), x && i && (i.revert({
          kill: !1
        }).invalidate(), i.getChildren && i.getChildren(!0, !0, !1).forEach(function(ke) {
          return ke.vars.immediateRender && ke.render(0, !0, !0);
        })), I.isReverted || I.revert(!0, !0), I._subPinOffset = !1;
        var cn = J(), yt = K(), jt = R ? R.duration() : hs(W, B), wn = $ <= 0.01 || !$, en = 0, $t = _t || 0, Kt = fa(rt) ? rt.end : n.end, Ei = n.endTrigger || p, F = fa(rt) ? rt.start : n.start || (n.start === 0 || !p ? 0 : m ? "0 0" : "0 100%"), te = I.pinnedContainer = n.pinnedContainer && zi(n.pinnedContainer, I), ae = p && Math.max(0, Pt.indexOf(I)) || 0, oe = ae, re, Re, Je, ht, Xe, Ye, at, vt, sn, dn, Nt, un, ft;
        for (N && fa(rt) && (un = qe.getProperty(Q, B.p), ft = qe.getProperty(Ie, B.p)); oe-- > 0; )
          Ye = Pt[oe], Ye.end || Ye.refresh(0, 1) || (mi = I), at = Ye.pin, at && (at === p || at === m || at === te) && !Ye.isReverted && (dn || (dn = []), dn.unshift(Ye), Ye.revert(!0, !0)), Ye !== Pt[oe] && (ae--, oe--);
        for (vi(F) && (F = F(I)), F = tS(F, "start", I), pe = uS(F, p, cn, B, me(), Me, Q, I, yt, V, q, jt, R, I._startClamp && "_startClamp") || (m ? -1e-3 : 0), vi(Kt) && (Kt = Kt(I)), rr(Kt) && !Kt.indexOf("+=") && (~Kt.indexOf(" ") ? Kt = (rr(F) ? F.split(" ")[0] : "") + Kt : (en = Fd(Kt.substr(2), cn), Kt = rr(F) ? F : (R ? qe.utils.mapRange(0, R.duration(), R.scrollTrigger.start, R.scrollTrigger.end, pe) : pe) + en, Ei = p)), Kt = tS(Kt, "end", I), ce = Math.max(pe, uS(Kt || (Ei ? "100% 0" : jt), Ei, cn, B, me() + en, fe, Ie, I, yt, V, q, jt, R, I._endClamp && "_endClamp")) || -1e-3, en = 0, oe = ae; oe--; )
          Ye = Pt[oe], at = Ye.pin, at && Ye.start - Ye._pinPush <= pe && !R && Ye.end > 0 && (re = Ye.end - (I._startClamp ? Math.max(0, Ye.start) : Ye.start), (at === p && Ye.start - Ye._pinPush < pe || at === te) && isNaN(F) && (en += re * (1 - Ye.progress)), at === m && ($t += re));
        if (pe += en, ce += en, I._startClamp && (I._startClamp += en), I._endClamp && !Li && (I._endClamp = ce || -1e-3, ce = Math.min(ce, hs(W, B))), $ = ce - pe || (pe -= 0.01) && 1e-3, wn && (ge = qe.utils.clamp(0, 1, qe.utils.normalize(pe, ce, be))), I._pinPush = $t, Me && en && (re = {}, re[B.a] = "+=" + en, te && (re[B.p] = "-=" + me()), qe.set([Me, fe], re)), m && !(A0 && I.end >= hs(W, B)))
          re = Pr(m), ht = B === zn, Je = me(), ct = parseFloat(Te(B.a)) + $t, !jt && ce > 1 && (Nt = (z ? an.scrollingElement || or : W).style, Nt = {
            style: Nt,
            value: Nt["overflow" + B.a.toUpperCase()]
          }, z && Pr(qt)["overflow" + B.a.toUpperCase()] !== "scroll" && (Nt.style["overflow" + B.a.toUpperCase()] = "scroll")), o_(m, Ue, re), _e = xd(m), Re = Os(m, !0), vt = q && Fo(W, ht ? Ui : zn)(), _ ? (et = [_ + B.os2, $ + $t + Hn], et.t = Ue, oe = _ === Un ? rp(m, B) + $ + $t : 0, oe && (et.push(B.d, oe + Hn), Ue.style.flexBasis !== "auto" && (Ue.style.flexBasis = oe + Hn)), tc(et), te && Pt.forEach(function(ke) {
            ke.pin === te && ke.vars.pinSpacing !== !1 && (ke._subPinOffset = !0);
          }), q && me(be)) : (oe = rp(m, B), oe && Ue.style.flexBasis !== "auto" && (Ue.style.flexBasis = oe + Hn)), q && (Xe = {
            top: Re.top + (ht ? Je - pe : vt) + Hn,
            left: Re.left + (ht ? vt : Je - pe) + Hn,
            boxSizing: "border-box",
            position: "fixed"
          }, Xe[Pa] = Xe["max" + gc] = Math.ceil(Re.width) + Hn, Xe[Ia] = Xe["max" + Xv] = Math.ceil(Re.height) + Hn, Xe[Br] = Xe[Br + Bu] = Xe[Br + bu] = Xe[Br + Pu] = Xe[Br + Ru] = "0", Xe[Un] = re[Un], Xe[Un + Bu] = re[Un + Bu], Xe[Un + bu] = re[Un + bu], Xe[Un + Pu] = re[Un + Pu], Xe[Un + Ru] = re[Un + Ru], Ae = fU(xe, Xe, P), Li && me(0)), i ? (sn = i._initted, t_(1), i.render(i.duration(), !0, !0), ye = Te(B.a) - ct + $ + $t, je = Math.abs($ - ye) > 1, q && je && Ae.splice(Ae.length - 2, 2), i.render(0, !0, !0), sn || i.invalidate(!0), i.parent || i.totalTime(i.totalTime()), t_(0)) : ye = $, Nt && (Nt.value ? Nt.style["overflow" + B.a.toUpperCase()] = Nt.value : Nt.style.removeProperty("overflow-" + B.a));
        else if (p && me() && !R)
          for (Re = p.parentNode; Re && Re !== qt; )
            Re._pinOffset && (pe -= Re._pinOffset, ce -= Re._pinOffset), Re = Re.parentNode;
        dn && dn.forEach(function(ke) {
          return ke.revert(!1, !0);
        }), I.start = pe, I.end = ce, ze = X = Li ? be : me(), !R && !Li && (ze < be && me(be), I.scroll.rec = 0), I.revert(!1, !0), he = gi(), Ce && (ie = -1, Ce.restart(!0)), mi = 0, i && G && (i._initted || ot) && i.progress() !== ot && i.progress(ot || 0, !0).render(i.time(), !0, !0), (wn || ge !== I.progress || R || x || i && !i._initted) && (i && !G && (i._initted || ge || i.vars.immediateRender !== !1) && i.totalProgress(R && pe < -1e-3 && !ge ? qe.utils.normalize(pe, ce, 0) : ge, !0), I.progress = wn || (ze - pe) / $ === ge ? 0 : ge), m && _ && (Ue._pinOffset = Math.round(I.progress * ye)), Oe && Oe.invalidate(), isNaN(un) || (un -= qe.getProperty(Q, B.p), ft -= qe.getProperty(Ie, B.p), Ad(Q, B, un), Ad(Me, B, un - (_t || 0)), Ad(Ie, B, ft), Ad(fe, B, ft - (_t || 0))), wn && !Li && I.update(), f && !Li && !L && (L = !0, f(I), L = !1);
      }
    }, I.getVelocity = function() {
      return (me() - X) / (gi() - uu) * 1e3 || 0;
    }, I.endAnimation = function() {
      ou(I.callbackAnimation), i && (Oe ? Oe.progress(1) : i.paused() ? G || ou(i, I.direction < 0, 1) : ou(i, i.reversed()));
    }, I.labelToScroll = function(Se) {
      return i && i.labels && (pe || I.refresh() || pe) + i.labels[Se] / i.duration() * $ || 0;
    }, I.getTrailing = function(Se) {
      var ut = Pt.indexOf(I), rt = I.direction > 0 ? Pt.slice(0, ut).reverse() : Pt.slice(ut + 1);
      return (rr(Se) ? rt.filter(function(_t) {
        return _t.vars.preventOverlaps === Se;
      }) : rt).filter(function(_t) {
        return I.direction > 0 ? _t.end <= pe : _t.start >= ce;
      });
    }, I.update = function(Se, ut, rt) {
      if (!(R && !rt && !Se)) {
        var _t = Li === !0 ? be : I.scroll(), cn = Se ? 0 : (_t - pe) / $, yt = cn < 0 ? 0 : cn > 1 ? 1 : cn || 0, jt = I.progress, wn, en, $t, Kt, Ei, F, te, ae;
        if (ut && (X = ze, ze = R ? me() : _t, T && (Wt = St, St = i && !G ? i.totalProgress() : yt)), y && m && !mi && !pd && Fr && (!yt && pe < _t + (_t - X) / (gi() - uu) * y ? yt = 1e-4 : yt === 1 && ce > _t + (_t - X) / (gi() - uu) * y && (yt = 0.9999)), yt !== jt && I.enabled) {
          if (wn = I.isActive = !!yt && yt < 1, en = !!jt && jt < 1, F = wn !== en, Ei = F || !!yt != !!jt, I.direction = yt > jt ? 1 : -1, I.progress = yt, Ei && !mi && ($t = yt && !jt ? 0 : yt === 1 ? 1 : jt === 1 ? 2 : 3, G && (Kt = !F && ee[$t + 1] !== "none" && ee[$t + 1] || ee[$t], ae = i && (Kt === "complete" || Kt === "reset" || Kt in i))), C && (F || ae) && (ae || d || !i) && (vi(C) ? C(I) : I.getTrailing(C).forEach(function(Je) {
            return Je.endAnimation();
          })), G || (Oe && !mi && !pd ? (Oe._dp._time - Oe._start !== Oe._time && Oe.render(Oe._dp._time - Oe._start), Oe.resetTo ? Oe.resetTo("totalProgress", yt, i._tTime / i._tDur) : (Oe.vars.totalProgress = yt, Oe.invalidate().restart())) : i && i.totalProgress(yt, !!(mi && (he || Se)))), m) {
            if (Se && _ && (Ue.style[_ + B.os2] = bt), !q)
              Ze(fu(ct + ye * yt));
            else if (Ei) {
              if (te = !Se && yt > jt && ce + 1 > _t && _t + 1 >= hs(W, B), P)
                if (!Se && (wn || te)) {
                  var oe = Os(m, !0), re = _t - pe;
                  hS(m, qt, oe.top + (B === zn ? re : 0) + Hn, oe.left + (B === zn ? 0 : re) + Hn);
                } else
                  hS(m, Ue);
              tc(wn || te ? Ae : _e), je && yt < 1 && wn || Ze(ct + (yt === 1 && !te ? ye : 0));
            }
          }
          T && !Be.tween && !mi && !pd && Ce.restart(!0), a && (F || M && yt && (yt < 1 || !n_)) && nh(a.targets).forEach(function(Je) {
            return Je.classList[wn || M ? "add" : "remove"](a.className);
          }), o && !G && !Se && o(I), Ei && !mi ? (G && (ae && (Kt === "complete" ? i.pause().totalProgress(1) : Kt === "reset" ? i.restart(!0).pause() : Kt === "restart" ? i.restart(!0) : i[Kt]()), o && o(I)), (F || !n_) && (h && F && r_(I, h), j[$t] && r_(I, j[$t]), M && (yt === 1 ? I.kill(!1, 1) : j[$t] = 0), F || ($t = yt === 1 ? 1 : 3, j[$t] && r_(I, j[$t]))), U && !wn && Math.abs(I.getVelocity()) > (du(U) ? U : 2500) && (ou(I.callbackAnimation), Oe ? Oe.progress(1) : ou(i, Kt === "reverse" ? 1 : !yt, 1))) : G && o && !mi && o(I);
        }
        if (Ve) {
          var Re = R ? _t / R.duration() * (R._caScrollDist || 0) : _t;
          mt(Re + (Q._isFlipped ? 1 : 0)), Ve(Re);
        }
        it && it(-_t / R.duration() * (R._caScrollDist || 0));
      }
    }, I.enable = function(Se, ut) {
      I.enabled || (I.enabled = !0, ei(W, "resize", pu), z || ei(W, "scroll", Ll), D && ei(s, "refreshInit", D), Se !== !1 && (I.progress = ge = 0, ze = X = ie = me()), ut !== !1 && I.refresh());
    }, I.getTween = function(Se) {
      return Se && Be ? Be.tween : Oe;
    }, I.setPositions = function(Se, ut, rt, _t) {
      if (R) {
        var cn = R.scrollTrigger, yt = R.duration(), jt = cn.end - cn.start;
        Se = cn.start + jt * Se / yt, ut = cn.start + jt * ut / yt;
      }
      I.refresh(!1, !1, {
        start: nS(Se, rt && !!I._startClamp),
        end: nS(ut, rt && !!I._endClamp)
      }, _t), I.update();
    }, I.adjustPinSpacing = function(Se) {
      if (et && Se) {
        var ut = et.indexOf(B.d) + 1;
        et[ut] = parseFloat(et[ut]) + Se + Hn, et[1] = parseFloat(et[1]) + Se + Hn, tc(et);
      }
    }, I.disable = function(Se, ut) {
      if (I.enabled && (Se !== !1 && I.revert(!0, !0), I.enabled = I.isActive = !1, ut || Oe && Oe.pause(), be = 0, Pe && (Pe.uncache = 1), D && $n(s, "refreshInit", D), Ce && (Ce.pause(), Be.tween && Be.tween.kill() && (Be.tween = 0)), !z)) {
        for (var rt = Pt.length; rt--; )
          if (Pt[rt].scroller === W && Pt[rt] !== I)
            return;
        $n(W, "resize", pu), z || $n(W, "scroll", Ll);
      }
    }, I.kill = function(Se, ut) {
      I.disable(Se, ut), Oe && !ut && Oe.kill(), l && delete M0[l];
      var rt = Pt.indexOf(I);
      rt >= 0 && Pt.splice(rt, 1), rt === Ii && Od > 0 && Ii--, rt = 0, Pt.forEach(function(_t) {
        return _t.scroller === I.scroller && (rt = 1);
      }), rt || Li || (I.scroll.rec = 0), i && (i.scrollTrigger = null, Se && i.revert({
        kill: !1
      }), ut || i.kill()), Me && [Me, fe, Q, Ie].forEach(function(_t) {
        return _t.parentNode && _t.parentNode.removeChild(_t);
      }), Iu === I && (Iu = 0), m && (Pe && (Pe.uncache = 1), rt = 0, Pt.forEach(function(_t) {
        return _t.pin === m && rt++;
      }), rt || (Pe.spacer = 0)), n.onKill && n.onKill(I);
    }, Pt.push(I), I.enable(!1, !1), It && It(I), i && i.add && !$) {
      var tt = I.update;
      I.update = function() {
        I.update = tt, Ft.cache++, pe || ce || I.refresh();
      }, qe.delayedCall(0.01, I.update), $ = 0.01, pe = ce = 0;
    } else
      I.refresh();
    m && cU();
  }, s.register = function(n) {
    return Ul || (qe = n || iw(), nw() && window.document && s.enable(), Ul = hu), Ul;
  }, s.defaults = function(n) {
    if (n)
      for (var i in n)
        vd[i] = n[i];
    return vd;
  }, s.disable = function(n, i) {
    hu = 0, Pt.forEach(function(o) {
      return o[i ? "kill" : "disable"](n);
    }), $n(Dt, "wheel", Ll), $n(an, "scroll", Ll), clearInterval(dd), $n(an, "touchcancel", ls), $n(qt, "touchstart", ls), gd($n, an, "pointerdown,touchstart,mousedown", iS), gd($n, an, "pointerup,touchend,mouseup", rS), np.kill(), md($n);
    for (var r = 0; r < Ft.length; r += 3)
      _d($n, Ft[r], Ft[r + 1]), _d($n, Ft[r], Ft[r + 2]);
  }, s.enable = function() {
    if (Dt = window, an = document, or = an.documentElement, qt = an.body, qe && (nh = qe.utils.toArray, Cu = qe.utils.clamp, x0 = qe.core.context || ls, t_ = qe.core.suppressOverwrites || ls, Hv = Dt.history.scrollRestoration || "auto", S0 = Dt.pageYOffset || 0, qe.core.globals("ScrollTrigger", s), qt)) {
      hu = 1, ec = document.createElement("div"), ec.style.height = "100vh", ec.style.position = "absolute", fw(), nU(), In.register(qe), s.isTouch = In.isTouch, po = In.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), y0 = In.isTouch === 1, ei(Dt, "wheel", Ll), Gv = [Dt, an, or, qt], qe.matchMedia ? (s.matchMedia = function(h) {
        var f = qe.matchMedia(), d;
        for (d in h)
          f.add(d, h[d]);
        return f;
      }, qe.addEventListener("matchMediaInit", function() {
        return Yv();
      }), qe.addEventListener("matchMediaRevert", function() {
        return uw();
      }), qe.addEventListener("matchMedia", function() {
        Aa(0, 1), Va("matchMedia");
      }), qe.matchMedia().add("(orientation: portrait)", function() {
        return s_(), s_;
      })) : console.warn("Requires GSAP 3.11.0 or later"), s_(), ei(an, "scroll", Ll);
      var n = qt.hasAttribute("style"), i = qt.style, r = i.borderTopStyle, o = qe.core.Animation.prototype, a, l;
      for (o.revert || Object.defineProperty(o, "revert", {
        value: function() {
          return this.time(-0.01, !0);
        }
      }), i.borderTopStyle = "solid", a = Os(qt), zn.m = Math.round(a.top + zn.sc()) || 0, Ui.m = Math.round(a.left + Ui.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), n || (qt.setAttribute("style", ""), qt.removeAttribute("style")), dd = setInterval(aS, 250), qe.delayedCall(0.5, function() {
        return pd = 0;
      }), ei(an, "touchcancel", ls), ei(qt, "touchstart", ls), gd(ei, an, "pointerdown,touchstart,mousedown", iS), gd(ei, an, "pointerup,touchend,mouseup", rS), v0 = qe.utils.checkPrefix("transform"), Nd.push(v0), Ul = gi(), np = qe.delayedCall(0.2, Aa).pause(), Ol = [an, "visibilitychange", function() {
        var h = Dt.innerWidth, f = Dt.innerHeight;
        an.hidden ? ($M = h, eS = f) : ($M !== h || eS !== f) && pu();
      }, an, "DOMContentLoaded", Aa, Dt, "load", Aa, Dt, "resize", pu], md(ei), Pt.forEach(function(h) {
        return h.enable(0, 1);
      }), l = 0; l < Ft.length; l += 3)
        _d($n, Ft[l], Ft[l + 1]), _d($n, Ft[l], Ft[l + 2]);
    }
  }, s.config = function(n) {
    "limitCallbacks" in n && (n_ = !!n.limitCallbacks);
    var i = n.syncInterval;
    i && clearInterval(dd) || (dd = i) && setInterval(aS, i), "ignoreMobileResize" in n && (y0 = s.isTouch === 1 && n.ignoreMobileResize), "autoRefreshEvents" in n && (md($n) || md(ei, n.autoRefreshEvents || "none"), $T = (n.autoRefreshEvents + "").indexOf("resize") === -1);
  }, s.scrollerProxy = function(n, i) {
    var r = zi(n), o = Ft.indexOf(r), a = Ha(r);
    ~o && Ft.splice(o, a ? 6 : 2), i && (a ? ms.unshift(Dt, i, qt, i, or, i) : ms.unshift(r, i));
  }, s.clearMatchMedia = function(n) {
    Pt.forEach(function(i) {
      return i._ctx && i._ctx.query === n && i._ctx.kill(!0, !0);
    });
  }, s.isInViewport = function(n, i, r) {
    var o = (rr(n) ? zi(n) : n).getBoundingClientRect(), a = o[r ? Pa : Ia] * i || 0;
    return r ? o.right - a > 0 && o.left + a < Dt.innerWidth : o.bottom - a > 0 && o.top + a < Dt.innerHeight;
  }, s.positionInViewport = function(n, i, r) {
    rr(n) && (n = zi(n));
    var o = n.getBoundingClientRect(), a = o[r ? Pa : Ia], l = i == null ? a / 2 : i in sp ? sp[i] * a : ~i.indexOf("%") ? parseFloat(i) * a / 100 : parseFloat(i) || 0;
    return r ? (o.left + l) / Dt.innerWidth : (o.top + l) / Dt.innerHeight;
  }, s.killAll = function(n) {
    if (Pt.slice(0).forEach(function(r) {
      return r.vars.id !== "ScrollSmoother" && r.kill();
    }), n !== !0) {
      var i = za.killAll || [];
      za = {}, i.forEach(function(r) {
        return r();
      });
    }
  }, s;
}();
Ut.version = "3.13.0";
Ut.saveStyles = function(s) {
  return s ? nh(s).forEach(function(e) {
    if (e && e.style) {
      var t = ir.indexOf(e);
      t >= 0 && ir.splice(t, 5), ir.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), qe.core.getCache(e), x0());
    }
  }) : ir;
};
Ut.revert = function(s, e) {
  return Yv(!s, e);
};
Ut.create = function(s, e) {
  return new Ut(s, e);
};
Ut.refresh = function(s) {
  return s ? pu(!0) : (Ul || Ut.register()) && Aa(!0);
};
Ut.update = function(s) {
  return ++Ft.cache && Ws(s === !0 ? 2 : 0);
};
Ut.clearScrollMemory = hw;
Ut.maxScroll = function(s, e) {
  return hs(s, e ? Ui : zn);
};
Ut.getScrollFunc = function(s, e) {
  return Fo(zi(s), e ? Ui : zn);
};
Ut.getById = function(s) {
  return M0[s];
};
Ut.getAll = function() {
  return Pt.filter(function(s) {
    return s.vars.id !== "ScrollSmoother";
  });
};
Ut.isScrolling = function() {
  return !!Fr;
};
Ut.snapDirectional = Jv;
Ut.addEventListener = function(s, e) {
  var t = za[s] || (za[s] = []);
  ~t.indexOf(e) || t.push(e);
};
Ut.removeEventListener = function(s, e) {
  var t = za[s], n = t && t.indexOf(e);
  n >= 0 && t.splice(n, 1);
};
Ut.batch = function(s, e) {
  var t = [], n = {}, i = e.interval || 0.016, r = e.batchMax || 1e9, o = function(h, f) {
    var d = [], p = [], m = qe.delayedCall(i, function() {
      f(d, p), d = [], p = [];
    }).pause();
    return function(_) {
      d.length || m.restart(!0), d.push(_.trigger), p.push(_), r <= d.length && m.progress(1);
    };
  }, a;
  for (a in e)
    n[a] = a.substr(0, 2) === "on" && vi(e[a]) && a !== "onRefreshInit" ? o(a, e[a]) : e[a];
  return vi(r) && (r = r(), ei(Ut, "refresh", function() {
    return r = e.batchMax();
  })), nh(s).forEach(function(l) {
    var h = {};
    for (a in n)
      h[a] = n[a];
    h.trigger = l, t.push(Ut.create(h));
  }), t;
};
var dS = function(e, t, n, i) {
  return t > i ? e(i) : t < 0 && e(0), n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1;
}, a_ = function s(e, t) {
  t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (In.isTouch ? " pinch-zoom" : "") : "none", e === or && s(qt, t);
}, Md = {
  auto: 1,
  scroll: 1
}, pU = function(e) {
  var t = e.event, n = e.target, i = e.axis, r = (t.changedTouches ? t.changedTouches[0] : t).target, o = r._gsap || qe.core.getCache(r), a = gi(), l;
  if (!o._isScrollT || a - o._isScrollT > 2e3) {
    for (; r && r !== qt && (r.scrollHeight <= r.clientHeight && r.scrollWidth <= r.clientWidth || !(Md[(l = Pr(r)).overflowY] || Md[l.overflowX])); )
      r = r.parentNode;
    o._isScroll = r && r !== n && !Ha(r) && (Md[(l = Pr(r)).overflowY] || Md[l.overflowX]), o._isScrollT = a;
  }
  (o._isScroll || i === "x") && (t.stopPropagation(), t._gsapAllow = !0);
}, pw = function(e, t, n, i) {
  return In.create({
    target: e,
    capture: !0,
    debounce: !1,
    lockAxis: !0,
    type: t,
    onWheel: i = i && pU,
    onPress: i,
    onDrag: i,
    onScroll: i,
    onEnable: function() {
      return n && ei(an, In.eventTypes[0], mS, !1, !0);
    },
    onDisable: function() {
      return $n(an, In.eventTypes[0], mS, !0);
    }
  });
}, mU = /(input|label|select|textarea)/i, pS, mS = function(e) {
  var t = mU.test(e.target.tagName);
  (t || pS) && (e._gsapAllow = !0, pS = t);
}, gU = function(e) {
  fa(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
  var t = e, n = t.normalizeScrollX, i = t.momentum, r = t.allowNestedScroll, o = t.onRelease, a, l, h = zi(e.target) || or, f = qe.core.globals().ScrollSmoother, d = f && f.get(), p = po && (e.content && zi(e.content) || d && e.content !== !1 && !d.smooth() && d.content()), m = Fo(h, zn), _ = Fo(h, Ui), x = 1, y = (In.isTouch && Dt.visualViewport ? Dt.visualViewport.scale * Dt.visualViewport.width : Dt.outerWidth) / Dt.innerWidth, v = 0, S = vi(i) ? function() {
    return i(a);
  } : function() {
    return i || 2.8;
  }, M, T, P = pw(h, e.type, !0, r), b = function() {
    return T = !1;
  }, R = ls, U = ls, C = function() {
    l = hs(h, zn), U = Cu(po ? 1 : 0, l), n && (R = Cu(0, hs(h, Ui))), M = La;
  }, B = function() {
    p._gsap.y = fu(parseFloat(p._gsap.y) + m.offset) + "px", p.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(p._gsap.y) + ", 0, 1)", m.offset = m.cacheID = 0;
  }, G = function() {
    if (T) {
      requestAnimationFrame(b);
      var N = fu(a.deltaY / 2), V = U(m.v - N);
      if (p && V !== m.v + m.offset) {
        m.offset = V - m.v;
        var I = fu((parseFloat(p && p._gsap.y) || 0) - m.offset);
        p.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + I + ", 0, 1)", p._gsap.y = I + "px", m.cacheID = Ft.cache, Ws();
      }
      return !0;
    }
    m.offset && B(), T = !0;
  }, W, se, z, q, j = function() {
    C(), W.isActive() && W.vars.scrollY > l && (m() > l ? W.progress(1) && m(l) : W.resetTo("scrollY", l));
  };
  return p && qe.set(p, {
    y: "+=0"
  }), e.ignoreCheck = function(ee) {
    return po && ee.type === "touchmove" && G() || x > 1.05 && ee.type !== "touchstart" || a.isGesturing || ee.touches && ee.touches.length > 1;
  }, e.onPress = function() {
    T = !1;
    var ee = x;
    x = fu((Dt.visualViewport && Dt.visualViewport.scale || 1) / y), W.pause(), ee !== x && a_(h, x > 1.01 ? !0 : n ? !1 : "x"), se = _(), z = m(), C(), M = La;
  }, e.onRelease = e.onGestureStart = function(ee, N) {
    if (m.offset && B(), !N)
      q.restart(!0);
    else {
      Ft.cache++;
      var V = S(), I, D;
      n && (I = _(), D = I + V * 0.05 * -ee.velocityX / 0.227, V *= dS(_, I, D, hs(h, Ui)), W.vars.scrollX = R(D)), I = m(), D = I + V * 0.05 * -ee.velocityY / 0.227, V *= dS(m, I, D, hs(h, zn)), W.vars.scrollY = U(D), W.invalidate().duration(V).play(0.01), (po && W.vars.scrollY >= l || I >= l - 1) && qe.to({}, {
        onUpdate: j,
        duration: V
      });
    }
    o && o(ee);
  }, e.onWheel = function() {
    W._ts && W.pause(), gi() - v > 1e3 && (M = 0, v = gi());
  }, e.onChange = function(ee, N, V, I, D) {
    if (La !== M && C(), N && n && _(R(I[2] === N ? se + (ee.startX - ee.x) : _() + N - I[1])), V) {
      m.offset && B();
      var J = D[2] === V, K = J ? z + ee.startY - ee.y : m() + V - D[1], ie = U(K);
      J && K !== ie && (z += ie - K), m(ie);
    }
    (V || N) && Ws();
  }, e.onEnable = function() {
    a_(h, n ? !1 : "x"), Ut.addEventListener("refresh", j), ei(Dt, "resize", j), m.smooth && (m.target.style.scrollBehavior = "auto", m.smooth = _.smooth = !1), P.enable();
  }, e.onDisable = function() {
    a_(h, !0), $n(Dt, "resize", j), Ut.removeEventListener("refresh", j), P.kill();
  }, e.lockAxis = e.lockAxis !== !1, a = new In(e), a.iOS = po, po && !m() && m(1), po && qe.ticker.add(ls), q = a._dc, W = qe.to(a, {
    ease: "power4",
    paused: !0,
    inherit: !1,
    scrollX: n ? "+=0.1" : "+=0",
    scrollY: "+=0.1",
    modifiers: {
      scrollY: dw(m, m(), function() {
        return W.pause();
      })
    },
    onUpdate: Ws,
    onComplete: q.vars.onComplete
  }), a;
};
Ut.sort = function(s) {
  if (vi(s))
    return Pt.sort(s);
  var e = Dt.pageYOffset || 0;
  return Ut.getAll().forEach(function(t) {
    return t._sortY = t.trigger ? e + t.trigger.getBoundingClientRect().top : t.start + Dt.innerHeight;
  }), Pt.sort(s || function(t, n) {
    return (t.vars.refreshPriority || 0) * -1e6 + (t.vars.containerAnimation ? 1e6 : t._sortY) - ((n.vars.containerAnimation ? 1e6 : n._sortY) + (n.vars.refreshPriority || 0) * -1e6);
  });
};
Ut.observe = function(s) {
  return new In(s);
};
Ut.normalizeScroll = function(s) {
  if (typeof s > "u")
    return Pi;
  if (s === !0 && Pi)
    return Pi.enable();
  if (s === !1) {
    Pi && Pi.kill(), Pi = s;
    return;
  }
  var e = s instanceof In ? s : gU(s);
  return Pi && Pi.target === e.target && Pi.kill(), Ha(e.target) && (Pi = e), e;
};
Ut.core = {
  // smaller file size way to leverage in ScrollSmoother and Observer
  _getVelocityProp: _0,
  _inputObserver: pw,
  _scrollers: Ft,
  _proxies: ms,
  bridge: {
    // when normalizeScroll sets the scroll position (ss = setScroll)
    ss: function() {
      Fr || Va("scrollStart"), Fr = gi();
    },
    // a way to get the _refreshing value in Observer
    ref: function() {
      return mi;
    }
  }
};
iw() && qe.registerPlugin(Ut);
const _U = {
  "sec-1": { name: "sec-1", modelTransform: { posX: -1, posY: 0, posZ: 0, rotX: 0, rotY: -5, rotZ: 0 }, background: { type: "solid", color1: "#fbfbfb", color2: "#350000" }, lights: [{ id: 17530033689119426e-4, type: "Point", intensity: 9.999999999999998, color: "#e8d8d4", position: [2, 5, 3], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }, { id: 17530033689117395e-4, type: "Ambient", intensity: 28, color: "#7f7f7f", position: [0, 0, 0], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }, { id: 17530039069154421e-4, type: "Directional", intensity: 9.700000000000001, color: "#ffeeee", position: [6.7, 8.700000000000001, 0], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }], selectedAnimation: "Idle", loopCount: "Infinity" },
  "sec-2": { name: "sec-2", modelTransform: { posX: 0, posY: 0, posZ: 0, rotX: 0, rotY: -0.7000000000000001, rotZ: 0 }, background: { type: "solid", color1: "#ff6262", color2: "#350000" }, lights: [{ id: 1753003615642278e-3, type: "Directional", intensity: 25, color: "#ff3300", position: [2, 5, 3], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }, { id: 17530036156426309e-4, type: "Ambient", intensity: 28, color: "#803030", position: [0, 0, 0], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }], selectedAnimation: "Idle", loopCount: "Infinity" },
  "sec-3": { name: "sec-3", modelTransform: { posX: -2.7, posY: -0.9, posZ: 3.4000000000000004, rotX: 0, rotY: 1.2000000000000002, rotZ: 0 }, background: { type: "solid", color1: "#0bbc96", color2: "#350000" }, lights: [{ id: 17530037182022205e-4, type: "Directional", intensity: 25, color: "#07ff00", position: [-11102230246251565e-32, 5, 3], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }, { id: 17530037182026328e-4, type: "Ambient", intensity: 28, color: "#2d5c36", position: [0, 0, 0], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }], selectedAnimation: "Take 001", loopCount: "Infinity" },
  "sec-4": { name: "sec-4", modelTransform: { posX: 0, posY: -1.2000000000000002, posZ: 4.9, rotX: 0, rotY: -6.1000000000000005, rotZ: 0 }, background: { type: "solid", color1: "#cfb82f", color2: "#350000" }, lights: [{ id: 1753003968378131e-3, type: "Directional", intensity: 6.699999999999999, color: "#e1ff00", position: [2, 5, 3], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }, { id: 17530039683783835e-4, type: "Ambient", intensity: 5.999999999999999, color: "#708030", position: [0, 0, 0], castShadow: !1, angle: 0, penumbra: 0, distance: 0, decay: 1 }], selectedAnimation: "Idle", loopCount: "Infinity" }
};
jl.registerPlugin(Ut);
function vU({ modelPath: s, activeSection: e, sceneSettings: t }) {
  const n = nt.useRef(), { scene: i } = Ku(s);
  Ku.preload(s);
  const { scene: r } = P2(), o = nt.useRef({
    position: new k(),
    rotation: new yc()
  }).current, [a, l] = nt.useState([]);
  return nt.useEffect(() => {
    if (!e) return;
    const h = t[e];
    if (!h || !h.modelTransform) return;
    const { modelTransform: f, background: d, lights: p } = h;
    if (jl.to(o.position, {
      x: f.posX,
      y: f.posY,
      z: f.posZ,
      duration: 1,
      ease: "power1.out"
    }), jl.to(o.rotation, {
      x: f.rotX,
      y: f.rotY,
      z: f.rotZ,
      duration: 1,
      ease: "power1.out"
    }), d.type === "solid") {
      const m = new Ne(d.color1);
      r.background || (r.background = new Ne(m));
      const _ = r.background;
      jl.to(_, {
        r: m.r,
        g: m.g,
        b: m.b,
        duration: 1,
        onUpdate: () => {
          r.background.setRGB(_.r, _.g, _.b);
        }
      });
    } else
      r.background = null;
    l(p || []);
  }, [e, r, t]), I2(() => {
    n.current && (n.current.position.lerp(o.position, 0.1), n.current.rotation.x = _u.lerp(n.current.rotation.x, o.rotation.x, 0.1), n.current.rotation.y = _u.lerp(n.current.rotation.y, o.rotation.y, 0.1), n.current.rotation.z = _u.lerp(n.current.rotation.z, o.rotation.z, 0.1));
  }), /* @__PURE__ */ Pn.jsxs(Pn.Fragment, { children: [
    a.map((h) => {
      const f = {
        key: h.id,
        position: h.position,
        intensity: h.intensity,
        color: h.color,
        castShadow: h.castShadow
      };
      switch (h.type) {
        case "Directional":
          return /* @__PURE__ */ Pn.jsx("directionalLight", { ...f });
        case "Point":
          return /* @__PURE__ */ Pn.jsx("pointLight", { ...f });
        case "Ambient":
          return /* @__PURE__ */ Pn.jsx("ambientLight", { ...f });
        case "Spot":
          return /* @__PURE__ */ Pn.jsx(
            "spotLight",
            {
              ...f,
              angle: h.angle || Math.PI / 6,
              penumbra: h.penumbra || 0,
              decay: h.decay || 1,
              distance: h.distance || 0
            }
          );
        default:
          return null;
      }
    }),
    /* @__PURE__ */ Pn.jsx("primitive", { object: i, ref: n })
  ] });
}
function yU({ modelPath: s = "https://white-deane-36.tiiny.site/models/Compressed-Sphere-Bot.glb" }) {
  const [e, t] = nt.useState(_U), [n, i] = nt.useState(Object.values(e)[0].name);
  return nt.useEffect(() => {
    const r = (o) => {
      o?.data?.type && o.data.type === "UPDATE_SCENE_SETTINGS" && t(o.data.data);
    };
    return window.addEventListener("message", r), () => window.removeEventListener("message", r);
  }, []), nt.useLayoutEffect(() => {
    const r = jl.context(() => {
      Object.values(e).forEach((a, l, h) => {
        Ut.create({
          trigger: `#${a.name}`,
          start: "top center",
          end: "bottom center",
          onEnter: () => i(a.name),
          onEnterBack: () => i(a.name)
        });
      });
    });
    return () => r.revert();
  }, [e]), /* @__PURE__ */ Pn.jsx(
    "div",
    {
      style: {
        width: "100%",
        height: "100%",
        position: "fixed",
        top: 0,
        left: 0,
        zIndex: -1,
        pointerEvents: "none"
      },
      children: /* @__PURE__ */ Pn.jsx(
        $2,
        {
          style: { background: "transparent" },
          camera: { position: [0, 0, 10], fov: 50 },
          shadows: !0,
          children: /* @__PURE__ */ Pn.jsx(vU, { modelPath: s, activeSection: n, sceneSettings: e })
        }
      )
    }
  );
}
export {
  yU as default
};
